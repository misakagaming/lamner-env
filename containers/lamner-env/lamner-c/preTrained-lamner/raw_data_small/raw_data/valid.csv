code,summary
"public static MediaTable create(String tableName, String idColumnName,
			List<UserCustomColumn> additionalColumns) {

		List<UserCustomColumn> columns = new ArrayList<>();
		columns.addAll(createRequiredColumns(idColumnName));

		if (additionalColumns != null) {
			columns.addAll(additionalColumns);
		}

		return new MediaTable(tableName, columns, idColumnName);
	}",Creates a new media table with the required columns.
"public boolean isAsync() {
        return invokeType != null && (RpcConstants.INVOKER_TYPE_CALLBACK.equals(invokeType)
            || RpcConstants.INVOKER_TYPE_FUTURE.equals(invokeType));
    }",Returns true if this method is async.
"protected final static int getConversionFnid(int authoritative_type, int new_type) {
        if (new_type == authoritative_type) return 0;
        switch (new_type) {
            case AS_TYPE.null_value:
                assert( authoritative_type == AS_TYPE.string_value );
                return from_string_conversion[AS_TYPE.null_value];
            case AS_TYPE.boolean_value:
                assert( authoritative_type == AS_TYPE.string_value );
                return from_string_conversion[AS_TYPE.boolean_value];
            case AS_TYPE.int_value:
                return to_int_conversion[authoritative_type];
            case AS_TYPE.long_value:
                return to_long_conversion[authoritative_type];
            case AS_TYPE.bigInteger_value:
                return to_bigInteger_conversion[authoritative_type];
            case AS_TYPE.decimal_value:
                return to_decimal_conversion[authoritative_type];
            case AS_TYPE.double_value:
                return to_double_conversion[authoritative_type];
            case AS_TYPE.string_value:
                return to_string_conversions[authoritative_type];
            case AS_TYPE.date_value:
                assert( authoritative_type == AS_TYPE.timestamp_value );
                return FNID_FROM_TIMESTAMP_TO_DATE;
            case AS_TYPE.timestamp_value:
                assert( authoritative_type == AS_TYPE.date_value );
                return FNID_FROM_DATE_TO_TIMESTAMP;
        }
        String message = ""can't convert from ""
                       + getValueTypeName(authoritative_type)
                       + "" to ""
                       + getValueTypeName(new_type);
        throw new CantConvertException(message);
    }",Get the fnid of conversion from the authoritative_type to the new_type.
"protected void setNextValue(final long pValue, final int pLength, final int pMaxSize) {
		long value = pValue;
		// Set to max value if pValue cannot be stored on pLength bits.
		long bitMax = (long) Math.pow(2, Math.min(pLength, pMaxSize));
		if (pValue > bitMax) {
			value = bitMax - 1;
		}
		// size to wrote
		int writeSize = pLength;
		while (writeSize > 0) {
			// modulo
			int mod = currentBitIndex % BYTE_SIZE;
			byte ret = 0;
			if (mod == 0 && writeSize <= BYTE_SIZE || pLength < BYTE_SIZE - mod) {
				// shift left value
				ret = (byte) (value << BYTE_SIZE - (writeSize + mod));
			} else {
				// shift right
				long length = Long.toBinaryString(value).length();
				ret = (byte) (value >> writeSize - length - (BYTE_SIZE - length - mod));
			}
			byteTab[currentBitIndex / BYTE_SIZE] |= ret;
			long val = Math.min(writeSize, BYTE_SIZE - mod);
			writeSize -= val;
			currentBitIndex += val;
		}
	}",Sets the next value in the sequence of bytes.
"@SafeVarargs
    public static Function<CharSequence, TemporalAccessor> orderedParseAttempter(Function<CharSequence, TemporalAccessor>... parsers) {
        return date -> {
            RuntimeException first = null;
            for (Function<CharSequence, TemporalAccessor> parser : parsers) {
                try { return parser.apply(date); }
                catch (RuntimeException ex) {
                    if (first == null) first = ex;
                }
            }
            if (first == null) throw new IllegalStateException(""Empty parse attempter"");
            throw first;
        };
    }",Returns a function that parses the given date using the given parsers.
"@Override
    public Predicate lt(Expression<? extends Number> arg0, Number arg1)
    {
        return new ComparisonPredicate(arg0, arg1, ConditionalOperator.LT);
    }",Create a predicate that returns true if the two expressions in the sequence are less than the first.
"protected Map<String, WeakReference<T>> getClassLoaderCache(ClassLoader cl)
   {
      synchronized (cache)
      {
         Map<String, WeakReference<T>> result = cache.get(cl);
         if (result == null)
         {
            result = CollectionsFactory.createConcurrentReaderMap();
            cache.put(cl, result);
         }
         return result;
      }
   }",Get the class loader cache.
"protected final Value decodeNumberLax(boolean minus) {
        char[] array = charArray;

        final int startIndex = __index;
        int index = __index;
        char currentChar;
        boolean doubleFloat = false;
        boolean foundDot = false;
        boolean foundSign = false;
        boolean foundExp = false;

        if (minus && index + 1 < array.length) {
            index++;
        }

        while (true) {
            currentChar = array[index];
            if (isNumberDigit(currentChar)) {
                //noop
            } else if (currentChar <= 32) { //white
                break;
            } else if (isDelimiter(currentChar)) {
                break;
            } else if (isDecimalChar(currentChar)) {
                switch (currentChar) {
                    case DECIMAL_POINT:
                        if (foundDot || foundExp) { return decodeStringLax(); }
                        foundDot = true;
                        break;
                    case LETTER_E:
                    case LETTER_BIG_E:
                        if (foundExp) { return decodeStringLax(); }
                        foundExp = true;
                        break;
                    case MINUS:
                    case PLUS:
                        if (foundSign || !foundExp) { return decodeStringLax(); }
                        if (foundExp && array[index - 1] != LETTER_E && array[index - 1] != LETTER_BIG_E) {
                            return decodeStringLax();
                        }
                        foundSign = true;
                        break;
                }
                doubleFloat = true;
            } else {
                return decodeStringLax();
            }
            index++;
            if (index >= array.length) break;
        }

        // Handle the case where the exponential number ends without the actual exponent
        if (foundExp) {
            char prevChar = array[index - 1];
            if (prevChar == LETTER_E || prevChar == LETTER_BIG_E || prevChar == MINUS || prevChar == PLUS) {
                return decodeStringLax();
            }
        }

        __index = index;
        __currentChar = currentChar;

        Type type = doubleFloat ? Type.DOUBLE : Type.INTEGER;

        return new NumberValue(chop, type, startIndex, __index, this.charArray);
    }",Decode a number from the string.
"public CandidateList getStatewide(String stateId) throws VoteSmartException, VoteSmartErrorException {
		return api.query(""Officials.getStatewide"", new ArgMap(""stateId"", stateId), CandidateList.class );
	}",Get the list of candidate objects that are in the given state.
"public com.google.privacy.dlp.v2.FixedSizeBucketingConfigOrBuilder
      getFixedSizeBucketingConfigOrBuilder() {
    if (transformationCase_ == 5) {
      return (com.google.privacy.dlp.v2.FixedSizeBucketingConfig) transformation_;
    }
    return com.google.privacy.dlp.v2.FixedSizeBucketingConfig.getDefaultInstance();
  }",Gets the value of the fixedSizeBucketingConfig property.
"private static int parseOffsetISO8601(String text, ParsePosition pos, boolean extendedOnly, Output<Boolean> hasDigitOffset) {
        if (hasDigitOffset != null) {
            hasDigitOffset.value = false;
        }
        int start = pos.getIndex();
        if (start >= text.length()) {
            pos.setErrorIndex(start);
            return 0;
        }

        char firstChar = text.charAt(start);
        if (Character.toUpperCase(firstChar) == ISO8601_UTC.charAt(0)) {
            // ""Z"" - indicates UTC
            pos.setIndex(start + 1);
            return 0;
        }

        int sign;
        if (firstChar == '+') {
            sign = 1;
        } else if (firstChar == '-') {
            sign = -1;
        } else {
            // Not an ISO 8601 offset string
            pos.setErrorIndex(start);
            return 0;
        }
        ParsePosition posOffset = new ParsePosition(start + 1);
        int offset = parseAsciiOffsetFields(text, posOffset, ':', OffsetFields.H, OffsetFields.HMS);
        if (posOffset.getErrorIndex() == -1 && !extendedOnly && (posOffset.getIndex() - start <= 3)) {
            // If the text is successfully parsed as extended format with the options above, it can be also parsed
            // as basic format. For example, ""0230"" can be parsed as offset 2:00 (only first digits are valid for
            // extended format), but it can be parsed as offset 2:30 with basic format. We use longer result.
            ParsePosition posBasic = new ParsePosition(start + 1);
            int tmpOffset = parseAbuttingAsciiOffsetFields(text, posBasic, OffsetFields.H, OffsetFields.HMS, false);
            if (posBasic.getErrorIndex() == -1 && posBasic.getIndex() > posOffset.getIndex()) {
                offset = tmpOffset;
                posOffset.setIndex(posBasic.getIndex());
            }
        }

        if (posOffset.getErrorIndex() != -1) {
            pos.setErrorIndex(start);
            return 0;
        }

        pos.setIndex(posOffset.getIndex());
        if (hasDigitOffset != null) {
            hasDigitOffset.value = true;
        }
        return sign * offset;
    }",Parse ISO 8601 offset string.
"@Generated(value = ""com.sun.tools.xjc.Driver"", date = ""2018-10-12T02:54:50+02:00"", comments = ""JAXB RI v2.2.11"")
    public void setBueroTyp(BueroPraxen.BueroTyp value) {
        this.bueroTyp = value;
    }",Sets the value of the bueroTyp property.
"@Override
    public boolean isConnectedTo(IBond bond) {
        for (IAtom atom : atoms) {
            if (bond.contains(atom)) return true;
        }
        return false;
    }",Returns true if this molecule is connected to the given bond.
"private Locale getLocale() {
        Locale userlocale = null;
        if (localeName.length() > 0) {
            int firstuscore = localeName.indexOf('_');
            int seconduscore = -1;
            String language = null;
            String country = null;
            String variant = null;
            if (firstuscore == 2) {
                language = localeName.substring(0, firstuscore);
                seconduscore = localeName.indexOf('_', firstuscore + 1);
                if (seconduscore > 0) {
                    if (seconduscore != firstuscore + 3 ||
                           localeName.length() <= seconduscore + 1) {
                        docenv.error(null, ""main.malformed_locale_name"", localeName);
                        return null;
                    }
                    country = localeName.substring(firstuscore + 1,
                                                   seconduscore);
                    variant = localeName.substring(seconduscore + 1);
                } else if (localeName.length() == firstuscore + 3) {
                    country = localeName.substring(firstuscore + 1);
                } else {
                    docenv.error(null, ""main.malformed_locale_name"", localeName);
                    return null;
                }
            } else if (firstuscore == -1 && localeName.length() == 2) {
                language = localeName;
            } else {
                docenv.error(null, ""main.malformed_locale_name"", localeName);
                return null;
            }
            userlocale = searchLocale(language, country, variant);
            if (userlocale == null) {
                docenv.error(null, ""main.illegal_locale_name"", localeName);
                return null;
            } else {
                return userlocale;
            }
        } else {
            return Locale.getDefault();
        }
    }",Gets the locale.
"@Override
    public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
        if (handshakeOccurred.get()) {
            return super.onHeadersReceived(headers);
        }
        return STATE.CONTINUE;
    }",Override onHeadersReceived to handle headers received by the client.
"public void addChildrenOf(CSTNode of) {
        for (int i = 1; i < of.size(); i++) {
            add(of.get(i));
        }
    }",Add children of another node.
"public void setDestinationResolver(DestinationResolver destinationResolver) {
        Assert.notNull(destinationResolver, ""destinationResolver must not be null"");
        this.jmsTemplate.setDestinationResolver(destinationResolver);
        this.messageListenerContainer.setDestinationResolver(destinationResolver);
    }",Sets the destinationResolver for this localization.
"public static String repeat(final String s, final int repeat) {
        if (s == null) {
            return null;
        }
        if (repeat <= 0) {
            return """";
        }
        final int inputLength = s.length();
        if (repeat == 1 || inputLength == 0) {
            return s;
        }

        final int outputLength = inputLength * repeat;
        switch (inputLength) {
        case 1:
            return repeat(s.charAt(0), repeat);
        case 2:
            final char ch0 = s.charAt(0);
            final char ch1 = s.charAt(1);
            final char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            final StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(s);
            }
            return buf.toString();
        }
    }",Repeats a string in a sequence of times.
"public int convertTo(StringToUniqueIntegerMap other, int localId) {
        if (other == null) {
            throw new IllegalStateException(""Other map is null"");
        }
        String localKey = store.reverseGet(localId);
        if (localKey == null) {
            throw new IllegalArgumentException(""Cannot convert an id that is not registered locally."");
        }

        Integer foreignId = null;

        if (other == this) {
            return localId;
        } else if (other == parent) {
            foreignId = thisToParentMap.get(localId);
        } else if (other.parent == this) {
            foreignId = other.parentToThisMap.get(localId);
        }

        // Cache hit
        if (foreignId != null) {
            return foreignId;
        }

        Integer integerForeignId = other.store.get(localKey);

        // The other map doesn't have an entry for this key
        if (integerForeignId == null) {
            integerForeignId = other.register(localKey);
        }

        // Add the key/value pair to the cache
        if (other == parent) {
            thisToParentMap.set(localId, integerForeignId);
            parentToThisMap.set(integerForeignId, localId);
        } else if (other.parent == this) {
            other.thisToParentMap.set(integerForeignId, localId);
            other.parentToThisMap.set(localId, integerForeignId);
        }

        return integerForeignId;
    }",Convert a String to Unique Integer Map.
"@SuppressWarnings(""Unchecked"")
    public static Object checkImmutable(String className, String fieldName, Object field) {
        if (field == null || field instanceof Enum || inImmutableList(field.getClass().getName())) return field;
        if (field instanceof Collection) return DefaultGroovyMethods.asImmutable((Collection) field);
        if (field.getClass().getAnnotation(MY_CLASS) != null) return field;
        final String typeName = field.getClass().getName();
        throw new RuntimeException(createErrorMessage(className, fieldName, typeName, ""constructing""));
    }",Checks if the field is an immutable field.
"void markAsCollapsedCommand(HystrixCollapserKey collapserKey, int sizeOfBatch) {
        eventNotifier.markEvent(HystrixEventType.COLLAPSED, this.commandKey);
        executionResult = executionResult.markCollapsed(collapserKey, sizeOfBatch);
    }",Mark this command as collapsed.
"public <O extends BaseOption> ArgumentParser add(O option) {
        if (option.getName() != null) {
            if (longNameOptions.containsKey(option.getName())) {
                throw new IllegalArgumentException(""Option "" + option.getName() + "" already exists"");
            }
            if (parent != null && parent.longNameOptions.containsKey(option.getName())) {
                throw new IllegalArgumentException(""Option "" + option.getName() + "" already exists in parent"");
            }

            longNameOptions.put(option.getName(), option);
        }

        if (option instanceof Flag) {
            String negate = ((Flag) option).getNegateName();
            if (negate != null) {
                if (longNameOptions.containsKey(negate)) {
                    throw new IllegalArgumentException(""Flag "" + negate + "" already exists"");
                }
                if (parent != null && parent.longNameOptions.containsKey(negate)) {
                    throw new IllegalArgumentException(""Flag "" + negate + "" already exists in parent"");
                }

                longNameOptions.put(negate, option);
            }
        }

        if (option.getShortNames()
                  .length() > 0) {
            for (char s : option.getShortNames()
                                .toCharArray()) {
                if (shortOptions.containsKey(s)) {
                    throw new IllegalArgumentException(""Short option -"" + s + "" already exists"");
                }
                if (parent != null && parent.shortOptions.containsKey(s)) {
                    throw new IllegalArgumentException(""Short option -"" + s + "" already exists in parent"");
                }

                shortOptions.put(s, option);
            }
        }

        this.options.add(option);
        return this;
    }",Add an option to the command line.
"public List<IAtom> getRgroupQueryAtoms(Integer rgroupNumber) {

        List<IAtom> rGroupQueryAtoms = null;

        if (rootStructure != null) {
            rGroupQueryAtoms = new ArrayList<IAtom>();

            for (int i = 0; i < rootStructure.getAtomCount(); i++) {
                IAtom atom = rootStructure.getAtom(i);
                if (atom instanceof IPseudoAtom) {
                    IPseudoAtom rGroup = (IPseudoAtom) atom;
                    if (!rGroup.getLabel().equals(""R"")
                            && // just ""R"" is not a proper query atom
                            rGroup.getLabel().startsWith(""R"")
                            && (rgroupNumber == null || Integer.valueOf(rGroup.getLabel().substring(1)).equals(
                                    rgroupNumber))) rGroupQueryAtoms.add(atom);
                }
            }
        }
        return rGroupQueryAtoms;
    }",Get the Rgroup query atoms.
"public ServiceFuture<List<RecommendationInner>> listRecommendedRulesForWebAppAsync(final String resourceGroupName, final String siteName, final Boolean featured, final String filter, final ListOperationCallback<RecommendationInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listRecommendedRulesForWebAppSinglePageAsync(resourceGroupName, siteName, featured, filter),
            new Func1<String, Observable<ServiceResponse<Page<RecommendationInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<RecommendationInner>>> call(String nextPageLink) {
                    return listRecommendedRulesForWebAppNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }",List recommended rules for an App Service Environment.
"@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
    public static boolean hasPortraitScreenFeature(Context context) {
        return hasPortraitScreenFeature(context.getPackageManager());
    }",Check if the application has a homespan screen feature.
"public void close() throws IOException {
		writer.write(""</rdf:RDF>"");
		writer.write(""</x:xmpmeta>\n"");
		for (int i = 0; i < extraSpace; i++) {
			writer.write(EXTRASPACE);
		}
		writer.write(end == 'r' ? XPACKET_PI_END_R : XPACKET_PI_END_W);
		writer.flush();
		writer.close();
	}",Writes the RDF and XMP meta data to the output stream.
"@Override
    public DeploymentPlanBuilder andDeploy() {
        String addedKey = getAddedContentKey();
        DeploymentActionImpl deployMod = DeploymentActionImpl.getDeployAction(addedKey);
        return new DeploymentPlanBuilderImpl(this, deployMod);
    }",Create a new DeploymentPlanBuilder and deploy the content key.
"void set3(int newPrice, int optCur, int back2, int len2, int back) {
        price = newPrice;
        optPrev = optCur + len2 + 1;
        backPrev = back;
        prev1IsLiteral = true;
        hasPrev2 = true;
        optPrev2 = optCur;
        backPrev2 = back2;
    }",Set the 3 - tuple of tokens.
"private synchronized ReceiveAllowedThread getReceiveAllowedThread(DestinationHandler destinationHandler)
    {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.entry(tc, ""getReceiveAllowedThread"", destinationHandler);

        if (_receiveAllowedThread == null)
        {
            _receiveAllowedThread = new ReceiveAllowedThread(destinationHandler);
            if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
                SibTr.exit(tc, ""getReceiveAllowedThread"", _receiveAllowedThread);

            return _receiveAllowedThread;
        }

        _receiveAllowedThread.markForUpdate();
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.exit(tc, ""getReceiveAllowedThread"", null);
        return null;
    }",Gets the ReceiveAllowedThread object.
"public User get(String loginname, String password) {
        Connection conn = null;
        User user = null;
        if (loginname == null || password == null) return null;
        String cryptpassword = MD5.encodeString(password,null);
        try {
            conn = ConnectionUtils.getConnection();
            user = userDAO.get(conn,loginname,cryptpassword);
        } catch(SQLException e) {
            logger.error(e.getMessage());
        } finally {
            DbUtils.closeQuietly(conn);
        }
        return user;
    }",Get a user from the database.
"public static void elementPower(double a , DMatrixD1 B , DMatrixD1 C ) {

        if( B.numRows != C.numRows || B.numCols != C.numCols ) {
            throw new MatrixDimensionException(""All matrices must be the same shape"");
        }

        int size = B.getNumElements();
        for( int i = 0; i < size; i++ ) {
            C.data[i] = Math.pow(a, B.data[i]);
        }
    }",This method convert a double to element power.
"public void changePassword(String newPassword) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
        if (!connection().isSecureConnection() && !allowSensitiveOperationOverInsecureConnection) {
            throw new IllegalStateException(""Changing password over insecure connection."");
        }
        Map<String, String> map = new HashMap<>();
        map.put(""username"",  connection().getUser().getLocalpart().toString());
        map.put(""password"",newPassword);
        Registration reg = new Registration(map);
        reg.setType(IQ.Type.set);
        reg.setTo(connection().getXMPPServiceDomain());
        createStanzaCollectorAndSend(reg).nextResultOrThrow();
    }",Change the password of a user.
"public boolean isTriggeringEvent(LoggingEvent event) {
    //
    //   in the abnormal case of no contained filters
    //     always return true to avoid each logging event
    //     from having its own file.
    if (headFilter == null) {
      return false;
    }

    //
    //    otherwise loop through the filters
    //
    for (Filter f = headFilter; f != null; f = f.next) {
      switch (f.decide(event)) {
      case Filter.DENY:
        return false;

      case Filter.ACCEPT:
        return true;
      }
    }

    return true;
   }",Checks if the event is triggered by the filter
"public static void readLine(final String line, final Map<Long, List<Pair<Long, Double>>> mapUserRecommendations) {
        String[] toks = line.split(""\t"");
        // mymedialite format: user \t [item:score,item:score,...]
        if (line.contains("":"") && line.contains("","")) {
            Long user = Long.parseLong(toks[0]);
            String items = toks[1].replace(""["", """").replace(""]"", """");
            for (String pair : items.split("","")) {
                String[] pairToks = pair.split("":"");
                Long item = Long.parseLong(pairToks[0]);
                Double score = Double.parseDouble(pairToks[1]);
                List<Pair<Long, Double>> userRec = mapUserRecommendations.get(user);
                if (userRec == null) {
                    userRec = new ArrayList<Pair<Long, Double>>();
                    mapUserRecommendations.put(user, userRec);
                }
                userRec.add(new Pair<Long, Double>(item, score));
            }
        } else {
            Long user = Long.parseLong(toks[0]);
            Long item = Long.parseLong(toks[1]);
            Double score = Double.parseDouble(toks[2]);
            List<Pair<Long, Double>> userRec = mapUserRecommendations.get(user);
            if (userRec == null) {
                userRec = new ArrayList<Pair<Long, Double>>();
                mapUserRecommendations.put(user, userRec);
            }
            userRec.add(new Pair<Long, Double>(item, score));
        }
    }",Read a line of CRA - CRA related information.
"public CmsGroup getParent(CmsDbContext dbc, String groupname) throws CmsException {

        CmsGroup group = readGroup(dbc, groupname);
        if (group.getParentId().isNullUUID()) {
            return null;
        }

        // try to read from cache
        CmsGroup parent = m_monitor.getCachedGroup(group.getParentId().toString());
        if (parent == null) {
            parent = getUserDriver(dbc).readGroup(dbc, group.getParentId());
            m_monitor.cacheGroup(parent);
        }
        return parent;
    }",Returns the parent group of the given name.
"@Override
	public EClass getIfcCrewResource() {
		if (ifcCrewResourceEClass == null) {
			ifcCrewResourceEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)
					.getEClassifiers().get(154);
		}
		return ifcCrewResourceEClass;
	}",Get the IfcCrewResourceEClass for the ifcCrewResource feature.
"public synchronized void remove()
  {
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.entry(tc, ""remove"");

    if(removable != null)
    {
      index.remove(removable);
    }
    else
    {
      if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
        SibTr.exit(tc, ""remove"", ""IllegalStateException"");
      throw new IllegalStateException(
        nls.getFormattedMessage(
          ""NO_ELEMENTS_ERROR_CWSIP0602"",
          null,
          null));
    }

    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.exit(tc, ""remove"");
  }",Remove a single element from the index.
"public void write(File file, Integer indent) throws TransformerException, IOException {
		write(file, indent, null);
	}",Write the XML document to a file.
"public String getName(int i) {
        if (i < 0 || i >= names.size()) {
            return null;
        }
        return names.get(i);
    }",Gets the name of the i th record.
"@JsonProperty(""e"")
    @JsonSerialize(using = Base64UrlJsonSerializer.class)
    @JsonDeserialize(using = Base64UrlJsonDeserializer.class)
    public byte[] e() {
        return ByteExtensions.clone(this.e);
    }",Get the value of the e property.
"public static MozuUrl deleteAccountContactUrl(Integer accountId, Integer contactId)
	{
		UrlFormatter formatter = new UrlFormatter(""/api/commerce/customer/accounts/{accountId}/contacts/{contactId}"");
		formatter.formatUrl(""accountId"", accountId);
		formatter.formatUrl(""contactId"", contactId);
		return new MozuUrl(formatter.getResourceUrl(), MozuUrl.UrlLocation.TENANT_POD) ;
	}",Get Resource Url for DeleteAccountContact
"protected ModalShownHandler createShownHandler(final DisplayerSettings settings) {

        return new ModalShownHandler() {
            @Override
            public void onShown(ModalShownEvent modalShownEvent) {
                editor.init(settings);
                setTitle(editor.isBrandNewDisplayer() ? newDisplayerTitle : editDisplayerTitle);
                removeShownHandler();
            }
        };
    }",Create the modalShownHandler.
"@Override
    public <T> void apply(final Query<T> query) {
        pathProperties.each(props -> {
            String path = props.getPath();
            String propsStr = props.getPropertiesAsString();

            if (path == null || path.isEmpty()) {
                query.select(propsStr);
            } else {
                query.fetch(path, propsStr);
            }
        });
    }",Apply the filter to a query.
"public static double convertFromCelsius(TemperatureScale to, double temperature) {

        switch(to) {

            case FARENHEIT:
                return convertCelsiusToFarenheit(temperature);
            case CELSIUS:
                return temperature;
            case KELVIN:
                return convertCelsiusToKelvin(temperature);
            case RANKINE:
                return convertCelsiusToRankine(temperature);
            default:
                throw(new RuntimeException(""Invalid termpature conversion""));
        }
    }",Convert from CELSIUS temperature scale to CELSIUS temperature scale.
"private void updateImageInfo() {

        String crop = getCrop();
        String point = getPoint();
        m_imageInfoDisplay.fillContent(m_info, crop, point);
    }",Update the image info display.
"public Response createSystemProperty(SystemProperty property) {
		return restClient.post(""system/properties"", property, new HashMap<String, String>());
	}",Create a system property.
"public final void mUNION() throws RecognitionException {
		try {
			int _type = UNION;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// hql.g:67:7: ( 'union' )
			// hql.g:67:9: 'union'
			{
			match(""union""); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}",start UNION
"public static <T> TypeLiteral<T> get(Class<T> type) {
    return new TypeLiteral<T>(type);
  }",Get a type literal for a class.
"public final <A extends Number & Comparable<?>> BooleanExpression lt(Expression<A> right) {
        return Expressions.booleanOperation(Ops.LT, this, right);
    }",Gets the less than expression for this expression
"public static boolean parseBoolean(String bool, boolean defaultInt) {
        if (bool == null) {
            return defaultInt;
        } else {
            return Boolean.parseBoolean(bool);
        }
    }",Parse boolean.
"protected <T> T getPropertyOrStaticPropertyOrFieldValue(String name, Class<T> type) {
        return ClassPropertyFetcher.getStaticPropertyValue(getClazz(), name, type);
    }",Gets the property or static property or field value.
"@Override
    public int removeProperties(String pattern, Character escape) throws Exception {
        StringBuilder delete = new StringBuilder(58)
                        .append(""DELETE FROM Property WHERE ID LIKE :pattern"");
        if (escape != null)
            delete.append("" ESCAPE :escape"");

        final boolean trace = TraceComponent.isAnyTracingEnabled();
        if (trace && tc.isEntryEnabled())
            Tr.entry(this, tc, ""removeProperties"", pattern, escape, delete);

        EntityManager em = getPersistenceServiceUnit().createEntityManager();
        try {
            Query query = em.createQuery(delete.toString());
            query.setParameter(""pattern"", pattern);
            if (escape != null)
                query.setParameter(""escape"", escape);
            int count = query.executeUpdate();

            if (trace && tc.isEntryEnabled())
                Tr.exit(this, tc, ""removeProperties"", count);
            return count;
        } finally {
            em.close();
        }
    }",Removes all properties matching the specified pattern from the database.
"public <E> E deserialize(final String str, final Class<E> type, final Collection<Converter<?>> converters) {
        logger.debug(""deserialize(\""{}\"", {})"", str, type);

        if (converters == null || converters.isEmpty()) {
            // when possible, just reuse the base converter
            @SuppressWarnings(""unchecked"") final E result = (E) _baseConverter.fromString(type, str);
            return result;
        }

        final DelegatingConverter delegatingConverter = new DelegatingConverter();

        if (converters != null) {
            for (final Converter<?> converter : converters) {
                delegatingConverter.addConverter(converter);
                delegatingConverter.initialize(converter, _injectionManager);
            }
        }

        final List<Converter<?>> baseconverters = _baseConverter.getConverters();
        for (final Converter<?> converter : baseconverters) {
            delegatingConverter.addConverter(converter);
        }

        @SuppressWarnings(""unchecked"") final E result = (E) delegatingConverter.fromString(type, str);
        return result;
    }",Deserialize the given string into an object of the specified type using the given converters.
"@SafeVarargs
    public final PromiseAggregator<V, F> add(Promise<V>... promises) {
        if (promises == null) {
            throw new NullPointerException(""promises"");
        }
        if (promises.length == 0) {
            return this;
        }
        synchronized (this) {
            if (pendingPromises == null) {
                int size;
                if (promises.length > 1) {
                    size = promises.length;
                } else {
                    size = 2;
                }
                pendingPromises = new LinkedHashSet<Promise<V>>(size);
            }
            for (Promise<V> p : promises) {
                if (p == null) {
                    continue;
                }
                pendingPromises.add(p);
                p.addListener(this);
            }
        }
        return this;
    }",Add a list of Promises to the aggregator.
"public IfcWallTypeEnum createIfcWallTypeEnumFromString(EDataType eDataType, String initialValue) {
		IfcWallTypeEnum result = IfcWallTypeEnum.get(initialValue);
		if (result == null)
			throw new IllegalArgumentException(
					""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");
		return result;
	}",Converts a String to a IfcWallTypeEnum object.
"@SuppressFBWarnings(value = ""DM_DEFAULT_ENCODING"", justification = ""Open TODO item for wider rework"")
    @Override
    protected void eol(byte[] bytes, int len) throws IOException {
        String line = new String(bytes, 0, len);
        if(passwordsAsPattern != null) {
            line = passwordsAsPattern.matcher(line).replaceAll(MASKED_PASSWORD);
        }
        logger.write(line.getBytes());
    }",Write a line of bytes.
"public void setTerminal(AbstractUDPTerminal terminal) {
        this.terminal = terminal;
        if (terminal.isActive()) {
            transport = terminal.getTransport();
        }
    }",Sets the terminal.
"protected int getTransactionIsolation() {
		String val = props.get(PROPS_TRANSACTION_ISOLATION);
		return val == null ? -1 : Integer.parseInt(val);
	}",Returns the transaction isolation level.
"@Override
    public String getText() {
        String retType = AstToTextHelper.getClassText(returnType);
        String exceptionTypes = AstToTextHelper.getThrowsClauseText(exceptions);
        String parms = AstToTextHelper.getParametersText(parameters);
        return AstToTextHelper.getModifiersText(modifiers) + "" "" + retType + "" "" + name + ""("" + parms + "") "" + exceptionTypes + "" { ... }"";
    }",Get the text of the exception.
"private void getImportResource() throws CmsVfsException {

        // get the import resource
        m_importResource = new File(m_importFolderName);
        // check if this is a folder or a ZIP file
        if (m_importResource.isFile()) {
            try {
                m_zipStreamIn = new ZipInputStream(new FileInputStream(m_importResource));
            } catch (IOException e) {
                // if file but no ZIP file throw an exception
                throw new CmsVfsException(
                    Messages.get().container(Messages.ERR_NO_ZIPFILE_1, m_importResource.getName()),
                    e);
            }
        }
    }",Get the import resource.
"public static ImmoXmlDocument newDocument(Immoxml immoxml) throws ParserConfigurationException, JAXBException {
        if (immoxml.getUebertragung() == null)
            immoxml.setUebertragung(ImmoXmlUtils.getFactory().createUebertragung());
        if (StringUtils.isBlank(immoxml.getUebertragung().getVersion()))
            immoxml.getUebertragung().setVersion(ImmoXmlUtils.VERSION.toReadableVersion());

        Document document = XmlUtils.newDocument();
        ImmoXmlUtils.createMarshaller(""UTF-8"", true).marshal(immoxml, document);
        return new ImmoXmlDocument(document);
    }",Create a new document from an immoxml object.
"public static ResourceMeta withStream(final HasInputStream stream, final Map<String, String> meta) {
        return new BaseStreamResource(meta,stream);
    }",Create a new stream resource.
"public InputStream getInputStream() {
        if (m_requestEntity.length == 0) {
            return null;
        }
        ByteArrayInputStream bis = new ByteArrayInputStream(m_requestEntity);
        InputStream inStream = bis;
        if (m_bEntityCompressed) {
            try {
                inStream = new GZIPInputStream(bis);
            } catch (IOException e) {
                throw new IllegalArgumentException(""Error decompressing input: "" + e.toString());
            }
        }
        return inStream;
    }",Returns an input stream for the HTTP request entity.
"public boolean canFilter(Example example)
    {
        Example result = example;

        if (result == null) return false;

        if (isBeginTag(result) || isEndTag(result)) return true;
        else if (!lazyMode) return false;

        if (isEndTag(getNextTag(result)))
            return false;
        
        return !isWithinBeginAndEndTags(result);
    }",Checks if the example can be filtered by the CIDCTYPE filter.
"public static void cublasCherk(char uplo, char trans, int n, int k, float alpha, Pointer A, int lda, float beta, Pointer C, int ldc)
    {
        cublasCherkNative(uplo, trans, n, k, alpha, A, lda, beta, C, ldc);
        checkResultBLAS();
    }",Cublas Cherk for a symmetric matrix.
"private static boolean isCollectionMatching(Joinable mainSideJoinable, OgmCollectionPersister inverseSidePersister) {
		boolean isSameTable = mainSideJoinable.getTableName().equals( inverseSidePersister.getTableName() );

		if ( !isSameTable ) {
			return false;
		}

		return Arrays.equals( mainSideJoinable.getKeyColumnNames(), inverseSidePersister.getElementColumnNames() );
	}",Checks if the given joinable and inverse persister are matching.
"void genCode() throws IOException {
        if (!outputDirectory.exists()) {
            if (!outputDirectory.mkdirs()) {
                throw new IOException(""unable to create output directory ""
                        + outputDirectory);
            }
        }
        FileWriter cc = new FileWriter(new File(outputDirectory, mName + "".cc""));
        FileWriter hh = new FileWriter(new File(outputDirectory, mName + "".hh""));

        hh.write(""/**\n"");
        hh.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
        hh.write(""* or more contributor license agreements.  See the NOTICE file\n"");
        hh.write(""* distributed with this work for additional information\n"");
        hh.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
        hh.write(""* to you under the Apache License, Version 2.0 (the\n"");
        hh.write(""* \""License\""); you may not use this file except in compliance\n"");
        hh.write(""* with the License.  You may obtain a copy of the License at\n"");
        hh.write(""*\n"");
        hh.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
        hh.write(""*\n"");
        hh.write(""* Unless required by applicable law or agreed to in writing, software\n"");
        hh.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
        hh.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
        hh.write(""* See the License for the specific language governing permissions and\n"");
        hh.write(""* limitations under the License.\n"");
        hh.write(""*/\n"");
        hh.write(""\n"");

        cc.write(""/**\n"");
        cc.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
        cc.write(""* or more contributor license agreements.  See the NOTICE file\n"");
        cc.write(""* distributed with this work for additional information\n"");
        cc.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
        cc.write(""* to you under the Apache License, Version 2.0 (the\n"");
        cc.write(""* \""License\""); you may not use this file except in compliance\n"");
        cc.write(""* with the License.  You may obtain a copy of the License at\n"");
        cc.write(""*\n"");
        cc.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
        cc.write(""*\n"");
        cc.write(""* Unless required by applicable law or agreed to in writing, software\n"");
        cc.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
        cc.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
        cc.write(""* See the License for the specific language governing permissions and\n"");
        cc.write(""* limitations under the License.\n"");
        cc.write(""*/\n"");
        cc.write(""\n"");

        hh.write(""#ifndef __"" + mName.toUpperCase().replace('.', '_') + ""__\n"");
        hh.write(""#define __"" + mName.toUpperCase().replace('.', '_') + ""__\n"");

        hh.write(""#include \""recordio.hh\""\n"");
        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext();) {
            JFile f = i.next();
            hh.write(""#include \"""" + f.getName() + "".hh\""\n"");
        }
        cc.write(""#include \"""" + mName + "".hh\""\n"");

        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext();) {
            JRecord jr = i.next();
            jr.genCppCode(hh, cc);
        }

        hh.write(""#endif //"" + mName.toUpperCase().replace('.', '_') + ""__\n"");

        hh.close();
        cc.close();
    }",Generate the code for the class.
"public UNode toDoc() {
        // Root object is a MAP called ""batch"".
        UNode batchNode = UNode.createMapNode(""batch"");
        
        // Add a ""docs"" node as an array.
        UNode docsNode = batchNode.addArrayNode(""docs"");
        for (DBObject dbObj : m_dbObjList) {
            docsNode.addChildNode(dbObj.toDoc());
        }
        return batchNode;
    }",Returns a UNode tree representing the object in this DBObjectList as a MAP.
"public Link expand(Map<String, ? extends Object> arguments) {
		return new Link(template.expand(arguments).toString(), getRel());
	}",Expand the template with the given arguments.
"public List<Runnable> shutdownNow() {
        List<Runnable> tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            /* J2ObjC removed.
            checkShutdownAccess();
            */
            advanceRunState(STOP);
            interruptWorkers();
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
        return tasks;
    }",Shutdown the thread.
"private String findContainerId(String imageNameOrAlias, boolean checkAllContainers) throws DockerAccessException {
        String id = lookupContainer(imageNameOrAlias);

        // check for external container. The image name is interpreted as a *container name* for that case ...
        if (id == null) {
            Container container = queryService.getContainer(imageNameOrAlias);
            if (container != null && (checkAllContainers || container.isRunning())) {
                id = container.getId();
            }
        }
        return id;
    }",Find the container id for the image name or alias.
"public String getOauthPageUrl(String redirectUrl, OauthScope scope, String state) {
        BeanUtil.requireNonNull(redirectUrl, ""redirectUrl is null"");
        BeanUtil.requireNonNull(scope, ""scope is null"");
        String userState = StrUtil.isBlank(state) ? ""STATE"" : state;
        String url = null;
        try {
            url = URLEncoder.encode(redirectUrl, ""UTF-8"");
        } catch (UnsupportedEncodingException e) {
            LOG.error(""异常"", e);
        }
        StringBuilder stringBuilder = new StringBuilder(""https://open.weixin.qq.com/connect/oauth2/authorize?"");
        stringBuilder.append(""appid="").append(this.config.getAppid())
                .append(""&redirect_uri="").append(url)
                .append(""&response_type=code&scope="").append(scope.toString())
                .append(""&state="")
                .append(userState)
                .append(""#wechat_redirect"");
        return stringBuilder.toString();
    }",Gets the authorization page url.
"public static Scopes from(String... scopes)
    {
        if (scopes == null || scopes.length == 0) return NONE;
        return new Scopes(scopes, true);
    }",Creates a new Scopes object from the given list of scopes.
"void compressNew(PointList points, int removed) {
        int freeIndex = -1;
        for (int currentIndex = 0; currentIndex < points.getSize(); currentIndex++) {
            if (Double.isNaN(points.getLatitude(currentIndex))) {
                if (freeIndex < 0)
                    freeIndex = currentIndex;

                continue;
            } else if (freeIndex < 0) {
                continue;
            }

            points.set(freeIndex, points.getLatitude(currentIndex), points.getLongitude(currentIndex), points.getElevation(currentIndex));
            points.set(currentIndex, Double.NaN, Double.NaN, Double.NaN);
            // find next free index
            int max = currentIndex;
            int searchIndex = freeIndex + 1;
            freeIndex = currentIndex;
            for (; searchIndex < max; searchIndex++) {
                if (Double.isNaN(points.getLatitude(searchIndex))) {
                    freeIndex = searchIndex;
                    break;
                }
            }
        }
        points.trimToSize(points.getSize() - removed);
    }",Compress new points.
"@Override
	public CPDefinition create(long CPDefinitionId) {
		CPDefinition cpDefinition = new CPDefinitionImpl();

		cpDefinition.setNew(true);
		cpDefinition.setPrimaryKey(CPDefinitionId);

		String uuid = PortalUUIDUtil.generate();

		cpDefinition.setUuid(uuid);

		cpDefinition.setCompanyId(companyProvider.getCompanyId());

		return cpDefinition;
	}",Creates a new cp definition in the database. Also sets the new flag to true.
"public AttributeDataset parse(InputStream stream) throws IOException, ParseException {
        try (Reader r = new BufferedReader(new InputStreamReader(stream))) {
            StreamTokenizer tokenizer = new StreamTokenizer(r);
            initTokenizer(tokenizer);

            List<Attribute> attributes = new ArrayList<>();
            String relationName = readHeader(tokenizer, attributes);

            if (attributes.isEmpty()) {
                throw new IOException(""no header information available"");
            }
        
            Attribute response = null;
            Attribute[] attr = new Attribute[attributes.size()];
            attributes.toArray(attr);
        
            for (int i = 0; i < attributes.size(); i++) {
                if (responseIndex == i) {
                    response = attributes.remove(i);
                    break;
                }
            }
        
            AttributeDataset data = new AttributeDataset(relationName, attributes.toArray(new Attribute[attributes.size()]), response);
        
            while (true) {
                // Check if end of file reached.
                getFirstToken(tokenizer);
                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {
                    break;
                }

                // Parse instance
                if (tokenizer.ttype == '{') {
                    readSparseInstance(tokenizer, data, attr);
                } else {
                    readInstance(tokenizer, data, attr);
                }
            }
        
            for (Attribute attribute : attributes) {
                if (attribute instanceof NominalAttribute) {
                    NominalAttribute a = (NominalAttribute) attribute;
                    a.setOpen(false);
                }
            
                if (attribute instanceof StringAttribute) {
                    StringAttribute a = (StringAttribute) attribute;
                    a.setOpen(false);
                }
            }
        
            return data;
        }
    }",Parses the specified input stream.
"public static void copyParagraphAnnotations(JCas source, JCas target)
            throws IllegalArgumentException
    {
        if (!source.getDocumentText().equals(target.getDocumentText())) {
            throw new IllegalArgumentException(
                    ""source.documentText and target.documentText are not equal"");
        }

        Collection<Paragraph> targetParagraphs = JCasUtil.select(target, Paragraph.class);
        if (!targetParagraphs.isEmpty()) {
            throw new IllegalArgumentException(""target already contains paragraph annotations"");
        }

        for (Paragraph paragraph : JCasUtil.select(source, Paragraph.class)) {
            Paragraph paragraphCopy = new Paragraph(target);
            paragraphCopy.setBegin(paragraph.getBegin());
            paragraphCopy.setEnd(paragraph.getEnd());
            paragraphCopy.addToIndexes();
        }
    }",Copy Paragraph annotations from source to target.
"protected Object getValue(Object value, ComparisonType type) {
        return type == ComparisonType.NODE_TYPE ? nodeType((Short) value) : value;
    }",Get the value of the attribute.
"public final void mVOID() throws RecognitionException {
        try {
            int _type = VOID;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // com/dyuproject/protostuff/parser/ProtoLexer.g:223:5: ( 'void' )
            // com/dyuproject/protostuff/parser/ProtoLexer.g:223:9: 'void'
            {
            match(""void""); 


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }",start void
"@SuppressWarnings(""unchecked"")
	@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case AfplibPackage.PPORG__RG_LENGTH:
				setRGLength((Integer)newValue);
				return;
			case AfplibPackage.PPORG__OBJ_TYPE:
				setObjType((Integer)newValue);
				return;
			case AfplibPackage.PPORG__PROC_FLGS:
				setProcFlgs((Integer)newValue);
				return;
			case AfplibPackage.PPORG__XOCA_OSET:
				setXocaOset((Integer)newValue);
				return;
			case AfplibPackage.PPORG__YOCA_OSET:
				setYocaOset((Integer)newValue);
				return;
			case AfplibPackage.PPORG__TRIPLETS:
				getTriplets().clear();
				getTriplets().addAll((Collection<? extends Triplet>)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}",Override the eSet method for the featureID
"private String getElementID(final String relativePath) {
        final String fragment = getFragment(relativePath);
        if (fragment != null) {
            if (fragment.lastIndexOf(SLASH) != -1) {
                return fragment.substring(fragment.lastIndexOf(SLASH) + 1);
            } else {
                return fragment;
            }
        }
        return null;
    }",Gets the element ID from the relative path.
"public static SelectColumn includes(String[] cols, String... columns) {
        return new SelectColumn(Utility.append(cols, columns), false);
    }",Creates a SelectColumn that includes the specified columns.
"@NullableDecl
  static <T> T pollNext(Iterator<T> iterator) {
    if (iterator.hasNext()) {
      T result = iterator.next();
      iterator.remove();
      return result;
    } else {
      return null;
    }
  }",Polls the next element from the iterator.
"private void increment(final Calendar cal) {
        // initialise interval..
        final int calInterval = (getInterval() >= 1) ? getInterval() : 1;
        cal.add(calIncField, calInterval);
    }",Increments the calendar by the value of the interval field.
"@Override
	public CommerceOrderNote fetchByC_R_Last(long commerceOrderId,
		boolean restricted,
		OrderByComparator<CommerceOrderNote> orderByComparator) {
		int count = countByC_R(commerceOrderId, restricted);

		if (count == 0) {
			return null;
		}

		List<CommerceOrderNote> list = findByC_R(commerceOrderId, restricted,
				count - 1, count, orderByComparator);

		if (!list.isEmpty()) {
			return list.get(0);
		}

		return null;
	}",Returns the last commerce order note in the ordered set where C_R = 1
"public static Point2i convert(Tuple2D<?> tuple) {
		if (tuple instanceof Point2i) {
			return (Point2i) tuple;
		}
		return new Point2i(tuple.getX(), tuple.getY());
	}",Convert the given tuple to a real Point2i.
"protected Response getWithAccepts(MultivaluedMap<String, String> queryParams, URL url, String accepts) {
        return (invocation(url, queryParams, accepts).get());
    }",Get a response with the given query parameters and URL
"protected void stopJobAcquisitionThread() {
    if (asyncJobAcquisitionThread != null) {
      try {
        asyncJobAcquisitionThread.join();
      } catch (InterruptedException e) {
        log.warn(""Interrupted while waiting for the async job acquisition thread to terminate"", e);
      }
      asyncJobAcquisitionThread = null;
    }
  }",Stop the async job acquisition thread
"public static Element getChild(Element element, String name) {
        return (Element) element.getElementsByTagName(name).item(0);
    }",Get the first child element with the given name.
"protected void initMojoMultiValueParameters() {

		// Set default values for 'checkFileSets' to ""src/main/resources/*.btdesign""
		if (checkFileSets == null) {
			FileSet defaultFileSet = new FileSet();
			defaultFileSet.setDirectory(project.getBasedir() + ""/src/main/resources"");
			defaultFileSet.addInclude(""*.btdesign"");
			checkFileSets = new FileSet[] { defaultFileSet };
		}
	}",Initialize the multi - value parameters.
"public Set<Class<? extends Exception>> getRecoverableExceptions() {
    return recoverableExceptions != null ? recoverableExceptions : parent != null ? parent.getRecoverableExceptions()
      : Collections.<Class<? extends Exception>>emptySet();
  }",Returns the set of recoverable exceptions.
"public Coordinate getCoordinateN(int n) {
		if (isEmpty()) {
			return null;
		}
		if (n >= 0 && n < coordinates.length) {
			return coordinates[n];
		}
		return null;
	}",Get the n - th coordinate in this list.
"@Override
	public Integer next() {
		if (!hasNext()) {
			throw new NoSuchElementException(toString() + "" ended"");
		}

		current = next;
		next = next + increment;

		return current();
	}",Returns the next value in the iterator.
"protected void writeIndent() throws IOException {
		final int start = writeLineSepartor ? 0 : offsetNewLine;
		final int level = (depth > maxIndentLevel) ? maxIndentLevel : depth;
		out.write(indentationBuf, start, ((level - 1) * indentationJump) + offsetNewLine);
	}",Write indentation.
"public final static String process(final File file, final Configuration configuration) throws IOException
    {
        final FileInputStream input = new FileInputStream(file);
        final String ret = process(input, configuration);
        input.close();
        return ret;
    }",Process a file containing a CIDCTYPE file.
"@GetMapping(value = ""/{entityTypeId}/exist"", produces = APPLICATION_JSON_VALUE)
  public boolean entityExists(@PathVariable(""entityTypeId"") String entityTypeId) {
    return dataService.hasRepository(entityTypeId);
  }",Checks if entity exists.
"public ResultsWrapper<Issue> getIssues(Params parameters) throws RedmineException {
        return transport.getObjectsListNoPaging(Issue.class, parameters.getList());
    }",Gets the issues.
"public void openGalleryDialog(CmsResource resource) {

        try {
            CmsObject cms = A_CmsUI.getCmsObject();
            JSONObject conf = new JSONObject();
            conf.put(I_CmsGalleryProviderConstants.CONFIG_GALLERY_MODE, GalleryMode.view.name());
            conf.put(I_CmsGalleryProviderConstants.CONFIG_GALLERY_PATH, cms.getSitePath(resource));
            conf.put(I_CmsGalleryProviderConstants.CONFIG_GALLERY_STORAGE_PREFIX, """");
            conf.put(I_CmsGalleryProviderConstants.CONFIG_TAB_CONFIG, CmsGalleryTabConfiguration.TC_SELECT_ALL);
            getRpcProxy(I_CmsGwtDialogClientRpc.class).openGalleryDialog(conf.toString());
        } catch (JSONException e) {
            CmsErrorDialog.showErrorDialog(e);
        }
    }",Open the gallery dialog for the given resource.
"public final V set(int index, K key, V value) {
    if (index < 0) {
      throw new IndexOutOfBoundsException();
    }
    int minSize = index + 1;
    ensureCapacity(minSize);
    int dataIndex = index << 1;
    V result = valueAtDataIndex(dataIndex + 1);
    setData(dataIndex, key, value);
    if (minSize > this.size) {
      this.size = minSize;
    }
    return result;
  }",Sets the value at the given index.
"public static VectorNd normalizeSafe(VectorNd v) {
        try {
            return v.normalize();
        } catch (ArithmeticException ex) {
            return new VectorNd(v.size());
        }
    }",Normalize a vector.
"public void setSecond(Integer newSecond) {
		Integer oldSecond = second;
		second = newSecond;
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, AfplibPackage.UNIVERSAL_DATE_AND_TIME_STAMP__SECOND, oldSecond, second));
	}",Sets the second value.
"<E> Observable<E> addLogging(@NonNull Observable<E> obs, @NonNull Logger log, final String msg) {
        return obs.doOnNext(r -> log(log, (ComapiResult) r, msg))
                .doOnError(t -> log(log, t, msg));
    }",Add logging to an observable.
"private static List<MutableDoubleTuple> validate(
        Collection<? extends DoubleTuple> inputs,
        List<MutableDoubleTuple> results)
    {
        if (results == null)
        {
            results = new ArrayList<MutableDoubleTuple>(inputs.size());
            for (DoubleTuple input : inputs)
            {
                results.add(DoubleTuples.create(input.getSize()));
            }
        }
        else
        {
            if (inputs.size() != results.size())
            {
                throw new IllegalArgumentException(
                    ""The number of inputs ("" + inputs.size() + "") must "" +
                    ""be the same as the number of results "" +
                    ""("" + results.size() + "")"");
            }
        }
        return results;
    }",Validates the input list and results.
"public EvalError toEvalError(
        String msg, SimpleNode node, CallStack callstack  )
    {
        if ( null == msg )
            msg = this.getMessage();
        else
            msg += "": "" + this.getMessage();

        return new TargetError( msg, this.getCause(), node, callstack, false );
    }",To EvalError.
"public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case NUM_CPUS:
      return isSetNumCpus();
    case NETWORK_MBPS:
      return isSetNetworkMBps();
    case MEMORY_MB:
      return isSetMemoryMB();
    case DISK_GB:
      return isSetDiskGB();
    }
    throw new IllegalStateException();
  }",Checks if the specified field is set to a value of a CRA_Compute_Product_Group object.
"public Object invokeMethod(String name, Object args) {
        boolean notExpectedArgs = false;
        if (args != null && Object[].class.isAssignableFrom(args.getClass())) {
            Object[] arr = (Object[]) args;
            try {
                switch(arr.length) {
                    case 0:
                        call(name);
                    break;
                    case 1:
                        if (arr[0] instanceof Closure) {
                            final Closure callable = (Closure) arr[0];
                            call(name, callable);
                        } else if (arr[0] instanceof Map) {
                            final Map<String, Map> map = Collections.singletonMap(name, (Map) arr[0]);
                            call(map);
                        } else {
                            notExpectedArgs = true;
                        }
                    break;
                    case 2:
                        final Object first = arr[0];
                        final Object second = arr[1];
                        final boolean isClosure = second instanceof Closure;

                        if(isClosure && first instanceof Map ) {
                            final Closure callable = (Closure) second;
                            call(name, (Map)first, callable);
                        }
                        else if(isClosure && first instanceof Iterable) {
                            final Iterable coll = (Iterable) first;
                            final Closure callable = (Closure) second;
                            call(name, coll, callable);
                        }
                        else if(isClosure && first.getClass().isArray()) {
                            final Iterable coll = Arrays.asList((Object[])first);
                            final Closure callable = (Closure) second;
                            call(name, coll, callable);
                        }
                        else {
                            notExpectedArgs = true;
                        }
                    break;
                    default:
                        notExpectedArgs = true;
                }
            } catch (IOException ioe) {
                throw new JsonException(ioe);
            }
        } else {
            notExpectedArgs = true;
        }

        if (!notExpectedArgs) {
            return this;
        } else {
            throw new JsonException(""Expected no arguments, a single map, a single closure, or a map and closure as arguments."");
        }
    }",This method is called by the reflection to call a method on the class that is passed as parameter.
"public ListApplicationVersionsResult withVersions(VersionSummary... versions) {
        if (this.versions == null) {
            setVersions(new java.util.ArrayList<VersionSummary>(versions.length));
        }
        for (VersionSummary ele : versions) {
            this.versions.add(ele);
        }
        return this;
    }",A list of the versions of the application.
"public Observable<Void> createOrUpdateAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, String protectedItemName, ProtectedItemResourceInner parameters) {
        return createOrUpdateWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName, protectedItemName, parameters).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }",Creates or updates a CDNA resource.
"@Override
    public void close() {
        namedParamSqlCache.clear();
        namedParamIndexPropCache.clear();
        clearStatementCache();
        if (useConnection != null) {
            try {
                useConnection.close();
            } catch (SQLException e) {
                LOG.finest(""Caught exception closing connection: "" + e.getMessage());
            }
        }
    }",Close the database connection.
"public static ThreeDSecure retrieve(String threeDSecure) throws StripeException {
    return retrieve(threeDSecure, (Map<String, Object>) null, (RequestOptions) null);
  }",Retrieves a ThreeDSecure resource.
"@Override
    public UpdatePullRequestStatusResult updatePullRequestStatus(UpdatePullRequestStatusRequest request) {
        request = beforeClientExecution(request);
        return executeUpdatePullRequestStatus(request);
    }",Updates the status of a PRON process.
"void register(URL url, InMemoryMappingFile immf) {
        _data.put(url.getFile(), immf);
    }",Registers an InMemoryMappingFile for the given URL.
"protected void add(IIsotope isotope) {
        Integer atomicNum = isotope.getAtomicNumber();
        assert atomicNum != null;
        List<IIsotope> isotopesForElement = isotopes[atomicNum];
        if (isotopesForElement == null) {
            isotopesForElement = new ArrayList<>();
            isotopes[atomicNum] = isotopesForElement;
        }
        isotopesForElement.add(isotope);
    }",Add an IIsotope to the set of isotopes.
"protected X509Credential loadProxyCredential(String proxyPath) {

    PEMCredential cred = null;

    listener.notifyCredentialLookup(proxyPath);

    try {

      FilePermissionHelper.checkProxyPermissions(proxyPath);
      cred = new PEMCredential(new FileInputStream(proxyPath), (char[]) null);
      listener.notifyLoadCredentialSuccess(proxyPath);

    } catch (Throwable t) {

      listener.notifyLoadCredentialFailure(t, proxyPath);
    }

    return cred;
  }",Load the proxy credential.
"protected void checkAttribute(String attribute) {
        if (!hasAttribute(attribute)) {
            String sb = ""Attribute: '"" + attribute + ""' is not defined in model: '"" + getModelClass() + "". ""
                    + ""Available attributes: "" +getAttributeNames();
            throw new IllegalArgumentException(sb);
        }
    }",Check if the attribute is defined in the model.
"private void readConfig(){
		AccumulatorsConfig config = MoskitoConfigurationHolder.getConfiguration().getAccumulatorsConfig();
		AccumulatorConfig[] acs = config.getAccumulators();
		if (acs!=null && acs.length>0){
			for (AccumulatorConfig ac  : acs){
				AccumulatorDefinition ad = new AccumulatorDefinition();
				ad.setName(ac.getName());
				ad.setIntervalName(ac.getIntervalName());
				ad.setProducerName(ac.getProducerName());
				ad.setStatName(ac.getStatName());
				ad.setTimeUnit(TimeUnit.valueOf(ac.getTimeUnit()));
				ad.setValueName(ac.getValueName());
				Accumulator acc = createAccumulator(ad);
				if (log.isDebugEnabled()){
					log.debug(""Created accumulator ""+acc);
				}
			}
		}

		AutoAccumulatorConfig[] autoAccumulatorConfigs = config.getAutoAccumulators();
		if (autoAccumulatorConfigs != null && autoAccumulatorConfigs.length>0){
			for (AutoAccumulatorConfig aac : autoAccumulatorConfigs){
				AutoAccumulatorDefinition aad = new AutoAccumulatorDefinition();
				aad.setNamePattern(aac.getNamePattern());
				aad.setProducerNamePattern(aac.getProducerNamePattern());
				aad.setIntervalName(aac.getIntervalName());
				aad.setValueName(aac.getValueName());
				aad.setStatName(aac.getStatName());
				aad.setTimeUnit(TimeUnit.fromString(aac.getTimeUnit()));
				aad.setAccumulationAmount(aac.getAccumulationAmount());
				autoAccumulatorDefinitions.add(aad);
			}
		}

	}",Read configuration.
"@Override
    public void contextRootAdded(String contextRoot, VirtualHost virtualHost) {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEventEnabled()) {
            Tr.event(tc, ""Added contextRoot {0} to virtual host {1}"", contextRoot, virtualHost.getName());
        }

        // Check that our app got installed
        if (contextRoot != null
            && contextRoot.contains(APIConstants.JMX_CONNECTOR_API_ROOT_PATH)
            && ""default_host"".equals(virtualHost.getName())) {
            registeredContextRoot = contextRoot;

            if (secureVirtualHost == virtualHost) {
                createJMXWorkAreaResourceIfChanged(virtualHost);
            }
        }
    }",Override contextRootAdded to add a contextRoot to a VirtualHost.
"public static void bufferedToPlanar_U8(DataBufferInt buffer, WritableRaster src, Planar<GrayU8> dst) {
		int[] srcData = buffer.getData();

		int srcStride = stride(src);
		int srcOffset = getOffset(src);

		int numBands = src.getNumBands();
		byte[] data1 = dst.getBand(0).data;
		byte[] data2 = dst.getBand(1).data;
		byte[] data3 = dst.getBand(2).data;

		if( numBands == 3 ) {
			//CONCURRENT_BELOW BoofConcurrency.loopFor(0, dst.height, y -> {
			for (int y = 0; y < dst.height; y++) {
				int indexSrc = srcOffset + y*srcStride;
				int indexDst = dst.startIndex + y * dst.stride;
				for (int x = 0; x < dst.width; x++, indexDst++) {

					int rgb = srcData[indexSrc++];

					data1[indexDst] = (byte) (rgb >>> 16);
					data2[indexDst] = (byte) (rgb >>> 8);
					data3[indexDst] = (byte) rgb;
				}
			}
			//CONCURRENT_ABOVE });
		} else if( numBands == 4 ) {
			byte[] data4 = dst.getBand(3).data;

			//CONCURRENT_BELOW BoofConcurrency.loopFor(0, dst.height, y -> {
			for (int y = 0; y < dst.height; y++) {
				int indexSrc = srcOffset + y*srcStride;
				int indexDst = dst.startIndex + y * dst.stride;
				for (int x = 0; x < dst.width; x++, indexDst++) {

					int rgb = srcData[indexSrc++];

					data1[indexDst] = (byte) (rgb >>> 24);
					data2[indexDst] = (byte) (rgb >>> 16);
					data3[indexDst] = (byte) (rgb >>> 8);
					data4[indexDst] = (byte) rgb;
				}
			}
			//CONCURRENT_ABOVE });
		}
	}",Converts a buffered raster into a planar image.
"static Pair<String, Integer> getId(Annotation annot) {

		if (annot instanceof DictTerm) {
			DictTerm dt = (DictTerm) annot;
			String[] split = dt.getEntityId().split("":"");
			return Pair.of(split[0], parseInt(split[1]));

			// } else if (annot instanceof Measure) {
			// Measure m = (Measure) annot;
			// return Pair.of(""""+m.getNormalizedUnit(), parseInt(split[1]));

		} else
			throw new RuntimeException(""NOT IMPLEMENTED xxx"");// FIXME
	}",Get the ID of an annotation.
"public void removeAndTryClose(Connection connection) {
        if (null == connection) {
            return;
        }
        boolean res = this.conns.remove(connection);
        if (res) {
            connection.decreaseRef();
        }
        if (connection.noRef()) {
            connection.close();
        }
    }",Remove and try close a connection.
"private static boolean isCompatibleWithProvidedType(Class<?> providedClass,
                                                      Class<?> replacementClass) {
    if (Integer.class.isAssignableFrom(providedClass)) {
      return (replacementClass == String.class ||
          replacementClass == Integer.class ||
          replacementClass == Long.class);
    } else if (Long.class.isAssignableFrom(providedClass)) {
      return (replacementClass == String.class ||
          replacementClass == Long.class);
    } else if (String.class.isAssignableFrom(providedClass)) {
      return replacementClass == String.class;
    }
    return false;
  }",Checks if the provided type is compatible with the replacement type.
"public void addItem (int index, T item)
    {
        if (_items == null) {
            return;
        }
        _items.add(index, item);
    }",Add an item to the list of items.
"public static Observable<AsyncViewResult> mapToViewResult(final AsyncBucket bucket, final ViewQuery query,
        final ViewQueryResponse response) {

        return response
            .info()
            .singleOrDefault(null)
            .map(new ByteBufToJsonObject())
            .map(new BuildViewResult(bucket, query, response));
    }",Map to view result observable.
"public static int setPrivate(int modifier, boolean b) {
        if (b) {
            return (modifier | PRIVATE) & (~PUBLIC & ~PROTECTED);
        }
        else {
            return modifier & ~PRIVATE;
        }
    }",Sets the private modifier.
"@Override
    public <T> T getJsonProperty(String propertyName) {
        return (T) getProperty(propertyName, String.class);
    }",Get a property from the cache.
"protected Element createTextElement(float width)
    {
        Element el = doc.createElement(""div"");
        el.setAttribute(""id"", ""p"" + (textcnt++));
        el.setAttribute(""class"", ""p"");
        String style = curstyle.toString();
        style += ""width:"" + width + UNIT + "";"";
        el.setAttribute(""style"", style);
        return el;
    }",Create a text element.
"public void onCommandException(CommandResponse response) {
		String message = I18nProvider.getGlobal().commandError() + "":"";
		for (String error : response.getErrorMessages()) {
			message += ""\n"" + error;
		}
		Log.logWarn(message);
		if (response.getExceptions() == null || response.getExceptions().size() == 0) {
			SC.warn(message);
		} else {
			// The error messaging window only supports 1 exception to display:
			ExceptionWindow window = new ExceptionWindow(response.getExceptions().get(0));
			window.show();
		}
	}",Called when a command exception occurs.
"public void invalidate(Key... keys) {
        for (Key key : keys) {
            logger.debug(""Invalidating the response cache key : {} {} {} {}, {}"",
                    key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());

            readWriteCacheMap.invalidate(key);
            Collection<Key> keysWithRegions = regionSpecificKeys.get(key);
            if (null != keysWithRegions && !keysWithRegions.isEmpty()) {
                for (Key keysWithRegion : keysWithRegions) {
                    logger.debug(""Invalidating the response cache key : {} {} {} {} {}"",
                            key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());
                    readWriteCacheMap.invalidate(keysWithRegion);
                }
            }
        }
    }",Invalidates the response cache for the given keys.
"@Override
    public Money divide(Number divisor) {
        if (NumberVerifier.isInfinityAndNotNaN(divisor)) {
            return Money.of(0, getCurrency());
        }
        BigDecimal divisorBD = MoneyUtils.getBigDecimal(divisor);
        if (divisorBD.equals(BigDecimal.ONE)) {
            return this;
        }
        BigDecimal dec =
                this.number.divide(divisorBD, MoneyUtils.getMathContext(getContext(), RoundingMode.HALF_EVEN));
        return new Money(dec, getCurrency());
    }",This method is used to divide this Money by another.
"public JSONObject linkToJSON(Link s) {
        JSONObject o = new JSONObject();
        o.put(""id"", s.id());
        o.put(CAPACITY_LABEL, s.getCapacity());
        o.put(SWITCH_LABEL, s.getSwitch().id());
        o.put(""physicalElement"", physicalElementToJSON(s.getElement()));
        return o;
    }",Convert a Link to a JSONObject
"public AVQuery<T> whereContainsAll(String key, Collection<?> values) {
    conditions.whereContainsAll(key, values);
    return this;
  }",Add a constraint to the query that requires a particular key s value to contain all of the provided values.
"private final JSRemoteConsumerPoint findOrCreateJSRemoteConsumerPoint(String[] discriminators, int[] selectorDomains,
                                                        String[] selectors)
    throws ClosedException
  {
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.entry(tc, ""findOrCreateJSRemoteConsumerPoint"",
          new Object[]{Arrays.toString(discriminators),
                       Arrays.toString(selectorDomains),
                       Arrays.toString(selectors)});

    String selectionCriteriasAsString = parent.convertSelectionCriteriasToString(
                                                  discriminators, selectorDomains, selectors);

    JSRemoteConsumerPoint aock = (JSRemoteConsumerPoint) consumerKeyTable.get(selectionCriteriasAsString);
    if (aock == null)
    {
      try
      {
        // create an JSRemoteConsumerPoint
        aock = new JSRemoteConsumerPoint();
        SelectionCriteria[] criterias = new SelectionCriteria[discriminators.length];
        ConsumableKey[] consumerKeys = new ConsumableKey[discriminators.length];
        OrderingContextImpl ocontext = null;
        SIBUuid12 connectionUuid = new SIBUuid12();

        if (discriminators.length > 1)
          ocontext = new OrderingContextImpl(); // create a new ordering context
        for (int i=0; i < discriminators.length; i++)
        {
          SelectorDomain domain = SelectorDomain.getSelectorDomain(selectorDomains[i]);
          criterias[i] = parent.createSelectionCriteria(discriminators[i], selectors[i], domain);

          // attach as many times as necessary
          consumerKeys[i] =
            (ConsumableKey) consumerDispatcher.attachConsumerPoint(
              aock,
              criterias[i],
              connectionUuid,
              false,
              false,
              null);

          if (ocontext != null)
            consumerDispatcher.joinKeyGroup(consumerKeys[i], ocontext);

          consumerKeys[i].start(); // in case we use a ConsumerKeyGroup, this is essential

        }

        if (parent.getCardinalityOne() || consumerDispatcher.isPubSub())
        {
          // effectively infinite timeout, since don't want to close the ConsumerKey if RME is inactive for
          // a while. Only close this ConsumerKey when start flushing this stream.
          // NOTE shared durable subs might not be cardinality one but we still do not want the streams
          // to flush on timeout
          //
          // Defect 516583, set the idleTimeout parameter to 0, not to Long.MAX_VALUE in order to have an
          // ""infinite timeout"".
          aock.init(this, selectionCriteriasAsString, consumerKeys, 0, am, criterias);
        }
        else
        {
          aock.init(
            this,
            selectionCriteriasAsString,
            consumerKeys,
            mp.getCustomProperties().get_ck_idle_timeout(),
            am,
            criterias);
        }
        consumerKeyTable.put(selectionCriteriasAsString, aock);
      }
      catch (Exception e)
      {
        // should not occur!
        FFDCFilter.processException(
          e,
          ""com.ibm.ws.sib.processor.impl.AOStream.findOrCreateJSRemoteConsumerPoint"",
          ""1:2942:1.80.3.24"",
          this);
        SibTr.exception(tc, e);

        aock = null;
        ClosedException e2 = new ClosedException(e.getMessage());
        // just using the ClosedException as a convenience
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
          SibTr.exit(tc, ""findOrCreateJSRemoteConsumerPoint"", e2);

        throw e2;
      }
    }

    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.exit(tc, ""findOrCreateJSRemoteConsumerPoint"", aock);

    return aock;
  }",This method is called by the JSRemoteConsumerPoint class when a JSRemoteConsumerPoint object is created.
"String getPath() {
    StringBuilder result = new StringBuilder();

    boolean first = true;
    for (String part : getSegments()) {
      if (first) {
        result.append(part);
        first = false;
      } else {
        result.append(""/"").append(part);
      }
    }

    return result.toString();
  }",Get the path of the resource.
"public static void writeIntegerLittleEndian(IO.WritableByteStream io, int value) throws IOException {
		io.write((byte)(value & 0xFF));
		io.write((byte)((value >> 8) & 0xFF));
		io.write((byte)((value >> 16) & 0xFF));
		io.write((byte)((value >> 24) & 0xFF));
	}",Writes the given big - endian value to the given IO.
"private void setUpdateTimer(final String subscriptionId, final String serviceContextId, long ms) {
    Date timeToRun = new Date(System.currentTimeMillis() + ms);
    sendUpdatetimer.schedule(new TimerTask() {
      public void run() {
        try {
          updateCharging(subscriptionId, serviceContextId, partialCallDurationCounter);
        }
        catch (Exception e) {
          logger.error(""(( $ )) Failure trying to create/send CCR (UPDATE) message. (( $ ))"", e);
        }
      }
    }, timeToRun);
  }",Set the update timer to run when the update is complete.
"@Override
    public ListJobsByStatusResult listJobsByStatus(ListJobsByStatusRequest request) {
        request = beforeClientExecution(request);
        return executeListJobsByStatus(request);
    }",Returns a list of jobs that have the specified status.
"public DescribeSessionsResult withSessions(Session... sessions) {
        if (this.sessions == null) {
            setSessions(new com.amazonaws.internal.SdkInternalList<Session>(sessions.length));
        }
        for (Session ele : sessions) {
            this.sessions.add(ele);
        }
        return this;
    }",Adds the sessions value to the list of sessions.
"@Override
    public synchronized ServerBootstrap newServerBootstrap() throws Exception {
        if (serverChannelFactory == null) {
            Executor workerExecutor = executorServiceFactory.newExecutorService(""worker.server"");
            NioDatagramWorkerPool workerPool = new NioDatagramWorkerPool(workerExecutor, 1);
            serverChannelFactory = new UdpServerChannelFactory(workerPool, timer);

            // unshared
            channelFactories.add(serverChannelFactory);
        }

        return new ServerBootstrap(serverChannelFactory);
    }",Creates a new server bootstrap.
"public static void copy(String in, Writer out) throws IOException {
		Assert.notNull(in, ""No input String specified"");
		Assert.notNull(out, ""No Writer specified"");
		try {
			out.write(in);
		}
		finally {
			try {
				out.close();
			}
			catch (IOException ex) {
			}
		}
	}",Copy the contents of the given String to the given Writer.
"public void startAuthActivity(Context context, Bundle extras) {
        if (!startDelegateActivity(context, delegate.getAuthStartIntent(), extras)) {
            startActivity(context, extras, AuthActivity.class);
        }
    }",Start the AuthActivity.
"@Override
	public Statement apply(final Statement base, final Description description) {
		return new Statement() {

			@Override
			public void evaluate() throws Throwable {
				PactVerifications pactVerifications = description.getAnnotation(PactVerifications.class);
				if (pactVerifications != null) {
					evaluatePactVerifications(pactVerifications, base, description);
					return;
				}

				PactVerification pactDef = description.getAnnotation(PactVerification.class);
				// no pactVerification? execute the test normally
				if (pactDef == null) {
					base.evaluate();
					return;
				}

				Message providedMessage = null;
				Map<String, Message> pacts;
				if (StringUtils.isNoneEmpty(pactDef.fragment())) {
          Optional<Method> possiblePactMethod = findPactMethod(pactDef);
          if (!possiblePactMethod.isPresent()) {
            base.evaluate();
            return;
          }

          pacts = new HashMap<>();
          Method method = possiblePactMethod.get();
          Pact pact = method.getAnnotation(Pact.class);
          MessagePactBuilder builder = MessagePactBuilder.consumer(pact.consumer()).hasPactWith(provider);
          messagePact = (MessagePact) method.invoke(testClassInstance, builder);
          for (Message message : messagePact.getMessages()) {
            pacts.put(message.getProviderStates().stream().map(ProviderState::getName).collect(Collectors.joining()),
							message);
          }
        } else {
          pacts = parsePacts();
        }

        if (pactDef.value().length == 2 && !pactDef.value()[1].trim().isEmpty()) {
          providedMessage = pacts.get(pactDef.value()[1].trim());
        } else if (!pacts.isEmpty()) {
          providedMessage = pacts.values().iterator().next();
        }

				if (providedMessage == null) {
					base.evaluate();
					return;
				}

				setMessage(providedMessage, description);
				try {
					base.evaluate();
					PactFolder pactFolder = testClassInstance.getClass().getAnnotation(PactFolder.class);
					if (pactFolder != null) {
						messagePact.write(pactFolder.value(), PactSpecVersion.V3);
					} else {
						messagePact.write(PactConsumerConfig.INSTANCE.getPactDirectory(), PactSpecVersion.V3);
					}
				} catch (Throwable t) {
					throw t;
				}
			}
		};
	}",Override the default implementation of the Statement.
"public static base_responses unset(nitro_service client, String groupname[], String args[]) throws Exception {
		base_responses result = null;
		if (groupname != null && groupname.length > 0) {
			systemgroup unsetresources[] = new systemgroup[groupname.length];
			for (int i=0;i<groupname.length;i++){
				unsetresources[i] = new systemgroup();
				unsetresources[i].groupname = groupname[i];
			}
			result = unset_bulk_request(client, unsetresources,args);
		}
		return result;
	}",Use this API to unset the properties of systemgroup resources. Properties that need to be unset are specified in args array.
"private static void setupCSSClasses(Object owner, CSSClassManager manager, StyleLibrary style) throws CSSNamingConflict {
    if(!manager.contains(CSS_AXIS)) {
      CSSClass axis = new CSSClass(owner, CSS_AXIS);
      axis.setStatement(SVGConstants.CSS_STROKE_PROPERTY, style.getColor(StyleLibrary.AXIS));
      axis.setStatement(SVGConstants.CSS_STROKE_WIDTH_PROPERTY, style.getLineWidth(StyleLibrary.AXIS));
      manager.addClass(axis);
    }
    if(!manager.contains(CSS_AXIS_TICK)) {
      CSSClass tick = new CSSClass(owner, CSS_AXIS_TICK);
      tick.setStatement(SVGConstants.CSS_STROKE_PROPERTY, style.getColor(StyleLibrary.AXIS_TICK));
      tick.setStatement(SVGConstants.CSS_STROKE_WIDTH_PROPERTY, style.getLineWidth(StyleLibrary.AXIS_TICK));
      manager.addClass(tick);
    }
    if(!manager.contains(CSS_AXIS_LABEL)) {
      CSSClass label = new CSSClass(owner, CSS_AXIS_LABEL);
      label.setStatement(SVGConstants.CSS_FILL_PROPERTY, style.getTextColor(StyleLibrary.AXIS_LABEL));
      label.setStatement(SVGConstants.CSS_FONT_FAMILY_PROPERTY, style.getFontFamily(StyleLibrary.AXIS_LABEL));
      label.setStatement(SVGConstants.CSS_FONT_SIZE_PROPERTY, style.getTextSize(StyleLibrary.AXIS_LABEL));
      manager.addClass(label);
    }
  }",Setup the CSS classes.
"@SuppressFBWarnings(""RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE"")
    private C4Document save(Document document, C4Document base, boolean deletion)
        throws LiteCoreException {
        FLSliceResult body = null;
        try {
            int revFlags = 0;
            if (deletion) { revFlags = C4Constants.RevisionFlags.DELETED; }
            if (!deletion && !document.isEmpty()) {
                // Encode properties to Fleece data:
                body = document.encode();
                if (C4Document.dictContainsBlobs(body, sharedKeys.getFLSharedKeys())) {
                    revFlags |= C4Constants.RevisionFlags.HAS_ATTACHMENTS;
                }
            }

            // Save to database:
            final C4Document c4Doc = base != null ? base : document.getC4doc();
            if (c4Doc != null) { return c4Doc.update(body, revFlags); }

            return getC4Database().create(document.getId(), body, revFlags);
        }
        finally {
            if (body != null) { body.free(); }
        }
    }",Save a document to the database.
"public LDIFChangeRecord nextRecord() {
        if (entryIterator.hasNext()) {
            try {
                final Node entryNode = entryIterator.next();
                final String dn = entryNode.valueOf(""@dn"");
                final List<Attribute> attributes = new ArrayList<Attribute>();

                final List<Node> objectClassList = (List<Node>) objectClassXPath.selectNodes(entryNode);
                final String[] objectClasses = new String[objectClassList.size()];
                for (int j = 0; j < objectClasses.length; ++j) {
                    objectClasses[j] = objectClassList.get(j).getStringValue();
                }
                attributes.add(new Attribute(""objectclass"", objectClasses));
                for (final Node attributeNode : (List<Node>) attrXPath.selectNodes(entryNode)) {
                    final String attributeName = attributeNode.valueOf(""@name"");
                    final List<Node> attributeValueNodes = (List<Node>) attrValueXPath.selectNodes(attributeNode);
                    switch (attributeValueNodes.size()) {
                        case 0:
                            break;
                        case 1: {
                            final String attributeValue = attributeValueNodes.get(0).getStringValue();
                            attributes.add(new Attribute(attributeName, attributeValue));
                            break;
                        }
                        default: {
                            final String[] attributeValues = new String[attributeValueNodes.size()];
                            for (int j = 0; j < attributeValueNodes.size(); ++j) {
                                attributeValues[j] = attributeValueNodes.get(j).getStringValue();
                            }
                            attributes.add(new Attribute(attributeName, attributeValues));
                            break;
                        }
                    }
                }
                return new LDIFAddChangeRecord(dn, attributes);
            } catch (final JaxenException e) {
                return null;
            }
        } else {
            return null;
        }
    }",Gets the next LDIFChangeRecord.
"synchronized void checkLeases() {
    int numPathsChecked = 0;
    for(; sortedLeases.size() > 0; ) {
      final Lease oldest = sortedLeases.first();
      if (!oldest.expiredHardLimit()) {
        return;
      }
      
      // internalReleaseLease() removes paths corresponding to empty files,
      // i.e. it needs to modify the collection being iterated over
      // causing ConcurrentModificationException
      String[] leasePaths = new String[oldest.getPaths().size()];
      oldest.getPaths().toArray(leasePaths);
      LOG.info(""Lease "" + oldest
          + "" has expired hard limit. Recovering lease for paths: ""
          + Arrays.toString(leasePaths));
      for(String p : leasePaths) {
        if (++numPathsChecked > this.maxPathsPerCheck) {
          return;
        }
        try {
          fsnamesystem.getFSNamesystemMetrics().numLeaseRecoveries.inc();
          fsnamesystem.internalReleaseLeaseOne(
              oldest, p, this.discardLastBlockIfNoSync);
        } catch (IOException e) {
          LOG.error(""Cannot release the path ""+p+"" in the lease ""+oldest, e);
          removeLease(oldest, p);
          fsnamesystem.getFSNamesystemMetrics().numLeaseManagerMonitorExceptions.inc();
        }
      }
    }
  }",Check leases.
"public void undelete(CmsUUID entryId, String sitePath) {

        CmsSitemapChange change = new CmsSitemapChange(entryId, sitePath, ChangeType.undelete);
        CmsSitemapClipboardData data = CmsSitemapView.getInstance().getController().getData().getClipboardData().copy();
        data.getDeletions().remove(entryId);
        change.setClipBoardData(data);
        commitChange(change, null);
    }",Undelete an entry from the sitemap.
"public Analyzer<Partition<T>> getOrCreateAnalyzer()
   {
      Node node = childNode.getOrCreate(""analyzer"");
      Analyzer<Partition<T>> analyzer = new AnalyzerImpl<Partition<T>>(this, ""analyzer"", childNode, node);
      return analyzer;
   }",Get or create an analyzer object.
"public static Window showCWF(BaseComponent root, String... excludedProperties) {
        Window window = showXML(CWF2XML.toDocument(root, excludedProperties));
        window.setTitle(""CWF Markup"");
        return window;
    }",Show a CWF Markup window.
"protected String getValue(String arg) {
        String[] split = arg.split(""="");
        if (split.length <= 1) {
            return null;
        }
        return split[1];
    }",Get the value of a CIDCTYPE attribute.
"public final void success () {
		Status previousStatus = status;
		status = Status.SUCCEEDED;
		if (tree.listeners != null && tree.listeners.size > 0) tree.notifyStatusUpdated(this, previousStatus);
		end();
		if (control != null) control.childSuccess(this);
	}",Notify all listeners that the node has been successfully updated.
"public Future<IEvaluation[]> execute(IEvaluation[] evals, int evalWorkers, int evalBatchSize, Iterator<DataSet> ds, Iterator<MultiDataSet> mds,
                                         boolean isCG, Broadcast<String> json, Broadcast<byte[]> params){
        Preconditions.checkArgument(evalWorkers > 0, ""Invalid number of evaluation workers: must be > 0. Got: %s"", evalWorkers);
        Preconditions.checkState(ds != null || mds != null, ""No data provided - both DataSet and MultiDataSet iterators were null"");

        //For multi-GPU we'll use a round robbin approach for worker thread/GPU affinity
        int numDevices = Nd4j.getAffinityManager().getNumberOfDevices();
        if(numDevices <= 0)
            numDevices = 1;

        //Create the device local params if required
        DeviceLocalNDArray deviceLocalParams;
        synchronized (this){
            if(!paramsMap.containsKey(params.getValue())){
                //Due to singleton pattern, this block should execute only once (first thread)
                //Initially put on device 0. For CPU, this means we only have a single copy of the params INDArray shared by
                // all threads, which is both safe and uses the least amount of memory
                //For CUDA, we can't share threads otherwise arrays will be continually relocated, causing a crash
                //Nd4j.getMemoryManager().releaseCurrentContext();
                //NativeOpsHolder.getInstance().getDeviceNativeOps().setDevice(0);
                //Nd4j.getAffinityManager().attachThreadToDevice(Thread.currentThread(), 0);
                byte[] pBytes = params.getValue();
                INDArray p;
                try{
                    p = Nd4j.read(new ByteArrayInputStream(pBytes));
                } catch (IOException e){
                    throw new RuntimeException(e);  //Should never happen
                }
                DeviceLocalNDArray dlp = new DeviceLocalNDArray(p);
                paramsMap.put(params.getValue(), dlp);
                //log.info(""paramsMap: size {}"", paramsMap.size());
            }
            deviceLocalParams = paramsMap.get(params.getValue());
        }

        int currentWorkerCount;
        while((currentWorkerCount = workerCount.get()) < evalWorkers){
            //For load balancing: we're relying on the fact that threads are mapped to devices in a round-robbin approach
            // the first time they touch an INDArray. If we assume this method is called by new threads,
            // then the first N workers will be distributed evenly across available devices.

                if (workerCount.compareAndSet(currentWorkerCount, currentWorkerCount + 1)) {
                    log.debug(""Starting evaluation in thread {}"", Thread.currentThread().getId());
                    //This thread is now a worker
                    EvaluationFuture f = new EvaluationFuture();
                    f.setResult(evals);
                    try {
                        Model m;
                        if (isCG) {
                            ComputationGraphConfiguration conf = ComputationGraphConfiguration.fromJson(json.getValue());
                            ComputationGraph cg = new ComputationGraph(conf);
                            cg.init(deviceLocalParams.get(), false);
                            m = cg;
                        } else {
                            MultiLayerConfiguration conf = MultiLayerConfiguration.fromJson(json.getValue());
                            MultiLayerNetwork net = new MultiLayerNetwork(conf);
                            net.init(deviceLocalParams.get(), false);
                            m = net;
                        }

                        //Perform eval on this thread's data
                        try {
                            doEval(m, evals, ds, mds, evalBatchSize);
                        } catch (Throwable t) {
                            f.setException(t);
                        } finally {
                            f.getSemaphore().release(1);
                        }

                        //Perform eval on other thread's data
                        while (!queue.isEmpty()) {
                            Eval e = queue.poll();  //Use poll not remove to avoid race condition on last element
                            if (e == null)
                                continue;
                            try {
                                doEval(m, evals, e.getDs(), e.getMds(), evalBatchSize);
                            } catch (Throwable t) {
                                e.getFuture().setException(t);
                            } finally {
                                e.getFuture().getSemaphore().release(1);
                            }
                        }
                    } finally {
                        workerCount.decrementAndGet();
                        log.debug(""Finished evaluation in thread {}"", Thread.currentThread().getId());
                    }

                    Nd4j.getExecutioner().commit();
                    return f;
                }
        }

        //At this point: not a worker thread (otherwise, would have returned already)
        log.debug(""Submitting evaluation from thread {} for processing in evaluation thread"", Thread.currentThread().getId());
        EvaluationFuture f = new EvaluationFuture();
        queue.add(new Eval(ds, mds, evals, f));
        return f;
    }",Execute the block
"public void marshall(CatalogImportStatus catalogImportStatus, ProtocolMarshaller protocolMarshaller) {

        if (catalogImportStatus == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(catalogImportStatus.getImportCompleted(), IMPORTCOMPLETED_BINDING);
            protocolMarshaller.marshall(catalogImportStatus.getImportTime(), IMPORTTIME_BINDING);
            protocolMarshaller.marshall(catalogImportStatus.getImportedBy(), IMPORTEDBY_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given CatalogImportStatus object to the JSON object.
"public final void setValidField(final int field, final boolean valid)
	{
		if (field < 0 || field >= FIELD_MASKS.length)
			throw new KNXIllegalArgumentException(""illegal field"");
		setBit(0, FIELD_MASKS[field], !valid);
	}",Sets the value of a field to a valid state.
"public static void append(StringBuilder buf, String s, int offset, int length) {
        synchronized (buf) {
            int end = offset + length;
            for (int i = offset; i < end; i++) {
                if (i >= s.length())
                    break;
                buf.append(s.charAt(i));
            }
        }
    }",Append a sequence of characters to a StringBuilder.
"public void setFeature (String name, boolean value)
    throws SAXNotRecognizedException, SAXNotSupportedException
    {
    if (name.equals(NAMESPACES)) {
        checkNotParsing(""feature"", name);
        namespaces = value;
        if (!namespaces && !prefixes) {
        prefixes = true;
        }
    } else if (name.equals(NAMESPACE_PREFIXES)) {
        checkNotParsing(""feature"", name);
        prefixes = value;
        if (!prefixes && !namespaces) {
        namespaces = true;
        }
    } else if (name.equals(XMLNS_URIs)) {
        checkNotParsing(""feature"", name);
        uris = value;
    } else {
        throw new SAXNotRecognizedException(""Feature: "" + name);
    }
    }",Sets the value of a feature.
"private void processMultipart(final Multipart mp) throws MessagingException, IOException {
		final int count = mp.getCount();
		for (int i = 0; i < count; i++) {
			final Part innerPart = mp.getBodyPart(i);
			processPart(innerPart);
		}
	}",Process a Multipart.
"public void instrumentClassFile(File classfile) throws IOException {
        FileInputStream fis = new FileInputStream(classfile);
        byte[] bytes = transform(fis);
        fis.close();
        fis = null;

        // If the class was successfully transformed, rewrite it
        if (bytes != null) {
            FileOutputStream fos = new FileOutputStream(classfile);
            fos.write(bytes);
            fos.close();
        }
    }",Instrument a class file.
"@Override
    protected XWikiSyntaxResourceRenderer createXWikiSyntaxLinkRenderer(ListenerChain listenerChain,
        ResourceReferenceSerializer linkReferenceSerializer)
    {
        return new XWikiSyntaxResourceRenderer((XWikiSyntaxListenerChain) listenerChain, linkReferenceSerializer);
    }",Create an instance of the XWikiSyntaxLinkRenderer interface.
"public static ThreadPoolExecutor getBoundedThreadPoolExecutor(int maxPoolSize, long keepAliveTime, TimeUnit unit, ThreadFactory tFactory) {
        return new ThreadPoolExecutor(0, maxPoolSize, keepAliveTime, unit,
                                      new SynchronousQueue<Runnable>(), tFactory);
    }",Get a bounded thread pool executor.
"public final void recycle(final T instance) {
        if (instance != null) {
            usedInstances.remove(instance);
            if (instance instanceof Resettable) {
                ((Resettable) instance).reset();
            }
            unusedInstances.add(instance);
        }
    }",Recycle an instance.
"public Integer updateInfoByIdService(String id,Map requestParamMap,String tableName,String cusCondition,String cusSetStr) throws Exception{
		return updateInfoServiceInner(id,requestParamMap,tableName,cusCondition,cusSetStr,null);
	}",Update the info of a service identified by the id.
"public static void onCreate(Context context) {
        sContext = context;
        context.registerReceiver(ALARM_BROADCAST_RECEIVER, new IntentFilter(PING_ALARM_ACTION));
        sAlarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        sPendingIntent = PendingIntent.getBroadcast(context, 0, new Intent(PING_ALARM_ACTION), 0);
        sAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,
                SystemClock.elapsedRealtime() + AlarmManager.INTERVAL_HALF_HOUR,
                AlarmManager.INTERVAL_HALF_HOUR, sPendingIntent);
    }",Called when the application is created.
"@Override
	public void stopped() {

		// Stop heartbeat timer
		if (heartBeatTimer != null) {
			heartBeatTimer.cancel(false);
			heartBeatTimer = null;
		}

		// Stop timeout checker's timer
		if (checkTimeoutTimer != null) {
			checkTimeoutTimer.cancel(false);
			checkTimeoutTimer = null;
		}

		// Send ""disconnected"" packet
		sendDisconnectPacket();

		// Clear all stored data
		nodes.clear();
	}",Called by the server to inform us that the connection has been stopped.
"public synchronized <T extends Object> T register(Class<T> type) throws InvalidTypeException, TypeFilterException, DoubleIDException, InvalidMethodException, InvocationException, ControllerPersistenceException {
	return register(type, null);
    }",Registers a new type with the controller.
"@Override
  public void setPermission(Path path, FsPermission permission) throws IOException {
    LOG.debug(""setMode({},{})"", path, permission.toString());
    AlluxioURI uri = new AlluxioURI(HadoopUtils.getPathWithoutScheme(path));
    SetAttributePOptions options = SetAttributePOptions.newBuilder()
        .setMode(new Mode(permission.toShort()).toProto()).setRecursive(false).build();
    try {
      mFileSystem.setAttribute(uri, options);
    } catch (AlluxioException e) {
      throw new IOException(e);
    }
  }",Sets the permission for a node.
"public final void evalError() {
    final List<EvaluationMonitor<POSSample>> listeners = new LinkedList<EvaluationMonitor<POSSample>>();
    listeners.add(new POSEvaluationErrorListener());
    final POSEvaluator evaluator = new POSEvaluator(this.posTagger,
        listeners.toArray(new POSTaggerEvaluationMonitor[listeners.size()]));
    try {
      evaluator.evaluate(this.testSamples);
    } catch (IOException e) {
      e.printStackTrace();
    }
    System.out.println(evaluator.getWordAccuracy());
  }",Evaluate the error.
"private void configureEvent(CacheEntryListenerInvocation listenerInvocation,
                               EventImpl<K, V> e, K key, V value, Metadata metadata) {
      e.setKey(convertKey(listenerInvocation, key));
      e.setValue(convertValue(listenerInvocation, value));
      e.setMetadata(metadata);
      e.setOriginLocal(true);
      e.setPre(false);
   }",Configure the event.
"public void getDistributedObjects(Collection<DistributedObject> result) {
        Collection<DistributedObjectFuture> futures = proxies.values();
        for (DistributedObjectFuture future : futures) {
            if (!future.isSetAndInitialized()) {
                continue;
            }
            try {
                DistributedObject object = future.get();
                result.add(object);
            } catch (Throwable ignored) {
                // ignore if proxy creation failed
                ignore(ignored);
            }
        }
    }",Get all DistributedObjects in the cache.
"public static ProcessBuilder getProcessBuilder(String mainClass, List<URL> classPath, List<String> args) throws LauncherException
	{
		List<String> cmdList = new ArrayList<String>();
		String[] cmdArray;
		
		cmdList.add(getJavaPath());
		if(classPath != null && classPath.size() > 0)
		{
			cmdList.add(""-cp"");
			cmdList.add(mkPath(classPath));
		}
		cmdList.add(mainClass);
		if(args!=null && args.size()>0)
			cmdList.addAll(args);
		cmdArray = cmdList.toArray(new String[cmdList.size()]);
		if(logger.isDebugEnabled())
			logger.debug(""cmdArray="" + Arrays.toString(cmdArray));
		return new ProcessBuilder(cmdArray);
	}",Get a ProcessBuilder for the specified main class and class path.
"@Override
	public CPOptionValue fetchByUUID_G(String uuid, long groupId) {
		return fetchByUUID_G(uuid, groupId, true);
	}",Returns the cp option value with the matching UUID and group.
"@Override
    public CancelReservedInstancesListingResult cancelReservedInstancesListing(CancelReservedInstancesListingRequest request) {
        request = beforeClientExecution(request);
        return executeCancelReservedInstancesListing(request);
    }",Cancels a list of reserved instances.
"private List<TransformerChangeListener> getAllListeners() {
        @SuppressWarnings(""deprecation"") final List<TransformerChangeListener> globalChangeListeners =
                getAnalysisJobBuilder().getTransformerChangeListeners();

        final List<TransformerChangeListener> list =
                new ArrayList<>(globalChangeListeners.size() + _localChangeListeners.size());
        list.addAll(globalChangeListeners);
        list.addAll(_localChangeListeners);
        return list;
    }",Gets all transformer change listeners.
"public Future<AuthenticationResult> acquireTokenByAuthorizationCode(
            final String authorizationCode, final URI redirectUri,
            final AsymmetricKeyCredential credential,
            final AuthenticationCallback callback)
            throws AuthenticationException {
        return this.acquireTokenByAuthorizationCode(authorizationCode,
                redirectUri, credential, null, callback);
    }",Acquire token by authorization code.
"@Override
    public Request<DescribeBundleTasksRequest> getDryRunRequest() {
        Request<DescribeBundleTasksRequest> request = new DescribeBundleTasksRequestMarshaller().marshall(this);
        request.addParameter(""DryRun"", Boolean.toString(true));
        return request;
    }",Returns a request configured with additional parameters to indicate whether to delete the bundle tasks.
"public void setTau0(double tau0)
    {
        if(tau0 <= 0 || Double.isInfinite(tau0) || Double.isNaN(tau0))
            throw new IllegalArgumentException(""Eta must be a positive constant, not "" + tau0);
        this.tau0 = tau0;
    }",Sets the tau0 value.
"public static void runExample(AdManagerServices adManagerServices, AdManagerSession session)
      throws RemoteException {
    // Get the NetworkService.
    NetworkServiceInterface networkService =
        adManagerServices.get(session, NetworkServiceInterface.class);

    // Get all networks that you have access to with the current authentication
    // credentials.
    Network[] networks = networkService.getAllNetworks();

    if (networks == null || networks.length == 0) {
      System.out.printf(""No accessible networks found.%n"");
      return;
    }

    int i = 0;
    for (Network network : networks) {
      System.out.printf(
          ""%d) Network with network code '%s' and display name '%s' was found.%n"",
          i++, network.getNetworkCode(), network.getDisplayName());
    }

    System.out.printf(""Number of networks found: %d%n"", networks.length);
  }",Example of how to run the example.
"@Nonnull
  public static ICommonsList <IAuthToken> getAllTokensOfSubject (@Nonnull final IAuthSubject aSubject)
  {
    ValueEnforcer.notNull (aSubject, ""Subject"");

    return s_aRWLock.readLocked ( () -> CommonsArrayList.createFiltered (s_aMap.values (),
                                                                         aToken -> aToken.getIdentification ()
                                                                                         .hasAuthSubject (aSubject)));
  }",Get all tokens of the given subject.
"@Execute
    public HtmlResponse index() {
        esApiManager.saveToken();
        return asHtml(path_AdminDashboard_AdminDashboardJsp).renderWith(data -> {
            RenderDataUtil.register(data, ""serverPath"", esApiManager.getServerPath());
        });
    }",Display a single page of the page.
"protected void sendExit2(final OtpErlangPid from, final OtpErlangPid dest,
            final OtpErlangObject reason) throws IOException {
        sendExit(exit2Tag, from, dest, reason);
    }",Send an exit message to a node.
"public String getGlobusID(String userID) {
        if (userID == null) {
            throw new IllegalArgumentException(i18n.getMessage(""userIdNull""));
        }

        if (this.map == null) {
            return null;
        }

        Iterator iter = this.map.entrySet().iterator();
        Map.Entry mapEntry;
        GridMapEntry entry;
        while(iter.hasNext()) {
            mapEntry = (Map.Entry)iter.next();
            entry = (GridMapEntry)mapEntry.getValue();
            if (entry.containsUserID(userID)) {
                return entry.getGlobusID();
            }
        }
        return null;
    }",Gets the globus ID for the specified user ID.
"public Formula getFormula() {
		Reagent[] reagents = new Reagent[] {SOURCE, PARAMETER_NAME};
		return new SimpleFormula(ServletContextInitParameterPhrase.class, reagents);
	}",Gets the formula for the ServletContextInitParameterPhrase.
"public List<J4pRemoteException> getRemoteExceptions() {
        List<J4pRemoteException> ret = new ArrayList<J4pRemoteException>();
        for (Object entry : results) {
            if (entry instanceof J4pRemoteException) {
                ret.add((J4pRemoteException) entry);
            }
        }
        return ret;
    }",Get the list of remote exceptions.
"@Override
  public void run() {
    // Workaround for Issue #4 (http://code.google.com/p/jdiameter/issues/detail?id=4)
    // BEGIN WORKAROUND // Give some time to initialization...
    int sleepTime = 250;
    logger.debug(""Sleeping for {}ms before starting transport so that listeners can all be added and ready for messages"", sleepTime);
    try {
      Thread.sleep(sleepTime);
    }
    catch (InterruptedException e) {
      // ignore
    }
    logger.debug(""Finished sleeping for {}ms. By now, MutablePeerTableImpl should have added its listener"", sleepTime);

    logger.debug(""Transport is started. Socket is [{}]"", socketDescription);
    Selector selector = null;
    try {
      selector = Selector.open();
      socketChannel.register(selector, SelectionKey.OP_READ);
      while (!stop) {
        selector.select(SELECT_TIMEOUT);
        Iterator<SelectionKey> it = selector.selectedKeys().iterator();
        while (it.hasNext()) {
          // Get the selection key
          SelectionKey selKey = it.next();
          // Remove it from the list to indicate that it is being processed
          it.remove();
          if (selKey.isValid() && selKey.isReadable()) {
            // Get channel with bytes to read
            SocketChannel sChannel = (SocketChannel) selKey.channel();
            int dataLength = sChannel.read(buffer);
            logger.debug(""Just read [{}] bytes on [{}]"", dataLength, socketDescription);
            if (dataLength == -1) {
              stop = true;
              break;
            }
            buffer.flip();
            byte[] data = new byte[buffer.limit()];
            buffer.get(data);
            append(data);
            buffer.clear();
          }
        }
      }
    }
    catch (ClosedByInterruptException e) {
      logger.error(""Transport exception "", e);
    }
    catch (AsynchronousCloseException e) {
      logger.error(""Transport is closed"");
    }
    catch (Throwable e) {
      logger.error(""Transport exception "", e);
    }
    finally {
      try {
        clearBuffer();
        if (selector != null) {
          selector.close();
        }
        if (socketChannel != null && socketChannel.isOpen()) {
          socketChannel.close();
        }
        getParent().onDisconnect();
      }
      catch (Exception e) {
        logger.error(""Error"", e);
      }
      stop = false;
      logger.info(""Read thread is stopped for socket [{}]"", socketDescription);
    }
  }","Run method for the
 banner transport."
"private void checkPopup(MouseEvent e) {
        if (e.isPopupTrigger()) {
            popup.show(this, e.getX(), e.getY());
        }
    }",Check popup.
"public static Set<String> lowercaseLines(final Class<?> origin, final String resource) throws IOException {
        return ImmutableSet.copyOf(new HashSet<String>() {{
            readResource(origin, resource, new NullReturnLineProcessor() {
                @Override
                public boolean processLine(@Nonnull final String line) {
                    final String l = simplify(line);
                    // add to the containing HashSet we are currently in the init block of
                    if (!l.startsWith(""#"") && !l.isEmpty()) add(toEngLowerCase(l));
                    return true;
                }
            });
        }});
    }",Returns a set of lines from a file that are lowercase.
"private void syncVfsToRfs(String folder) throws CmsException {

        int action = 0;
        //get all resources in the given folder
        List<CmsResource> resources = m_cms.getResourcesInFolder(folder, CmsResourceFilter.IGNORE_EXPIRATION);
        // now look through all resources in the folder
        for (int i = 0; i < resources.size(); i++) {
            CmsResource res = resources.get(i);
            // test if the resource is marked as deleted. if so,
            // do nothing, the corresponding file in the FS will be removed later
            if (!res.getState().isDeleted()) {
                // do a recursion if the current resource is a folder
                if (res.isFolder()) {
                    // first check if this folder must be synchronized
                    action = testSyncVfs(res);
                    // do the correct action according to the test result
                    if (action == EXPORT_VFS) {
                        exportToRfs(res);
                    } else if (action != DELETE_VFS) {
                        skipResource(res);
                    }
                    // recurse into the sub folders. This must be done before
                    // the folder might be deleted!
                    syncVfsToRfs(m_cms.getSitePath(res));
                    if (action == DELETE_VFS) {
                        deleteFromVfs(res);
                    }
                } else {
                    // if the current resource is a file, check if it has to
                    // be synchronized
                    action = testSyncVfs(res);
                    // do the correct action according to the test result
                    switch (action) {
                        case EXPORT_VFS:
                            exportToRfs(res);
                            break;

                        case UPDATE_VFS:
                            updateFromRfs(res);
                            break;

                        case DELETE_VFS:
                            deleteFromVfs(res);
                            break;

                        default:
                            skipResource(res);

                    }
                }
                // free memory
                res = null;
            }
        }
        //  free memory
        resources = null;
    }",Synchronize VFS to RFS.
"public void addInheritedSummaryAnchor(ClassDoc cd, Content inheritedTree) {
        inheritedTree.addContent(writer.getMarkerAnchor(
                SectionName.NESTED_CLASSES_INHERITANCE,
                cd.qualifiedName()));
    }",Add the inherited summary anchor.
"public static void setPreferredRoadInternColor(Integer color) {
		final Preferences prefs = Preferences.userNodeForPackage(RoadNetworkLayerConstants.class);
		if (prefs != null) {
			if (color == null) {
				prefs.remove(""ROAD_INTERN_COLOR""); //$NON-NLS-1$
			} else {
				prefs.put(""ROAD_INTERN_COLOR"", Integer.toString(color.intValue())); //$NON-NLS-1$
			}
			try {
				prefs.flush();
			} catch (BackingStoreException exception) {
				//
			}
		}
	}",Set the preferred color for the road network.
"private void initDefaultLoginFilter(H http) {
		DefaultLoginPageGeneratingFilter loginPageGeneratingFilter = http
				.getSharedObject(DefaultLoginPageGeneratingFilter.class);
		if (loginPageGeneratingFilter != null) {
			loginPageGeneratingFilter.setRememberMeParameter(getRememberMeParameter());
		}
	}",Initialize the default login filter.
"public <T> void register(final Class<T> type, final TypeConverter<T> typeConverter) {
		converters.put(type, typeConverter);
	}",Register a type converter.
"@Override
    public R visitUnknown(TypeMirror t, P p) {
        throw new UnknownTypeException(t, p);
    }",Visit an unknown type mirror.
"public void removeAttributeNS(String namespaceURI, String localName)
        throws DOMException {
        throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, null);
    }",Remove an attribute from the attribute set.
"@Override
    public boolean isJobInstancePurgeable(long jobInstanceId) {
        InstanceState instanceState = getJobInstance(jobInstanceId).getInstanceState();

        if (instanceState.equals(InstanceState.SUBMITTED)
            || instanceState.equals(InstanceState.JMS_QUEUED)
            || instanceState.equals(InstanceState.JMS_CONSUMED)
            || instanceState.equals(InstanceState.DISPATCHED)) {
            return false;
        } else {
            return true;
        }
    }",This method is used to check if a job instance is purgeable.
"public synchronized void putAll(SerialArrayList<U> data, int startIndex) {
    ensureCapacity((startIndex * unitSize) + data.maxByte);
    System.arraycopy(data.buffer, 0, this.buffer, startIndex * unitSize, data.maxByte);
  }",Copies all the elements from the given array into this array.
"@Override
  public void doAction(char cha) {

    if (cha == '\""') {

      /* annotation for first section:simple polymer section */
      if (sectionCounter == 1) {
        LOG.info(""Add annotation to simple polymer:"");
        PolymerNotation current = _parser.notationContainer.getCurrentPolymer();
        _parser.notationContainer.changeLastPolymerNotation(new PolymerNotation(current.getPolymerID(),
            current.getPolymerElements(), comment));
        _parser.setState(new BetweenParser(_parser));
      } /* annotation for second section:connection section */ else if (sectionCounter == 2) {
        LOG.info(""Add annotation to connection section:"");
        ConnectionNotation current = _parser.notationContainer.getCurrentConnection();
        _parser.notationContainer.changeConnectionNotation(new ConnectionNotation(current.getSourceId(),
            current.getTargetId(), current.getSourceUnit(), current.getTargetUnit(), current.getrGroupSource(),
            current.getrGroupTarget(), comment));
        _parser.setState(new BetweenInlineConnectionParser(_parser));
      } /* annotation for a single monomer in the first section */ else if (sectionCounter == 11) {
        LOG.info(""Add annotation to a single monomer:"");
        _parser.notationContainer.getCurrentPolymer().getPolymerElements().getCurrentMonomerNotation().setAnnotation(comment);
        _parser.setState(new BetweenInlineMonomerParser(_parser));
      }

    } else {
      comment += (cha);
    }
  }","Method to handle the
    action"
"@Programmatic
    public List<CommunicationChannelOwnerLink> findByOwner(final CommunicationChannelOwner owner) {
        if(owner == null) {
            return null;
        }
        final Bookmark bookmark = bookmarkService.bookmarkFor(owner);
        if(bookmark == null) {
            return null;
        }
        return container.allMatches(
                new QueryDefault<>(CommunicationChannelOwnerLink.class,
                        ""findByOwner"",
                        ""ownerObjectType"", bookmark.getObjectType(),
                        ""ownerIdentifier"", bookmark.getIdentifier()));
    }",Find by owner.
"public static NumberingSystem getInstance(ULocale locale) {
        // Check for @numbers
        boolean nsResolved = true;
        String numbersKeyword = locale.getKeywordValue(""numbers"");
        if (numbersKeyword != null ) {
            for ( String keyword : OTHER_NS_KEYWORDS ) {
                if ( numbersKeyword.equals(keyword)) {
                    nsResolved = false;
                    break;
                }
            }
        } else {
            numbersKeyword = ""default"";
            nsResolved = false;
        }

        if (nsResolved) {
            NumberingSystem ns = getInstanceByName(numbersKeyword);
            if (ns != null) {
                return ns;
            }
            // If the @numbers keyword points to a bogus numbering system name,
            // we return the default for the locale.
            numbersKeyword = ""default"";
        }

        // Attempt to get the numbering system from the cache
        String baseName = locale.getBaseName();
        // TODO: Caching by locale+numbersKeyword could yield a large cache.
        // Try to load for each locale the mappings from OTHER_NS_KEYWORDS and default
        // to real numbering system names; can we get those from supplemental data?
        // Then look up those mappings for the locale and resolve the keyword.
        String key = baseName+""@numbers=""+numbersKeyword;
        LocaleLookupData localeLookupData = new LocaleLookupData(locale, numbersKeyword);
        return cachedLocaleData.getInstance(key, localeLookupData);
    }",Get the NumberingSystem object for the given locale.
"@NonNull
  public Caffeine<K, V> weakKeys() {
    requireState(keyStrength == null, ""Key strength was already set to %s"", keyStrength);
    requireState(writer == null, ""Weak keys may not be used with CacheWriter"");

    keyStrength = Strength.WEAK;
    return this;
  }",Sets the key strength to weak.
"protected void validate(String operationType) throws Exception
	{
		super.validate(operationType);

		MPSString id_validator = new MPSString();
		id_validator.validate(operationType, id, ""\""id\"""");
		
		MPSInt adapter_id_validator = new MPSInt();
		adapter_id_validator.validate(operationType, adapter_id, ""\""adapter_id\"""");
		
		MPSInt virtualdrive_validator = new MPSInt();
		virtualdrive_validator.validate(operationType, virtualdrive, ""\""virtualdrive\"""");
		
		MPSInt targetid_validator = new MPSInt();
		targetid_validator.validate(operationType, targetid, ""\""targetid\"""");
		
		MPSString name_validator = new MPSString();
		name_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);
		name_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);
		name_validator.validate(operationType, name, ""\""name\"""");
		
		MPSString size_validator = new MPSString();
		size_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);
		size_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);
		size_validator.validate(operationType, size, ""\""size\"""");
		
		MPSString state_validator = new MPSString();
		state_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);
		state_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);
		state_validator.validate(operationType, state, ""\""state\"""");
		
		MPSString drives_validator = new MPSString();
		drives_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);
		drives_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);
		drives_validator.validate(operationType, drives, ""\""drives\"""");
		
		MPSIPAddress host_ip_address_validator = new MPSIPAddress();
		host_ip_address_validator.validate(operationType, host_ip_address, ""\""host_ip_address\"""");
		
		MPSString physical_disk_slot_1_validator = new MPSString();
		physical_disk_slot_1_validator.validate(operationType, physical_disk_slot_1, ""\""physical_disk_slot_1\"""");
		
		MPSString physical_disk_slot_2_validator = new MPSString();
		physical_disk_slot_2_validator.validate(operationType, physical_disk_slot_2, ""\""physical_disk_slot_2\"""");
		
	}","Validates the
 operationType."
"public T put(YamlNode key, Long value) {
        return put(key, getNodeFactory().longNode(value));
    }",Put a Long value into the context.
"private static int scanDatePart(char prefix, int defaultValue, String str, AtomicInteger pos,
                                    int minDigits, int maxDigits, int minValue, int maxValue) 
            throws IllegalArgumentException {
        // If all characters are consumed, just return the default value.
        if (pos.get() >= str.length()) {
            return defaultValue;
        }
        
        // If there's a prefix character, require it.
        if (prefix != '\0') {
            require(str.charAt(pos.getAndIncrement()) == prefix, ""'"" + prefix + ""' expected"");
        }
        
        // Scan up to maxDigits into a numeric value.
        int value = 0;
        int digitsScanned = 0;
        while (pos.get() < str.length() && digitsScanned < maxDigits) {
            char ch = str.charAt(pos.get());
            if (ch >= '0' && ch <= '9') {
                value = value * 10 + (ch - '0');
                digitsScanned++;
                pos.incrementAndGet();
            } else {
                break;
            }
        }
        
        // Ensure we got the required minimum digits and the value is within range.
        Utils.require(digitsScanned >= minDigits && value >= minValue && value <= maxValue,
                      ""Invalid value for date/time part"");
        return value;
    }",Scans a date part of a string.
"public <T> T getValue(Class<T> type, String parameter, Message message, T uriParameterValue){
        if(message==null && uriParameterValue!=null){
            return uriParameterValue;
        }
        T value = message.getHeader(parameter, type);
        if(value==null){
            value = uriParameterValue;
        }
        return value;
    }",Gets the value of the attribute.
"private PatchingResult applyPatch(final String patchId, final Patch patch, final IdentityPatchContext context) throws PatchingException, IOException, XMLStreamException {

        final Identity identity = patch.getIdentity();
        final Patch.PatchType patchType = identity.getPatchType();
        final InstallationManager.InstallationModification modification = context.getModification();
        if (patchType == Patch.PatchType.CUMULATIVE) {
            // Invalidate all installed patches (one-off, cumulative) - we never need to invalidate the release base
            final List<String> invalidation = new ArrayList<String>(modification.getPatchIDs());
            if (!invalidation.isEmpty()) {
                try {
                    // Before rolling back the one-off patches, validate that the state until that point is consistent
                    validateRollbackState(invalidation.get(invalidation.size() - 1),
                            modification.getUnmodifiedInstallationState());
                } catch (PatchingException e) {
                    throw e;
                } catch (Exception e) {
                    throw new PatchingException(e);
                }
                // Invalidate the installed patches first
                for (final String rollback : invalidation) {
                    rollback(rollback, context);
                }
            }
        }

        // Add to installed patches list
        modification.addInstalledPatch(patchId);

        // Then apply the current patch
        for (final PatchElement element : patch.getElements()) {
            // Apply the content modifications
            final IdentityPatchContext.PatchEntry target = context.resolveForElement(element);
            final PatchElementProvider provider = element.getProvider();
            final Patch.PatchType elementPatchType = provider.getPatchType();
            final String elementPatchId = element.getId();
            // See if we can skip this element
            if (target.isApplied(elementPatchId)) {
                // TODO if it is already applied, we can just skip the entry (maybe based ont the type of the patch)
                // This needs some further testing, maybe we need to compare our history with the patch if they are consistent
                throw PatchLogger.ROOT_LOGGER.alreadyApplied(elementPatchId);
            }
            // Check upgrade conditions
            checkUpgradeConditions(provider, target);
            apply(elementPatchId, element.getModifications(), target);
            target.apply(elementPatchId, elementPatchType);
        }
        // Apply the patch to the identity
        final IdentityPatchContext.PatchEntry identityEntry = context.getIdentityEntry();
        apply(patchId, patch.getModifications(), identityEntry);
        identityEntry.apply(patchId, patchType);

        // Port forward missing module changes
        if (patchType == Patch.PatchType.CUMULATIVE) {
            portForward(patch, context);
        }

        // We need the resulting version for rollback
        if (patchType == Patch.PatchType.CUMULATIVE) {
            final Identity.IdentityUpgrade upgrade = identity.forType(Patch.PatchType.CUMULATIVE, Identity.IdentityUpgrade.class);
            identityEntry.setResultingVersion(upgrade.getResultingVersion());
        }

        // Execute the tasks
        final IdentityApplyCallback callback = new IdentityApplyCallback(patch, identityEntry.getDirectoryStructure());
        try {
            return executeTasks(context, callback);
        } catch (Exception e) {
            context.cancel(callback);
            throw rethrowException(e);
        }
    }",Apply a patch.
"private Map<NodeId, NodeId> resolveAliases(Iterable<Alias> aliases) {
        Map<NodeId, NodeId> resolved = Maps.newHashMap();
        Map<NodeId, Set<NodeId>> inverse = Maps.newHashMap();

        for (Alias alias : aliases) {
            NodeId from = alias.getFromId();
            NodeId to = alias.getToId();
            if (resolved.containsKey(to)) {
                to = resolved.get(to);
            }
            resolved.put(from, to);
            if (inverse.get(to) == null) {
                inverse.put(to, Sets.<NodeId> newHashSet());
            }
            inverse.get(to).add(from);

            Set<NodeId> prev = inverse.get(from);
            if (prev != null) {
                for (NodeId id : prev) {
                    resolved.remove(id);
                    inverse.get(from).remove(id);
                    resolved.put(id, to);
                    inverse.get(to).add(id);
                }
            }
        }

        return resolved;
    }",Resolve the aliases.
"public List<InputColumn<?>> getAvailableInputColumns(final ComponentBuilder componentBuilder,
            final Class<?> dataType) {
        List<InputColumn<?>> result = getAvailableInputColumns(dataType);

        final SourceColumnFinder finder = new SourceColumnFinder();
        finder.addSources(this);

        result = CollectionUtils.filter(result, new Predicate<InputColumn<?>>() {
            @Override
            public Boolean eval(InputColumn<?> inputColumn) {
                if (inputColumn.isPhysicalColumn()) {
                    return true;
                }

                final InputColumnSourceJob origin = finder.findInputColumnSource(inputColumn);
                if (origin == null) {
                    return true;
                }

                if (origin == componentBuilder) {
                    // exclude columns from the component itself
                    return false;
                }

                final Set<Object> sourceComponents = finder.findAllSourceJobs(origin);
                if (sourceComponents.contains(componentBuilder)) {
                    // exclude columns that depend
                    return false;
                }

                return true;
            }
        });

        return result;
    }",Get the list of input columns for a given data type.
"public static Member member(MemberId memberId, Address address) {
    return builder(memberId)
        .withAddress(address)
        .build();
  }",Create a member with the given member id and address.
"@Override
	public void close() throws IOException {
		for(int i=0;i<oss.length;++i) {
			if(close[i]) {
				oss[i].close();
			}
    	}
	}",Close the underlying file.
"public Object executeOutboundOperation(final Message<?> message) {

		try {
			String serializedMessage = messageMarshaller.serialize(message);

			if (snsTestProxy == null) {
				PublishRequest request = new PublishRequest();
				PublishResult result = client.publish(request.withTopicArn(
						topicArn).withMessage(serializedMessage));
				log.debug(""Published message to topic: ""
						+ result.getMessageId());
			} else {
				snsTestProxy.dispatchMessage(serializedMessage);
			}

		} catch (MessageMarshallerException e) {
			log.error(e.getMessage(), e);
			throw new MessagingException(e.getMessage(), e.getCause());
		}

		return message.getPayload();
	}",Execute an outbound operation on the SNS topic.
"public static String formatDate(Date d, String fmt) {
        return FastDateFormat.getInstance(fmt).format(d);
    }",Format a date to a string.
"private boolean isInlineAppend(FQMethod fqm) {
        if (!SignatureUtils.isPlainStringConvertableClass(fqm.getClassName())) {
            return false;
        }

        if (stack.getStackDepth() <= 1) {
            return true;
        }

        OpcodeStack.Item itm = stack.getStackItem(1);
        return itm.getUserValue() == UCPMUserValue.INLINE;
    }",returns true if the method is an inline append method
"@Override
    public void clear() {
        for (int i = 0; i < buckets.length; i++) {
            buckets[i] = null;
        }
        size = 0;
        lastDeletedKey = minKey;
        currentMin = null;
    }",Clear the cache.
"@NotNull
    public OptionalLong or(@NotNull Supplier<OptionalLong> supplier) {
        if (isPresent()) return this;
        Objects.requireNonNull(supplier);
        return Objects.requireNonNull(supplier.get());
    }",Gets the value of the CID    either from the given Supplier.
"public static FSAHeader read(InputStream in) throws IOException {
    if (in.read() != ((FSA_MAGIC >>> 24)       ) ||
        in.read() != ((FSA_MAGIC >>> 16) & 0xff) ||
        in.read() != ((FSA_MAGIC >>>  8) & 0xff) ||
        in.read() != ((FSA_MAGIC       ) & 0xff)) {
      throw new IOException(""Invalid file header, probably not an FSA."");
    }

    int version = in.read();
    if (version == -1) {
      throw new IOException(""Truncated file, no version number."");
    }

    return new FSAHeader((byte) version);
  }",Read the FSA header from the specified input stream.
"@Override
	protected Variable[] createVariablesSub(int num) {
		int[] tp = tpCreate(num);
		Variable[] ret = new Variable[num];
		for (int i = 0; i < tp.length; i++) {
			ret[i] = tPoints[tp[i]];			
		}
		return ret;
	}",Create the variable array sub - array.
"public JSON with(Feature feature, boolean state)
    {
        int f = _features;
        if (state) {
            f |= feature.mask();
        } else {
            f &= ~feature.mask();
        }
        return _with(f);
    }",Sets the feature mask and state of the result.
"@BetaApi
  public final Policy setIamPolicyImage(
      ProjectGlobalImageResourceName resource,
      GlobalSetPolicyRequest globalSetPolicyRequestResource) {

    SetIamPolicyImageHttpRequest request =
        SetIamPolicyImageHttpRequest.newBuilder()
            .setResource(resource == null ? null : resource.toString())
            .setGlobalSetPolicyRequestResource(globalSetPolicyRequestResource)
            .build();
    return setIamPolicyImage(request);
  }",Sets the Iam Policy image for the specified resource.
"protected static String toLowerCase(String input) {
        if(Character.isUpperCase(input.charAt(0)))
            return input.substring(0, 1).toLowerCase() + input.substring(1);
        return input;
    }",Returns the first letter of the input string.
"public void marshall(ShareDetails shareDetails, ProtocolMarshaller protocolMarshaller) {

        if (shareDetails == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(shareDetails.getSuccessfulShares(), SUCCESSFULSHARES_BINDING);
            protocolMarshaller.marshall(shareDetails.getShareErrors(), SHAREERRORS_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given ShareDetails object to the JSON object.
"public String toQueryString(Criteria criteria, CriteriaQueryBuilder queryBuilder) {

    // query builder
    StringBuilder builder = new StringBuilder();

    // build the basic query
    builder.append( queryBuilder.getAbsolutePath(criteria, relativePath) );
    builder.append( "" IN ("");
    
    // We must add each value as a parameter, because not all JPA
    // implementations allow lists or arrays as parameters.
    if( values != null ) {
      for( int i = 0; i < values.length; i++) {
        builder.append( queryBuilder.createPositionalParameter() );
        if( i < values.length - 1 ) {
          builder.append(',');
        }
      }
    }
    builder.append("")"");
    
    // return result
    return builder.toString();
  }",Build the query string for the IN clause.
"public static ClassFinder instance(Context context) {
        ClassFinder instance = context.get(classFinderKey);
        if (instance == null)
            instance = new ClassFinder(context);
        return instance;
    }",Get the ClassFinder instance.
"@Override
	public void close() throws IOException {
		if (upload != null) {
			flush();
			// close the connection
			try {
				upload.close();
			} catch (SQLException e) {
				LOG.info(""JDBC statement could not be closed: "" + e.getMessage());
			} finally {
				upload = null;
			}
		}

		if (dbConn != null) {
			try {
				dbConn.close();
			} catch (SQLException se) {
				LOG.info(""JDBC connection could not be closed: "" + se.getMessage());
			} finally {
				dbConn = null;
			}
		}
	}",Close the connection.
"protected void checkDiskError(Exception e ) throws IOException {
    if (e instanceof ClosedByInterruptException
        || e instanceof java.io.InterruptedIOException) {
      return;
    }
    LOG.warn(""checkDiskError: exception: "", e);
    
    if (e.getMessage() != null &&
        e.getMessage().startsWith(""No space left on device"")) {
      throw new DiskOutOfSpaceException(""No space left on device"");
    } else {
      checkDiskError();
    }
  }",Check disk error.
"public static int ptb2Text(Reader ptbText, Writer w) throws IOException {
    int numTokens = 0;
    PTB2TextLexer lexer = new PTB2TextLexer(ptbText);
    for (String token; (token = lexer.next()) != null; ) {
      numTokens++;
      w.write(token);
    }
    return numTokens;
  }",Read and write a sequence of tokens from a PTB file.
"public static String getDisplayName(String localeID, String displayLocaleID) {
        return getDisplayNameInternal(new ULocale(localeID), new ULocale(displayLocaleID));
    }",Get the display name for a locale ID.
"public List<MethodSymbol> interfaceCandidates(Type site, MethodSymbol ms) {
        CandidatesCache.Entry e = candidatesCache.new Entry(site, ms);
        List<MethodSymbol> candidates = candidatesCache.get(e);
        if (candidates == null) {
            Filter<Symbol> filter = new MethodFilter(ms, site);
            List<MethodSymbol> candidates2 = List.nil();
            for (Symbol s : membersClosure(site, false).getSymbols(filter)) {
                if (!site.tsym.isInterface() && !s.owner.isInterface()) {
                    return List.of((MethodSymbol)s);
                } else if (!candidates2.contains(s)) {
                    candidates2 = candidates2.prepend((MethodSymbol)s);
                }
            }
            candidates = prune(candidates2);
            candidatesCache.put(e, candidates);
        }
        return candidates;
    }",Get the candidates of a method in an interface.
"public ImmutableSet<ClassInfo> getTopLevelClassesRecursive(String packageName) {
    checkNotNull(packageName);
    String packagePrefix = packageName + '.';
    ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();
    ImmutableSet<ClassInfo> topLevelClasses = getTopLevelClasses();
    List<String> debugData = Lists.newLinkedList();
    for (ClassInfo classInfo : topLevelClasses) {
      if (classInfo.getName().startsWith(packagePrefix)) {
        builder.add(classInfo);
        debugData.add(classInfo.getResourceName() + ""\n"");
      }
    }
    return builder.build();
  }",Get the top level classes recursively.
"public GetDocumentTextDetectionResult withWarnings(Warning... warnings) {
        if (this.warnings == null) {
            setWarnings(new java.util.ArrayList<Warning>(warnings.length));
        }
        for (Warning ele : warnings) {
            this.warnings.add(ele);
        }
        return this;
    }",A list of warnings that were detected during the detection process.
"public File getFilteredVersion(File input) {
        File out = getOutputFile(input);
        if (!out.isFile()) {
            return null;
        }
        return out;
    }",Get the filtered version of a file.
"public JobDetails getJobByJobID(String cluster, String jobId)
      throws IOException {
    return getJobByJobID(cluster, jobId, false);
  }",Get the JobDetails for a given job ID.
"public boolean markMigrated(VectorClock vectorClock) {
        stateWriteLock.lock();
        try {
            if (stateVectorClock.equals(vectorClock)) {
                migrated = true;
            }
            return migrated;
        } finally {
            stateWriteLock.unlock();
        }
    }",Mark the migration of a class to a new vector clock.
"public static WxaUserInfo validateUserInfo(String session_key, String rawData, String signature) {
		try {
			if (DigestUtils.shaHex(rawData + session_key).equals(signature)) {
				return JsonUtil.parseObject(rawData, WxaUserInfo.class);
			}
		} catch (Exception e) {
			logger.error("""", e);
		}
		return null;
	}",Validate a raw data and signature.
"public static String getFilename(final URL url) throws UnsupportedEncodingException
	{
		if (isJar(url) || isEar(url))
		{
			String fileName = URLDecoder.decode(url.getFile(), ""UTF-8"");
			fileName = fileName.substring(5, fileName.indexOf(""!""));
			return fileName;
		}
		return URLDecoder.decode(url.getFile(), ""UTF-8"");
	}",Gets the filename from the URL.
"public static DZcsn cs_chol(DZcs A, DZcss S) {
		double[] d, lki ;
		DZcsa Lx = new DZcsa (), x, Cx = new DZcsa () ;
		int top, i, p, k, n, Li[], Lp[], cp[], pinv[], s[], c[], parent[], Cp[], Ci[] ;
		DZcs L, C, E ;
		DZcsn N ;
		if (!CS_CSC(A) || S == null || S.cp == null || S.parent == null) return (null) ;
		n = A.n ;
		N = new DZcsn () ;		/* allocate result */
		c = new int [2*n] ;		/* get int workspace */
		x = new DZcsa (n) ;		/* get complex workspace */
		cp = S.cp ; pinv = S.pinv ; parent = S.parent ;
		C = pinv != null ? cs_symperm (A, pinv, true) : A ;
		E = pinv != null ? C : null ;	/* E is alias for A, or a copy E=A(p,p) */
		if (N == null || c == null || x == null || C == null) return (cs_ndone (N, E, c, x, false)) ;
		s = c ;
		int s_offset = n ;
		Cp = C.p ; Ci = C.i ; Cx.x = C.x ;
		N.L = L = cs_spalloc (n, n, cp[n], true, false); /* allocate result */
		if (L == null) return (cs_ndone (N, E, c, x, false)) ;
		Lp = L.p ; Li = L.i ; Lx.x = L.x ;
		for (k = 0 ; k < n ; k++) Lp [k] = c [k] = cp [k] ;
		for (k = 0 ; k < n ; k++)	/* compute L(k,:) for L*L' = C */
		{
			/* --- Nonzero pattern of L(k,:) ------------------------------------ */
			top = cs_ereach (C, k, parent, s, s_offset, c) ;		/* find pattern of L(k,:) */
			x.set(k, cs_czero ()) ;					/* x (0:k) is now zero */
			for (p = Cp [k] ; p < Cp [k + 1] ; p++)			/* x = full(triu(C(:,k))) */
			{
				if (Ci [p] <= k) x.set(Ci [p], Cx.get(p)) ;
			}
			d = x.get(k) ;				/* d = C(k,k) */
			x.set(k, cs_czero ()) ;			/* clear x for k+1st iteration */
			/* --- Triangular solve --------------------------------------------- */
			for ( ; top < n ; top++)		/* solve L(0:k-1,0:k-1) * x = C(:,k) */
			{
				i = s [s_offset + top] ;	/* s [top..n-1] is pattern of L(k,:) */
				lki = cs_cdiv (x.get(i), Lx.get(Lp [i])) ; /* L(k,i) = x (i) / L(i,i) */
				x.set(i, cs_czero ()) ;		/* clear x for k+1st iteration */
				for (p = Lp [i] + 1 ; p < c [i] ; p++)
				{
					x.set(Li [p], cs_cminus (x.get(Li [p]), cs_cmult (Lx.get(p), lki))) ;
				}
				d = cs_cminus (d, cs_cmult (lki, cs_conj (lki))) ;	/* d = d - L(k,i)*L(k,i) */
				p = c [i]++ ;
				Li [p] = k ;			/* store L(k,i) in column i */
				Lx.set(p, cs_conj (lki)) ;
			}
			/* --- Compute L(k,k) ----------------------------------------------- */
			if (d[0] <= 0 || d[1] != 0)
				return (cs_ndone (N, E, c, x, false)) ;	/* not pos def */
			p = c [k]++ ;
			Li [p] = k ;				/* store L(k,k) = sqrt (d) in column k */
			Lx.set(p, cs_csqrt (d)) ;
		}
		Lp [n] = cp [n] ;				/* finalize L */
		return (cs_ndone (N, E, c, x, true)) ;		/* success: free E,s,x; return N */
	}",Returns the Cholesky decomposition of A and S.
"public static Map<Object, int[]> countAnnotationsPerCategory(
			final ICodingAnnotationStudy study) {
		Map<Object, int[]> result = new HashMap<Object, int[]>();
		for (ICodingAnnotationItem item : study.getItems()) {
            for (IAnnotationUnit unit : item.getUnits()) {
				Object category = unit.getCategory();
				if (category == null) {
                    continue;
                }

				int[] counts = result.get(category);
				if (counts == null) {
                    counts = new int[study.getRaterCount()];
                }
				counts[unit.getRaterIdx()]++;
				result.put(category, counts);
			}
        }
		return result;
	}",Count the number of annotations per category for a given annotation study.
"@SuppressWarnings(""unchecked"")
  void registerConsumer(Inspector<? super OutT> subInspector) {
    consumers.add((Inspector<OutT>) subInspector);
  }",Registers a consumer to the container.
"void logOrphans(final List<Map<String, Object>> toLog) {
        try {
            String result = pretty
                    ? prettyWriter().writeValueAsString(toLog)
                    : writer().writeValueAsString(toLog);
            LOGGER.warn(""Orphan responses observed: {}"", result);
        } catch (Exception ex) {
            LOGGER.warn(""Could not write orphan log."", ex);
        }
    }",Log orphans.
"public void setRefreshType(com.google.api.ads.admanager.axis.v201902.RefreshType refreshType) {
        this.refreshType = refreshType;
    }",Sets the refreshType value for this BaseResource.
"protected void resolvePropertyReplacements(Api api) {
        if (api == null) {
            return;
        }
        String endpoint = api.getEndpoint();
        endpoint = resolveProperties(endpoint);
        api.setEndpoint(endpoint);

        Map<String, String> properties = api.getEndpointProperties();
        for (Entry<String, String> entry : properties.entrySet()) {
            String value = entry.getValue();
            value = resolveProperties(value);
            entry.setValue(value);
        }

        resolvePropertyReplacements(api.getApiPolicies());
    }",Resolve property replacements for the API.
"private static Method accessible(Method method) {
        if (method != null) {
            method.setAccessible(true);
        }
        return method;
    }",Set the method accessible.
"public static boolean isISODate(final String val) throws BadDateException {
    try {
      if (val.length() != 8) {
        return false;
      }
      fromISODate(val);
      return true;
    } catch (Throwable t) {
      return false;
    }
  }",Check if the string is a valid date.
"public void setFragment(boolean newFragment)
  {
    boolean oldFragment = fragment;
    fragment = newFragment;
    if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, SimpleAntlrPackage.RULE__FRAGMENT, oldFragment, fragment));
  }",Sets the fragment flag.
"@NonNull
    private static ObservableTransformer<byte[], PresenterEvent> transformToPresenterEvent(Type type) {
        return observable -> observable.map(writtenBytes -> ((PresenterEvent) new ResultEvent(writtenBytes, type)))
                .onErrorReturn(throwable -> new ErrorEvent(throwable, type));
    }",Transform a result event to a presenter event.
"private List<String> searchTokens(SNode n, long cnr)
  {
    List<String> result = new LinkedList<String>();
    if (n instanceof SToken)
    {
      result.add(n.getId());
      if (componentOfToken.get(n.getId()) == null)
      {
        List<Long> newlist = new LinkedList<Long>();
        newlist.add(cnr);
        componentOfToken.put(n.getId(), newlist);
      }
      else
      {
        List<Long> newlist = componentOfToken.get(n.getId());
        if (!newlist.contains(cnr))
        {
          newlist.add(cnr);
        }
      }
    }
    else
    {
      List<SRelation<SNode, SNode>> outgoing = n.getGraph().getOutRelations(n.getId());
      if(outgoing != null)
      {
        for (SRelation<? extends SNode,? extends SNode> e : outgoing)
        {
          if(!(e instanceof SPointingRelation) && e.getSource() instanceof SNode && e.getTarget() instanceof SNode)
          {
            List<String> Med = searchTokens((SNode) e.getTarget(), cnr);
            for (String s : Med)
            {
              if (!result.contains(s))
              {
                result.add(s);
              }
            }
          }
        }
      }
    }
    return result;
  }",Search tokens.
"protected ResultSet getResultSet() {
		if (table == null) {
			throw new IllegalArgumentException(""missing parameter: table"");
		}

		String whereClause = """";
		if (where != null) {
            whereClause = "" WHERE "" + where;
        }

        try {
			statement = connection.createStatement();
			return statement.executeQuery(""SELECT * FROM "" + table + whereClause);
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}",Returns a ResultSet object for the table where the where clause is not null.
"public Observable<ServiceResponse<OperationStatus>> updatePrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdatePrebuiltEntityRoleOptionalParameter updatePrebuiltEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException(""Parameter this.client.endpoint() is required and cannot be null."");
        }
        if (appId == null) {
            throw new IllegalArgumentException(""Parameter appId is required and cannot be null."");
        }
        if (versionId == null) {
            throw new IllegalArgumentException(""Parameter versionId is required and cannot be null."");
        }
        if (entityId == null) {
            throw new IllegalArgumentException(""Parameter entityId is required and cannot be null."");
        }
        if (roleId == null) {
            throw new IllegalArgumentException(""Parameter roleId is required and cannot be null."");
        }
        final String name = updatePrebuiltEntityRoleOptionalParameter != null ? updatePrebuiltEntityRoleOptionalParameter.name() : null;

        return updatePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name);
    }",Updates an entity role.
"@Override
    public <T, A> AsyncFuture<T> executeRequest(final Integer operationId, final ManagementRequest<T, A> request) throws IOException {
        final ActiveOperation<T, A> operation = super.getActiveOperation(operationId);
        if(operation == null) {
            throw ProtocolLogger.ROOT_LOGGER.responseHandlerNotFound(operationId);
        }
        return executeRequest(operation, request);
    }",Execute a request.
"private static void assignKeyFromAddressNode(ModelNode payload, ModelNode address) {
        List<Property> props = address.asPropertyList();
        Property lastToken = props.get(props.size()-1);
        payload.get(""entity.key"").set(lastToken.getValue().asString());
    }",Assigns the key from the address node to the last token in the address node.
"public void setNeedleBorderColor(final Color COLOR) {
        if (null == needleBorderColor) {
            _needleBorderColor = null == COLOR ? Color.TRANSPARENT : COLOR;
            fireUpdateEvent(REDRAW_EVENT);
        } else {
            needleBorderColor.set(COLOR);
        }
    }",Defines the color that will be used to colorize the border of the contour of the contour.
"public String getReservedNickname() throws SmackException, InterruptedException {
        try {
            DiscoverInfo result =
                ServiceDiscoveryManager.getInstanceFor(connection).discoverInfo(
                    room,
                    ""x-roomuser-item"");
            // Look for an Identity that holds the reserved nickname and return its name
            for (DiscoverInfo.Identity identity : result.getIdentities()) {
                return identity.getName();
            }
        }
        catch (XMPPException e) {
            LOGGER.log(Level.SEVERE, ""Error retrieving room nickname"", e);
        }
        // If no Identity was found then the user does not have a reserved room nickname
        return null;
    }",Get the reserved nickname of the user.
"private boolean isInjectorOrAssistedProvider(Dependency<?> dependency) {
    Class<?> annotationType = dependency.getKey().getAnnotationType();
    if (annotationType != null && annotationType.equals(Assisted.class)) { // If it's assisted..
      if (dependency
          .getKey()
          .getTypeLiteral()
          .getRawType()
          .equals(Provider.class)) { // And a Provider...
        return true;
      }
    } else if (dependency
        .getKey()
        .getTypeLiteral()
        .getRawType()
        .equals(Injector.class)) { // If it's the Injector...
      return true;
    }
    return false;
  }",Checks if the dependency is an Injector or an AssistedProvider.
"private static void doInsert(CallInfo callInfo, Table table, DataSet data) {
    StringBuilder sql = new StringBuilder(""INSERT INTO "");
    List<String> tableColumns = table.getColumns();
    int columnCount = tableColumns.size();
    int[] paramIdx = new int[columnCount];
    int param = 0;
    Iterator<String> itr = tableColumns.iterator();
    String col = itr.next();
    
    paramIdx[param] = ++param;
    sql.append(table.getName())
       .append('(')
       .append(col);
    
    while (itr.hasNext()) {
      paramIdx[param] = ++param;
      col = itr.next();
      sql.append(',')
         .append(col);
    }
    sql.append("") VALUES (?"");
    for (int i=1; i < columnCount; i++) {
      sql.append("",?"");
    }
    sql.append(')');

    dataSetOperation(callInfo, table, data, sql.toString(), paramIdx);
  }",Insert data set into a table.
"private Map<Key, Object> cacheGetAll(final Collection<Key> keys) {
		try {
			return this.memcache.getAll(keys);
		} catch (Exception ex) {
			// Some sort of serialization error, just wipe out the values
			log.warn(""Error fetching values from memcache, deleting keys"", ex);

			this.memcache.deleteAll(keys);

			return new HashMap<>();
		}
	}",Gets all the values from the memcached cache.
"@Override
	public HashMap<String, Object> getApplicationMap() {
		return (HashMap<String, Object>) JKThreadLocal.getValue(JKContextConstants.APPLICATION_MAP);
	}",Get the application map.
"@SuppressWarnings(""unchecked"")
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException
    {
        // Read in the key type and any hidden stuff
        s.defaultReadObject();

        keyUniverse = getKeyUniverse(keyType);
        vals = new Object[keyUniverse.length];

        // Read in size (number of Mappings)
        int size = s.readInt();

        // Read the keys and values, and put the mappings in the HashMap
        for (int i = 0; i < size; i++) {
            K key = (K) s.readObject();
            V value = (V) s.readObject();
            put(key, value);
        }
    }",Read the object from an input stream.
"public Set getSIBDestinationLocalitySet(String busName, String uuid,
                                            boolean newSet) throws SIBExceptionDestinationNotFound,
                    SIBExceptionBase {

        /*
         * if (TraceComponent.isAnyTracingEnabled() &&
         * tc.isEntryEnabled()) SibTr.entry(tc, ""getSIBDestinationLocalitySet"",
         * new Object[] { busName, uuid, new Boolean(newSet) });
         * 
         * Set results = _engine.getSIBDestinationLocalitySet(busName, uuid,
         * newSet);
         * 
         * if (TraceComponent.isAnyTracingEnabled() &&
         * tc.isEntryEnabled()) SibTr.exit(tc, ""getSIBDestinationLocalitySet"",
         * results);
         */

        //Venu Liberty change:
        //_localistySet is filled up with this ME Uuid in startInternal();
        // This function would get called only after _localistySet is filled up at lease once

        return _localistySet;
    }",This method is called by the SIBEngineImpl to get a set of Locality objects from a destination.
"@Override
    public List<Character> subList(int fromIndex, int toIndex) {
        return new CharArrayList(a, fromIndex, toIndex - fromIndex);
    }",Returns a sub - list of this sequence.
"public static Response get(URI uri, Credentials credentials, Header[] requestHeaders)
        throws URISyntaxException, HttpException {
        return send(new HttpGet(uri), credentials, requestHeaders);
    }",Perform an HTTP GET on the given URI using the given credentials and request headers.
"private static String[][] resizeArray(String[][] array, int size)
    {
        if (array.length == size) return array;
        String[][] nArray = new String[size][];
        System.arraycopy(array, 0, nArray, 0, size);
        return nArray;
    }",Resize the array to the given size.
"static <T> Optional<T> findFirst(final Class<T> service) {
        final ServiceLoader<T> loader = load(service);
        if (loader == null) return empty();
        final Iterator<T> services = loader.iterator();
        return services.hasNext() ? of(services.next()) : empty();
    }",Find first Service in ServiceLoader.
"public static double getDouble(String pStr) {
        if (isEmpty(pStr)) {
            return 0.0;
        }
        double value = 0.0;
        pStr = pStr.substring(0, pStr.length() - 2) + ""."" + pStr.substring(pStr.length() - 2);
        try {
            value = Double.parseDouble(pStr);
        } catch (NumberFormatException ex) {
        }
        return value;
    }",Get the double value from a string.
"public void marshall(ListUsersRequest listUsersRequest, ProtocolMarshaller protocolMarshaller) {

        if (listUsersRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(listUsersRequest.getBrokerId(), BROKERID_BINDING);
            protocolMarshaller.marshall(listUsersRequest.getMaxResults(), MAXRESULTS_BINDING);
            protocolMarshaller.marshall(listUsersRequest.getNextToken(), NEXTTOKEN_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",Creates the marshalling method for the ANSCTYPE service.
"private Mapper<K, V> addConstraint(MapConstraint<K, V> constraint) {
		this.delegate = Optional.of(MapConstraints.constrainedMap(delegate.get(), constraint));
		return this;
	}",Add a constraint to the delegate map.
"private static void inplace_merge(int first, int middle, int last, IntComparator comp, Swapper swapper) {
	if (first >= middle || middle >= last)
		return;
	if (last - first == 2) {
		if (comp.compare(middle, first)<0) {
			swapper.swap(first,middle);
		}
		return;
	}
	int firstCut;
	int secondCut;
	if (middle - first > last - middle) {
		firstCut = first + (middle - first) / 2;
		secondCut = lower_bound(middle, last, firstCut, comp);
	} 
	else {
		secondCut = middle + (last - middle) / 2;
		firstCut = upper_bound(first, middle, secondCut, comp);
	}

	// rotate(firstCut, middle, secondCut, swapper);
	// is manually inlined for speed (jitter inlining seems to work only for small call depths, even if methods are ""static private"")
	// speedup = 1.7
	// begin inline
	int first2 = firstCut; int middle2 = middle; int last2 = secondCut;
	if (middle2 != first2 && middle2 != last2) {
		int first1 = first2; int last1 = middle2;
		while (first1 < --last1) swapper.swap(first1++,last1);
		first1 = middle2; last1 = last2;
		while (first1 < --last1) swapper.swap(first1++,last1);
		first1 = first2; last1 = last2;
		while (first1 < --last1) swapper.swap(first1++,last1);
	}
	// end inline

	middle = firstCut + (secondCut - middle);
	inplace_merge(first, firstCut, middle, comp, swapper);
	inplace_merge(middle, secondCut, last, comp, swapper);
}",Inplace merge of two 16 - bit integers.
"public Observable<ServiceResponse<RegexEntityExtractor>> getRegexEntityEntityInfoWithServiceResponseAsync(UUID appId, String versionId, UUID regexEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException(""Parameter this.client.endpoint() is required and cannot be null."");
        }
        if (appId == null) {
            throw new IllegalArgumentException(""Parameter appId is required and cannot be null."");
        }
        if (versionId == null) {
            throw new IllegalArgumentException(""Parameter versionId is required and cannot be null."");
        }
        if (regexEntityId == null) {
            throw new IllegalArgumentException(""Parameter regexEntityId is required and cannot be null."");
        }
        String parameterizedHost = Joiner.on("", "").join(""{Endpoint}"", this.client.endpoint());
        return service.getRegexEntityEntityInfo(appId, versionId, regexEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RegexEntityExtractor>>>() {
                @Override
                public Observable<ServiceResponse<RegexEntityExtractor>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RegexEntityExtractor> clientResponse = getRegexEntityEntityInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }",Gets information about an entity in an App Service Environment.
"public void setContent(IContent content)
	{
		this.content = content;
		content.setParent(this);
		content.setPosition(Position.middleCenter(content).plus(offsetPosition));
	}",Sets the content of the page.
"@Override
    protected AstNode parseCreateViewStatement( DdlTokenStream tokens,
                                                AstNode parentNode ) throws ParsingException {
        assert tokens != null;
        assert parentNode != null;

        markStartOfStatement(tokens);
        // CREATE [OR REPLACE]
        // [[NO] FORCE] VIEW [schema.] view
        // [ ( { alias [ inline_constraint... ]
        // | out_of_line_constraint
        // }
        // [, { alias [ inline_constraint...]
        // | out_of_line_constraint
        // }
        // ]
        // )
        // | object_view_clause
        // | XMLType_view_clause
        // ]
        // AS subquery [ subquery_restriction_clause ] ;

        // NOTE: the query expression along with the CHECK OPTION clause require no SQL statement terminator.
        // So the CHECK OPTION clause will NOT

        String stmtType = ""CREATE"";
        tokens.consume(""CREATE"");
        if (tokens.canConsume(""OR"", ""REPLACE"")) {
            stmtType = stmtType + SPACE + ""OR REPLACE"";
        } else if (tokens.canConsume(""NO"", ""FORCE"")) {
            stmtType = stmtType + SPACE + ""NO FORCE"";
        } else if (tokens.canConsume(""FORCE"")) {
            stmtType = stmtType + SPACE + ""FORCE"";
        }

        tokens.consume(""VIEW"");
        stmtType = stmtType + SPACE + ""VIEW"";

        String name = parseName(tokens);

        AstNode createViewNode = nodeFactory().node(name, parentNode, TYPE_CREATE_VIEW_STATEMENT);

        // CONSUME COLUMNS
        parseColumnNameList(tokens, createViewNode, TYPE_COLUMN_REFERENCE);

        // (object_view_clause)
        //
        // OF [ schema. ] type_name
        // { WITH OBJECT IDENTIFIER
        // { DEFAULT | ( attribute [, attribute ]... ) }
        // | UNDER [ schema. ] superview
        // }
        // ( { out_of_line_constraint
        // | attribute { inline_constraint }...
        // } [, { out_of_line_constraint
        // | attribute { inline_constraint }...
        // }
        // ]...
        // )

        // (XMLType_view_clause)
        //
        // OF XMLTYPE [ XMLSchema_spec ]
        // WITH OBJECT IDENTIFIER
        // { DEFAULT | ( expr [, expr ]...) }

        // Basically, if next token matches ""OF"", then parse until token matches ""AS""

        if (tokens.matches(""OF"")) {
            do {
                tokens.consume();
            } while (!tokens.matches(""AS""));
        }

        tokens.consume(""AS"");

        String queryExpression = parseUntilTerminator(tokens);

        createViewNode.setProperty(CREATE_VIEW_QUERY_EXPRESSION, queryExpression);

        markEndOfStatement(tokens, createViewNode);

        return createViewNode;
    }",Parse a CREATE VIEW statement.
"public byte[] getBytes(int size){ 
        _checkForRead(size);
        byte[] dst = new byte[size];
       _buf.get(dst, 0, size);
       return dst;
    }",Get a byte array of the specified size from the buffer.
"public static vpnglobal_authenticationlocalpolicy_binding[] get(nitro_service service) throws Exception{
		vpnglobal_authenticationlocalpolicy_binding obj = new vpnglobal_authenticationlocalpolicy_binding();
		vpnglobal_authenticationlocalpolicy_binding response[] = (vpnglobal_authenticationlocalpolicy_binding[]) obj.get_resources(service);
		return response;
	}",Use this API to fetch a vpnglobal_authenticationlocalpolicy_binding resources.
"public void setTerms(java.util.Collection<Term> terms) {
        if (terms == null) {
            this.terms = null;
            return;
        }

        this.terms = new java.util.ArrayList<Term>(terms);
    }",Sets the value terms property.
"public SslPolicy withSslProtocols(String... sslProtocols) {
        if (this.sslProtocols == null) {
            setSslProtocols(new java.util.ArrayList<String>(sslProtocols.length));
        }
        for (String ele : sslProtocols) {
            this.sslProtocols.add(ele);
        }
        return this;
    }",A list of ssl protocols to use for this certificate.
"public int scanScalar(int req_width, Pointer _cursor, int len) {
        byte[] cursorb = _cursor.buffer;
        int cursor = _cursor.start;

        int start = 0;
        int flags = SCAN_NONE;
        if(len < 1) {
            return flags;
        }

        switch(cursorb[cursor]) {
        case '[': case ']':
        case '{': case '}':
        case '!': case '*':
        case '&': case '|':
        case '>': case '\'':
        case '""': case '#':
        case '%': case '@':
        case '`':
            flags |= SCAN_INDIC_S;
            break;
        case '-': case ':':
        case '?': case ',':
            if(len == 1 || cursorb[cursor+1] == ' ' || cursorb[cursor+1] == '\n') {
                flags |= SCAN_INDIC_S;
            }
            break;
        }

        if(cursorb[cursor + len - 1] != '\n') {
            flags |= SCAN_NONL_E;
        } else if(len > 1 && cursorb[cursor + len - 2] == '\n') {
            flags |= SCAN_MANYNL_E;
        }

        if(
           (len>0 && (cursorb[cursor] == ' ' || cursorb[cursor] == '\t')) ||
           (len>1 && (cursorb[cursor + len - 1] == ' ' || cursorb[cursor + len - 1] == '\t'))
           ) {
            flags |= SCAN_WHITEEDGE;
        }

        if(len >= 3 && cursorb[cursor] == '-' && cursorb[cursor+1] == '-' && cursorb[cursor+2] == '-') {
            flags |= SCAN_DOCSEP;
        }

        for(int i=0; i<len; i++) {
            int ci = (int)(cursorb[cursor+i]&0xFF);
            if(! ( ci == 0x9 ||
                   ci == 0xA ||
                   ci == 0xD ||
                   (ci >= 0x20 && ci <= 0x7E))) {
                flags |= SCAN_NONPRINT;
            } else if(ci == '\n') {
                flags |= SCAN_NEWLINE;
                if(len - i >= 3 && cursorb[cursor+i+1] == '-' && cursorb[cursor+i+2] == '-' && cursorb[cursor+i+3] == '-' ) {
                    flags |= SCAN_DOCSEP;
                }
                if(i+1 < len && (cursorb[cursor+i+1] == ' ' || cursorb[cursor+i+1] == '\t')) {
                    flags |= SCAN_INDENTED;
                }
                if(req_width > 0 && (i - start) > req_width) {
                    flags |= SCAN_WIDE;
                }
                start = i;
            } else if(ci == '\'') {
                flags |= SCAN_SINGLEQ;
            } else if(ci == '""') {
                flags |= SCAN_DOUBLEQ;
            } else if(ci == ']') {
                flags |= SCAN_FLOWSEQ;
            } else if(ci == '}') {
                flags |= SCAN_FLOWMAP;
            } else if(((ci == ' ' && (i+1<len && cursorb[cursor+i+1] == '#') ) ||
                       (ci == ':' && ((i+1<len && cursorb[cursor+i+1] == ' ') || 
                                      (i+1<len && cursorb[cursor+i+1] == '\n') || 
                                      i == len - 1 )))) {
                flags |= SCAN_INDIC_C;
            } else if(ci == ',' && ((i == len - 1 ||
                                     cursorb[cursor+i+1] == ' ' || 
                                     cursorb[cursor+i+1] == '\n'))) {
                flags |= SCAN_FLOWMAP;
                flags |= SCAN_FLOWSEQ;
            }
        }

        return flags;
    }",Scan scalar.
"private boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg) {
    for (DiGraphEdge<Node, Branch> s : cfg.getImplicitReturn().getInEdges()) {
      Node n = s.getSource().getValue();
      // NOTE(dimvar): it is possible to change ControlFlowAnalysis.java, so
      // that the calls that always throw are treated in the same way as THROW
      // in the CFG. Then, we would not need to use the coding convention here.
      if (!n.isReturn() && !convention.isFunctionCallThatAlwaysThrows(n)) {
        return false;
      }
    }
    return true;
  }",Fast check for all paths that always throw a return value.
"public static Date dateStrToDate(final String dateStr) {
		
		String paddedDateStr = padStartDateStr(dateStr);
		try {
			return ArchiveUtils.parse14DigitDate(paddedDateStr);
		} catch (ParseException e) {
			e.printStackTrace();
			// TODO: This is certainly not the right thing, but padStartDateStr
			// should ensure we *never* get here..
			return new Date((long)SSE_YEAR_LOWER_LIMIT * 1000);
		}
	}",Converts a date string to a Date object.
"public QueryResult execute(Query query) throws QueryEngineException {
        if (!(query instanceof QueryImpl)) {
            throw new QueryEngineException(""Couldn't cast Query to QueryImpl."");
        }
        QueryImpl q = (QueryImpl) query;


        // search for unbound results vars
        resvarsLoop:
        for (QueryArgument arg : q.getResultVars()) {
            for (QueryAtomGroup g : q.getAtomGroups()) {
                for (QueryAtom a : g.getAtoms()) {
                    if (a.getArguments().contains(arg)) {
                        continue resvarsLoop;
                    }
                }
            }
//			throw new QueryEngineException(""Query contains an unbound result argument "" + arg + ""."");
        }

        Queue<QueryResultImpl> results = new LinkedList<>();
        for (QueryAtomGroup g : q.getAtomGroups()) {

            QueryAtomGroupImpl group = (QueryAtomGroupImpl) g;

            List<QueryAtomGroupImpl> components = findComponents(group);
            Queue<QueryResultImpl> componentResults = new LinkedList<>();
            boolean groupAsk = true;
            for (QueryAtomGroupImpl component : components) {

                QueryAtomGroupImpl preorderedGroup = preorder(component);

                QueryResultImpl result = new QueryResultImpl(query);
                if (eval(q, preorderedGroup, result, new QueryBindingImpl(), BoundChecking.CHECK_BOUND)) {
                    if (query.isSelectDistinct()) {
                        result = eliminateDuplicates(result);
                    }

                    componentResults.add(result);
                }
                else {
                    groupAsk = false;
                    break;
                }
            }

            if (groupAsk) {
                results.add(combineResults(componentResults,
                                           query.getType() == SELECT_DISTINCT));
            }
            else {
                // return only empty result with no solution for this group
                QueryResultImpl ret = new QueryResultImpl(query);
                ret.setAsk(false);
                results.add(ret);
            }
        }

        return unionResults(q, results, query.getType() == SELECT_DISTINCT);
    }",Execute the given query.
"protected void addTagsAsChildren( Git git,
                                      CallSpecification spec,
                                      DocumentWriter writer ) throws GitAPIException {
        // Generate the child references to the branches, which will be sorted by name (by the command).
        ListTagCommand command = git.tagList();
        List<Ref> tags = command.call();
        // Reverse the sort of the branch names, since they might be version numbers ...
        Collections.sort(tags, REVERSE_REF_COMPARATOR);
        for (Ref ref : tags) {
            String fullName = ref.getName();
            String name = fullName.replaceFirst(TAG_PREFIX, """");
            writer.addChild(spec.childId(name), name);
        }
    }",Add the tags as children of the branch.
"public void resume(UOWHandle handle) throws CSIException {
        final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();
        if (isTraceOn && tc.isEntryEnabled())
            Tr.entry(tc, ""resume : "" + handle);

        //A null handle indicates that during the execution of the corresponding suspend,
        //there wasn't a Tx to suspend, so do nothing.
        if (handle != null) {
            //Cast the handle to a UOWHandleImpl in order to get the instance
            //variables from it.
            UOWHandleImpl handleImpl = (UOWHandleImpl) handle;

            try {
                //From the handle we can determine if it is a local tx.  If so resume the local
                // tx, otherwise we have a global tx.
                if (handleImpl.suspendedLocalTx != null) {
                    //Get the LocalTransactionCoordinator from the handle, and resume the local
                    //Tx associated with it.
                    resumeLocalTx(handleImpl.suspendedLocalTx);
                }
                else {
                    //Get the suspended global tx from the handle, and resume the global
                    //tx associated with it.
                    resumeGlobalTx(handleImpl.suspendedGlobalTx, TIMEOUT_CLOCK_START);
                }
            } catch (Throwable t) {
                FFDCFilter.processException(t, CLASS_NAME + "".resume"", ""1491"", this);
                if (isTraceOn && tc.isEntryEnabled())
                    Tr.exit(tc, ""resume"", ""Error resuming tx in TransactionControlImpl: "" + t);
                throw new CSIException(""Error resuming tx in TransactionControlImpl."", t);
            }
        }

        if (isTraceOn && tc.isEntryEnabled())
            Tr.exit(tc, ""resume"");
    }",Resume the transaction associated with the specified UOWHandle.
"public static Collection<AbstractAttribute> findAttributesByAttributeFilter(
            final boolean parallel,
            final Predicate<? super AbstractAttribute> filter,
            final AbstractHtml... fromTags) throws NullValueException {

        if (filter == null) {
            throw new NullValueException(""The tagName should not be null"");
        }

        if (fromTags == null) {
            throw new NullValueException(""The fromTags should not be null"");
        }

        final Collection<Lock> locks = getReadLocks(fromTags);
        for (final Lock lock : locks) {
            lock.lock();
        }

        try {
            return getAllNestedChildrenIncludingParent(parallel, fromTags)
                    .filter(child -> {
                        return child.getAttributes() != null;
                    }).map(child -> {
                        return child.getAttributes();
                    }).flatMap(attributes -> attributes.stream()).filter(filter)
                    .collect(Collectors.toSet());
        } finally {
            for (final Lock lock : locks) {
                lock.unlock();
            }
        }
    }",Find attributes by attribute filter.
"private void sendFile(final YokeRequest request, final String file, final FileProps props) {
        // write content type
        String contentType = MimeType.getMime(file);
        String charset = MimeType.getCharset(contentType);
        request.response().setContentType(contentType, charset);
        request.response().putHeader(""Content-Length"", Long.toString(props.size()));

        // head support
        if (HttpMethod.HEAD.equals(request.method())) {
            request.response().end();
        } else {
            request.response().sendFile(file);
        }
    }",Send file.
"public final String getValue() {
        final StringBuilder b = new StringBuilder();
        if (getMinVersion() != null) {
            b.append(getMinVersion());
            if (getMaxVersion() != null) {
                b.append(';');
            }
        }
        if (getMaxVersion() != null) {
            b.append(getMaxVersion());
        }
        return b.toString();
    }",Gets the value of the attribute.
"private static boolean keyIsValid(final BinaryRequest request) {
        if (request.keyBytes() == null || request.keyBytes().length < MIN_KEY_BYTES) {
            request.observable().onError(new IllegalArgumentException(""The Document ID must not be null or empty.""));
            return false;
        }

        if (request.keyBytes().length > MAX_KEY_BYTES) {
            request.observable().onError(new IllegalArgumentException(
                ""The Document ID must not be longer than 250 bytes.""));
            return false;
        }

        return true;
    }",Check if the key is valid.
"public void setRfpType(com.google.api.ads.admanager.axis.v201811.RfpType rfpType) {
        this.rfpType = rfpType;
    }",Sets the rfpType value for this BaseRfp.
"private static void allocateNodeLengthsWithRelocation(final int[] array,
                                                           final int nodesToMove, final int insertDepth) {
        int firstNode = array.length - 2;
        int nextNode = array.length - 1;
        int currentDepth = insertDepth == 1 ? 2 : 1;
        int nodesLeftToMove = insertDepth == 1 ? nodesToMove - 2 : nodesToMove;

        for (int availableNodes = currentDepth << 1; availableNodes > 0; currentDepth++) {
            final int lastNode = firstNode;
            firstNode = firstNode <= nodesToMove ? firstNode : first(array, lastNode - 1, nodesToMove);

            int offset = 0;
            if (currentDepth >= insertDepth) {
                offset = Math.min(nodesLeftToMove, 1 << (currentDepth - insertDepth));
            } else if (currentDepth == insertDepth - 1) {
                offset = 1;
                if (array[firstNode] == lastNode) {
                    firstNode++;
                }
            }

            for (int i = availableNodes - (lastNode - firstNode + offset); i > 0; i--) {
                array[nextNode--] = currentDepth;
            }

            nodesLeftToMove -= offset;
            availableNodes = (lastNode - firstNode + offset) << 1;
        }
    }",Allocate node lengths with relocation.
"public Map<String, List<String>> listCommands() {
        Map<String, List<String>> result = new HashMap<String, List<String>>();
        for (String cat : restMetadataJson.keySet())  {
            JsonObject commands = restMetadataJson.getJsonObject(cat);
            List<String> names = new ArrayList<String>();
            for (String commandName: commands.keySet()) {
                names.add(commandName);
            }       
            result.put(cat, names);
        }
        return result;
    }",List all the commands in the resource.
"@Override
	public void open(Configuration config) throws IOException {
		streamer.open();
		streamer.sendBroadCastVariables(config);
	}",Open the connection to the server.
"public List<JAXBElement<Object>> get_GenericApplicationPropertyOfSquare() {
        if (_GenericApplicationPropertyOfSquare == null) {
            _GenericApplicationPropertyOfSquare = new ArrayList<JAXBElement<Object>>();
        }
        return this._GenericApplicationPropertyOfSquare;
    }",Gets the value of the genericApplicationPropertyOfSquare property.
"public static Object columnlist(PageContext pc, Object obj) throws PageException {
	if (obj instanceof Query) {
	    Key[] columnNames = ((Query) obj).getColumnNames();

	    boolean upperCase = pc.getCurrentTemplateDialect() == CFMLEngine.DIALECT_CFML;

	    StringBuilder sb = new StringBuilder();
	    for (int i = 0; i < columnNames.length; i++) {
		if (i > 0) sb.append(',');
		sb.append(upperCase ? columnNames[i].getUpperString() : columnNames[i].getString());
	    }
	    return sb.toString();

	}
	return pc.getCollection(obj, KeyConstants._COLUMNLIST);
    }",returns a column list of the specified object
"public static void exportevaluationCalibrationToHtmlFile(EvaluationCalibration ec, File file) throws IOException {
        String asHtml = evaluationCalibrationToHtml(ec);
        FileUtils.writeStringToFile(file, asHtml);
    }",Export evaluation calibration to HTML file.
"public static DrawBlock getDrawBlockFromBlockState(IBlockState state, List<IProperty> extraProperties)
    {
        if (state == null)
            return null;

        DrawBlock block = new DrawBlock();
        Object blockName = Block.REGISTRY.getNameForObject(state.getBlock());
        if (blockName instanceof ResourceLocation)
        {
            String name = ((ResourceLocation)blockName).getResourcePath();
            BlockType type = BlockType.fromValue(name);
            block.setType(type);
        }

        Colour col = null;
        Variation var = null;
        Facing face = null;

        // Add properties:
        for (IProperty prop : state.getProperties().keySet())
        {
            String propVal = state.getValue(prop).toString();
            boolean matched = false;
            // Try colour first:
            if (col == null)
            {
                col = attemptToGetAsColour(propVal);
                if (col != null)
                    matched = true;
            }
            // Then variant:
            if (!matched && var == null)
            {
                var = attemptToGetAsVariant(propVal);
                if (var != null)
                    matched = true;
            }
            // Then facing:
            if (!matched && face == null)
            {
                face = attemptToGetAsFacing(propVal);
                if (face != null)
                    matched = true;
            }
            if (!matched)
            {
                if (extraProperties != null)
                    extraProperties.add(prop);
            }
        }
        if (col != null)
            block.setColour(col);
        if (var != null)
            block.setVariant(var);
        if (face != null)
            block.setFace(face);
        return block;
    }",Get a DrawBlock object from a block state.
"protected SemanticSpace getSpace() {
        Transform transform = null;
        if (argOptions.hasOption('T'))
            transform = ReflectionUtil.getObjectInstance(
                    argOptions.getStringOption('T'));
        else
            transform = new NoTransform();
        int bound = argOptions.getIntOption('b', 10000);
        int windowSize = argOptions.getIntOption('w', 5);
        return new OccurrenceCounter(transform, bound, windowSize);
    }",Get the SemanticSpace object.
"public void setLastPoint(Point3d point) {
		if (this.numCoordsProperty.get()>=3) {
			this.coordsProperty[this.numCoordsProperty.get()-3] = point.xProperty;
			this.coordsProperty[this.numCoordsProperty.get()-2] = point.yProperty;
			this.coordsProperty[this.numCoordsProperty.get()-1] = point.zProperty;
			this.graphicalBounds = null;
			this.logicalBounds = null;
		}
	}",Sets the last point of this shape.
"private void addListToTerm(List<NewWord> newWords) {
		if (newWords.size() == 0) {
			return;
		}
		for (NewWord newWord : newWords) {

			TermNatures termNatures = new NatureRecognition(forests).getTermNatures(newWord.getName());

			if (termNatures == TermNatures.NULL) {
				addTerm(newWord);
			}
		}
	}",Adds the list of words to the term.
"private JsonToken scanUnquotedString(final char firstChar) {
        StringBuilder sb = new StringBuilder();
        sb.append(firstChar);
        int c = buffer.read();
        while (c == '$' || c == '_' || Character.isLetterOrDigit(c)) {
            sb.append((char) c);
            c = buffer.read();
        }
        buffer.unread(c);
        String lexeme = sb.toString();
        return new JsonToken(JsonTokenType.UNQUOTED_STRING, lexeme);
    }",Scan an unquoted string.
"public Object getInfoFromHandle(Object bookmark, boolean bGetTable, int iHandleType) throws DBException
    {
        if (iHandleType == DBConstants.OBJECT_ID_HANDLE)
        {
            if (!(bookmark instanceof String))
                return null;
            int iLastColon = ((String)bookmark).lastIndexOf(BaseTable.HANDLE_SEPARATOR);
            if (iLastColon == -1)
                return null;
            if (bGetTable)
                return ((String)bookmark).substring(0, iLastColon);
            else
                return ((String)bookmark).substring(iLastColon+1);
        }
        return bookmark;
    }",Get the bookmark from the bookmark.
"public static void writePng(Image image, OutputStream out) throws IORuntimeException {
		write(image, IMAGE_TYPE_PNG, out);
	}",Write a PNG image to an OutputStream.
"public static int select(long w, int j) {
    int part1 = (int) (w & 0xFFFFFFFF);
    int wfirsthalf = Integer.bitCount(part1);
    if (wfirsthalf > j) {
      return select(part1, j);
    } else {
      return select((int) (w >>> 32), j - wfirsthalf) + 32;
    }
  }",Select the first j bits of a long.
"public static boolean hasRoles(List<String> roleNames) throws Throwable
    {
        DEADBOLT_HANDLER.beforeRoleCheck();

        RoleHolder roleHolder = getRoleHolder();

        return roleHolder != null &&
               roleHolder.getRoles() != null &&
               hasAllRoles(roleHolder,
                           roleNames.toArray(new String[roleNames.size()]));
    }",Check if a set of roles exists in the current application.
"public void drawCornerShadow(
            Canvas canvas,
            Matrix matrix,
            RectF bounds,
            int elevation,
            float startAngle,
            float sweepAngle) {

        Path arcBounds = scratch;

        // Calculate the arc bounds to prevent drawing shadow in the same part of the arc.
        arcBounds.rewind();
        arcBounds.moveTo(bounds.centerX(), bounds.centerY());
        arcBounds.arcTo(bounds, startAngle, sweepAngle);
        arcBounds.close();

        bounds.inset(-elevation, -elevation);
        cornerColors[0] = 0;
        cornerColors[1] = shadowStartColor;
        cornerColors[2] = shadowMiddleColor;
        cornerColors[3] = shadowEndColor;

        float startRatio = 1f - (elevation / (bounds.width() / 2f));
        float midRatio = startRatio + ((1f - startRatio) / 2f);
        cornerPositions[1] = startRatio;
        cornerPositions[2] = midRatio;

        cornerShadowPaint.setShader(
                new RadialGradient(
                        bounds.centerX(),
                        bounds.centerY(),
                        bounds.width() / 2,
                        cornerColors,
                        cornerPositions,
                        Shader.TileMode.CLAMP));

        // TODO: handle oval bounds by scaling the canvas.

        canvas.save();
        canvas.concat(matrix);
        cornerShadowPaint.setStyle(Paint.Style.STROKE);
        cornerShadowPaint.setStrokeWidth(elevation * 2);
        canvas.drawArc(bounds, startAngle, sweepAngle, false, cornerShadowPaint);
        canvas.restore();
    }",Draw a corner shadow.
"@Override
	public StatementInfo[] getInfos(String CorpNum, int ItemCode,
			String[] MgtKeyList) throws PopbillException {
		if (MgtKeyList == null)
			throw new PopbillException(-99999999, ""관리번호 배열이 입력되지 않았습니다."");
		
		String PostData = toJsonString(MgtKeyList);
		
		return httppost(""/Statement/"" + ItemCode, CorpNum, 
					PostData, null, StatementInfo[].class);
	}",Get the Statement infos for the given item code
"synchronized void close()
   {
      releaseWriterAndReaders();
      if (directory != null)
      {
         try
         {
            directory.close();
         }
         catch (IOException e)
         {
            directory = null;
         }
      }
   }",Close the file system.
"public static boolean isColumnNullable (Connection conn, String table,
                                            String column)
        throws SQLException
    {
        ResultSet rs = getColumnMetaData(conn, table, column);
        try {
            return rs.getString(""IS_NULLABLE"").equals(""YES"");
        } finally {
            rs.close();
        }
    }",Get the column nullable.
"@Override
	public void cacheResult(
		CommerceUserSegmentCriterion commerceUserSegmentCriterion) {
		entityCache.putResult(CommerceUserSegmentCriterionModelImpl.ENTITY_CACHE_ENABLED,
			CommerceUserSegmentCriterionImpl.class,
			commerceUserSegmentCriterion.getPrimaryKey(),
			commerceUserSegmentCriterion);

		commerceUserSegmentCriterion.resetOriginalValues();
	}",Caches the commerce user segment criterion in the entity cache if it is enabled.
"protected void prepareDataForNextChannel() {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {
            Tr.entry(tc, ""prepareDataForNextChannel"");
        }

        // Ensure the output buffers are already set in place for the calling channel.
        if (getJITAllocateAction()) {
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""Allocation was done here, adjust and hand off buffers, JIT=""
                             + getJITAllocateSize());
            }

            // Multiple cases to handle here. Remember, we allocated these buffers.
            // 1 - decNetBuffers has only 1 buffer and it is <= the JIT size
            // We can just send it up to the caller.
            // 2 - decNetBuffers has only 1 buffer, but it is > the JIT size
            // We need to copy it to a JIT sized buffer and save the rest of a future read.
            // 3 - decNetBuffers has multiple buffers, the first of which has the matching JIT size.
            // We should pass the first buffer back to the caller and save the rest of a future read.
            // 4 - decNetBuffers has multiple buffers, the first of which does not match the JIT size.
            // We have to check ensure the JIT size is honored. May have to do a buffer copy.
            int decryptedDataSize = SSLUtils.lengthOf(decryptedNetBuffers, 0);
            if (decryptedNetBuffers.length == 1) {
                if (decryptedDataSize <= getJITAllocateSize()) {

                    // Case 1:
                    // There is only one decryptedNetBuffer and the size is less than the JIT.
                    // Therefore, we can return this buffer to the caller.
                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                        Tr.debug(tc, ""single decNetBuffer is okay to pass to caller"");
                    }
                    // Data is currently between pos and lim. Adjust for calling channel.
                    SSLUtils.positionToLimit(decryptedNetBuffers);
                    // Reset the limits saved for the decryptedNetBuffers.
                    SSLUtils.setBufferLimits(decryptedNetBuffers, decryptedNetLimitInfo);
                    // Store the decrypted buffer to this context for reference by the caller.
                    setBuffer(decryptedNetBuffers[0]);

                } else {
                    // Case 2:
                    // There is only one decryptedNetBuffer, but the size is greater than the JIT.
                    // Therefore, we have to copy the buffer into a JIT sized buffer
                    // and save the left overs.
                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                        Tr.debug(tc, ""only one decNetBuffer, but too big (""
                                     + decryptedDataSize + "") for JIT.  Need to copy."");
                    }
                    // Create a new buffer to hand to the caller.
                    // We want to reuse copyDataToCallerBuffers.
                    // It copies from decryptedNetBuffers to getBuffers() which
                    // are currently the same, so change it.
                    setBuffer(SSLUtils.allocateByteBuffer(getJITAllocateSize(), false));
                    getBuffer().limit(getJITAllocateSize());
                    // Copy from the decNetBuffers into the buffers to be sent to the caller.
                    copyDataToCallerBuffers();
                }

            } else {
                // There are > 1 decryptedNetBuffers.
                // Check if the first one matches the JIT size.
                // TODO this is wrong. should be using capacity() instead of
                // remaining I think since after decrypt, remaining is less than
                // buffer cap (decrypt 4 bytes and remaining is 8188 but buffer is
                // the 8192 that JIT size is by default), meaning it's fine
                // not sure about all cases though...
                if (decryptedNetBuffers[0].remaining() == getJITAllocateSize()) {
                    // Case 3:
                    // Found a match. Return the first buffer to the caller and
                    // save the rest for a future read.
                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                        Tr.debug(tc, ""multiple buffers, first of which matches the JIT size"");
                    }
                    // Data is currently between pos and lim. Adjust for calling channel.
                    decryptedNetBuffers[0].position(decryptedNetBuffers[0].limit());
                    // Store the decrypted buffer to this context for reference by the caller.
                    setBuffer(decryptedNetBuffers[0]);
                    // Now save the other buffers in the unconsumedDecData (which is null at this point)
                    if (null != unconsumedDecData) {
                        if (TraceComponent.isAnyTracingEnabled() && tc.isEventEnabled()) {
                            Tr.event(tc, ""Expected null unconsumed array, but isn't: ""
                                         + SSLUtils.getBufferTraceInfo(unconsumedDecData));
                        }
                        // shouldn't release buffers we might not own (especially since
                        // they shouldn't even be here in the first place)
                        // WsByteBufferUtils.releaseBufferArray(unconsumedDecData);
                    }
                    // figure out if any more buffers exist with actual data to save
                    int size = 0;
                    for (int i = 1; i < decryptedNetBuffers.length; i++) {
                        // if there is nothing in this buffer, just release it
                        if (0 == decryptedNetBuffers[i].remaining()) {
                            decryptedNetBuffers[i].release();
                        } else {
                            size++;
                        }
                    }
                    if (0 < size) {
                        unconsumedDecData = new WsByteBuffer[size];
                        for (int i = 1, x = 0; x < size; i++, x++) {
                            unconsumedDecData[x] = decryptedNetBuffers[i];
                        }
                        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                            Tr.debug(tc, ""unconsumedDecData: ""
                                         + SSLUtils.getBufferTraceInfo(unconsumedDecData));
                        }
                    }

                } else {
                    // Case 4:
                    // Multiple buffers, first of which doesn't match the JIT. Need to copy.
                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                        Tr.debug(tc, ""multiple buffers, first does not match the JIT size."");
                    }
                    // Create a new buffer to hand to the caller.
                    // We want to reuse copyDataToCallerBuffers.
                    // It copies from decryptedNetBuffers to getBuffers() which
                    // are currently the same, so change it.
                    setBuffer(SSLUtils.allocateByteBuffer(getJITAllocateSize(), false));
                    getBuffer().limit(getJITAllocateSize());
                    // Adjust the decryptedNetBuffers. Results from the JSSE keep
                    // untouched buffers with their pos = lim. Buffers with data
                    // have nonzero pos and lim. Unused buffers have zero
                    // pos and lim. We need the data to be between pos and lim
                    // for the copy. Zeroing out the pos enables this.
                    for (int i = 0; i < decryptedNetBuffers.length; i++) {
                        decryptedNetBuffers[i].position(0);
                    }
                    // Copy from the decNetBuffers into the buffers to be sent to the caller.
                    copyDataToCallerBuffers();
                }
            }

        } else {
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""Using channel provided buffers"");
            }
            // Calling channel provided buffers to read into.
            if (decryptedNetBufferReleaseRequired) {
                // User provided buffers were not originally adequate. Temporary
                // buffers were allocated to hold the result.
                for (int i = 0; i < this.decryptedNetBuffers.length; i++) {
                    if (null != this.decryptedNetBuffers[i]) {
                        this.decryptedNetBuffers[i].position(0);
                    }
                }
                copyDataToCallerBuffers();
            } else {
                // User provided buffers were adequate
                SSLUtils.positionToLimit(decryptedNetBuffers);
                SSLUtils.setBufferLimits(decryptedNetBuffers, decryptedNetLimitInfo);
            }
        }
        // The decryptedNetBuffers are being given to the next channel.
        // Eliminate tracking of ownership.
        decryptedNetBuffers = null;
        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
            Tr.debug(tc, ""Buffers being sent to next channel: ""
                         + SSLUtils.getBufferTraceInfo(getBuffers()));
        }

        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {
            Tr.exit(tc, ""prepareDataForNextChannel"");
        }
    }",This method is called by the SSL channel to prepare the output buffers for the next channel.
"@Indexable(type = IndexableType.DELETE)
	@Override
	public CommerceNotificationTemplate deleteCommerceNotificationTemplate(
		long commerceNotificationTemplateId) throws PortalException {
		return commerceNotificationTemplatePersistence.remove(commerceNotificationTemplateId);
	}",Deletes the commerce notification template with the primary key from the database. Also notifies the appropriate model listeners.
"public ReportRequest asReportRequest(ReportingRule rules, Clock clock) {
    Preconditions.checkState(!Strings.isNullOrEmpty(getServiceName()),
        ""a service name must be set"");

    // Populate metrics and labels if they can be associated with a method/operation
    Operation.Builder o = asOperation(clock).toBuilder();
    if (!Strings.isNullOrEmpty(o.getOperationId())
        && !Strings.isNullOrEmpty(o.getOperationName())) {
      Map<String, String> addedLabels = Maps.newHashMap();
      for (KnownLabels l : rules.getLabels()) {
        l.performUpdate(this, addedLabels);
      }
      // Forcibly add platform reporting here, as the base service config does not specify it as a
      // label.
      if (!o.getLabelsMap().containsKey(KnownLabels.SCC_PLATFORM.getName())) {
        KnownLabels.SCC_PLATFORM.performUpdate(this, addedLabels);
      }
      o.putAllLabels(getSystemLabels());
      o.putAllLabels(addedLabels);
      KnownMetrics[] metrics = rules.getMetrics();
      for (KnownMetrics m : metrics) {
        m.performUpdate(this, o);
      }
    }

    String[] logs = rules.getLogs();
    long timestampMillis = clock.currentTimeMillis();
    for (String l : logs) {
      o.addLogEntries(asLogEntry(l, timestampMillis));
    }

    return ReportRequest.newBuilder().addOperations(o).setServiceName(getServiceName()).build();
  }",Creates a ReportRequest object from this report rule.
"public PrintWriter getLogWriter() throws SQLException
    {
        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
            Tr.debug(tc, ""getLogWriter : "" + ivPuId + "", "" + ivLogWriter);

        return ivLogWriter;
    }",Get the PrintWriter object that will be used to write the log file to the underlying stream.
"public PhotoList<Photo> getPhotos(String photosetId, int perPage, int page) throws FlickrException {
        return getPhotos(photosetId, Extras.MIN_EXTRAS, Flickr.PRIVACY_LEVEL_NO_FILTER, perPage, page);
    }",Get a list of photos from a photoset.
"public static <T, X extends Throwable> Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(
            final Stream<T> stream, final long x, final Consumer<? super T> consumerElement, final Consumer<? super Throwable> consumerError) {
        return forEachXEvents(stream, x, consumerElement, consumerError, () -> {
        });
    }",For each X event of a Stream with a Consumer element and a Consumer error.
"public static SSTableIndexIndex readIndex(final FileSystem fileSystem, final Path sstablePath) throws IOException {
        final Closer closer = Closer.create();
        final Path indexPath = sstablePath.suffix(SSTABLE_INDEX_SUFFIX);

        // Detonate if we don't have an index.
        final FSDataInputStream inputStream = closer.register(fileSystem.open(indexPath));

        final SSTableIndexIndex indexIndex = new SSTableIndexIndex();
        try {
            while (inputStream.available() != 0) {
                indexIndex.add(inputStream.readLong(), inputStream.readLong());
            }
        } finally {
            closer.close();
        }

        return indexIndex;
    }",Read the index.
"public <T> T unwrap(final Class<T> iface) throws SQLException {
        if (!isWrapperFor(iface)) {
            throw new SQLException();
        } // end of if

        @SuppressWarnings(""unchecked"")
        final T proxy = (T) this;

        return proxy;
    }",Unwraps the underlying object.
"private V binarySearch(final K iKey) {
    int low = 0;
    int high = getSize() - 1;
    int mid = 0;

    while (low <= high) {
      mid = (low + high) >>> 1;
      Object midVal = getKeyAt(mid);

      if (tree.comparator != null)
        tree.pageItemComparator = tree.comparator.compare((K) midVal, iKey);
      else
        tree.pageItemComparator = ((Comparable<? super K>) midVal).compareTo(iKey);

      if (tree.pageItemComparator == 0) {
        // FOUND: SET THE INDEX AND RETURN THE NODE
        tree.pageItemFound = true;
        tree.pageIndex = mid;
        return getValueAt(tree.pageIndex);
      }

      if (low == high)
        break;

      if (tree.pageItemComparator < 0)
        low = mid + 1;
      else
        high = mid;
    }

    tree.pageIndex = mid;
    return null;
  }",Searches for the key in the array and returns the value at the index.
"private static String initCreateEntityQuery(EntityKeyMetadata entityKeyMetadata) {
		StringBuilder queryBuilder = new StringBuilder( ""CREATE "" );
		appendEntityNode( ENTITY_ALIAS, entityKeyMetadata, queryBuilder );
		queryBuilder.append( "" RETURN "" );
		queryBuilder.append( ENTITY_ALIAS );
		return queryBuilder.toString();
	}",Create the create entity query.
"public void loadFolder(String folderPath) {
		// Get the file path.
		File path = null;
		if(folderPath != null && folderPath.length() > 0) {
			path = new File(folderPath);
		}
		
		this.loadFolder(path);
	}",Loads a folder from the file system.
"@Override
	public void addDecorator(String clazzName, IDecorator decorator) {
		registry.put(clazzName, decorator);
	}",Add a decorator to the registry.
"protected boolean setConnector() {
    if (this.host == null) {
      log.error(""No host value set, cannot set up socket connector."");
      return false;
    }
    if (this.port < 0 || this.port > 65535) {
      log.error(""Port value is invalid {}."", Integer.valueOf(this.port));
      return false;
    }
    if (this.executors == null) {
      this.executors = new ExecutorFilter(1);
    }

    this.connector = new NioSocketConnector();
    this.connector.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE,
        ClientWorldModelInterface.TIMEOUT_PERIOD / 2);
//    this.connector.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE,
//        (int) (ClientWorldModelInterface.TIMEOUT_PERIOD * 1.1f));
    if (!this.connector.getFilterChain().contains(
        WorldModelClientProtocolCodecFactory.CODEC_NAME)) {
      this.connector.getFilterChain().addLast(
          WorldModelClientProtocolCodecFactory.CODEC_NAME,
          new ProtocolCodecFilter(
              new WorldModelClientProtocolCodecFactory(true)));
    }
    this.connector.getFilterChain().addLast(""ExecutorPool"", this.executors);
    this.connector.setHandler(this.ioHandler);
    log.debug(""Connector set up successful."");
    return true;
  }",Set the connector.
"public Observable<ServiceResponse<JobExecutionInner>> createWithServiceResponseAsync(String resourceGroupName, String serverName, String jobAgentName, String jobName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");
        }
        if (serverName == null) {
            throw new IllegalArgumentException(""Parameter serverName is required and cannot be null."");
        }
        if (jobAgentName == null) {
            throw new IllegalArgumentException(""Parameter jobAgentName is required and cannot be null."");
        }
        if (jobName == null) {
            throw new IllegalArgumentException(""Parameter jobName is required and cannot be null."");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");
        }
        Observable<Response<ResponseBody>> observable = service.create(resourceGroupName, serverName, jobAgentName, jobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<JobExecutionInner>() { }.getType());
    }",Creates a new job in an App Service Environment.
"public void updateSecurityMetadataWithRunAs(SecurityMetadata securityMetadataFromDD, IServletConfig servletConfig) {
        String runAs = servletConfig.getRunAsRole();
        if (runAs != null) {
            String servletName = servletConfig.getServletName();
            //only add if there is no run-as entry in web.xml
            Map<String, String> servletNameToRunAsRole = securityMetadataFromDD.getRunAsMap();
            if (servletNameToRunAsRole.get(servletName) == null) {
                servletNameToRunAsRole.put(servletName, runAs);
                List<String> allRoles = securityMetadataFromDD.getRoles();
                if (!allRoles.contains(runAs)) {
                    allRoles.add(runAs);
                }
                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                    Tr.debug(tc, ""Added runAs role: "" + runAs);
                }
            }
        }
    }",Update the security metadata with the run - as entry in web. xml.
"static <K, V> WellBehavedMap<K, V> wrap(Map<K, V> delegate) {
    return new WellBehavedMap<K, V>(delegate);
  }",Wrap a map in a WellBehavedMap.
"public void writeToFile(File file, String fileContent) {
        if (!file.exists()) {
            try {
                FileWriter writer = new FileWriter(file);
                writer.write(fileContent);
                writer.close();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {

            }
        }
    }",Write to file.
"@Override
    public void visit(NodeVisitor v) {
        if (v.visit(this)) {
            for (AstNode var : variables) {
                var.visit(v);
            }
        }
    }",Visit this node then all the variables.
"public static void extractZip(final String path, final File dest, final String prefix, final String stripPrefix,
                                  final streamCopier copier) throws IOException {
        extractZip(path, dest, prefix, new PrefixStripper(stripPrefix), copier);
    }",Extract a zip file to a destination file using the CID license.
"public Object allocateConnection(ManagedConnectionFactory mcf, ConnectionRequestInfo cri) throws ResourceException
   {
      if (shutdown.get())
         throw new ResourceException();
      Credential credential;
      if (subjectFactory == null || cmConfiguration.getSecurityDomain() == null)
      {
         credential = new Credential(null, cri);
      }
      else
      {
         credential = new Credential(SecurityActions.createSubject(subjectFactory,
                                                                   cmConfiguration.getSecurityDomain(),
                                                                   mcf),
                                     cri);
      }
      org.ironjacamar.core.connectionmanager.listener.ConnectionListener cl = getConnectionListener(credential);
      Object connection = cl.getConnection();

      if (ccm != null)
         ccm.registerConnection(this, cl, connection);

      return connection;
   }",Allocate a connection.
"public I_CmsExtractionResult extractContent(CmsObject cms, CmsResource resource, I_CmsSearchIndex index)
    throws CmsIndexException, CmsException {

        logContentExtraction(resource, index);
        CmsFile file = readFile(cms, resource);
        try {
            return CmsExtractorPdf.getExtractor().extractText(file.getContents());
        } catch (Exception e) {
            if (e.getClass().getSimpleName().equals(""EncryptedDocumentException"")) {
                throw new CmsIndexException(
                    Messages.get().container(Messages.ERR_DECRYPTING_RESOURCE_1, resource.getRootPath()),
                    e);
            }
            if (e instanceof InvalidPasswordException) {
                // default password """" was wrong.
                throw new CmsIndexException(
                    Messages.get().container(Messages.ERR_PWD_PROTECTED_1, resource.getRootPath()),
                    e);
            }
            throw new CmsIndexException(
                Messages.get().container(Messages.ERR_TEXT_EXTRACTION_1, resource.getRootPath()),
                e);
        }
    }",Extract content from a resource.
"public static boolean delete(File file) {
        if (!file.exists())
            return false;
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; files != null && i < files.length; i++)
                delete(files[i]);
        }
        return file.delete();
    }

    /**
     * Closes an arbitrary closable, and logs exceptions at ignore level
     *
     * @param closeable the closeable to close
     */
    public static void close(Closeable closeable) {
        try {
            if (closeable != null)
                closeable.close();
        } catch (IOException ignore) {
        }
    }

    /**
     * closes an input stream, and logs exceptions
     *
     * @param is the input stream to close
     */
    public static void close(InputStream is) {
        close((Closeable) is);
    }

    /**
     * closes an output stream, and logs exceptions
     *
     * @param os the output stream to close
     */
    public static void close(OutputStream os) {
        close((Closeable) os);
    }

    /**
     * closes a reader, and logs exceptions
     *
     * @param reader the reader to close
     */
    public static void close(Reader reader) {
        close((Closeable) reader);
    }

    /**
     * closes a writer, and logs exceptions
     *
     * @param writer the writer to close
     */
    public static void close(Writer writer) {
        close((Closeable) writer);
    }

    public static byte[] readBytes(InputStream in) throws IOException {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        copy(in, bout);
        return bout.toByteArray();
    }

    /**
     * A gathering write utility wrapper.
     * <p>
     * This method wraps a gather write with a loop that handles the limitations
     * of some operating systems that have a limit on the number of buffers
     * written. The method loops on the write until either all the content is
     * written or no progress is made.
     *
     * @param out     The GatheringByteChannel to write to
     * @param buffers The buffers to write
     * @param offset  The offset into the buffers array
     * @param length  The length in buffers to write
     * @return The total bytes written
     * @throws IOException if unable write to the GatheringByteChannel
     */
    public static long write(GatheringByteChannel out, ByteBuffer[] buffers, int offset, int length)
            throws IOException {
        long total = 0;
        write:
        while (length > 0) {
            // Write as much as we can
            long wrote = out.write(buffers, offset, length);

            // If we can't write any more, give up
            if (wrote == 0)
                break;

            // count the total
            total += wrote;

            // Look for unwritten content
            for (int i = offset; i < buffers.length; i++) {
                if (buffers[i].hasRemaining()) {
                    // loop with new offset and length;
                    length = length - (i - offset);
                    offset = i;
                    continue write;
                }
            }
            length = 0;
        }

        return total;
    }

    /**
     * @return An outputstream to nowhere
     */
    public static OutputStream getNullStream() {
        return __nullStream;
    }

    /**
     * @return An outputstream to nowhere
     */
    public static InputStream getClosedStream() {
        return __closedStream;
    }

    private static class NullOS extends OutputStream {
        @Override
        public void close() {
        }

        @Override
        public void flush() {
        }

        @Override
        public void write(byte[] b) {
        }

        @Override
        public void write(byte[] b, int i, int l) {
        }

        @Override
        public void write(int b) {
        }
    }

    private static NullOS __nullStream = new NullOS();

    private static class ClosedIS extends InputStream {
        @Override
        public int read() throws IOException {
            return -1;
        }
    }

    private static ClosedIS __closedStream = new ClosedIS();

    /**
     * @return An writer to nowhere
     */
    public static Writer getNullWriter() {
        return __nullWriter;
    }

    /**
     * @return An writer to nowhere
     */
    public static PrintWriter getNullPrintWriter() {
        return __nullPrintWriter;
    }

    private static class NullWrite extends Writer {
        @Override
        public void close() {
        }

        @Override
        public void flush() {
        }

        @Override
        public void write(char[] b) {
        }

        @Override
        public void write(char[] b, int o, int l) {
        }

        @Override
        public void write(int b) {
        }

        @Override
        public void write(String s) {
        }

        @Override
        public void write(String s, int o, int l) {
        }
    }

    private static NullWrite __nullWriter = new NullWrite();
    private static PrintWriter __nullPrintWriter = new PrintWriter(__nullWriter);

}",Delete a single file from the cache.
"public static <T1, T2> BiFunction<T1, T2, Void> function(BiConsumer<T1, T2> adaptee) {
        dbc.precondition(adaptee != null, ""cannot adapt a null consumer"");
        return (first, second) -> {
            adaptee.accept(first, second);
            return null;
        };
    }",Adapts a binary consumer to a binary function.
"URI generateOutputFile(final URI ref) {
        final FileInfo srcFi = job.getFileInfo(ref);
        final URI newSrc = srcFi.src.resolve(generateFilename());
        final URI tmp = tempFileNameScheme.generateTempFileName(newSrc);

        if (job.getFileInfo(tmp) == null) {
            job.add(new FileInfo.Builder()
                    .result(newSrc)
                    .uri(tmp)
                    .build());
        }

        return job.tempDirURI.resolve(tmp);
    }",Generate output file.
"@Override
	public void stopped() {

		// Stop timer
		ScheduledFuture<?> task = callTimeoutTimer.get();
		if (task != null) {
			task.cancel(false);
		}

		// Stop pending invocations
		Iterator<PendingPromise> pendingPromises = promises.values().iterator();
		while (pendingPromises.hasNext()) {
			PendingPromise pending = pendingPromises.next();
			pendingPromises.remove();
			try {
				pending.promise.complete(new RequestRejectedError(nodeID, pending.action));
			} catch (Throwable cause) {
				logger.warn(""Unable to reject action \"""" + pending.action + ""\""!"", cause);
			}
		}

		// Stop middlewares
		for (Middleware middleware : middlewares) {
			try {
				middleware.stopped();
			} catch (Throwable cause) {
				logger.warn(""Unable to stop middleware \"""" + middleware.name + ""\""!"", cause);
			}
		}

		// Stop registered services
		stopAllLocalServices();

		// Clear registries
		final long stamp = lock.writeLock();
		try {

			// Delete strategies (and registered actions)
			strategies.clear();

			// Delete all service names
			names.clear();

			// Delete middlewares
			middlewares.clear();

			// Delete cached node descriptor
			clearDescriptorCache();

		} finally {
			lock.unlockWrite(stamp);
		}
	}",Stop all the services and invocations.
"public BufferedImage copyImage(BufferedImage image) {
        BufferedImage newImage = new BufferedImage(image.getWidth(), image.getHeight(), image.getType());
        Graphics2D g2d = newImage.createGraphics();
        g2d.drawImage(image, 0, 0, null);
        g2d.dispose();
        return newImage;
    }",Copy the image to a new BufferedImage.
"public DepictionGenerator withMappedRxnAlign(boolean val) {
        DepictionGenerator copy = new DepictionGenerator(this);
        copy.alignMappedReactions = val;
        return copy;
    }",This method is used to set the mapped RxnAlign flag.
"public static Consul consul(final String host, final int port) {
        try {
            return new Consul(new URL(""http"", host, port, """").toString());
        } catch (MalformedURLException e) {
            throw new ConsulException(""Bad Consul URL"", e);
        }
    }",Create a Consul instance with the given host and port.
"public void setLocaterInfo(SourceLocator locator)
  {

    if (null != locator)
    {
      m_publicId = locator.getPublicId();
      m_systemId = locator.getSystemId();

      if (null != m_systemId)
      {
        try
        {
          m_href = SystemIDResolver.getAbsoluteURI(m_systemId, null);
        }
        catch (TransformerException se)
        {

          // Ignore this for right now
        }
      }

      super.setLocaterInfo(locator);
    }
  }",Set the LocaterInfo field of the SourceLocator object.
"public void setParameter(final String key, final String value) {
		parameters.put(key, new String[]{value});
	}",Sets a parameter to the connection.
"public T find(Object val, CacheLoader<T> loader) {
        if( order.size() != 1 ) {
            throw new CacheManagementException(""You may only call this method when the cache is managing one unique identifier."");
        }
        return find(order.get(0), val, loader);
    }",Find the object in the cache.
"public SoyMsgBundle createFromResource(URL inputResource) throws IOException {

    try {
      String inputFileContent = Resources.asCharSource(inputResource, UTF_8).read();
      return msgPlugin.parseTranslatedMsgsFile(inputFileContent);

    } catch (SoyMsgException sme) {
      sme.setFileOrResourceName(inputResource.toString());
      throw sme;
    }
  }",Creates a SoyMsgBundle from a file or resource name.
"public static void buildFieldProperties(final Class<?> aClass, final DescriptionBuilder builder) {
        for (final Field field : collectClassFields(aClass)) {
            final PluginProperty annotation = field.getAnnotation(PluginProperty.class);
            if (null == annotation) {
                continue;
            }
            final Property pbuild = propertyFromField(field, annotation);
            if (null == pbuild) {
                continue;
            }
            builder.property(pbuild);
        }
    }",Build field properties from the class.
"public void debug(Object message, Throwable t) {
        differentiatedLog(null, CATEGORY_FQCN, LocationAwareLogger.DEBUG_INT, message, t);
    }",Issue a log message and throwable with a level of DEBUG.
"public org.grails.datastore.mapping.query.api.ProjectionList sum(String propertyName, String alias) {
        final AggregateProjection proj = Projections.sum(calculatePropertyName(propertyName));
        addProjectionToList(proj, alias);
        return this;
    }",Adds a projection to the result set.
"static SmileGenerator newSmileGenerator(OutputStream out, byte[] buf, int offset,
            boolean bufferRecyclable, IOContext context)
    {
        return new SmileGenerator(context,
                DEFAULT_SMILE_FACTORY.getGeneratorFeatures(),
                DEFAULT_SMILE_FACTORY.getSmileGeneratorFeatures(),
                DEFAULT_SMILE_FACTORY.getCodec(),
                out,
                buf,
                offset,
                bufferRecyclable);
    }",Creates a new instance of the smile generator class.
"@SuppressWarnings(""WeakerAccess"")
  public ApiFuture<List<Cluster>> listClustersAsync(String instanceId) {
    String name = NameUtil.formatInstanceName(projectId, instanceId);
    com.google.bigtable.admin.v2.ListClustersRequest request =
        com.google.bigtable.admin.v2.ListClustersRequest.newBuilder().setParent(name).build();

    return ApiFutures.transform(
        stub.listClustersCallable().futureCall(request),
        new ApiFunction<com.google.bigtable.admin.v2.ListClustersResponse, List<Cluster>>() {
          @Override
          public List<Cluster> apply(com.google.bigtable.admin.v2.ListClustersResponse proto) {
            // NOTE: serverside pagination is not and will not be implemented, so remaining pages
            // are not fetched. However, if that assumption turns out to be wrong, fail fast to
            // avoid returning partial data.
            Verify.verify(
                proto.getNextPageToken().isEmpty(),
                ""Server returned an unexpected paginated response"");

            ImmutableList.Builder<Cluster> clusters = ImmutableList.builder();
            for (com.google.bigtable.admin.v2.Cluster cluster : proto.getClustersList()) {
              clusters.add(Cluster.fromProto(cluster));
            }

            ImmutableList.Builder<String> failedZones = ImmutableList.builder();
            for (String locationStr : proto.getFailedLocationsList()) {
              failedZones.add(NameUtil.extractZoneIdFromLocationName(locationStr));
            }

            if (!failedZones.build().isEmpty()) {
              throw new PartialListClustersException(failedZones.build(), clusters.build());
            }

            return clusters.build();
          }
        },
        MoreExecutors.directExecutor());
  }",Asynchronously lists all clusters in the specified instance.
"private void checkForEmptyIdentifier() {
    Character la = chars.lookahead(1);
    if (CharType.DOT.isMatchedBy(la) || CharType.PLUS.isMatchedBy(la)
        || CharType.EOL.isMatchedBy(la)) {
      throw new ParseException(""Identifiers MUST NOT be empty"", new UnexpectedCharacterException(la,
          chars.currentOffset(), CharType.DIGIT, CharType.LETTER, CharType.HYPHEN));
    }
  }",Check for empty identifier.
"static synchronized CatLog getDefaultCatLog() {
        if (!PACKAGE_CAT_LOG_KEYS.isEmpty()) {
            String callingPackage = CatUtil.getCallingPackage();
            for (int i = PACKAGE_CAT_LOG_KEYS.size() - 1; i >= 0; i--) {
                String catLogPackage = PACKAGE_CAT_LOG_KEYS.get(i);
                if (callingPackage.startsWith(catLogPackage)) {
                    return PACKAGE_CAT_LOGS.get(catLogPackage);
                }
            }
        }

        return defaultCatLog;
    }",Get the default CatLog
"private void cacheStream() {
        try {
            File fi = getTemproralCacheFile();
            if (fi.exists()) {
                if (!fi.delete()) {
                    throw new IllegalStateException(""Cannot delete file "" + fi.getAbsolutePath() + ""!"");
                }
            }
            FileOutputStream fout = new FileOutputStream(fi);
            InputStream in = grabStream();
            byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
            int n;
            while (-1 != (n = in.read(buffer))) {
                fout.write(buffer, 0, n);
            }
            fout.flush();
            fout.close();
            in.close();
            
            File cacheFile = getCacheFile();
            if (!fi.renameTo(cacheFile)) {
                throw new IllegalStateException(""Cannot rename file \"""" + fi.getAbsolutePath() + ""\"" to \"""" + cacheFile.getAbsolutePath() + ""\""!"");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }",Cache the result of a single record in a stream.
"public void initializePackageContents()
  {
    if (isInitialized) return;
    isInitialized = true;

    // Initialize package
    setName(eNAME);
    setNsPrefix(eNS_PREFIX);
    setNsURI(eNS_URI);

    // Obtain other dependent packages
    XtypePackage theXtypePackage = (XtypePackage)EPackage.Registry.INSTANCE.getEPackage(XtypePackage.eNS_URI);
    XbasePackage theXbasePackage = (XbasePackage)EPackage.Registry.INSTANCE.getEPackage(XbasePackage.eNS_URI);

    // Create type parameters

    // Set bounds for type parameters

    // Add supertypes to classes

    // Initialize classes and features; add operations and parameters
    initEClass(modelEClass, Model.class, ""Model"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEReference(getModel_ImportSection(), theXtypePackage.getXImportSection(), null, ""importSection"", null, 0, 1, Model.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getModel_Block(), theXbasePackage.getXBlockExpression(), null, ""block"", null, 0, 1, Model.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    // Create resource
    createResource(eNS_URI);
  }",Initialize the package contents.
"public synchronized static boolean areConnectedUpstream(PfafstetterNumber p1,
                                                            PfafstetterNumber p2) {

        List<Integer> p1OrdersList = p1.getOrdersList();
        List<Integer> p2OrdersList = p2.getOrdersList();

        int levelDiff = p1OrdersList.size() - p2OrdersList.size();
        if (levelDiff == 0) {
            if (p1.toStringUpToLastLevel().equals(p2.toStringUpToLastLevel())) {
                int p1Last = p1OrdersList.get(p1OrdersList.size() - 1);
                int p2Last = p2OrdersList.get(p2OrdersList.size() - 1);
                if (p2Last == p1Last + 1 || p2Last == p1Last + 2) {
                    return p1Last % 2 != 0;
                }
            }
        } else if (levelDiff == -1) {
            if (p2.toString().startsWith(p1.toStringUpToLastLevel())) {
                int p2Last = p2OrdersList.get(p2OrdersList.size() - 1);
                if (p2Last != 1) {
                    return false;
                }
                int p1Last = p1OrdersList.get(p1OrdersList.size() - 1);
                int p2LastMinus1 = p2OrdersList.get(p2OrdersList.size() - 2);
                if (p2LastMinus1 == p1Last + 1 || p2Last == p1Last + 2) {
                    return p1Last % 2 != 0;
                }
            }
        }
        return false;
    }",Is the two PfafstetterNumber objects connected upstream?
"@Nullable
  @ReturnsMutableCopy
  public static ICommonsList <String> readStreamLines (@Nullable final IHasInputStream aISP,
                                                       @Nonnull final Charset aCharset,
                                                       @Nonnegative final int nLinesToSkip,
                                                       @CheckForSigned final int nLinesToRead)
  {
    if (aISP == null)
      return null;

    return readStreamLines (aISP.getInputStream (), aCharset, nLinesToSkip, nLinesToRead);
  }",Read the lines from the passed input stream.
"private Collection<org.ironjacamar.core.api.deploymentrepository.ConfigProperty>
      injectConfigProperties(Object o,
                             Collection<org.ironjacamar.common.api.metadata.spec.ConfigProperty> configProperties,
                             Map<String, String> overrides,
                             ClassLoader classLoader)
      throws Throwable
   {
      Collection<org.ironjacamar.core.api.deploymentrepository.ConfigProperty> dcps = null;
      if (configProperties != null && !configProperties.isEmpty())
      {
         Injection injector = new Injection();

         dcps = new ArrayList<org.ironjacamar.core.api.deploymentrepository.ConfigProperty>(configProperties.size());
         for (org.ironjacamar.common.api.metadata.spec.ConfigProperty cp : configProperties)
         {
            String name = cp.getConfigPropertyName().getValue();
            Class<?> type = Class.forName(cp.getConfigPropertyType().getValue(), true, classLoader);
            boolean readOnly = cp.getConfigPropertySupportsDynamicUpdates() != null ?
               cp.getConfigPropertySupportsDynamicUpdates().booleanValue() : true;
            boolean confidential = cp.getConfigPropertyConfidential() != null ?
               cp.getConfigPropertyConfidential().booleanValue() : false;
            boolean declared = true;

            Object value = cp.isValueSet() ? cp.getConfigPropertyValue().getValue() : null;
            if (overrides != null)
            {
               if (overrides.containsKey(cp.getConfigPropertyName().getValue()))
               {
                  value = overrides.get(cp.getConfigPropertyName().getValue());
               }
               else
               {
                  String alternative = cp.getConfigPropertyName().getValue().substring(0, 1).toUpperCase();
                  if (cp.getConfigPropertyName().getValue().length() > 1)
                     alternative += cp.getConfigPropertyName().getValue().substring(1);

                  if (overrides.containsKey(alternative))
                  {
                     value = overrides.get(alternative);
                  }
                  else
                  {
                     log.tracef(""%s: Override for %s not found"", o.getClass().getName(),
                                cp.getConfigPropertyName().getValue());
                  }
               }
            }

            if (value != null)
            {
               try
               {
                  injector.inject(o,
                                  cp.getConfigPropertyName().getValue(),
                                  value,
                                  cp.getConfigPropertyType().getValue());
               }
               catch (Throwable t)
               {
                  type = convertType(type);
                     
                  if (type != null)
                  {
                     injector.inject(o,
                                     cp.getConfigPropertyName().getValue(),
                                     value,
                                     type.getName());
                  }
                  else
                  {
                     throw new DeployException(bundle.unableToInject(o.getClass().getName(),
                           cp.getConfigPropertyName().getValue(),
                           value.toString()), t);
                  }
               }
            }

            dcps.add(new ConfigPropertyImpl(o, name, type,
                                            value, readOnly, confidential,
                                            declared));
         }
      }
      return dcps;
   }",Inject config properties into a single object.
"protected void writeVersion(WritableByteChannel channel) throws IOException {
        ByteBuffer version = ByteBuffer.allocate(STORAGE_VERSION_LENGTH);
        version.putInt(STORAGE_VERSION);
        version.flip();
        channel.write(version);
    }",Write the version of the class to the given channel.
"public static int nvgraphAllocateEdgeData(
        nvgraphHandle handle, 
        nvgraphGraphDescr descrG, 
        long numsets, 
        Pointer settypes)
    {
        return checkResult(nvgraphAllocateEdgeDataNative(handle, descrG, numsets, settypes));
    }",Allocate edge data for a graph.
"private static boolean criteriaListForcesUserLimitation(Set<String> userAndGroupIds, List<QueryCriteria> criteriaList) {
        boolean userLimitiationIntersection = false;

        if( criteriaList.isEmpty() ) {
            return false;
        }
        for( QueryCriteria criteria : criteriaList ) {
          if( criteria.isUnion() && criteriaList.size() > 1) {
              return false;
          }
          if( criteria.isGroupCriteria() ) {
              if( criteriaListForcesUserLimitation(userAndGroupIds, criteria.getCriteria()) ) {
                  return true;
              }
              continue;
          }
          // intersection criteria
          if( taskUserRoleLimitingListIds.contains(criteria.getListId()) ) {
              for( Object param : criteria.getParameters() ) {
                  if( userAndGroupIds.contains(param) )  {
                      return true;
                  }
              }
          }
        }
        return userLimitiationIntersection;
    }",Checks if the criteria list forces user limiting.
"String toTag(Archive source, String name, Archive target) {
        if (source == target || !target.getModule().isNamed()) {
            return target.getName();
        }

        Module module = target.getModule();
        String pn = name;
        if ((type == CLASS || type == VERBOSE)) {
            int i = name.lastIndexOf('.');
            pn = i > 0 ? name.substring(0, i) : """";
        }

        // exported API
        if (module.isExported(pn) && !module.isJDKUnsupported()) {
            return showProfileOrModule(module);
        }

        // JDK internal API
        if (!source.getModule().isJDK() && module.isJDK()){
            return ""JDK internal API ("" + module.name() + "")"";
        }

        // qualified exports or inaccessible
        boolean isExported = module.isExported(pn, source.getModule().name());
        return module.name() + (isExported ?  "" (qualified)"" : "" (internal)"");
    }",Returns a tag for the specified archive.
"public String newIndex(final String name,
                         final String mappingPath) throws IndexException {
    try {
      final String newName = name + newIndexSuffix();

      final IndicesAdminClient idx = getAdminIdx();

      final CreateIndexRequestBuilder cirb = idx.prepareCreate(newName);

      final File f = new File(mappingPath);

      final byte[] sbBytes = Streams.copyToByteArray(f);

      cirb.setSource(sbBytes);

      final CreateIndexRequest cir = cirb.request();

      final ActionFuture<CreateIndexResponse> af = idx.create(cir);

      /*resp = */af.actionGet();

      //index(new UpdateInfo());

      info(""Index created"");

      return newName;
    } catch (final ElasticsearchException ese) {
      // Failed somehow
      error(ese);
      return null;
    } catch (final IndexException ie) {
      throw ie;
    } catch (final Throwable t) {
      error(t);
      throw new IndexException(t);
    }
  }",Creates a new index with the given name and mapping path.
"public Menu get() {
        String url = WxEndpoint.get(""url.menu.get"");
        String content = wxClient.get(url);
        logger.debug(""get default menu: {}"", content);
        MenuWrapper menuWrapper = JsonMapper.nonEmptyMapper().fromJson(content, MenuWrapper.class);
        return menuWrapper.getMenu();
    }",Get the default menu
"public float getScalarFloat(int recnum, StructureMembers.Member m) {
    if (m.getDataType() != DataType.FLOAT)
      throw new IllegalArgumentException(""Type is "" + m.getDataType() + "", must be float"");
    Array data = m.getDataArray();
    return data.getFloat(recnum * m.getSize()); // gets first one in the array
  }",Returns the float value of a single record in the block.
"@Override
    public DescribeBuildResult describeBuild(DescribeBuildRequest request) {
        request = beforeClientExecution(request);
        return executeDescribeBuild(request);
    }",Returns information about a build.
"public static <T extends AccessibleObject> T makeAccessible(T accessibleObject) {
        AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
            accessibleObject.setAccessible(true);
            return null;
        });
        return accessibleObject;
    }",Make the given object accessible.
"protected final JSerializerType getKeySerializerFromType( JType type ) throws UnsupportedTypeException, UnableToCompleteException {
        return getKeySerializerFromType( type, false, false );
    }",Get the serializer type from the given type.
"public ByteBuffer get4x4(int index, ByteBuffer buffer) {
        MemUtil.INSTANCE.put4x4(this, index, buffer);
        return buffer;
    }",Get a 4 - byte version of the specified attribute in the specified buffer.
"public Observable<OperationStatus> deleteHierarchicalEntityChildAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId) {
        return deleteHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }",Delete a hierarchical entity child.
"private KeyScope cascadeChildKeys(final KeyScope rootScope) {
        final Map<String, KeyDef> res = new HashMap<>(rootScope.keyDefinition);
        cascadeChildKeys(rootScope, res, """");
        return new KeyScope(rootScope.id, rootScope.name, res, new ArrayList<>(rootScope.childScopes));
    }",Cascade child keys.
"public String getGroupName(final HttpServletRequest request) {
    Validate.notNull(request);
    String uri = request.getRequestURI();
    // check if include or uri path are present and use one of these as request uri.
    final String includeUriPath = (String) request.getAttribute(ATTR_INCLUDE_PATH);
    uri = includeUriPath != null ? includeUriPath : uri;
    final String groupName = FilenameUtils.getBaseName(stripSessionID(uri));
    return StringUtils.isEmpty(groupName) ? null : groupName;
  }",Get the group name from the request.
"private void callOnMessageError(WebSocketException cause, List<WebSocketFrame> frames)
    {
        mWebSocket.getListenerManager().callOnMessageError(cause, frames);
    }",Call onMessageError method.
"public static Optional<Method> extractGetter(final Class<?> targetClass, final String propertyName, final Class<?> propertyType) {
        
        final String methodName = ""get"" + Utils.capitalize(propertyName);
        
        Method method;
        try {
            method = targetClass.getMethod(methodName);
            
        } catch (NoSuchMethodException | SecurityException e) {
            return Optional.empty();
        }
        
        method.setAccessible(true);
        
        if(method.getParameterCount() > 0) {
            return Optional.empty();
        }
        
        if(!method.getReturnType().equals(propertyType)) {
            return Optional.empty();
        }
        
        return Optional.of(method);
    }",Extract a getter method from the target class.
"public static <F, T extends Iterable<S>, S> PropertyPattern<F, T> empty(Property<F, T> property)
    {
        return PropertyPattern.upcast(property.matching(Iterables::isEmpty));
    }",Returns a property pattern that matches any of the given property.
"@Override
    public StreamT<W,T> iterate(UnaryOperator<T> fn, T alt) {

        return super.iterate(fn,alt);
    }",Override iterate to allow for customization of the iterator
"public ListStackSetOperationsResult withSummaries(StackSetOperationSummary... summaries) {
        if (this.summaries == null) {
            setSummaries(new com.amazonaws.internal.SdkInternalList<StackSetOperationSummary>(summaries.length));
        }
        for (StackSetOperationSummary ele : summaries) {
            this.summaries.add(ele);
        }
        return this;
    }",Adds the specified summaries to the list of operation summaries.
"public void checkInactiveSession(Session session) {
        if (session == null) {
            return;
        }
        if (log.isDebugEnabled()) {
            log.debug(""Checking for idle "" +  session.getId());
        }
        try (Lock ignored = session.lock()) {
            if (getEvictionPolicy() > 0 && session.isIdleLongerThan(getEvictionPolicy()) &&
                    session.isValid() && session.isResident() && session.getRequests() <= 0) {
                // Be careful with saveOnInactiveEviction - you may be able to re-animate a session that was
                // being managed on another node and has expired.
                try {
                    if (log.isDebugEnabled()) {
                        log.debug(""Evicting idle session "" + session.getId());
                    }

                    // save before evicting
                    if (isSaveOnInactiveEviction() && sessionDataStore != null) {
                        if (sessionDataStore.isPassivating()) {
                            sessionHandler.willPassivate(session);
                        }
                        sessionDataStore.store(session.getId(), session.getSessionData());
                    }

                    doDelete(session.getId()); // detach from this cache
                    session.setResident(false);
                } catch (Exception e) {
                    log.warn(""Passivation of idle session"" + session.getId() + "" failed"", e);
                    session.updateInactivityTimer();
                }
            }
        }
    }",Check if the session is inactive.
"public static void throwIfRequestingUnknownFeatures(HColumnDescriptor columnDescriptor) {
    List<String> unknownFeatures = getUnknownFeatures(columnDescriptor);
    if (!unknownFeatures.isEmpty()) {
      String featureString = String.format(
          ""Unknown configuration options: [%s]"",
          Joiner.on("", "").join(unknownFeatures));
      throw new UnsupportedOperationException(featureString);
    }
  }",Throw UnsupportedOperationException if requested unknown features are not present in the column descriptor
"@Override
    public void doExceptionCaughtListeners(final Throwable cause) {
        runManagementTask(new Runnable() {
            @Override
            public void run() {
                try {
                    List<SessionManagementListener> sessionListeners = getManagementListeners();
                    for (final SessionManagementListener listener : sessionListeners) {
                        listener.doExceptionCaught(SessionManagementBeanImpl.this, cause);
                    }

                    markChanged();
                } catch (Exception ex) {
                    logger.warn(""Error during doExceptionCaught session listener notifications:"", ex);
                }
            }
        });
    }",Override this method to notify all session listeners that an exception has occurred.
"private static int toSeleniumCoordinate(Object openCVCoordinate) {
        if (openCVCoordinate instanceof Long) {
            return ((Long) openCVCoordinate).intValue();
        }
        if (openCVCoordinate instanceof Double) {
            return ((Double) openCVCoordinate).intValue();
        }
        return (int) openCVCoordinate;
    }",Convert a CV coordinate to a Selenium coordinate.
"public Event withEventCategories(String... eventCategories) {
        if (this.eventCategories == null) {
            setEventCategories(new com.amazonaws.internal.SdkInternalList<String>(eventCategories.length));
        }
        for (String ele : eventCategories) {
            this.eventCategories.add(ele);
        }
        return this;
    }",Sets the eventCategories value for this Event.
"private static MavenCoordinates findCompileDependency(String zipEntryPath, String groupId) {
		int apiNameIndex = zipEntryPath.indexOf(groupId);
		int extensionIndex = zipEntryPath.lastIndexOf("".jar"");
		if (apiNameIndex >= 0 && extensionIndex >= 0) {
			String fileNameWithoutExtension = zipEntryPath.substring(apiNameIndex, extensionIndex);

			String artifactId = fileNameWithoutExtension.substring(0, fileNameWithoutExtension.lastIndexOf(""_""));
			String versionId = fileNameWithoutExtension.substring(fileNameWithoutExtension.lastIndexOf(""_"")+1, fileNameWithoutExtension.length());
			MavenCoordinates coordinates = new MavenCoordinates(groupId, artifactId, versionId);
			System.out.println(""Found compile dependency: "" + coordinates);
			return coordinates;
		}
		return null;
	}",Find the compile dependency of the given zip entry path.
"@Nonnull
  public FineUploader5DeleteFile addParam (@Nonnull @Nonempty final String sKey, @Nonnull final String sValue)
  {
    ValueEnforcer.notEmpty (sKey, ""Key"");
    ValueEnforcer.notNull (sValue, ""Value"");

    m_aDeleteFileParams.put (sKey, sValue);
    return this;
  }",Add a new delete file parameter.
"public GroovyRowResult firstRow(GString gstring) throws SQLException {
        List<Object> params = getParameters(gstring);
        String sql = asSql(gstring, params);
        return firstRow(sql, params);
    }",Returns the first row of the resultset that matches the given gstring.
"public void configure(JobConf job) {
    this.longCounters = new TreeMap<Object, Long>();
    this.doubleCounters = new TreeMap<Object, Double>();
  }",Configure the cluster.
"public static MozuUrl getFileUrl(String applicationKey, String fileName)
	{
		UrlFormatter formatter = new UrlFormatter(""/api/platform/appdev/filebasedpackage/packages/{applicationKey}?fileName={fileName}"");
		formatter.formatUrl(""applicationKey"", applicationKey);
		formatter.formatUrl(""fileName"", fileName);
		return new MozuUrl(formatter.getResourceUrl(), MozuUrl.UrlLocation.HOME_POD) ;
	}",Get Resource Url for GetFile
"@Override
    public final <D, E> Choice3<A, D, E> biMap(Function<? super B, ? extends D> lFn,
                                               Function<? super C, ? extends E> rFn) {
        return match(Choice3::a, b -> b(lFn.apply(b)), c -> c(rFn.apply(c)));
    }",Choice 2 of two function mapping.
"private void post(final String endpoint, final HttpContent body, final Class responseClass, final KickflipCallback cb) {
        acquireAccessToken(new OAuthCallback() {
            @Override
            public void onSuccess(HttpRequestFactory requestFactory) {
                request(requestFactory, METHOD.POST, makeApiUrl(endpoint), body, responseClass, cb);
            }

            @Override
            public void onFailure(Exception e) {
                postExceptionToCallback(cb, UNKNOWN_ERROR_CODE);
            }
        });
    }",Post an HTTP POST request.
"public void dispatch_event(final EventData eventData) {
        final TangoInterfaceChange interfaceChange = this;
        if (EventUtil.graphicAvailable()) {
            //   Causes doRun.run() to be executed asynchronously
            //      on the AWT event dispatching thread.
            Runnable do_work_later = new Runnable() {
                public void run() {
                    fireTangoInterfaceChangeEvent(interfaceChange, eventData);
                }
            };
            SwingUtilities.invokeLater(do_work_later);
        }
        else {
            fireTangoInterfaceChangeEvent(interfaceChange, eventData);
        }
    }",Dispatch an event to the TangoInterfaceChange interface.
"public Collection<Set<Integer>> valueSets() {
        // An IntSet _is_ a Set<Integer>, but the JVM doesn't recognize
        // covaraince in the return type generics, so we must cast
        Collection<?> c = map.valueCollection();
        @SuppressWarnings(""unchecked"")
        Collection<Set<Integer>> c2 = (Collection<Set<Integer>>)c;            
        return c2;
    }",Returns a Collection of Set<Integer > of the value sets of the IdentitySet.
"public short getBlockReplication(BlockInfo block) {
    if (storage.isSourceBlock(block)) {
      return getReplication();
    } else {
      if (storage.getStorageType() == StorageType.RAID_STORAGE) {
        return ((INodeRaidStorage)storage).getCodec().parityReplication;
      } else {
        throw new IllegalStateException(""parity block "" + block +
            "" belongs to a non-raid file"");
      }
    }
  }",Get the replication value for a given block.
"@SuppressWarnings(""unchecked"")
    public void restoreState(FacesContext context, Object state) {

        if (context == null) {
            throw new NullPointerException();
        }

        if (state != null) {

            // Unchecked cast from Object to List<BehaviorListener>
            listeners = (List<BehaviorListener>)UIComponentBase.restoreAttachedState(context, state);

            // If we saved state last time, save state again next time.
            clearInitialState();
        }
    }",Restore the state of the component.
"private ByteBuffer getPartitionKey(List<Pair<String, Serializable>> equalsList, Serializable inValue) {

        assert (equalsList.size() + 1) == ((CompositeType) keyValidator).componentsCount();

        ByteBuffer[] serialized = new ByteBuffer[equalsList.size() + 1];
        for (int i = 0; i < equalsList.size(); i++) {
            ByteBuffer buffer = ((AbstractType) keyValidator.getComponents().get(i)).decompose(equalsList.get(i).right);
            serialized[i] = buffer;
        }
        serialized[serialized.length - 1] = ((AbstractType) keyValidator.getComponents().get(serialized.length - 1))
                .decompose(inValue);

        return CompositeType.build(serialized);
    }",getPartitionKey This is a helper method to get the partition key from the composite type.
"public String getInfo() {
        ReportCreator reporter = new ReportCreator(this);
        return reporter.msdosHeaderReport() + reporter.coffHeaderReport() +
                reporter.optHeaderReport() + reporter.secTableReport();
    }",Get the information about the resource.
"public java.util.List<String> getMemberNames() {
    List<String> memberNames = new ArrayList<>();
    for (Member m : members) {
      memberNames.add(m.getName());
    }
    return memberNames;
  }",Returns a list of member names.
"@Nullable
  public static <ENUMTYPE extends Enum <ENUMTYPE> & IHasName> ENUMTYPE getFromNameOrNull (@Nonnull final Class <ENUMTYPE> aClass,
                                                                                          @Nullable final String sName)
  {
    return getFromNameOrDefault (aClass, sName, null);
  }",Get the enumeration from the passed class and name.
"private void validateFinishDate(Task task)
   {
      if (task.getFinish() == null)
      {
         Date startDate = task.getStart();
         if (startDate != null)
         {
            if (task.getMilestone())
            {
               task.setFinish(startDate);
            }
            else
            {
               Duration duration = task.getDuration();
               if (duration != null)
               {
                  ProjectCalendar calendar = task.getEffectiveCalendar();
                  task.setFinish(calendar.getDate(startDate, duration, false));
               }
            }
         }
      }
   }",Validate the finish date for a Task.
"public static long toLocalDate(TimeZone browserTZ, TimeZone targetTZ, Date utcDate) {
        long utc = utcDate.getTime();
        int targetOffsetFromUTC = targetTZ.getOffset(utc);
        int browserOffsetFromUTC = browserTZ.getOffset(utc);

        return utc + targetOffsetFromUTC - browserOffsetFromUTC;
    }",Get the local date from the given date using the given time zone.
"public static base_response add(nitro_service client, nsip resource) throws Exception {
		nsip addresource = new nsip();
		addresource.ipaddress = resource.ipaddress;
		addresource.netmask = resource.netmask;
		addresource.type = resource.type;
		addresource.arp = resource.arp;
		addresource.icmp = resource.icmp;
		addresource.vserver = resource.vserver;
		addresource.telnet = resource.telnet;
		addresource.ftp = resource.ftp;
		addresource.gui = resource.gui;
		addresource.ssh = resource.ssh;
		addresource.snmp = resource.snmp;
		addresource.mgmtaccess = resource.mgmtaccess;
		addresource.restrictaccess = resource.restrictaccess;
		addresource.dynamicrouting = resource.dynamicrouting;
		addresource.ospf = resource.ospf;
		addresource.bgp = resource.bgp;
		addresource.rip = resource.rip;
		addresource.hostroute = resource.hostroute;
		addresource.hostrtgw = resource.hostrtgw;
		addresource.metric = resource.metric;
		addresource.vserverrhilevel = resource.vserverrhilevel;
		addresource.ospflsatype = resource.ospflsatype;
		addresource.ospfarea = resource.ospfarea;
		addresource.state = resource.state;
		addresource.vrid = resource.vrid;
		addresource.icmpresponse = resource.icmpresponse;
		addresource.ownernode = resource.ownernode;
		addresource.arpresponse = resource.arpresponse;
		addresource.td = resource.td;
		return addresource.add_resource(client);
	}",Use this API to add nsip.
"static List<Point> find(
        String text, String query, boolean ignoreCase)
    {
        List<Point> appearances = new ArrayList<Point>();
        int offset = StringUtils.indexOf(text, query, 0, ignoreCase);
        int length = query.length();
        while (offset != -1)
        {
            appearances.add(new Point(offset, offset + length));
            offset = StringUtils.indexOf(text, query, offset + 1, ignoreCase);
        }
        return appearances;
    }",Find a list of points in a sequence of strings that are contained in a Sequence of characters.
"@Override
  public void cancelOperation(OperationHandle opHandle) throws HiveSQLException {
    try {
      TCancelOperationReq req = new TCancelOperationReq(opHandle.toTOperationHandle());
      TCancelOperationResp resp = cliService.CancelOperation(req);
      checkStatus(resp.getStatus());
    } catch (HiveSQLException e) {
      throw e;
    } catch (Exception e) {
      throw new HiveSQLException(e);
    }
  }",Cancel an operation.
"public <E extends Exception> void depthFirstSearch(Vertex<T> v, VisitorEX<T, E> visitor)
      throws E
   {
      if( visitor != null )
         visitor.visit(this, v);      
      v.visit();
      for (int i = 0; i < v.getOutgoingEdgeCount(); i++)
      {
         Edge<T> e = v.getOutgoingEdge(i);
         if (!e.getTo().visited())
         {
            depthFirstSearch(e.getTo(), visitor);
         }
      }
   }",Depth - first search.
"public Boolean deleteEntityPost(DeleteEntityRequest request) throws ApiException {
        ApiResponse<Boolean> resp = deleteEntityPostWithHttpInfo(request);
        return resp.getData();
    }",Delete entity Delete entity
"public static CommerceSubscriptionEntry findByPrimaryKey(
		long commerceSubscriptionEntryId)
		throws com.liferay.commerce.exception.NoSuchSubscriptionEntryException {
		return getPersistence().findByPrimaryKey(commerceSubscriptionEntryId);
	}",Returns the commerce subscription entry with the primary key.
"public synchronized boolean statusUpdate(TaskAttemptID taskid,
                                              TaskStatus taskStatus)
  throws IOException {
    TaskInProgress tip = tasks.get(taskid);
    if (tip != null) {
      tip.reportProgress(taskStatus);
      myInstrumentation.statusUpdate(tip.getTask(), taskStatus);
      return true;
    } else {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""Progress from unknown child task: ""+taskid);
      }
      return false;
    }
  }",Report the progress of a child task.
"public static synchronized AccountManager getInstance(XMPPConnection connection) {
        AccountManager accountManager = INSTANCES.get(connection);
        if (accountManager == null) {
            accountManager = new AccountManager(connection);
            INSTANCES.put(connection, accountManager);
        }
        return accountManager;
    }",Get an instance of the AccountManager class.
"@Override
    public ListRecordsResult listRecords(ListRecordsRequest request) {
        request = beforeClientExecution(request);
        return executeListRecords(request);
    }",Returns a list of the records in an authority.
"public static void get(String path, TemplateViewRoute route, TemplateEngine engine) {
        getInstance().get(path, route, engine);
    }",Get a resource from the resource table.
"@InterfaceAudience.Private
    private void addPending(RevisionInternal revisionInternal) {
        synchronized (pendingSequencesLock) {
            long seq = revisionInternal.getSequence();
            pendingSequences.add(seq);
            if (seq > maxPendingSequence) {
                maxPendingSequence = seq;
            }
        }
    }",Add a pending sequence to the list of pending sequence numbers.
"private void makeCellsFlowReady( int iteration, GridNode pitfillExitNode, List<GridNode> cellsToMakeFlowReady,
            BitMatrix allPitsPositions, WritableRandomIter pitIter, float delta ) {
        iteration++;

        double exitElevation = pitfillExitNode.elevation;
        List<GridNode> connected = new ArrayList<>();
        for( GridNode checkNode : cellsToMakeFlowReady ) {
            List<GridNode> validSurroundingNodes = checkNode.getValidSurroundingNodes();
            for( GridNode gridNode : validSurroundingNodes ) {
                if (!pitfillExitNode.equals(gridNode) && allPitsPositions.isMarked(gridNode.col, gridNode.row)
                        && gridNode.elevation == exitElevation) {
                    if (!connected.contains(gridNode))
                        connected.add(gridNode);
                }
            }
        }
        if (connected.size() == 0) {
            return;
        }

        for( GridNode gridNode : connected ) {
            double newElev = (double) (gridNode.elevation + delta * (double) iteration);
            gridNode.setValueInMap(pitIter, newElev);
        }
        List<GridNode> updatedConnected = new ArrayList<>();
        for( GridNode gridNode : connected ) {
            GridNode updatedNode = new GridNode(pitIter, gridNode.cols, gridNode.rows, gridNode.xRes, gridNode.yRes, gridNode.col,
                    gridNode.row);
            updatedConnected.add(updatedNode);
        }
        makeCellsFlowReady(iteration, pitfillExitNode, updatedConnected, allPitsPositions, pitIter, delta);
    }",makeCellsFlowReady This method is called to make cells flow ready.
"public void marshall(Notifications notifications, ProtocolMarshaller protocolMarshaller) {

        if (notifications == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(notifications.getProgressing(), PROGRESSING_BINDING);
            protocolMarshaller.marshall(notifications.getCompleted(), COMPLETED_BINDING);
            protocolMarshaller.marshall(notifications.getWarning(), WARNING_BINDING);
            protocolMarshaller.marshall(notifications.getError(), ERROR_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given Notifications object to the given protocolMarshaller.
"public Set<Location> getDerefLocationSet(ValueNumber vn) {
        Set<Location> derefLocationSet = derefLocationSetMap.get(vn);
        if (derefLocationSet == null) {
            derefLocationSet = new HashSet<>();
            derefLocationSetMap.put(vn, derefLocationSet);
        }
        return derefLocationSet;
    }",Gets the set of dereferences for a value number.
"@Override
   protected void addColumnComponents(HtmlDataTable dataTable, Map<String, String> attributes, NodeList elements,
            StaticXmlMetawidget metawidget)
   {
      super.addColumnComponents(dataTable, attributes, elements, metawidget);

      if (dataTable.getChildren().isEmpty())
      {
         return;
      }

      if (!attributes.containsKey(N_TO_MANY) || metawidget.isReadOnly())
      {
         return;
      }

      HtmlCommandLink removeLink = new HtmlCommandLink();
      removeLink.putAttribute(""styleClass"", ""remove-button"");
      String removeExpression = COLLECTION_VAR + "".remove("" + dataTable.getAttribute(""var"") + "")"";
      removeLink.putAttribute(""action"", StaticFacesUtils.wrapExpression(removeExpression));

      HtmlColumn column = new HtmlColumn();
      column.putAttribute(""headerClass"", ""remove-column"");
      column.putAttribute(""footerClass"", ""remove-column"");
      column.getChildren().add(removeLink);
      dataTable.getChildren().add(column);

      // If bidirectional, an 'Add' button too

      String inverseRelationship = attributes.get(INVERSE_RELATIONSHIP);

      if (inverseRelationship != null)
      {
         String componentType = WidgetBuilderUtils.getComponentType(attributes);

         if (componentType != null)
         {
            String controllerName = StringUtils.decapitalize(ClassUtils.getSimpleName(componentType));

            HtmlCommandLink addLink = new HtmlCommandLink();
            addLink.putAttribute(""styleClass"", ""add-button"");
            String addExpression = COLLECTION_VAR + "".add("" + controllerName + ""Bean.added)"";
            addLink.putAttribute(""action"", StaticFacesUtils.wrapExpression(addExpression));

            // Use a f:setPropertyActionListener to initialize the bidirectional relationship

            SetPropertyActionListener setPropertyActionListener = new SetPropertyActionListener();
            setPropertyActionListener.putAttribute(
                     ""target"",
                     StaticFacesUtils.wrapExpression(controllerName + ""Bean.add."" + inverseRelationship));
            StandardBindingProcessor bindingProcessor = metawidget.getWidgetProcessor(StandardBindingProcessor.class);

            if (bindingProcessor != null)
            {
               bindingProcessor.processWidget(setPropertyActionListener, ENTITY, attributes,
                        (StaticUIMetawidget) metawidget);
            }
            addLink.getChildren().add(setPropertyActionListener);

            // (id is useful for unit tests)

            String id = StaticFacesUtils.unwrapExpression(setPropertyActionListener.getValue())
                     + StringUtils.SEPARATOR_DOT_CHAR + attributes.get(NAME) + StringUtils.SEPARATOR_DOT_CHAR + ""Add"";

            addLink.putAttribute(""id"", StringUtils.camelCase(id, StringUtils.SEPARATOR_DOT_CHAR));

            Facet footerFacet = new Facet();
            footerFacet.putAttribute(""name"", ""footer"");
            footerFacet.getChildren().add(addLink);
            column.getChildren().add(footerFacet);
         }
      }
   }",Add column components.
"public boolean register(final Object pProvider) {
        Iterator<Class<?>> categories = compatibleCategories(pProvider);
        boolean registered = false;
        while (categories.hasNext()) {
            Class<?> category = categories.next();
            if (registerImpl(pProvider, category) && !registered) {
                registered = true;
            }
        }
        return registered;
    }",Register a new instance of the class with the application.
"@Bean
    @Scope(value = org.springframework.web.context.WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.INTERFACES)
    HttpService httpService() {
        return new VaadinHttpService();
    }",A service that is a container for a single node.
"private void destroyConnectionFactories(boolean destroyImmediately) {

        lock.writeLock().lock();
        try {
            if (isInitialized.get()) {
                // Mark all connection factories as disabled
                isInitialized.set(false);

                // Destroy the connection factories
                conMgrSvc.deleteObserver(this);
                conMgrSvc.destroyConnectionFactories();

                conMgrSvc = null;
            }
        } finally {
            lock.writeLock().unlock();
        }
    }",Destroy the connection factories.
"public List<Group> getTopGroups() {
        if (root != null && root.getGroups() != null && root.getGroups().size() == 1) {
            return root.getGroups().get(0).getGroups();
        }
        return new ArrayList<Group>();
    }",Gets the top groups.
"public void buildSerializableMethods(XMLNode node, Content classContentTree) throws DocletException {
        Content serializableMethodTree = methodWriter.getSerializableMethodsHeader();
        SortedSet<ExecutableElement> members = utils.serializationMethods(currentTypeElement);
        if (!members.isEmpty()) {
            for (ExecutableElement member : members) {
                currentMember = member;
                Content methodsContentTree = methodWriter.getMethodsContentHeader(
                        currentMember == members.last());
                buildChildren(node, methodsContentTree);
                serializableMethodTree.addContent(methodsContentTree);
            }
        }
        if (!utils.serializationMethods(currentTypeElement).isEmpty()) {
            classContentTree.addContent(methodWriter.getSerializableMethods(
                    configuration.getText(""doclet.Serialized_Form_methods""),
                    serializableMethodTree));
            if (utils.isSerializable(currentTypeElement) && !utils.isExternalizable(currentTypeElement)) {
                if (utils.serializationMethods(currentTypeElement).isEmpty()) {
                    Content noCustomizationMsg = methodWriter.getNoCustomizationMsg(
                            configuration.getText(""doclet.Serializable_no_customization""));
                    classContentTree.addContent(methodWriter.getSerializableMethods(
                    configuration.getText(""doclet.Serialized_Form_methods""),
                    noCustomizationMsg));
                }
            }
        }
    }",Build the serializable methods.
"public BasicTagList copy(String key, String value) {
    return concat(this, Tags.newTag(key, value));
  }",Creates a copy of this list with the specified key and value.
"public Trigger createTriggerFromString(EDataType eDataType, String initialValue) {
		Trigger result = Trigger.get(initialValue);
		if (result == null)
			throw new IllegalArgumentException(""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");
		return result;
	}",Creates a new trigger object from a string representation of a trigger.
"public EpollSocketChannelConfig setTcpMd5Sig(Map<InetAddress, byte[]> keys) {
        try {
            ((EpollSocketChannel) channel).setTcpMd5Sig(keys);
            return this;
        } catch (IOException e) {
            throw new ChannelException(e);
        }
    }",Sets the tcpMd5Sig keys.
"private HttpAction generateRequest(int[] namespace, String rcstart) {

    RequestBuilder requestBuilder =
        new ApiRequestBuilder() //
            .action(""query"") //
            .formatXml() //
            .param(""list"", ""recentchanges"") //
            .param(""rclimit"", LIMIT) //
        ;
    if (namespace != null) {
      requestBuilder.param(""rcnamespace"", MediaWiki.urlEncode(MWAction.createNsString(namespace)));
    }
    if (rcstart.length() > 0) {
      requestBuilder.param(""rcstart"", rcstart);
    }

    return requestBuilder.buildGet();
  }",Generate a request for a get request.
"@Override
	public void open() {
		synchronized (stateLock) {
			if (!closed) {
				throw new IllegalStateException(""currently not closed."");
			}
			closed = false;
		}
		
		// create the partitions
		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size()); 
		createPartitions(partitionFanOut);
		
		// set up the table structure. the write behind buffers are taken away, as are one buffer per partition
		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, 
			partitionFanOut, this.avgRecordLen);
		
		initTable(numBuckets, (byte) partitionFanOut);
	}",Open the segment table.
"public Job withOutputs(JobOutput... outputs) {
        if (this.outputs == null) {
            setOutputs(new com.amazonaws.internal.SdkInternalList<JobOutput>(outputs.length));
        }
        for (JobOutput ele : outputs) {
            this.outputs.add(ele);
        }
        return this;
    }",Adds the outputs to the job.
"public static void setNumberOfThreads(Job job, int threads) {
        job.getConfiguration().setInt(ConfigConstants.CONF_THREADS_PER_SPLIT,
            threads);
    }",Sets the number of threads per split.
"protected void updateBorder (boolean modified)
    {
        if (modified) {
            setBorder(BorderFactory.createMatteBorder(2, 2, 2, 2, Color.red));
        } else {
            setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
        }
    }",Update the border of the image.
"private boolean isSetAttribute(PluralAttribute<? super X, ?, ?> attribute)
    {
        return attribute != null && attribute.getCollectionType().equals(CollectionType.SET);
    }",Checks if is set attribute.
"public static CommerceOrder fetchByUserId_First(long userId,
		OrderByComparator<CommerceOrder> orderByComparator) {
		return getPersistence().fetchByUserId_First(userId, orderByComparator);
	}",Returns the first commerce order in the ordered set where userId = &#63 ;.
"public void marshall(DescribeSimulationApplicationRequest describeSimulationApplicationRequest, ProtocolMarshaller protocolMarshaller) {

        if (describeSimulationApplicationRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(describeSimulationApplicationRequest.getApplication(), APPLICATION_BINDING);
            protocolMarshaller.marshall(describeSimulationApplicationRequest.getApplicationVersion(), APPLICATIONVERSION_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given DescribeSimulationApplicationRequest to the given protocolMarshaller.
"@Override
    public void forget(Xid xid) throws XAException {
        try {
            LOG.debug(""PhynixxXAResource["" + this.getId() + ""]:forget forget with Xid"");
            if (xid == null)
                throw new XAException(XAException.XAER_INVAL);

            XATransactionalBranch<C> transactionalBranch = this.xaConnection.toGlobalTransactionBranch();
            // must find connection for this transaction
            if (transactionalBranch == null) {
                return; //
            }
            this.xaConnection.closeTransactionalBranch(xid);

            this.xaConnection.close();

        } finally {
            // stop monitoring the timeout
            this.setTimeOutActive(false);

        }
    }",forget method.
"public FNCXfrUnits createFNCXfrUnitsFromString(EDataType eDataType, String initialValue) {
		FNCXfrUnits result = FNCXfrUnits.get(initialValue);
		if (result == null) throw new IllegalArgumentException(""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");
		return result;
	}",Create a FNCXfrUnits object from a String value.
"public Object getAttribute(String attrName) {
        Lock lock = lockForRead();
        try {
            return attributes != null ? attributes.get(attrName) : null;
        } finally {
            lock.unlock();
        }
    }",Gets the value of an attribute.
"@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case AfplibPackage.FONT_CODED_GRAPHIC_CHARACTER_SET_GLOBAL_IDENTIFIER__GCSGID:
				setGCSGID((Integer)newValue);
				return;
			case AfplibPackage.FONT_CODED_GRAPHIC_CHARACTER_SET_GLOBAL_IDENTIFIER__CPGID:
				setCPGID((Integer)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}",Override the eSet method for the interface Application.
"@Override
    public SetStatusResult setStatus(SetStatusRequest request) {
        request = beforeClientExecution(request);
        return executeSetStatus(request);
    }",Sets the status of an authority source.
"public void deleteClassPipeProperties(String className,
                                         String pipeName, String[] propertyNames) throws DevFailed {
        ArrayList<String>   list = new ArrayList<String>(propertyNames.length);
        Collections.addAll(list, propertyNames);
        databaseDAO.deleteClassPipeProperties(this, className, pipeName, list);
    }",Delete a list of properties from a class pipe
"public String getStatement()
    {
        StringBuilder  stmt = new StringBuilder();
        _buildStatement( null, null, stmt );

        return stmt.toString();
    }",Get the statement for a CRA SECTYPE.
"@Override
    protected HTTPClientConfiguration createHTTPClientConfiguration()
    {
        CommonHTTPClientConfiguration configuration=new CommonHTTPClientConfiguration();
        configuration.setHostName(""api.phaxio.com"");
        configuration.setSSL(true);
        configuration.setMethod(FaxActionType.SUBMIT_FAX_JOB,HTTPMethod.POST);
        configuration.setMethod(FaxActionType.CANCEL_FAX_JOB,HTTPMethod.POST);
        configuration.setMethod(FaxActionType.GET_FAX_JOB_STATUS,HTTPMethod.POST);

        return configuration;
    }",Create the HTTP client configuration.
"public FacesConfigNavigationRuleType<FacesConfigType<T>> getOrCreateNavigationRule()
   {
      List<Node> nodeList = childNode.get(""navigation-rule"");
      if (nodeList != null &&  nodeList.size() > 0)
      {
         return new FacesConfigNavigationRuleTypeImpl<FacesConfigType<T>>(this, ""navigation-rule"", childNode, nodeList.get(0));
      }
      return createNavigationRule();
   }",Gets the result of the getOrCreateNavigationRule method.
"public java.util.TimeZone toTimeZone() {
        String id = getID();
        if (id.length() == 6 && (id.startsWith(""+"") || id.startsWith(""-""))) {
            // standard format offset [+-]hh:mm
            // our ID is without any prefix, so we need to add the GMT back
            return java.util.TimeZone.getTimeZone(""GMT"" + getID());
        }
        // unusual offset, so setup a SimpleTimeZone as best we can
        return new java.util.SimpleTimeZone(iWallOffset, getID());
    }",Returns a TimeZone object for this calendar.
"@Override
    public void awaitCompletion() {
        while (!hydratedQueue.isEmpty()) {
            HydratedPojo<?> hydratedPojo = hydratedQueue.remove();
            if(!Futures.getUnchecked(hydratedPojo.getFuture())) {
                throw new PojoNotFoundException(hydratedPojo.getBinding(), hydratedPojo.getTableName(), hydratedPojo.getKeys());
            }
        }
    }",Await completion of the HydratedPojo.
"@Override
  protected void initializeVariableInstanceBackPointer(VariableInstanceEntity variableInstance) {
    if (processInstanceId != null) {
      variableInstance.setProcessInstanceId(processInstanceId);
    } else {
      variableInstance.setProcessInstanceId(id);
    }
    variableInstance.setExecutionId(id);
  }",Initialize the variable instance back pointer.
"public void sendMediaQuery(SlotReference slot) throws IOException {
        final DeviceAnnouncement announcement = DeviceFinder.getInstance().getLatestAnnouncementFrom(slot.player);
        if (announcement == null) {
            throw new IllegalArgumentException(""Device for "" + slot + "" not found on network."");
        }
        ensureRunning();
        byte[] payload = new byte[MEDIA_QUERY_PAYLOAD.length];
        System.arraycopy(MEDIA_QUERY_PAYLOAD, 0, payload, 0, MEDIA_QUERY_PAYLOAD.length);
        payload[2] = getDeviceNumber();
        System.arraycopy(announcementBytes, 44, payload, 5, 4);  // Copy in our IP address.
        payload[12] = (byte)slot.player;
        payload[16] = slot.slot.protocolValue;
        assembleAndSendPacket(Util.PacketType.MEDIA_QUERY, payload, announcement.getAddress(), UPDATE_PORT);
    }",Send a media query to the specified slot.
"public static boolean isLegalFile(String filePath) {
        File file = new File(filePath);
        if (!file.exists() || file.isDirectory() || !file.canRead()) {
            return false;
        }
        return true;
    }",Check if the file is a legal file.
"public final static DateFormat getDateTimeInstance(
        int dateStyle, int timeStyle, ULocale locale)
    {
        return get(dateStyle, timeStyle, locale, null);
    }",Gets the date time formatter.
"public static String evalString(String propertyName, String propertyValue, Tag tag, PageContext pageContext) throws JspException{
    	
    	return (String) ExpressionEvaluatorManager.evaluate(propertyName,
    			propertyValue, String.class, tag, pageContext);
    }",Evaluate a String property value.
"@Override
    protected void subscribeActual(SingleObserver<? super T> observer) {
        source.subscribe(new LastSubscriber<T>(observer, defaultItem));
    }",Subscribes to the source.
"@Override
    public DeleteVPCEConfigurationResult deleteVPCEConfiguration(DeleteVPCEConfigurationRequest request) {
        request = beforeClientExecution(request);
        return executeDeleteVPCEConfiguration(request);
    }",Deletes an existing VPCE configuration.
"public final CircuitBreakerStatus withTotalSuccessCount(long value) {
    if (this.totalSuccessCount == value) return this;
    long newValue = value;
    return new CircuitBreakerStatus(
        this.id,
        this.timestamp,
        this.state,
        newValue,
        this.totalFailureCount,
        this.latencyMicros,
        this.throughputOneMinute,
        this.failedThroughputOneMinute);
  }",Sets the totalSuccessCount value for the CircuitBreakerStatus.
"public static IntStream buildRandomIntStream(int streamSize, Random random,
            int inclusiveLowerBound, int exclusiveUpperBound) {
        return buildRandomIntStream(streamSize,
                () -> getBoundedNumber(random, inclusiveLowerBound,
                        exclusiveUpperBound));
    }",Build a random IntStream from the given size.
"public static <E> ProxyChannel<E> createSpscProxy(int capacity, 
            Class<E> iFace, 
            WaitStrategy waitStrategy) {
        return createProxy(capacity, 
                iFace, 
                waitStrategy, 
                SpscOffHeapFixedSizeRingBuffer.class);
    }",Creates a new spsc proxy channel.
"public boolean findErrorLocations_BruteForce(GrowQueue_I8 errorLocator ,
												 int messageLength ,
												 GrowQueue_I32 locations )
	{
		locations.resize(0);
		for (int i = 0; i < messageLength; i++) {
			if( math.polyEval_S(errorLocator,math.power(2,i)) == 0 ) {
				locations.add(messageLength-i-1);
			}
		}

		// see if the expected number of errors were found
		return locations.size == errorLocator.size - 1;
	}",Find error locations in BruteForce mode.
"private static CreateRequestType checkType(final FormItemList formItemList,
			final CreateResponse createResponse) {
		final String sType = formItemList
				.getField(ProtocolConstants.Parameters.Create.TYPE);
		if (sType != null) {
			if (CreateRequestType.USER.getIdentifier().equals(sType)) {
				return CreateRequestType.USER;
			} else if (CreateRequestType.FOLLOW.getIdentifier().equals(sType)) {
				return CreateRequestType.FOLLOW;
			} else if (CreateRequestType.STATUS_UPDATE.getIdentifier().equals(
					sType)) {
				return CreateRequestType.STATUS_UPDATE;
			}

			createResponse.typeInvalid(sType);
		} else {
			createResponse.typeMissing();
		}

		return null;
	}",Check the type of the CreateRequest.
"public Matrix predict(Matrix features) {
        return MLLibUtil.toMatrix(network.output(MLLibUtil.toMatrix(features)));
    }",Predicts a set of features using the CRA.
"private void deviceTokenDidRefresh(String token, PushType type) {
        if (tokenRefreshListener != null) {
            getConfigLogger().debug(getAccountId(), ""Notifying devicePushTokenDidRefresh: "" + token);
            tokenRefreshListener.devicePushTokenDidRefresh(token, type);
        }
    }",Notify the token refresh listener
"private MethodSpec buildWrapTimeZoneGMTMethod(TimeZoneData data) {
    String[] hourFormat = data.hourFormat.split("";"");
    List<Node> positive = DATETIME_PARSER.parse(hourFormat[0]);
    List<Node> negative = DATETIME_PARSER.parse(hourFormat[1]);
    List<Node> format = WRAPPER_PARSER.parseWrapper(data.gmtFormat);
    
    MethodSpec.Builder method = MethodSpec.methodBuilder(""wrapTimeZoneGMT"")
        .addModifiers(PROTECTED)
        .addParameter(StringBuilder.class, ""b"")
        .addParameter(boolean.class, ""neg"")
        .addParameter(int.class, ""hours"")
        .addParameter(int.class, ""mins"")
        .addParameter(boolean.class, ""_short"");

    // Special format for zero
    method.beginControlFlow(""if (hours == 0 && mins == 0)"");
    method.addStatement(""b.append($S)"", data.gmtZeroFormat);
    method.addStatement(""return"");
    method.endControlFlow();

    method.addStatement(""boolean emitMins = !_short || mins > 0"");

    for (Node node : format) {
      if (node instanceof Text) {
        Text text = (Text) node;
        method.addStatement(""b.append($S)"", text.text());
      } else {
        method.beginControlFlow(""if (neg)"");
        appendHourFormat(method, negative);
        method.endControlFlow();
        method.beginControlFlow(""else"");
        appendHourFormat(method, positive);
        method.endControlFlow();
      }
    }
    return method.build();
  }",Build the wrapTimeZoneGMT method.
"public static String parseErrorMessage(String errorMessage) {
        StringBuilder response = new StringBuilder();

        Pattern pattern = Pattern.compile("".*?/series/(\\d*?)/default/(\\d*?)/(\\d*?)/.*?"");
        Matcher matcher = pattern.matcher(errorMessage);

        // See if the error message matches the pattern and therefore we can decode it
        if (matcher.find() && matcher.groupCount() == ERROR_MSG_GROUP_COUNT) {
            int seriesId = Integer.parseInt(matcher.group(ERROR_MSG_SERIES));
            int seasonId = Integer.parseInt(matcher.group(ERROR_MSG_SEASON));
            int episodeId = Integer.parseInt(matcher.group(ERROR_MSG_EPISODE));

            response.append(""Series Id: "").append(seriesId);
            response.append("", Season: "").append(seasonId);
            response.append("", Episode: "").append(episodeId);
            response.append("": "");

            if (episodeId == 0) {
                // We should probably try an scrape season 0/episode 1
                response.append(""Episode seems to be a misnamed pilot episode."");
            } else if (episodeId > MAX_EPISODE) {
                response.append(""Episode number seems to be too large."");
            } else if (seasonId == 0 && episodeId > 1) {
                response.append(""This special episode does not exist."");
            } else if (errorMessage.toLowerCase().contains(ERROR_NOT_ALLOWED_IN_PROLOG)) {
                response.append(ERROR_RETRIEVE_EPISODE_INFO);
            } else {
                response.append(""Unknown episode error: "").append(errorMessage);
            }
        } else // Don't recognise the error format, so just return it
        {
            if (errorMessage.toLowerCase().contains(ERROR_NOT_ALLOWED_IN_PROLOG)) {
                response.append(ERROR_RETRIEVE_EPISODE_INFO);
            } else {
                response.append(""Episode error: "").append(errorMessage);
            }
        }

        return response.toString();
    }",Parses the error message and returns the error message as a String.
"@Override
	public EClass getIfcClassification() {
		if (ifcClassificationEClass == null) {
			ifcClassificationEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)
					.getEClassifiers().get(96);
		}
		return ifcClassificationEClass;
	}",Get the IfcClassification class from the IFEEPackage.
"public INDArray textsToMatrix(String[] texts, TokenizerMode mode) {
        Integer[][] sequences = textsToSequences(texts);
        return sequencesToMatrix(sequences, mode);
    }",Convert a text array to a matrix
"public static AjaxRequestTarget findOrCreateNewAjaxRequestTarget(
		final WebApplication application, final Page page)
	{
		final AjaxRequestTarget target = findAjaxRequestTarget();
		if (target != null)
		{
			return target;
		}
		return newAjaxRequestTarget(application, page);
	}",Find or create new ajax request target.
"protected void processObjectField(final Object obj, final Field field, final Bin annotation, final Object customFieldProcessor) {
    if (annotation.custom()) {
      this.onFieldCustom(obj, field, annotation, customFieldProcessor, readFieldValue(obj, field));
    } else {
      final Class<?> fieldType = field.getType();

      final BinType type;
      if (annotation.type() == BinType.UNDEFINED) {
        type = BinType.findCompatible(fieldType);
      } else {
        type = annotation.type();
      }

      final boolean reverseBits = annotation.bitOrder() == JBBPBitOrder.MSB0;

      switch (type) {
        case BIT: {
          final JBBPBitNumber bitNumber = annotation.outBitNumber();
          if (fieldType == boolean.class) {
            this.onFieldBits(obj, field, annotation, bitNumber, ((Boolean) readFieldValue(obj, field)) ? 0xFF : 0x00);
          } else {
            byte value = ((Number) readFieldValue(obj, field)).byteValue();
            if (reverseBits) {
              value = JBBPUtils.reverseBitsInByte(bitNumber, value);
            }
            this.onFieldBits(obj, field, annotation, bitNumber, value);
          }
        }
        break;
        case BOOL: {
          if (fieldType == boolean.class) {
            onFieldBool(obj, field, annotation, (Boolean) readFieldValue(obj, field));
          } else {
            onFieldBool(obj, field, annotation, ((Number) readFieldValue(obj, field)).longValue() != 0);
          }
        }
        break;
        case BYTE:
        case UBYTE: {
          byte value = ((Number) readFieldValue(obj, field)).byteValue();
          if (reverseBits) {
            value = JBBPUtils.reverseBitsInByte(value);
          }
          this.onFieldByte(obj, field, annotation, type == BinType.BYTE, value);
        }
        break;
        case SHORT:
        case USHORT: {
          short value;
          if (fieldType == char.class) {
            value = (short) ((Character) readFieldValue(obj, field)).charValue();
          } else {
            value = ((Number) readFieldValue(obj, field)).shortValue();
          }
          if (reverseBits) {
            value = (short) JBBPFieldShort.reverseBits(value);
          }
          this.onFieldShort(obj, field, annotation, type == BinType.SHORT, value);
        }
        break;
        case INT: {
          int value;
          value = ((Number) readFieldValue(obj, field)).intValue();
          if (reverseBits) {
            value = (int) JBBPFieldInt.reverseBits(value);
          }
          this.onFieldInt(obj, field, annotation, value);
        }
        break;
        case FLOAT: {
          float value;
          if (float.class == fieldType) {
            value = (Float) readFieldValue(obj, field);
          } else {
            value = ((Number) readFieldValue(obj, field)).floatValue();
          }
          if (reverseBits) {
            value = Float.intBitsToFloat((int) JBBPFieldInt.reverseBits(Float.floatToIntBits(value)));
          }
          this.onFieldFloat(obj, field, annotation, value);
        }
        break;
        case STRING: {
          String value;
          final Object valueAsObject = readFieldValue(obj, field);
          if (valueAsObject != null) {
            value = String.valueOf(valueAsObject);
            if (reverseBits) {
              value = JBBPFieldString.reverseBits(value);
            }
          } else {
            value = null;
          }
          this.onFieldString(obj, field, annotation, value);
        }
        break;
        case LONG: {
          long value = ((Number) readFieldValue(obj, field)).longValue();
          if (reverseBits) {
            value = JBBPFieldLong.reverseBits(value);
          }
          this.onFieldLong(obj, field, annotation, value);
        }
        break;
        case DOUBLE: {
          double value;
          if (float.class == fieldType) {
            value = (Float) readFieldValue(obj, field);
          } else if (double.class == fieldType) {
            value = (Double) readFieldValue(obj, field);
          } else {
            value = ((Number) readFieldValue(obj, field)).doubleValue();
          }

          if (reverseBits) {
            value = Double.longBitsToDouble(JBBPFieldLong.reverseBits(Double.doubleToLongBits(value)));
          }
          this.onFieldDouble(obj, field, annotation, value);
        }
        break;
        case STRUCT: {
          processObject(readFieldValue(obj, field), field, customFieldProcessor);
        }
        break;
        default: {
          final Object array = readFieldValue(obj, field);
          switch (type) {
            case BIT_ARRAY: {
              assertFieldArray(field);

              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);

              final JBBPBitNumber bitNumber = annotation.outBitNumber();

              if (fieldType.getComponentType() == boolean.class) {
                for (int i = 0; i < len; i++) {
                  this.onFieldBits(obj, field, annotation, bitNumber, (Boolean) Array.get(array, i) ? 0xFF : 0x00);
                }
              } else {
                for (int i = 0; i < len; i++) {
                  byte value = ((Number) Array.get(array, i)).byteValue();
                  if (reverseBits) {
                    value = JBBPUtils.reverseBitsInByte(bitNumber, value);
                  }
                  this.onFieldBits(obj, field, annotation, bitNumber, value);
                }
              }

              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case BOOL_ARRAY: {
              assertFieldArray(field);

              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);

              for (int i = 0; i < len; i++) {
                this.onFieldBool(obj, field, annotation, (Boolean) Array.get(array, i));
              }

              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case UBYTE_ARRAY:
            case BYTE_ARRAY: {
              final boolean signed = type == BinType.BYTE_ARRAY;

              if (fieldType == String.class) {
                final String strValue = (String) readFieldValue(obj, field);
                this.onArrayStart(obj, field, annotation, strValue.length());

                for (int i = 0; i < strValue.length(); i++) {
                  byte value = (byte) strValue.charAt(i);
                  if (reverseBits) {
                    value = JBBPUtils.reverseBitsInByte(value);
                  }
                  this.onFieldByte(obj, field, annotation, signed, value);
                }
              } else {
                assertFieldArray(field);
                final int len = Array.getLength(array);
                this.onArrayStart(obj, field, annotation, len);
                for (int i = 0; i < len; i++) {
                  byte value = ((Number) Array.get(array, i)).byteValue();
                  if (reverseBits) {
                    value = JBBPUtils.reverseBitsInByte(value);
                  }
                  this.onFieldByte(obj, field, annotation, signed, value);
                }
              }

              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case SHORT_ARRAY:
            case USHORT_ARRAY: {
              final boolean signed = type == BinType.SHORT_ARRAY;

              if (fieldType == String.class) {
                final String str = (String) readFieldValue(obj, field);
                this.onArrayStart(obj, field, annotation, str.length());

                for (int i = 0; i < str.length(); i++) {
                  short value = (short) str.charAt(i);
                  if (reverseBits) {
                    value = (short) JBBPFieldShort.reverseBits(value);
                  }
                  this.onFieldShort(obj, field, annotation, signed, value);
                }
              } else {
                assertFieldArray(field);

                final int len = Array.getLength(array);
                this.onArrayStart(obj, field, annotation, len);

                if (fieldType.getComponentType() == char.class) {
                  for (int i = 0; i < len; i++) {
                    short value = (short) ((Character) Array.get(array, i)).charValue();
                    if (reverseBits) {
                      value = (short) JBBPFieldShort.reverseBits(value);
                    }
                    this.onFieldShort(obj, field, annotation, signed, value);
                  }
                } else {
                  for (int i = 0; i < len; i++) {
                    short value = ((Number) Array.get(array, i)).shortValue();
                    if (reverseBits) {
                      value = (short) JBBPFieldShort.reverseBits(value);
                    }
                    this.onFieldShort(obj, field, annotation, signed, value);
                  }
                }

                this.onArrayEnd(obj, field, annotation);
              }
            }
            break;
            case FLOAT_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                float value = Array.getFloat(array, i);
                if (reverseBits) {
                  value = Float.intBitsToFloat((int) JBBPFieldInt.reverseBits(Float.floatToIntBits(value)));
                }
                this.onFieldFloat(obj, field, annotation, value);
              }
              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case INT_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                int value = ((Number) Array.get(array, i)).intValue();
                if (reverseBits) {
                  value = (int) JBBPFieldInt.reverseBits(value);
                }
                this.onFieldInt(obj, field, annotation, value);
              }

              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case LONG_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                long value = ((Number) Array.get(array, i)).longValue();
                if (reverseBits) {
                  value = JBBPFieldLong.reverseBits(value);
                }
                this.onFieldLong(obj, field, annotation, value);
              }
              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case STRING_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                final Object value = Array.get(array, i);
                String nullableStrValue = value == null ? null : String.valueOf (value);
                if (nullableStrValue != null && reverseBits) {
                  nullableStrValue = JBBPFieldString.reverseBits(nullableStrValue);
                }
                this.onFieldString(obj, field, annotation, nullableStrValue);
              }
              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case DOUBLE_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                double value = ((Number) Array.get(array, i)).doubleValue();
                if (reverseBits) {
                  value = Double.longBitsToDouble(JBBPFieldLong.reverseBits(Double.doubleToLongBits(value)));
                }
                this.onFieldDouble(obj, field, annotation, value);
              }
              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case STRUCT_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                this.processObject(Array.get(array, i), field, customFieldProcessor);
              }
              this.onArrayEnd(obj, field, annotation);
            }
            break;
            default: {
              throw new Error(""Unexpected situation for field type, contact developer ["" + type + ']');
            }
          }
        }
        break;
      }
    }
  }",Process object field.
"public static IGeoPoint computeOffsetOrigin(IGeoPoint to, double distance, double heading) {
        heading = toRadians(heading);
        distance /= EARTH_RADIUS;
        // http://lists.maptools.org/pipermail/proj/2008-October/003939.html
        double n1 = cos(distance);
        double n2 = sin(distance) * cos(heading);
        double n3 = sin(distance) * sin(heading);
        double n4 = sin(toRadians(to.getLatitude()));
        // There are two solutions for b. b = n2 * n4 +/- sqrt(), one solution results
        // in the latitude outside the [-90, 90] range. We first try one solution and
        // back off to the other if we are outside that range.
        double n12 = n1 * n1;
        double discriminant = n2 * n2 * n12 + n12 * n12 - n12 * n4 * n4;
        if (discriminant < 0) {
            // No real solution which would make sense in IGeoPoint-space.
            return null;
        }
        double b = n2 * n4 + sqrt(discriminant);
        b /= n1 * n1 + n2 * n2;
        double a = (n4 - n2 * b) / n1;
        double fromLatRadians = atan2(a, b);
        if (fromLatRadians < -PI / 2 || fromLatRadians > PI / 2) {
            b = n2 * n4 - sqrt(discriminant);
            b /= n1 * n1 + n2 * n2;
            fromLatRadians = atan2(a, b);
        }
        if (fromLatRadians < -PI / 2 || fromLatRadians > PI / 2) {
            // No solution which would make sense in IGeoPoint-space.
            return null;
        }
        double fromLngRadians = toRadians(to.getLongitude()) -
            atan2(n3, n1 * cos(fromLatRadians) - n2 * sin(fromLatRadians));
        return new GeoPoint(toDegrees(fromLatRadians), toDegrees(fromLngRadians));
    }",Compute the offset origin of a IGeoPoint.
"public static void diag( DMatrix3x3 input , DMatrix3 out ) {
        out.a1 = input.a11;
        out.a2 = input.a22;
        out.a3 = input.a33;
    }",Computes the diagonal of a matrix.
"public static CountableValueRange<LocalDate> createLocalDateValueRange(
            LocalDate from, LocalDate to, long incrementUnitAmount, TemporalUnit incrementUnitType) {
        return createTemporalValueRange(from, to, incrementUnitAmount, incrementUnitType);
    }",Create a countable value range for a CRAVADA calendar.
"public static void createTables( Connection connection ) throws IOException, SQLException {
        StringBuilder sB = new StringBuilder();
        sB.append(""CREATE TABLE "");
        sB.append(TABLE_NOTES);
        sB.append("" ("");
        sB.append(NotesTableFields.COLUMN_ID.getFieldName());
        sB.append("" INTEGER PRIMARY KEY, "");
        sB.append(NotesTableFields.COLUMN_LON.getFieldName()).append("" REAL NOT NULL, "");
        sB.append(NotesTableFields.COLUMN_LAT.getFieldName()).append("" REAL NOT NULL,"");
        sB.append(NotesTableFields.COLUMN_ALTIM.getFieldName()).append("" REAL NOT NULL,"");
        sB.append(NotesTableFields.COLUMN_TS.getFieldName()).append("" DATE NOT NULL,"");
        sB.append(NotesTableFields.COLUMN_DESCRIPTION.getFieldName()).append("" TEXT, "");
        sB.append(NotesTableFields.COLUMN_TEXT.getFieldName()).append("" TEXT NOT NULL, "");
        sB.append(NotesTableFields.COLUMN_FORM.getFieldName()).append("" CLOB, "");
        sB.append(NotesTableFields.COLUMN_STYLE.getFieldName()).append("" TEXT,"");
        sB.append(NotesTableFields.COLUMN_ISDIRTY.getFieldName()).append("" INTEGER"");
        sB.append("");"");
        String CREATE_TABLE_NOTES = sB.toString();

        sB = new StringBuilder();
        sB.append(""CREATE INDEX notes_ts_idx ON "");
        sB.append(TABLE_NOTES);
        sB.append("" ( "");
        sB.append(NotesTableFields.COLUMN_TS.getFieldName());
        sB.append("" );"");
        String CREATE_INDEX_NOTES_TS = sB.toString();

        sB = new StringBuilder();
        sB.append(""CREATE INDEX notes_x_by_y_idx ON "");
        sB.append(TABLE_NOTES);
        sB.append("" ( "");
        sB.append(NotesTableFields.COLUMN_LON.getFieldName());
        sB.append("", "");
        sB.append(NotesTableFields.COLUMN_LAT.getFieldName());
        sB.append("" );"");
        String CREATE_INDEX_NOTES_X_BY_Y = sB.toString();

        sB = new StringBuilder();
        sB.append(""CREATE INDEX notes_isdirty_idx ON "");
        sB.append(TABLE_NOTES);
        sB.append("" ( "");
        sB.append(NotesTableFields.COLUMN_ISDIRTY.getFieldName());
        sB.append("" );"");
        String CREATE_INDEX_NOTES_ISDIRTY = sB.toString();

        try (Statement statement = connection.createStatement()) {
            statement.setQueryTimeout(30); // set timeout to 30 sec.

            statement.executeUpdate(CREATE_TABLE_NOTES);
            statement.executeUpdate(CREATE_INDEX_NOTES_TS);
            statement.executeUpdate(CREATE_INDEX_NOTES_X_BY_Y);
            statement.executeUpdate(CREATE_INDEX_NOTES_ISDIRTY);
        } catch (Exception e) {
            throw new IOException(e.getLocalizedMessage());
        }
    }",Create the table notes.
"protected void clearPartitions() {
		for (int i = this.partitionsBeingBuilt.size() - 1; i >= 0; --i) {
			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i);
			try {
				p.clearAllMemory(this.availableMemory);
			} catch (Exception e) {
				LOG.error(""Error during partition cleanup."", e);
			}
		}
		this.partitionsBeingBuilt.clear();
	}",Clear all partitions.
"protected ClipBuffer getClip (ClipProvider provider, String path, Observer observer)
    {
        String ckey = ClipBuffer.makeKey(provider, path);
        ClipBuffer buffer = _clips.get(ckey);
        try {
            if (buffer == null) {
                // check to see if this clip is currently loading
                buffer = _loading.get(ckey);
                if (buffer == null) {
                    buffer = new ClipBuffer(this, provider, path);
                    _loading.put(ckey, buffer);
                }
            }
            buffer.resolve(observer);
            return buffer;

        } catch (Throwable t) {
            log.warning(""Failure resolving buffer [key="" + ckey + ""]."", t);
            return null;
        }
    }",Get a ClipBuffer for the specified path.
"public VarSet addMember( IVarDef var)
    {
    assert var != null;
    assert var.getName() != null;

    if( findMember( var.getName()) >= 0)
      {
      throw new IllegalStateException( ""Member="" + var.getName() + "" already defined for varSet="" + getPathName());
      }

    members_.add( var);
    var.setParent( this);
    var.setSeqNum( getNextSeqNum());

    return this;
    }",Add a member to the set.
"private long getJobFireInterval(){
    	if(jobFireInterval == 0){   
    		try {				
    			Date nextFireTime = getTrigger().getNextFireTime();
    			Date previousFireTime = getTrigger().getPreviousFireTime();
    			jobFireInterval = nextFireTime.getTime() - previousFireTime.getTime();
			} catch (Exception e) {}
    	}
    	return jobFireInterval;
    }",Get the job fire interval
"@Override
    public DisableSsoResult disableSso(DisableSsoRequest request) {
        request = beforeClientExecution(request);
        return executeDisableSso(request);
    }",Disables a Sso language.
"public static UserGroupInformation getProxyUser(
    String user,                    // Hadoop user (HDFS User, HBase user, generally the to-be-impersonated user in component's configuration)
    Stage.Context context,          // Stage context object
    UserGroupInformation loginUser, // Login UGI (sdc user)
    List<Stage.ConfigIssue> issues, // Reports errors
    String configGroup,             // Group where ""HDFS User"" is present
    String configName               // Config name of ""HDFS User""
  ) {
    // Should we always impersonate current user?
    boolean alwaysImpersonate = context.getConfiguration().get(
      HadoopConfigConstants.IMPERSONATION_ALWAYS_CURRENT_USER,
      false
    );

    // If so, propagate current user to ""user"" (the one to be impersonated)
    if(alwaysImpersonate) {
      if(!StringUtils.isEmpty(user)) {
        issues.add(context.createConfigIssue(configGroup, configName, Errors.HADOOP_00001));
      }
      user = context.getUserContext().getAliasName();
    }

    // If impersonated user is empty, simply return login UGI (no impersonation performed)
    if(StringUtils.isEmpty(user)) {
      return loginUser;
    }

    // Optionally lower case the user name
    boolean lowerCase = context.getConfiguration().get(
      HadoopConfigConstants.LOWERCASE_USER,
      false
    );
    if(lowerCase) {
      user = user.toLowerCase();
    }
    return UserGroupInformation.createProxyUser(user, loginUser);
  }",Get a proxy user for the given user name
"private void addWhere4ObjectPrint(final ObjectPrint _print)
    {
        final SQLWhere where = sqlSelect.getWhere();
        where.addCriteria(0, ""ID"", Comparison.EQUAL, String.valueOf(_print.getInstance().getId()), Connection.AND);
    }",Add where 4 object print.
"@Override
    public GetRegistrationCodeResult getRegistrationCode(GetRegistrationCodeRequest request) {
        request = beforeClientExecution(request);
        return executeGetRegistrationCode(request);
    }",Returns the code of a CA authority.
"public static double roundDoubleToClosest (double value, double steps) {
        final double down = DMatrixUtils.roundDoubleDownTo(value, steps);
        final double up = DMatrixUtils.roundDoubleUpTo(value, steps);
        if (Math.abs(value - down) < Math.abs(value - up)) {
            return down;
        }
        return up;
    }",Round double to closest.
"public void setObjects(Object injectionObject, Reference bindingObject)
                    throws InjectionException
    {
        final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();
        if (isTraceOn && tc.isDebugEnabled())
            Tr.debug(tc, ""setObjects"", injectionObject, bindingObjectToString(bindingObject));

        ivInjectedObject = injectionObject; // d392996.3

        if (bindingObject != null)
        {
            ivBindingObject = bindingObject;
            ivObjectFactoryClassName = bindingObject.getFactoryClassName(); // F48603.4
            if (ivObjectFactoryClassName == null) // F54050
            {
                throw new IllegalArgumentException(""expected non-null getFactoryClassName"");
            }
        }
        else
        {
            ivBindingObject = injectionObject;
        }
    }",Set the objects.
"@Override
  public FileStatus getFileStatus(Path f)  throws IOException {
    INode inode = store.retrieveINode(makeAbsolute(f));
    if (inode == null) {
      throw new FileNotFoundException(f + "": No such file or directory."");
    }
    return new S3FileStatus(f.makeQualified(this), inode);
  }",Get the FileStatus for a file or directory.
"@Override
    public void reload(ResourceConfig configuration) {
        ApplicationHandler applicationHandler = new ApplicationHandler(configuration, null, locator);
        applicationHandlerDelegate = new DefaultApplicationHandlerDelegate(applicationHandler);
        getApplicationHandler().onReload(this);
        applicationHandler.onStartup(this);
    }",Reload the application.
"public static void main(String[] args) throws Exception {
    Builder processingGraphBuilder = Builder.newBuilder();

    /**
     * A Pulsar source is constructed for a specific Pulsar installation, topic, and
     * subsecription.
     */
    Source<String> pulsarSource = new PulsarSource(
        ""pulsar://localhost:6650"", // Pulsar connection URL
        ""persistent://sample/standalone/ns1/heron-pulsar-test-topic"", // Pulsar topic
        ""subscription-1"" // Subscription name for the Pulsar topic
    );

    /**
     * In this processing graph, the source streamlet consists of messages on a
     * Pulsar topic. Those messages are simply logged without any processing logic
     * applied to them.
     */
    processingGraphBuilder.newSource(pulsarSource)
        .setName(""incoming-pulsar-messages"")
        .consume(s -> LOG.info(String.format(""Message received from Pulsar: \""%s\"""", s)));

    Config config = Config.defaultConfig();

    // Fetches the topology name from the first command-line argument
    String topologyName = StreamletUtils.getTopologyName(args);

    // Finally, the processing graph and configuration are passed to the Runner, which converts
    // the graph into a Heron topology that can be run in a Heron cluster.
    new Runner().run(topologyName, config, processingGraphBuilder);
  }",Main method for the Heron streamlet
"public static boolean hasBeanMethods(Class<?> type, String propertyName, Class<?> propertyType, boolean caseSensitive) {
        try {
            // if this succeeds without an exception, then the properties exist!
            @SuppressWarnings(""unused"")
            Method[] methods = getBeanMethods(type, propertyName, propertyType, caseSensitive);
            return true;
        } catch (Exception e) {
            return false;
        }
    }",Check if a bean has a method with the specified name and type.
"public void updateFaxJob(FaxJob faxJob,HTTPResponse httpResponse,FaxActionType faxActionType)
    {
        //get path
        String path=this.getPathToResponseData(faxActionType);

        //get fax job ID
        String id=this.findValue(httpResponse,path);
        
        if(id!=null)
        {
            faxJob.setID(id);
        }
    }",This function updates the fax job with the ID from the HTTP response data.
"@Override
    public void fit(DataSet dataSet) {
        featureStats = (S) newBuilder().addFeatures(dataSet).build();
        if (isFitLabel()) {
            labelStats = (S) newBuilder().addLabels(dataSet).build();
        }
    }",Fit the classifier with the data set.
"public static void loopBlocks(int start , int endExclusive , IntRangeConsumer consumer ) {
		final ForkJoinPool pool = BoofConcurrency.pool;
		int numThreads = pool.getParallelism();

		int range = endExclusive-start;
		if( range == 0 ) // nothing to do here!
			return;
		if( range < 0 )
			throw new IllegalArgumentException(""end must be more than start. ""+start+"" -> ""+endExclusive);

		// Did some experimentation here. Gave it more threads than were needed or exactly what was needed
		// exactly seemed to do better in the test cases
		int blockSize = Math.max(1,range/numThreads);

		try {
			pool.submit(new IntRangeTask(start,endExclusive,blockSize,consumer)).get();
		} catch (InterruptedException | ExecutionException e) {
			throw new RuntimeException(e);
		}
	}",Loop over blocks.
"@Override
    public void write(IChemObject object) throws CDKException {
        if (!(object instanceof IRGroupQuery)) {
            throw new CDKException(""Only IRGroupQuery input is accepted."");
        }
        try {

            IRGroupQuery rGroupQuery = (IRGroupQuery) object;
            String now = new SimpleDateFormat(""MMddyyHHmm"").format(System.currentTimeMillis());
            IAtomContainer rootAtc = rGroupQuery.getRootStructure();

            //Construct header
            StringBuffer rootBlock = new StringBuffer();
            String header = ""$MDL  REV  1   "" + now + LSEP + ""$MOL"" + LSEP + ""$HDR"" + LSEP
                    + ""  Rgroup query file (RGFile)"" + LSEP + ""  CDK    "" + now + ""2D"" + LSEP + LSEP + ""$END HDR""
                    + LSEP + ""$CTAB"";
            rootBlock.append(header).append(LSEP);

            //Construct the root structure, the scaffold
            String rootCTAB = getCTAB(rootAtc);
            rootCTAB = rootCTAB.replaceAll(LSEP + ""M  END"" + LSEP, """");
            rootBlock.append(rootCTAB).append(LSEP);

            //Write the root's LOG lines
            for (Integer rgrpNum : rGroupQuery.getRGroupDefinitions().keySet()) {
                RGroupList rgList = rGroupQuery.getRGroupDefinitions().get(rgrpNum);
                int restH = rgList.isRestH() ? 1 : 0;
                String logLine = ""M  LOG"" + MDLV2000Writer.formatMDLInt(1, 3) + MDLV2000Writer.formatMDLInt(rgrpNum, 4)
                        + MDLV2000Writer.formatMDLInt(rgList.getRequiredRGroupNumber(), 4)
                        + MDLV2000Writer.formatMDLInt(restH, 4) + ""   "" + rgList.getOccurrence();
                rootBlock.append(logLine).append(LSEP);
            }

            //AAL lines are optional, they are needed for R-atoms with multiple bonds to the root
            //for which the order of the attachment points can not be implicitly derived
            //from the order in the atom block. See CT spec for more on that.
            for (IAtom rgroupAtom : rGroupQuery.getRootAttachmentPoints().keySet()) {
                Map<Integer, IBond> rApo = rGroupQuery.getRootAttachmentPoints().get(rgroupAtom);
                if (rApo.size() > 1) {
                    int prevPos = -1;
                    int apoIdx = 1;
                    boolean implicitlyOrdered = true;
                    while (rApo.get(apoIdx) != null && implicitlyOrdered) {
                        IAtom partner = rApo.get(apoIdx).getOther(rgroupAtom);
                        for (int atIdx = 0; atIdx < rootAtc.getAtomCount(); atIdx++) {
                            if (rootAtc.getAtom(atIdx).equals(partner)) {
                                if (atIdx < prevPos) implicitlyOrdered = false;
                                prevPos = atIdx;
                                break;
                            }
                        }
                        apoIdx++;
                    }
                    if (!implicitlyOrdered) {
                        StringBuffer aalLine = new StringBuffer(""M  AAL"");
                        for (int atIdx = 0; atIdx < rootAtc.getAtomCount(); atIdx++) {
                            if (rootAtc.getAtom(atIdx).equals(rgroupAtom)) {
                                aalLine.append(MDLV2000Writer.formatMDLInt((atIdx + 1), 4));
                                aalLine.append(MDLV2000Writer.formatMDLInt(rApo.size(), 3));

                                apoIdx = 1;
                                while (rApo.get(apoIdx) != null) {
                                    IAtom partner = rApo.get(apoIdx).getOther(rgroupAtom);

                                    for (int a = 0; a < rootAtc.getAtomCount(); a++) {
                                        if (rootAtc.getAtom(a).equals(partner)) {
                                            aalLine.append(MDLV2000Writer.formatMDLInt(a + 1, 4));
                                            aalLine.append(MDLV2000Writer.formatMDLInt(apoIdx, 4));
                                        }
                                    }
                                    apoIdx++;
                                }
                            }
                        }
                        rootBlock.append(aalLine.toString()).append(LSEP);
                    }
                }
            }

            rootBlock.append(""M  END"").append(LSEP).append(""$END CTAB"").append(LSEP);

            //Construct each R-group block
            StringBuffer rgpBlock = new StringBuffer();
            for (Integer rgrpNum : rGroupQuery.getRGroupDefinitions().keySet()) {
                List<RGroup> rgrpList = rGroupQuery.getRGroupDefinitions().get(rgrpNum).getRGroups();
                if (rgrpList != null && rgrpList.size() != 0) {
                    rgpBlock.append(""$RGP"").append(LSEP);;
                    rgpBlock.append(MDLV2000Writer.formatMDLInt(rgrpNum, 4)).append(LSEP);

                    for (RGroup rgroup : rgrpList) {
                        //CTAB block
                        rgpBlock.append(""$CTAB"").append(LSEP);
                        String ctab = getCTAB(rgroup.getGroup());
                        ctab = ctab.replaceAll(LSEP + ""M  END"" + LSEP, """");
                        rgpBlock.append(ctab).append(LSEP);

                        //The APO line
                        IAtom firstAttachmentPoint = rgroup.getFirstAttachmentPoint();
                        IAtom secondAttachmentPoint = rgroup.getSecondAttachmentPoint();
                        int apoCount = 0;
                        if (firstAttachmentPoint != null) {
                            StringBuffer apoLine = new StringBuffer();
                            for (int atIdx = 0; atIdx < rgroup.getGroup().getAtomCount(); atIdx++) {
                                if (rgroup.getGroup().getAtom(atIdx).equals(firstAttachmentPoint)) {
                                    apoLine.append(MDLV2000Writer.formatMDLInt((atIdx + 1), 4));
                                    apoCount++;
                                    if (secondAttachmentPoint != null
                                            && secondAttachmentPoint.equals(firstAttachmentPoint)) {
                                        apoLine.append(MDLV2000Writer.formatMDLInt(3, 4));
                                    } else {
                                        apoLine.append(MDLV2000Writer.formatMDLInt(1, 4));
                                    }
                                }
                            }
                            if (secondAttachmentPoint != null && !secondAttachmentPoint.equals(firstAttachmentPoint)) {
                                for (int atIdx = 0; atIdx < rgroup.getGroup().getAtomCount(); atIdx++) {
                                    if (rgroup.getGroup().getAtom(atIdx).equals(secondAttachmentPoint)) {
                                        apoCount++;
                                        apoLine.append(MDLV2000Writer.formatMDLInt((atIdx + 1), 4));
                                        apoLine.append(MDLV2000Writer.formatMDLInt(2, 4));
                                    }
                                }
                            }
                            if (apoCount > 0) {
                                apoLine.insert(0, ""M  APO"" + MDLV2000Writer.formatMDLInt(apoCount, 3));
                                rgpBlock.append(apoLine).append(LSEP);
                            }
                        }

                        rgpBlock.append(""M  END"").append(LSEP);
                        rgpBlock.append(""$END CTAB"").append(LSEP);
                    }
                    rgpBlock.append(""$END RGP"").append(LSEP);
                }
            }
            rgpBlock.append(""$END MOL"").append(LSEP);

            writer.write(rootBlock.toString());
            writer.write(rgpBlock.toString());
            writer.flush();

        } catch (IOException e) {
            e.printStackTrace();
            throw new CDKException(""Unexpected exception when writing RGFile"" + LSEP + e.getMessage());
        }

    }",Write the IChemObject to the PDB file.
"public AlluxioURI joinUnsafe(String suffix) {
    String path = getPath();
    StringBuilder sb = new StringBuilder(path.length() + 1 + suffix.length());

    return new AlluxioURI(this,
        sb.append(path).append(AlluxioURI.SEPARATOR).append(suffix).toString(), false);
  }",Join this Alluxio URI with the specified suffix.
"public void delete_attribute_property(String attname, String[] propnames) throws DevFailed {
        database.delete_device_attribute_property(deviceName, attname, propnames);
    }",Delete an attribute s property.
"protected void switchToCurrentProject() throws CmsException {

        if (m_currentProjectId != null) {
            // switch back to the current users project
            getCms().getRequestContext().setCurrentProject(getCms().readProject(m_currentProjectId));
        }
    }",Switches the current project to the users project.
"public static XWPFRun getNewRun(ParagraphAlignment alignment) {
        createXwpfDocumentIfNull();
        XWPFParagraph paragraph = xwpfDocument.createParagraph();
        paragraph.setAlignment(alignment);
        return paragraph.createRun();
    }",Get a new run with the specified alignment.
"@Override
  public void trimContexts()
  {
    for (int index = 0; index < this.frames.length; ++index) {
      final Frame f = this.frames[index];
      f.trimRecursive();
    }

    this.frame_index = 0;
  }",Trims all the contexts in this sequence.
"public List<SystemEventListener> getListenersForEventClass(Class<? extends SystemEvent> facesEventClass) {

        if (null == listener) {
            List<SystemEventListener> list = new ArrayList<SystemEventListener>(1);
            list.add(context.getExceptionHandler());
            listener = Collections.unmodifiableList(list);
        }
        return listener;

    }",Gets the listeners for the given event class.
"public void marshall(AddLayerVersionPermissionRequest addLayerVersionPermissionRequest, ProtocolMarshaller protocolMarshaller) {

        if (addLayerVersionPermissionRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getLayerName(), LAYERNAME_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getVersionNumber(), VERSIONNUMBER_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getStatementId(), STATEMENTID_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getAction(), ACTION_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getPrincipal(), PRINCIPAL_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getOrganizationId(), ORGANIZATIONID_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getRevisionId(), REVISIONID_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given AddLayerVersionPermissionRequest to the given protocolMarshaller.
"public static WritableDoubleDataStore makeDoubleStorage(DBIDs ids, int hints) {
    return DataStoreFactory.FACTORY.makeDoubleStorage(ids, hints);
  }",Make a WritableDoubleDataStore for a CID   .
"@CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable fromFuture(final Future<?> future) {
        ObjectHelper.requireNonNull(future, ""future is null"");
        return fromAction(Functions.futureAction(future));
    }",Construct a new instance from a future of tokens.
"public static int copyWriterCount(final Reader in, final Writer out) throws IOException {
        final char[] buffer = new char[10240];
        int tot=0;
        int c;
        c = in.read(buffer);
        while (c >= 0) {
            if (c > 0) {
                out.write(buffer, 0, c);
                tot += c;
            }
            c = in.read(buffer);
        }
        return tot;
    }",Copy the reader count to the writer.
"private Asciidoctor getAsciidoctor() {
        if (asciidoctor == null) {
            asciidoctor = AsciidoctorFactory.getAsciidoctor();
            treeprocessor = new Treeprocessor();
            IgnoreIncludeProcessor includeProcessor = new IgnoreIncludeProcessor();
            JavaExtensionRegistry extensionRegistry = asciidoctor.javaExtensionRegistry();
            extensionRegistry.treeprocessor(treeprocessor);
            extensionRegistry.includeProcessor(includeProcessor);
        }
        return asciidoctor;
    }",Gets the Asciidoctor.
"public GetDomainStatisticsResponse getDomainStatistics(GetDomainStatisticsRequest request) {
        checkNotNull(request, ""The parameter request should NOT be null."");

        checkStringNotEmpty(request.getDomain(), ""Domain should NOT be empty."");
        InternalRequest internalRequest = createRequest(HttpMethodName.GET, request, STATISTICS,
                LIVE_DOMAIN, request.getDomain());
        if (request.getStartDate() != null) {
            internalRequest.addParameter(""startDate"", request.getStartDate());
        }
        if (request.getEndDate() != null) {
            internalRequest.addParameter(""endDate"", request.getEndDate());
        }
        if (request.getAggregate() != null) {
            internalRequest.addParameter(""aggregate"", request.getAggregate().toString());
        }
        return invokeHttpClient(internalRequest, GetDomainStatisticsResponse.class);
    }",Get domain statistics with specified attributes.
"@PostMapping(
      value = ""/{entityTypeId}/{id}"",
      params = ""_method=GET"",
      produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public Map<String, Object> retrieveEntity(
      @PathVariable(""entityTypeId"") String entityTypeId,
      @PathVariable(""id"") String untypedId,
      @Valid @RequestBody EntityTypeRequest request) {
    Set<String> attributesSet = toAttributeSet(request != null ? request.getAttributes() : null);
    Map<String, Set<String>> attributeExpandSet =
        toExpandMap(request != null ? request.getExpand() : null);

    EntityType meta = dataService.getEntityType(entityTypeId);
    Object id = getTypedValue(untypedId, meta.getIdAttribute());
    Entity entity = dataService.findOneById(entityTypeId, id);

    if (entity == null) {
      throw new UnknownEntityException(meta, untypedId);
    }

    return getEntityAsMap(entity, meta, attributesSet, attributeExpandSet);
  }",Retrieve a single entity from the database.
"public static Long parseLong(String param) {
		try {
			if (!StringUtils.isBlank(param)) {
				return Long.valueOf(param);
			}
		} catch (Exception e) {
			throw new IllegalArgumentException(""Parameter "" + param + "" is not a number."");
		}
		return null;
	}",Parses a string to a Long.
"protected void redraw() {
    long tstart = System.currentTimeMillis();

    java.awt.Graphics2D gNP = np.getBufferedImageGraphics();
    if (gNP == null) // panel not drawn on screen yet
      return;

    // clear it
    gNP.setBackground(np.getBackgroundColor());
    java.awt.Rectangle r = gNP.getClipBounds();
    gNP.clearRect(r.x, r.y, r.width, r.height);

    if (regionSelect && geoSelectionMode) {
      if (geoSelection != null) drawBB(gNP, geoSelection, Color.cyan);
      if (geoBounds != null) drawBB(gNP, geoBounds, null);
      // System.out.println(""GeoRegionChooser.redraw geoBounds= ""+geoBounds);

      if (geoSelection != null) {
        // gNP.setColor( Color.orange);
        Navigation navigate = np.getNavigation();
        double handleSize = RubberbandRectangleHandles.handleSizePixels / navigate.getPixPerWorld();
        Rectangle2D rect = new Rectangle2D.Double(geoSelection.getX(), geoSelection.getY(), geoSelection.getWidth(), geoSelection.getHeight());
        RubberbandRectangleHandles.drawHandledRect(gNP, rect, handleSize);
        if (debug) System.out.println(""GeoRegionChooser.drawHandledRect="" + handleSize + "" = "" + geoSelection);
      }
    }

    for (int i = 0; i < renderers.size(); i++) {
      ucar.nc2.ui.util.Renderer rend = (Renderer) renderers.get(i);
      rend.draw(gNP, atI);
    }
    gNP.dispose();

    if (debug) {
      long tend = System.currentTimeMillis();
      System.out.println(""StationRegionDateChooser draw time = "" + (tend - tstart) / 1000.0 + "" secs"");
    }

    // copy buffer to the screen
    np.repaint();
  }",redraw the station region panel
"@javax.annotation.Nonnull
  public com.simiacryptus.util.data.DoubleStatistics combine(@javax.annotation.Nonnull final com.simiacryptus.util.data.DoubleStatistics other) {
    super.combine(other);
    simpleSumOfSquare += other.simpleSumOfSquare;
    sumOfSquareWithCompensation(other.sumOfSquare);
    sumOfSquareWithCompensation(other.sumOfSquareCompensation);
    return this;
  }",Combine two double statistics.
"@NonNull
    public Intent build() {
        Uri mailtoUri = constructMailtoUri();
        return new Intent(Intent.ACTION_SENDTO, mailtoUri);
    }",Build an Intent to send the SMS to the user.
"@Override
	public RandomVariable getValue(double evaluationTime, AssetModelMonteCarloSimulationModel model) throws CalculationException {
		if(exerciseMethod == ExerciseMethod.UPPER_BOUND_METHOD) {
			// Find optimal lambda
			GoldenSectionSearch optimizer = new GoldenSectionSearch(-1.0, 1.0);
			while(!optimizer.isDone()) {
				double lambda = optimizer.getNextPoint();
				double value = this.getValues(evaluationTime, model, lambda).getAverage();
				optimizer.setValue(value);
			}
			return getValues(evaluationTime, model, optimizer.getBestPoint());
		}
		else {
			return getValues(evaluationTime, model, 0.0);
		}
	}",This method returns the value of the Cashflows model optimizer.
"private <T> Creator<T> register(ConstructorKey key, Constructor<T> constructor, CreationModifier<T> modifier) {

        Creator<T> creator = new ReflectionCreator<T>(constructor);

        if (modifier != null) creator = new ModifiedCreator<T>(creator, modifier);

        return register(key, creator);
    }",Register a new class with the constructor.
"public void set( List<Point2D_F64> list ) {
		vertexes.resize(list.size());
		for (int i = 0; i < list.size(); i++) {
			vertexes.data[i].set( list.get(i));
		}
	}",Sets the list of vertexes to be the same as the input.
"public void setExportIds(java.util.Collection<String> exportIds) {
        if (exportIds == null) {
            this.exportIds = null;
            return;
        }

        this.exportIds = new java.util.ArrayList<String>(exportIds);
    }",Sets the value of the exportIds property.
"public UrlChain moreUrl(Object... urlParts) {
        final String argTitle = ""urlParts"";
        assertArgumentNotNull(argTitle, urlParts);
        checkWrongUrlChainUse(argTitle, urlParts);
        this.urlParts = urlParts;
        return this;
    }",Add more urls to the url chain.
"@Override
    protected void compareData(ITable expectedTable, ITable actualTable, ComparisonColumn[] comparisonCols, FailureHandler failureHandler) throws DataSetException {
        logger.debug(""compareData(expectedTable={}, actualTable={}, ""
                        + ""comparisonCols={}, failureHandler={}) - start"",
                new Object[]{expectedTable, actualTable, comparisonCols,
                        failureHandler});

        if (expectedTable == null) {
            throw new NullPointerException(
                    ""The parameter 'expectedTable' must not be null"");
        }
        if (actualTable == null) {
            throw new NullPointerException(
                    ""The parameter 'actualTable' must not be null"");
        }
        if (comparisonCols == null) {
            throw new NullPointerException(
                    ""The parameter 'comparisonCols' must not be null"");
        }
        if (failureHandler == null) {
            throw new NullPointerException(
                    ""The parameter 'failureHandler' must not be null"");
        }

        // iterate over all rows
        for (int i = 0; i < expectedTable.getRowCount(); i++) {
            // iterate over all columns of the current row
            for (int j = 0; j < comparisonCols.length; j++) {
                ComparisonColumn compareColumn = comparisonCols[j];

                String columnName = compareColumn.getColumnName();
                DataType dataType = compareColumn.getDataType();

                Object expectedValue = expectedTable.getValue(i, columnName);
                Object actualValue = actualTable.getValue(i, columnName);

                // Compare the values
                if (skipCompare(columnName, expectedValue, actualValue)) {
                    if (logger.isTraceEnabled()) {
                        logger.trace(""ignoring comparison "" + expectedValue + ""="" +
                                actualValue + "" on column "" + columnName);
                    }
                    continue;
                }

                if(expectedValue != null && expectedValue.toString().startsWith(""regex:"")){
                    if(!regexMatches(expectedValue.toString(),actualValue.toString())){
                        Difference diff = new Difference(
                                expectedTable, actualTable,
                                i, columnName,
                                expectedValue, actualValue);

                        // Handle the difference (throw error immediately or something else)
                        failureHandler.handle(diff);
                    }
                }
                else if (dataType.compare(expectedValue, actualValue) != 0) {

                    Difference diff = new Difference(
                            expectedTable, actualTable,
                            i, columnName,
                            expectedValue, actualValue);

                    // Handle the difference (throw error immediately or something else)
                    failureHandler.handle(diff);
                }
            }
        }
    }",Compare data.
"public Response addItem( HttpServletRequest request,
                             String repositoryName,
                             String workspaceName,
                             String path,
                             String requestBody ) throws JSONException, RepositoryException {
        JSONObject requestBodyJSON = stringToJSONObject(requestBody);

        String parentAbsPath = parentPath(path);
        String newNodeName = newNodeName(path);

        Session session = getSession(request, repositoryName, workspaceName);
        Node parentNode = (Node)session.getItem(parentAbsPath);
        Node newNode = addNode(parentNode, newNodeName, requestBodyJSON);

        session.save();
        RestItem restNewNode = createRestItem(request, 0, session, newNode);
        return Response.status(Response.Status.CREATED).entity(restNewNode).build();
    }",Add a new item to the cache.
"@Override
    public void warning(String message, String sourceName, int offset, int length)
    {
        errors.add(new ParseProblem(ParseProblem.Type.Warning,
                                    message, sourceName,
                                    offset, length));
    }",Report a warning.
"private void parameterize(Parameterized parameterized) {
		try {
			parameterized.configure(parameters);
		} catch (RuntimeException ex) {
			throw new ProgramParametrizationException(ex.getMessage());
		}
	}",Parameterizes the given parameterized object.
"public void moveResource(CmsDbContext dbc, CmsResource source, String destination, boolean internal)
    throws CmsException {

        CmsFolder destinationFolder = readFolder(dbc, CmsResource.getParentFolder(destination), CmsResourceFilter.ALL);
        m_securityManager.checkPermissions(
            dbc,
            destinationFolder,
            CmsPermissionSet.ACCESS_WRITE,
            false,
            CmsResourceFilter.ALL);

        if (source.isFolder()) {
            m_monitor.flushCache(CmsMemoryMonitor.CacheType.HAS_ROLE, CmsMemoryMonitor.CacheType.ROLE_LIST);
        }
        getVfsDriver(dbc).moveResource(dbc, dbc.getRequestContext().getCurrentProject().getUuid(), source, destination);

        if (!internal) {
            CmsResourceState newState = CmsResource.STATE_CHANGED;
            if (source.getState().isNew()) {
                newState = CmsResource.STATE_NEW;
            } else if (source.getState().isDeleted()) {
                newState = CmsResource.STATE_DELETED;
            }
            source.setState(newState);
            // safe since this operation always uses the ids instead of the resource path
            getVfsDriver(dbc).writeResourceState(
                dbc,
                dbc.currentProject(),
                source,
                CmsDriverManager.UPDATE_STRUCTURE_STATE,
                false);
            // log it
            log(
                dbc,
                new CmsLogEntry(
                    dbc,
                    source.getStructureId(),
                    CmsLogEntryType.RESOURCE_MOVED,
                    new String[] {source.getRootPath(), destination}),
                false);
        }

        CmsResource destRes = readResource(dbc, destination, CmsResourceFilter.ALL);
        // move lock
        m_lockManager.moveResource(source.getRootPath(), destRes.getRootPath());

        // flush all relevant caches
        m_monitor.clearAccessControlListCache();
        m_monitor.flushCache(
            CmsMemoryMonitor.CacheType.PROPERTY,
            CmsMemoryMonitor.CacheType.PROPERTY_LIST,
            CmsMemoryMonitor.CacheType.PROJECT_RESOURCES);

        List<CmsResource> resources = new ArrayList<CmsResource>(4);
        // source
        resources.add(source);
        try {
            resources.add(readFolder(dbc, CmsResource.getParentFolder(source.getRootPath()), CmsResourceFilter.ALL));
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(e);
            }
        }
        // destination
        resources.add(destRes);
        resources.add(destinationFolder);

        Map<String, Object> eventData = new HashMap<String, Object>();
        eventData.put(I_CmsEventListener.KEY_RESOURCES, resources);
        eventData.put(I_CmsEventListener.KEY_DBCONTEXT, dbc);

        // fire the events
        OpenCms.fireCmsEvent(new CmsEvent(I_CmsEventListener.EVENT_RESOURCE_MOVED, eventData));
    }",Moves a resource from one location to another.
"public List<Object> getClauseValue(String paramString) {
        if (typedParameter != null && typedParameter.getParameters() != null) {
            List<FilterClause> clauses = typedParameter.getParameters().get(paramString);
            if (clauses != null) {
                return clauses.get(0).getValue();
            } else {
                throw new IllegalArgumentException(""parameter is not a parameter of the query"");
            }
        }

        logger.error(""Parameter {} is not a parameter of the query."", paramString);
        throw new IllegalArgumentException(""Parameter is not a parameter of the query."");
    }",Gets the clause value for the parameter.
"public ClientStatsContext fetch() {
        m_current = m_distributor.getStatsSnapshot();
        m_currentIO = m_distributor.getIOStatsSnapshot();
        m_currentTS = System.currentTimeMillis();
        m_currentAffinity = m_distributor.getAffinityStatsSnapshot();
        return this;
    }",Fetch the client stats from the cache.
"public DeleteVpcEndpointServiceConfigurationsRequest withServiceIds(String... serviceIds) {
        if (this.serviceIds == null) {
            setServiceIds(new com.amazonaws.internal.SdkInternalList<String>(serviceIds.length));
        }
        for (String ele : serviceIds) {
            this.serviceIds.add(ele);
        }
        return this;
    }",Sets the value of the serviceIds property.
"protected void initializeClient(JestClient client, String indexName, String defaultIndexName) {
        try {
            client.execute(new Health.Builder().build());
            Action<JestResult> action = new IndicesExists.Builder(indexName).build();
            // There was occasions where a race occurred here when multiple threads try to
            // create the index simultaneously. This caused a non-fatal, but annoying, exception.
            synchronized(AbstractClientFactory.class) {
                JestResult result = client.execute(action);
                if (!result.isSucceeded()) {
                    createIndex(client, indexName, defaultIndexName + ""-settings.json""); //$NON-NLS-1$
                }
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }",Initialize the client.
"public final static double roundToDecimals(double d, int c) {
		if(c < 0) return d;
		double p = Math.pow(10,c);
		d = d * p;
		double tmp = Math.round(d);
		return tmp/p;
	}",Round to decimals.
"private static boolean incrementLexicographically(
        MutableLongTuple current, LongTuple min, LongTuple max, int index)
    {
        if (index == -1)
        {
            return false;
        }
        long oldValue = current.get(index);
        long newValue = oldValue + 1;
        current.set(index, newValue);
        if (newValue >= max.get(index))
        {
            current.set(index, min.get(index));
            return incrementLexicographically(current, min, max, index-1);
        }
        return true;
    }",Increments the value of the Nth entry in the MutableLongTuple by one and increments the value of the Nth entry in the MutableLongTuple.
"public static <T> PVectorByteBufferedIntegral2s64<T> createWithBase(
    final ByteBuffer b,
    final MutableLongType base,
    final int offset)
  {
    return new PVectorByteBufferedIntegral2s64<>(b, base, offset);
  }",Creates a new PVectorByteBufferedIntegral2s64 object with the given ByteBuffer and MutableLongType base and offset.
"public T loadXml(String locationUrl) {

    DataResource resource = this.resourceFactory.createDataResource(locationUrl);
    return loadXml(resource);
  }",Load a CID    from a XML file.
"@Override
  public char[] transformIn(String inStr) throws CpoException {
    char[] retChars = null;

    if (inStr != null) {
      retChars = inStr.toCharArray();
    }

    return retChars;
  }",Transform in.
"public int executeUpdate() throws SQLException {
        return executeUpdate(new Updater() {
            
            @Override
            public int executeUpdate(final Statement statement, final String sql) throws SQLException {
                return statement.executeUpdate(sql);
            }
        });
    }",Execute an SQL update.
"public com.google.appengine.v1.UrlMap getHandlers(int index) {
    return handlers_.get(index);
  }",Gets the handlers at the given index.
"@XmlElementDecl(namespace = """", name = ""stp_duplex"")
    public JAXBElement<Stellplatz> createStpDuplex(Stellplatz value) {
        return new JAXBElement<Stellplatz>(_StpDuplex_QNAME, Stellplatz.class, null, value);
    }",Create an instance of a Stellplatz in the CTC namespace.
"public void changeFile(File file) throws FileNotFoundException {
        if (isTailing()) {
            throw new IllegalStateException(""Cannot Change FileTailer.file while current instance is tailing"");
        } else {
            if (file == null) {
                throw new NullPointerException(""changeFile(File argument) cannot be null"");
            } else if (!file.exists()) {
                throw new FileNotFoundException(""File does not exist: "" + file.getAbsolutePath());
            }
            this.file = file;
        }
    }",Changes the file of the file tailer.
"public void addFilter(final ItemFilter filter) {
        if (filters == null) {
            filters = new ArrayList<ItemFilter>();
        }

        filters.add(filter);
    }",Add a filter to the list of filters.
"public DynamicImageField<T> addDynamicImageField(int viewResId, StringExtractor<T> extractor,
                                                     DynamicImageLoader dynamicImageLoader) {

        DynamicImageField<T> field =
                new DynamicImageField<T>(viewResId, extractor, dynamicImageLoader);

        mDynamicImageFields.add(field);

        return field;
    }",Add a dynamic image field to the list of dynamic image fields.
"public void setBinding(String binding) 
        throws JspException {
        if (binding!= null && !UIComponentTag.isValueReference(binding)) {
            // PENDING i18n
            throw new JspException(""Invalid Expression:""+binding);
        }
        this.binding = binding;
    }",Sets the binding for this tag.
"protected void commitResponse(final SecurityContext securityContext, final HttpServletRequest request, final HttpServletResponse response, final RestMethodResult result, final boolean wrapSingleResultInArray) {

		final String outputDepthSrc       = request.getParameter(REQUEST_PARAMTER_OUTPUT_DEPTH);
		final int outputDepth             = Services.parseInt(outputDepthSrc, config.getOutputNestingDepth());
		final String baseUrl              = request.getRequestURI();
		final Map<String, String> headers = result.getHeaders();

		// set headers
		for (final Entry<String, String> header : headers.entrySet()) {
			response.setHeader(header.getKey(), header.getValue());
		}

		// set  response code
		response.setStatus(result.getResponseCode());

		try {

			final List<Object> content = result.getContent();
			if (content != null) {

				writeJson(securityContext, response, new PagingIterable(content), baseUrl, outputDepth, wrapSingleResultInArray);

			} else {

				final String message = result.getMessage();
				if (message != null) {

					writeStatus(response, result.getResponseCode(), message);

				} else {

					final Object nonGraphObjectResult = result.getNonGraphObjectResult();
					writeJson(securityContext, response, new PagingIterable(Arrays.asList(nonGraphObjectResult)), baseUrl, outputDepth, wrapSingleResultInArray);
				}

			}

		} catch (JsonIOException | IOException t) {

			logger.warn(""Unable to commit HttpServletResponse"", t);
		}
	}",Commit the response.
"public final void mT__141() throws RecognitionException {
        try {
            int _type = T__141;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // InternalSARL.g:127:8: ( 'finally' )
            // InternalSARL.g:127:10: 'finally'
            {
            match(""finally""); 


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }",start T__141
"public final Ix<T> skipWhile(IxPredicate<? super T> predicate) {
        return new IxSkipWhile<T>(this, nullCheck(predicate, ""predicate is null""));
    }",Creates an IxSkipWhile sequence that iterates over the elements of this sequence which are not skipped by the given predicate.
"public static <T, U> Function<T, U> memoize(final Function<T, U> function) {
    return new Memoizer<T, U>().doMemoize(function);
  }",Memoize a function.
"public T xpath(String expression, String value) {
        if (xpathMessageConstructionInterceptor == null) {
            xpathMessageConstructionInterceptor = new XpathMessageConstructionInterceptor();

            if (getAction().getMessageBuilder() != null) {
                (getAction().getMessageBuilder()).add(xpathMessageConstructionInterceptor);
            } else {
                PayloadTemplateMessageBuilder messageBuilder = new PayloadTemplateMessageBuilder();
                messageBuilder.getMessageInterceptors().add(xpathMessageConstructionInterceptor);

                getAction().setMessageBuilder(messageBuilder);
            }
        }

        xpathMessageConstructionInterceptor.getXPathExpressions().put(expression, value);
        return self;
    }",Adds an XPath expression to the message builder.
"public Iterable<DConnection> queryByUpdatedBy(java.lang.String updatedBy) {
    return queryByField(null, DConnectionMapper.Field.UPDATEDBY.getFieldName(), updatedBy);
  }",query - by method for field updatedBy
"Description validate(Tree tree, VisitorState state) {
    GuardedByValidationResult result = GuardedByUtils.isGuardedByValid(tree, state);
    if (result.isValid()) {
      return Description.NO_MATCH;
    }
    return buildDescription(tree)
        .setMessage(String.format(""Invalid @GuardedBy expression: %s"", result.message()))
        .build();
  }",Validate a GuardedBy expression.
"public Table getTable(String tableName) {
    // [START ]
    Table table = dataset.get(tableName);
    // [END ]
    return table;
  }",Get a table from the dataset.
"private CmsADEConfigData getConfigData(String pageRootPath) {

        if (m_configData == null) {
            m_configData = OpenCms.getADEManager().lookupConfiguration(getCmsObject(), pageRootPath);
        }
        return m_configData;
    }",Gets the configuration data.
"public static File getOwnCacheDirectory(Context context, String cacheDir) {
		File appCacheDir = null;
		if (MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) && hasExternalStoragePermission(context)) {
			appCacheDir = new File(Environment.getExternalStorageDirectory(), cacheDir);
		}
		if (appCacheDir == null || (!appCacheDir.exists() && !appCacheDir.mkdirs())) {
			appCacheDir = context.getCacheDir();
		}
		return appCacheDir;
	}",Get the cache directory that is owned by the current user.
"public void marshall(SamplingRuleRecord samplingRuleRecord, ProtocolMarshaller protocolMarshaller) {

        if (samplingRuleRecord == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(samplingRuleRecord.getSamplingRule(), SAMPLINGRULE_BINDING);
            protocolMarshaller.marshall(samplingRuleRecord.getCreatedAt(), CREATEDAT_BINDING);
            protocolMarshaller.marshall(samplingRuleRecord.getModifiedAt(), MODIFIEDAT_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given samplingRuleRecord to the JSON object.
"protected static String getFirstSpecifiedKeyID(final JWKMatcher jwkMatcher) {

		Set<String> keyIDs = jwkMatcher.getKeyIDs();

		if (keyIDs == null || keyIDs.isEmpty()) {
			return null;
		}

		for (String id: keyIDs) {
			if (id != null) {
				return id;
			}
		}
		return null; // No kid in matcher
	}",Gets the first specified kid in the JWKMatcher.
"public void log(LogLevel level, String msg, Throwable t)
	{
		if (level != LogLevel.OFF && level.level <= logLevel.level)
			logger.add(writers, name, level, msg, t);
	}",Add a message to the logger.
"private String getEmailAddresses() {

        List<String> emails = new ArrayList<String>();
        Iterator<String> itIds = idsList().iterator();
        while (itIds.hasNext()) {
            String id = itIds.next();
            CmsSessionInfo session = OpenCms.getSessionManager().getSessionInfo(id);
            if (session != null) {
                try {
                    String emailAddress = getCms().readUser(session.getUserId()).getEmail();
                    if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(emailAddress) && !emails.contains(emailAddress)) {
                        emails.add(emailAddress);
                    }
                } catch (Exception e) {
                    LOG.error(e.getLocalizedMessage(), e);
                }
            }
        }
        StringBuffer result = new StringBuffer(256);
        Iterator<String> itEmails = emails.iterator();
        while (itEmails.hasNext()) {
            result.append(itEmails.next());
            if (itEmails.hasNext()) {
                result.append(""; "");
            }
        }
        return result.toString();
    }",Returns the list of email addresses for all the session ids.
"public static long delayResponse() {
    Call call = CurCall.get();
    long res = 0;
    if (call != null) {
      call.delayResponse();
      res = delayedRpcId.getAndIncrement();
      delayedCalls.put(res, call);
    }
    return res;
  }",Delay the response.
"public <T> T safeGet(String fieldName){
		try {
			return get(fieldName);
		} catch (Exception e) {
			return null;
		}
	}",Get a field from the underlying resource.
"@XmlElementDecl(namespace = """", name = ""anzahl_badezimmer"")
    @XmlJavaTypeAdapter(Adapter2 .class)
    public JAXBElement<BigDecimal> createAnzahlBadezimmer(BigDecimal value) {
        return new JAXBElement<BigDecimal>(_AnzahlBadezimmer_QNAME, BigDecimal.class, null, value);
    }",Create an instance of an AnzahlBadezimmer in einen Tagen der angegebenen Badezimmer.
"protected void readHeader(ByteBuffer buffer) {
    super.readHeader(buffer);
    if (this.responseStatus == ResponseStatus.NO_ERROR) {
      this.decodeStatus = BinaryDecodeStatus.DONE;
    }
  }",readHeader This method is called to read the header of the response.
"@Override
    public UpdateXssMatchSetResult updateXssMatchSet(UpdateXssMatchSetRequest request) {
        request = beforeClientExecution(request);
        return executeUpdateXssMatchSet(request);
    }",Updates an XSSMatchSet.
"private static void verifyAncestry(Class<?> tClass) {
    if (!TBase.class.isAssignableFrom(tClass)) {
      Utils.ensureClassLoaderConsistency(TBase.class, tClass.getClassLoader());
      throw new ClassCastException(tClass.getName() + "" is not a Thrift class"");
    }
  }",Verify that the given class is a Thrift class.
"public static InstrumentedThreadFactory defaultThreadFactory(MetricRegistry registry, String name) {
        return new InstrumentedThreadFactory(Executors.defaultThreadFactory(), registry, name);
    }",Create a thread factory that uses the default thread factory.
"public AbucoinsOrderBook getAbucoinsOrderBook(String productID, AbucoinsOrderBookLevel level)
      throws IOException {
    return abucoins.getBook(productID, level.name());
  }",Get a Book object from a product ID and level
"static boolean isSignatureAssignable( Class[] from, Class[] to, int round )
    {
        if ( round != JAVA_VARARGS_ASSIGNABLE && from.length != to.length )
            return false;

        switch ( round )
        {
            case JAVA_BASE_ASSIGNABLE:
                for( int i=0; i<from.length; i++ )
                    if ( !isJavaBaseAssignable( to[i], from[i] ) )
                        return false;
                return true;
            case JAVA_BOX_TYPES_ASSIGABLE:
                for( int i=0; i<from.length; i++ )
                    if ( !isJavaBoxTypesAssignable( to[i], from[i] ) )
                        return false;
                return true;
            case JAVA_VARARGS_ASSIGNABLE:
                return isSignatureVarargsAssignable( from, to );
            case BSH_ASSIGNABLE:
                for( int i=0; i<from.length; i++ )
                    if ( !isBshAssignable( to[i], from[i] ) )
                        return false;
                return true;
            default:
                throw new InterpreterError(""bad case"");
        }
    }",Checks if the signature is assignable.
"public void start() {
        application = new CitrusRemoteApplication(configuration);
        port(configuration.getPort());
        application.init();

        if (!configuration.isSkipTests()) {
            new RunController(configuration).run();
        }

        if (configuration.getTimeToLive() == 0) {
            stop();
        }
    }",Start the application.
"private CmsInternalLinksValidator getValidator() {

        if (m_validator == null) {
            // get the content check result object
            Map objects = (Map)getSettings().getDialogObject();
            Object o = objects.get(CmsInternalLinkValidationDialog.class.getName());
            List resources = new ArrayList();
            if ((o != null) && (o instanceof List)) {
                resources = (List)o;
            }
            m_validator = new CmsInternalLinksValidator(getCms(), resources);
        }
        return m_validator;
    }",Gets the internal links validator.
"public static SqlExpressionGroup exps(String name, String op, Object value) {
        return exps(exp(name, op, value));
    }",Returns an ExpressionGroup representing a single Identity class expression.
"public static ClassFile buildClassFile(String className, Class<?>[] classes)
        throws IllegalArgumentException
    {
        return buildClassFile(className, classes, null, null, OBSERVER_DISABLED);
    }",Build a ClassFile from a class name and a list of classes.
"public static Document readXML(Reader reader) throws IOException, SAXException, ParserConfigurationException {
		assert reader != null : AssertMessages.notNullParameter();
		try {
			final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			final DocumentBuilder builder = factory.newDocumentBuilder();
			return builder.parse(new InputSource(reader));
		} finally {
			reader.close();
		}
	}",Read XML from a reader.
"public static clusternodegroup_nslimitidentifier_binding[] get(nitro_service service, String name) throws Exception{
		clusternodegroup_nslimitidentifier_binding obj = new clusternodegroup_nslimitidentifier_binding();
		obj.set_name(name);
		clusternodegroup_nslimitidentifier_binding response[] = (clusternodegroup_nslimitidentifier_binding[]) obj.get_resources(service);
		return response;
	}",Use this API to fetch clusternodegroup_nslimitidentifier_binding resources of given name.
"protected final List<DCSubject> parseSubjects(final List<Element> eList) {

        final List<DCSubject> subjects = new ArrayList<DCSubject>();

        for (final Element eSubject : eList) {

            final Element description = eSubject.getChild(""Description"", getRDFNamespace());

            if (description != null) {

                final String taxonomy = getTaxonomy(description);

                final List<Element> values = description.getChildren(""value"", getRDFNamespace());
                for (final Element value : values) {

                    final DCSubject subject = new DCSubjectImpl();
                    subject.setTaxonomyUri(taxonomy);
                    subject.setValue(value.getText());
                    subjects.add(subject);

                }

            } else {
                final DCSubject subject = new DCSubjectImpl();
                subject.setValue(eSubject.getText());
                subjects.add(subject);
            }
        }

        return subjects;
    }",Parses the Subjects.
"public static INDArrayIndex[] createCoveringShape(int[] shape) {
        INDArrayIndex[] ret = new INDArrayIndex[shape.length];
        for (int i = 0; i < ret.length; i++) {
            ret[i] = NDArrayIndex.interval(0, shape[i]);
        }
        return ret;
    }",Create covering shape
"public WritableGridFileChannel getWritableChannel(String pathname, boolean append, int chunkSize) throws IOException {
      GridFile file = (GridFile) getFile(pathname, chunkSize);
      checkIsNotDirectory(file);
      createIfNeeded(file);
      return new WritableGridFileChannel(file, data, append);
   }",Get a WritableGridFileChannel for a file.
"public JobExecutionStatusDetails withDetailsMap(java.util.Map<String, String> detailsMap) {
        setDetailsMap(detailsMap);
        return this;
    }",Sets the map of job status details to be used in the execution.
"@Override
    public void dereferenceConsumerManager()
    {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.entry(tc, ""dereferenceConsumerManager"");
        setOutputHandler(null);
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.exit(tc, ""dereferenceConsumerManager"");
    }",Dereference the Consumer Manager object.
"private BufferedImage rasterizeConvoLayers(@NonNull List<INDArray> tensors3D, BufferedImage sourceImage) {
        long width = 0;
        long height = 0;

        int border = 1;
        int padding_row = 2;
        int padding_col = 80;

        /*
            We determine height of joint output image. We assume that first position holds maximum dimensionality
         */
        val shape = tensors3D.get(0).shape();
        val numImages = shape[0];
        height = (shape[2]);
        width = (shape[1]);
        //        log.info(""Output image dimensions: {height: "" + height + "", width: "" + width + ""}"");
        int maxHeight = 0; //(height + (border * 2 ) + padding_row) * numImages;
        int totalWidth = 0;
        int iOffset = 1;

        Orientation orientation = Orientation.LANDSCAPE;
        /*
            for debug purposes we'll use portait only now
         */
        if (tensors3D.size() > 3) {
            orientation = Orientation.PORTRAIT;
        }



        List<BufferedImage> images = new ArrayList<>();
        for (int layer = 0; layer < tensors3D.size(); layer++) {
            INDArray tad = tensors3D.get(layer);
            int zoomed = 0;

            BufferedImage image = null;
            if (orientation == Orientation.LANDSCAPE) {
                maxHeight = (int) ((height + (border * 2) + padding_row) * numImages);
                image = renderMultipleImagesLandscape(tad, maxHeight, (int) width, (int) height);
                totalWidth += image.getWidth() + padding_col;
            } else if (orientation == Orientation.PORTRAIT) {
                totalWidth = (int) ((width + (border * 2) + padding_row) * numImages);
                image = renderMultipleImagesPortrait(tad, totalWidth, (int) width, (int) height);
                maxHeight += image.getHeight() + padding_col;
            }

            images.add(image);
        }

        if (orientation == Orientation.LANDSCAPE) {
            // append some space for arrows
            totalWidth += padding_col * 2;
        } else if (orientation == Orientation.PORTRAIT) {
            maxHeight += padding_col * 2;
            maxHeight += sourceImage.getHeight() + (padding_col * 2);
        }

        BufferedImage output = new BufferedImage(totalWidth, maxHeight, BufferedImage.TYPE_INT_RGB);
        Graphics2D graphics2D = output.createGraphics();

        graphics2D.setPaint(bgColor);
        graphics2D.fillRect(0, 0, output.getWidth(), output.getHeight());

        BufferedImage singleArrow = null;
        BufferedImage multipleArrows = null;

        /*
            We try to add nice flow arrow here
         */
        try {

            if (orientation == Orientation.LANDSCAPE) {
                try {
                    ClassPathResource resource = new ClassPathResource(""arrow_sing.PNG"");
                    ClassPathResource resource2 = new ClassPathResource(""arrow_mul.PNG"");

                    singleArrow = ImageIO.read(resource.getInputStream());
                    multipleArrows = ImageIO.read(resource2.getInputStream());
                } catch (Exception e) {
                }

                graphics2D.drawImage(sourceImage, (padding_col / 2) - (sourceImage.getWidth() / 2),
                                (maxHeight / 2) - (sourceImage.getHeight() / 2), null);

                graphics2D.setPaint(borderColor);
                graphics2D.drawRect((padding_col / 2) - (sourceImage.getWidth() / 2),
                                (maxHeight / 2) - (sourceImage.getHeight() / 2), sourceImage.getWidth(),
                                sourceImage.getHeight());

                iOffset += sourceImage.getWidth();

                if (singleArrow != null)
                    graphics2D.drawImage(singleArrow, iOffset + (padding_col / 2) - (singleArrow.getWidth() / 2),
                                    (maxHeight / 2) - (singleArrow.getHeight() / 2), null);
            } else {
                try {
                    ClassPathResource resource = new ClassPathResource(""arrow_singi.PNG"");
                    ClassPathResource resource2 = new ClassPathResource(""arrow_muli.PNG"");

                    singleArrow = ImageIO.read(resource.getInputStream());
                    multipleArrows = ImageIO.read(resource2.getInputStream());
                } catch (Exception e) {
                }

                graphics2D.drawImage(sourceImage, (totalWidth / 2) - (sourceImage.getWidth() / 2),
                                (padding_col / 2) - (sourceImage.getHeight() / 2), null);

                graphics2D.setPaint(borderColor);
                graphics2D.drawRect((totalWidth / 2) - (sourceImage.getWidth() / 2),
                                (padding_col / 2) - (sourceImage.getHeight() / 2), sourceImage.getWidth(),
                                sourceImage.getHeight());

                iOffset += sourceImage.getHeight();
                if (singleArrow != null)
                    graphics2D.drawImage(singleArrow, (totalWidth / 2) - (singleArrow.getWidth() / 2),
                                    iOffset + (padding_col / 2) - (singleArrow.getHeight() / 2), null);

            }
            iOffset += padding_col;
        } catch (Exception e) {
            // if we can't load images - ignore them
        }



        /*
            now we merge all images into one big image with some offset
        */


        for (int i = 0; i < images.size(); i++) {
            BufferedImage curImage = images.get(i);
            if (orientation == Orientation.LANDSCAPE) {
                // image grows from left to right
                graphics2D.drawImage(curImage, iOffset, 1, null);
                iOffset += curImage.getWidth() + padding_col;

                if (singleArrow != null && multipleArrows != null) {
                    if (i < images.size() - 1) {
                        // draw multiple arrows here
                        if (multipleArrows != null)
                            graphics2D.drawImage(multipleArrows,
                                            iOffset - (padding_col / 2) - (multipleArrows.getWidth() / 2),
                                            (maxHeight / 2) - (multipleArrows.getHeight() / 2), null);
                    } else {
                        // draw single arrow
                        //    graphics2D.drawImage(singleArrow, iOffset - (padding_col / 2) - (singleArrow.getWidth() / 2), (maxHeight / 2) - (singleArrow.getHeight() / 2), null);
                    }
                }
            } else if (orientation == Orientation.PORTRAIT) {
                // image grows from top to bottom
                graphics2D.drawImage(curImage, 1, iOffset, null);
                iOffset += curImage.getHeight() + padding_col;

                if (singleArrow != null && multipleArrows != null) {
                    if (i < images.size() - 1) {
                        // draw multiple arrows here
                        if (multipleArrows != null)
                            graphics2D.drawImage(multipleArrows, (totalWidth / 2) - (multipleArrows.getWidth() / 2),
                                            iOffset - (padding_col / 2) - (multipleArrows.getHeight() / 2), null);
                    } else {
                        // draw single arrow
                        //   graphics2D.drawImage(singleArrow, (totalWidth / 2) - (singleArrow.getWidth() / 2),  iOffset - (padding_col / 2) - (singleArrow.getHeight() / 2) , null);
                    }
                }
            }
        }

        return output;
    }",rasterizeConvoLayers This method is used to rasterize the input image for the Convo layers
"public OperationStatus updateSettings(UUID appId, UpdateSettingsOptionalParameter updateSettingsOptionalParameter) {
        return updateSettingsWithServiceResponseAsync(appId, updateSettingsOptionalParameter).toBlocking().single().body();
    }",Updates the application settings.
"public synchronized StorableProperties put(String key, Object val) {
        if (!key.equals(toLowerCase(key)))
            throw new IllegalArgumentException(""Do not use upper case keys ("" + key + "") for StorableProperties since 0.7"");

        map.put(key, val.toString());
        return this;
    }",Puts a value into the cache.
"public static ReportedData getReportedDataFrom(Stanza packet) {
        // Check if the packet includes the DataForm extension
        DataForm dataForm = DataForm.from(packet);
        if (dataForm != null) {
            if (dataForm.getReportedData() != null)
                return new ReportedData(dataForm);
        }
        // Otherwise return null
        return null;
    }",Get the ReportedData from the given stanza.
"protected final void registerSession( AbstractSession sessionToAdd )
    {
    	if (sessions.put(sessionToAdd.getId(),sessionToAdd) != null)
    		throw new IllegalArgumentException(""Session ""+sessionToAdd.getId()+"" already exists"");
    }",Register a session.
"public static byte[] readRAM(final File f) throws IOException {
    final int total = (int) f.length();
    final byte[] ret = new byte[total];
    final InputStream in = new FileInputStream(f);
    try {
      int offset = 0;
      int read = 0;
      do {
        read = in.read(ret, offset, total - read);
        if (read > 0) {
          offset += read;
        }
      } while ((read != -1) && (offset != total));
      return ret;
    } finally {
      in.close();
    }
  }",Read a CRAM file.
"void writeTransactionIdFile(StorageDirectory sd, long txid) throws IOException {
    if (txid < -1) {
      // -1 is valid when formatting
      throw new IOException(""Bad txid: "" + txid);
    }
    File txIdFile = getStorageFile(sd, NameNodeFile.SEEN_TXID);
    OutputStream fos = new AtomicFileOutputStream(txIdFile);
    try {
      fos.write(String.valueOf(txid).getBytes());
      fos.write('\n');
      fos.close();
      fos = null;
    } finally {
      IOUtils.cleanup(LOG, fos);
    }
  }",Write a txid file to the storage directory.
"@Override
	public void setMedial2(double x, double y, double z) {
		this.medial2.set(x, y, z);
		ensureAIsLowerPoint();
	}",Sets the median 2 coordinate.
"private static Class<?> parameterizedReturnType(Method method) {
    Type type = method.getGenericReturnType();
    if (type instanceof ParameterizedType) {
      try {
        return Class.forName(
            (((ParameterizedType) type).getActualTypeArguments()[0]).getTypeName());
      } catch (ClassNotFoundException e) {
        return Object.class;
      }
    } else {
      return Object.class;
    }
  }",Get the parameterized return type of a method.
"public XMLResource xml(URI anUri, AbstractContent requestContent) throws IOException {
		return doPOSTOrPUT(anUri, requestContent, createXMLResource());
	}",Performs an HTTP POST or PUT request to the specified URI and returns the XML resource.
"protected Dependency createDependency(Dependency dependency, String name, String version, String scope) {
        final Dependency nodeModule = new Dependency(new File(dependency.getActualFile() + ""?"" + name), true);
        nodeModule.setEcosystem(NPM_DEPENDENCY_ECOSYSTEM);
        //this is virtual - the sha1 is purely for the hyperlink in the final html report
        nodeModule.setSha1sum(Checksum.getSHA1Checksum(String.format(""%s:%s"", name, version)));
        nodeModule.setSha256sum(Checksum.getSHA256Checksum(String.format(""%s:%s"", name, version)));
        nodeModule.setMd5sum(Checksum.getMD5Checksum(String.format(""%s:%s"", name, version)));
        nodeModule.addEvidence(EvidenceType.PRODUCT, ""package.json"", ""name"", name, Confidence.HIGHEST);
        nodeModule.addEvidence(EvidenceType.VENDOR, ""package.json"", ""name"", name, Confidence.HIGH);
        if (!StringUtils.isBlank(version)) {
            nodeModule.addEvidence(EvidenceType.VERSION, ""package.json"", ""version"", version, Confidence.HIGHEST);
            nodeModule.setVersion(version);
        }
        if (dependency.getName() != null) {
            nodeModule.addProjectReference(dependency.getName() + "": "" + scope);
        } else {
            nodeModule.addProjectReference(dependency.getDisplayFileName() + "": "" + scope);
        }
        nodeModule.setName(name);

        //TODO  - we can likely create a valid CPE as a low confidence guess using cpe:2.3:a:[name]_project:[name]:[version]
        //(and add a targetSw of npm/node)
        Identifier id;
        try {
            final PackageURL purl = PackageURLBuilder.aPackageURL().withType(StandardTypes.NPM)
                    .withName(name).withVersion(version).build();
            id = new PurlIdentifier(purl, Confidence.HIGHEST);
        } catch (MalformedPackageURLException ex) {
            LOGGER.debug(""Unable to generate Purl - using a generic identifier instead "" + ex.getMessage());
            id = new GenericIdentifier(String.format(""npm:%s@%s"", dependency.getName(), version), Confidence.HIGHEST);
        }
        nodeModule.addSoftwareIdentifier(id);
        return nodeModule;
    }",Create a dependency object.
"public String buildPreparedStatementName() {
		if (!StringUtils.hasText(preparedStatementName)) {
			preparedStatementName = getParent().buildPreparedStatementName(getName());
		}
		return preparedStatementName;
	}",Build the name of the prepared statement.
"public Observable<PublicIPAddressInner> createOrUpdateAsync(String resourceGroupName, String publicIpAddressName, PublicIPAddressInner parameters) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, publicIpAddressName, parameters).map(new Func1<ServiceResponse<PublicIPAddressInner>, PublicIPAddressInner>() {
            @Override
            public PublicIPAddressInner call(ServiceResponse<PublicIPAddressInner> response) {
                return response.body();
            }
        });
    }",Creates or updates an IP address.
"public static String getPippoVersion() {
        // and the key inside the properties file.
        String pippoVersionPropertyKey = ""pippo.version"";

        String pippoVersion;

        try {
            Properties prop = new Properties();
            URL url = ClasspathUtils.locateOnClasspath(PippoConstants.LOCATION_OF_PIPPO_BUILTIN_PROPERTIES);
            InputStream stream = url.openStream();
            prop.load(stream);

            pippoVersion = prop.getProperty(pippoVersionPropertyKey);
        } catch (Exception e) {
            //this should not happen. Never.
            throw new PippoRuntimeException(""Something is wrong with your build. Cannot find resource {}"",
                PippoConstants.LOCATION_OF_PIPPO_BUILTIN_PROPERTIES);
        }

        return pippoVersion;
    }",Get the pippo version from the properties file.
"@Override
    public Page<Country> nextPage(final Page<Country> page, 
                                  final TwilioRestClient client) {
        Request request = new Request(
            HttpMethod.GET,
            page.getNextPageUrl(
                Domains.VOICE.toString(),
                client.getRegion()
            )
        );
        return pageForRequest(client, request);
    }",This method is used to retrieve the next page of a CDNA language.
"public Boolean getAndDecryptBoolean(String name, String providerName) throws Exception {
        return (Boolean) getAndDecrypt(name, providerName);
    }",Get a Boolean object from the cache.
"public void setAlertChannels(Collection<AlertChannel> channels)
    {
        for(AlertChannel channel : channels)
        {
            // Add the channel to any policies it is associated with
            List<Long> policyIds = channel.getLinks().getPolicyIds();
            for(long policyId : policyIds)
            {
                AlertPolicy policy = policies.get(policyId);
                if(policy != null)
                    alertChannels(policyId).add(channel);
                else
                    logger.severe(String.format(""Unable to find policy for channel '%s': %d"", channel.getName(), policyId));
            }
        }
    }",Sets the alert channels.
"@Deprecated
  public static URI getPath(String bucketName, String objectName) {
    return LEGACY_PATH_CODEC.getPath(
        bucketName, objectName, false /* do not allow empty object */);
  }",Get the path of the object in the given bucket.
"public static URI getRootUri(final Archive<?> archive) throws IllegalArgumentException {
        if (archive == null) {
            throw new IllegalArgumentException(""Archive must be specified"");
        }
        final StringBuilder sb = new StringBuilder();
        sb.append(PROTOCOL);
        sb.append(URI_PROTOCOL_SUFFIX);
        sb.append(archive.getId());
        sb.append('/');
        final URI uri = URI.create(sb.toString());
        return uri;
    }",Gets the root URI of the CRA.
"public void init()
            throws ServletException
    {
        org.slf4j.Logger logServerStartup = org.slf4j.LoggerFactory.getLogger(""serverStartup"");
        logServerStartup.info(getClass().getName() + "" initialization start"");
        try {
            System.setProperty(""file.encoding"", ""UTF-8"");
            Field charset = Charset.class.getDeclaredField(""defaultCharset"");
            charset.setAccessible(true);
            charset.set(null, null);
            initialize();
        } catch (Exception e) {
            throw new ServletException(e);
        }
    }",Initialize the application.
"@Override
    public void storeTrigger(OperableTrigger trigger, boolean replaceExisting, JedisCluster jedis) throws JobPersistenceException {
        final String triggerHashKey = redisSchema.triggerHashKey(trigger.getKey());
        final String triggerGroupSetKey = redisSchema.triggerGroupSetKey(trigger.getKey());
        final String jobTriggerSetKey = redisSchema.jobTriggersSetKey(trigger.getJobKey());

        if (!(trigger instanceof SimpleTrigger) && !(trigger instanceof CronTrigger)) {
            throw new UnsupportedOperationException(""Only SimpleTrigger and CronTrigger are supported."");
        }
        final boolean exists = jedis.exists(triggerHashKey);
        if (exists && !replaceExisting) {
            throw new ObjectAlreadyExistsException(trigger);
        }

        Map<String, String> triggerMap = mapper.convertValue(trigger, new TypeReference<HashMap<String, String>>() {
        });
        triggerMap.put(TRIGGER_CLASS, trigger.getClass().getName());

        jedis.hmset(triggerHashKey, triggerMap);
        jedis.sadd(redisSchema.triggersSet(), triggerHashKey);
        jedis.sadd(redisSchema.triggerGroupsSet(), triggerGroupSetKey);
        jedis.sadd(triggerGroupSetKey, triggerHashKey);
        jedis.sadd(jobTriggerSetKey, triggerHashKey);
        if (trigger.getCalendarName() != null && !trigger.getCalendarName().isEmpty()) {
            final String calendarTriggersSetKey = redisSchema.calendarTriggersSetKey(trigger.getCalendarName());
            jedis.sadd(calendarTriggersSetKey, triggerHashKey);
        }
        if (trigger.getJobDataMap() != null && !trigger.getJobDataMap().isEmpty()) {
            final String triggerDataMapHashKey = redisSchema.triggerDataMapHashKey(trigger.getKey());
            jedis.hmset(triggerDataMapHashKey, getStringDataMap(trigger.getJobDataMap()));
        }

        if (exists) {
            // We're overwriting a previously stored instance of this trigger, so clear any existing trigger state.
            unsetTriggerState(triggerHashKey, jedis);
        }

        Boolean triggerPausedResponse = jedis.sismember(redisSchema.pausedTriggerGroupsSet(), triggerGroupSetKey);
        Boolean jobPausedResponse = jedis.sismember(redisSchema.pausedJobGroupsSet(), redisSchema.jobGroupSetKey(trigger.getJobKey()));

        if (triggerPausedResponse || jobPausedResponse) {
            final long nextFireTime = trigger.getNextFireTime() != null ? trigger.getNextFireTime().getTime() : -1;
            final String jobHashKey = redisSchema.jobHashKey(trigger.getJobKey());
            if (isBlockedJob(jobHashKey, jedis)) {
                setTriggerState(RedisTriggerState.PAUSED_BLOCKED, (double) nextFireTime, triggerHashKey, jedis);
            } else {
                setTriggerState(RedisTriggerState.PAUSED, (double) nextFireTime, triggerHashKey, jedis);
            }
        } else if (trigger.getNextFireTime() != null) {
            setTriggerState(RedisTriggerState.WAITING, (double) trigger.getNextFireTime().getTime(), triggerHashKey, jedis);
        }
    }",Store a trigger in Redis
"protected String getQueryFor(final String key) {
        log.trace(""Trying to get query for {} "", key);
        String query = queries.get(key);
        log.trace(""Query found {} for key {}"", query, key);
        if (query == null) {
            log.error(""Query for {} key does not exist"", key);
            throw new IllegalArgumentException(""Query for key "" + key + "" does not exist"");
        } else if (StringUtils.isBlank(query)) {
            log.error(""Query for key {} can't be blank or be only whitespace"", key);
            throw new IllegalArgumentException(""Query for key "" + key + "" can't be blank or be only whitespace"");
        }
        return query.trim().replaceAll(""\\s+"", "" "");
    }",Gets the query for the given key.
"static private String findParamValueFor(String s)
	{
		int endParamIndex = s.indexOf('=');
		int endValueIndex = s.indexOf(']',endParamIndex);
		if (endValueIndex<0) throw new IllegalStateException(""illegal class description '""+s+""'"");
		return s.substring(endParamIndex+1,endValueIndex);
	}",Find the value of the parameter in the given string.
"@Nullable
  public String getListItemStartingWith (@Nullable final String sPrefix)
  {
    for (final Object aObj : m_aList)
      if (aObj instanceof List <?>)
        for (final Object aListItem : (List <?>) aObj)
          if (((String) aListItem).startsWith (sPrefix))
            return (String) aListItem;
    return null;
  }",Get the first list item starting with the passed prefix.
"public static Array convert( Array org, DataType wantType) {
    if (org == null) return null;
    Class wantClass = wantType.getPrimitiveClassType();
    if (org.getElementType().equals(wantClass))
      return org;

    Array result = Array.factory(wantType, org.getShape());
    copy(wantType, org.getIndexIterator(), result.getIndexIterator());
    return result;
  }",Converts an Array to a new Array of the given type.
"public void addTickLabelSection(final Section SECTION) {
        if (null == SECTION) return;
        tickLabelSections.add(SECTION);
        Collections.sort(tickLabelSections, new SectionComparator());
        fireUpdateEvent(REDRAW_EVENT);
    }",Adds the given Section to the list of ticklabel sections. Sections are sorted by the time of the entry.
"public void log( final Priority priority, final Object message, final Throwable t )
    {
        if ( priority == null )
        {
            return;
        }

        switch (priority.level)
        {
            case Level.FATAL_INT:
                this.fatal( message, t );
                break;
            case Level.ERROR_INT:
                this.error( message, t );
                break;
            case Level.WARN_INT:
                this.warn( message, t );
                break;
            case Level.INFO_INT:
                this.info( message, t );
                break;
            case Level.DEBUG_INT:
                this.debug( message, t );
                break;
            case Level.TRACE_INT:
            case Level.ALL_INT:
                this.trace( message, t );
                break;
            default:
                break;
        }
    }",Logs a message and exception with the specified priority.
"public static void putServiceTicketInRequestScope(final RequestContext context, final ServiceTicket ticketValue) {
        context.getRequestScope().put(PARAMETER_SERVICE_TICKET_ID, ticketValue.getId());
    }",Put service ticket in request scope.
"public ExportRequestResponse exportRequest(ExportRequestInfo exportRequestInfo) throws ApiException {
        ApiResponse<ExportRequestResponse> resp = exportRequestWithHttpInfo(exportRequestInfo);
        return resp.getData();
    }",Export Request Export Request
"public boolean getBoolean(String key, boolean def) {
        String value = getString(key);
        if (value == null) {
            return def;
        }
        else {
            return ""true"".equalsIgnoreCase(value);
        }
    }",Gets the boolean value.
"public HalCuriAugmenter register(String name, String href) {
    Link link = new Link(href).setName(name);
    return register(link);
  }",Register a new HAL CURI Augmenter with the specified name and href.
"@Override
    public boolean offer(final WaitStrategy.Offerable o) throws InterruptedException {
        while (!o.offer()) {
            LockSupport.parkNanos(1l);
        }
        return true;
    }",Offer a new object to the queue.
"public static Bitmap getFrameSloppy(SeekableDemuxerTrack vt, ContainerAdaptor decoder, int frameNumber)
            throws IOException, JCodecException {
        return ((AndroidFrameGrab) new AndroidFrameGrab(vt, decoder).seekToFrameSloppy(frameNumber)).getFrame();
    }",Get the frame from a seekable demuxer track.
"private VerticalLayout createEnableGoogleAuthButton() {
		final VerticalLayout formLayout = new VerticalLayout();
		formLayout.setSizeFull();

		final Panel formPanel = new Panel();
		formPanel.setSizeFull();

		formLayout.addComponent(formPanel);

		final FormLayout formContent = new FormLayout();
		formPanel.setContent(formContent);

		final SetGoogleAuthenticatorCredentialRequest request = new SetGoogleAuthenticatorCredentialRequest();
		request.setSessionId(RequestContextHolder.currentRequestAttributes().getSessionId());
		request.setUserpassword("""");
		final ClickListener listener = new SetGoogleAuthenticatorCredentialClickListener(request);
		getFormFactory().addRequestInputFormFields(formContent, request, SetGoogleAuthenticatorCredentialRequest.class,
				AS_LIST, ENABLE_GOOGLE_AUTHENTICATOR, listener);

		return formLayout;
	}",Create enable google auth button.
"private void processRunnableOperations(
            final Consumer<WorkflowSystem.OperationResult<DAT, RES, OP>> resultConsumer,
            final List<OP> shouldrun,
            final List<OP> shouldskip,
            final DAT inputData
    )
    {
        for (final OP operation : shouldrun) {
            if (shouldskip.contains(operation)) {
                continue;
            }
            pending.remove(operation);

            workflowEngine.event(
                    WorkflowSystemEventType.WillRunOperation,
                    String.format(""operation starting: %s"", operation),
                    operation
            );
            final ListenableFuture<RES> submit = executorService.submit(() -> operation.apply(inputData));
            inProcess.add(operation);
            futures.add(submit);
            FutureCallback<RES> callback = new FutureCallback<RES>() {
                @Override
                public void onSuccess(final RES successResult) {
                    workflowEngine.event(
                            WorkflowSystemEventType.OperationSuccess,
                            String.format(""operation succeeded: %s"", successResult),
                            successResult
                    );
                    assert successResult != null;
                    WorkflowSystem.OperationResult<DAT, RES, OP> result = result(successResult, operation);
                    resultConsumer.accept(result);
                    stateChangeQueue.add(successResult);
                    inProcess.remove(operation);
                }

                @Override
                public void onFailure(final Throwable t) {
                    workflowEngine.event(
                            WorkflowSystemEventType.OperationFailed,
                            String.format(""operation failed: %s"", t),
                            t
                    );
                    WorkflowSystem.OperationResult<DAT, RES, OP> result = result(t, operation);
                    resultConsumer.accept(result);
                    StateObj newFailureState = operation.getFailureState(t);
                    if (null != newFailureState && newFailureState.getState().size() > 0) {
                        WorkflowSystem.OperationCompleted<DAT> objectOperationCompleted = WorkflowEngine.dummyResult(
                                newFailureState);
                        stateChangeQueue.add(objectOperationCompleted);
                    }
                    inProcess.remove(operation);
                }
            };

            Futures.addCallback(submit, callback, manager);
        }
    }",Process runnable operations.
"@Override
	public EClass getIfcStructuralLoadOrResult() {
		if (ifcStructuralLoadOrResultEClass == null) {
			ifcStructuralLoadOrResultEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)
					.getEClassifiers().get(645);
		}
		return ifcStructuralLoadOrResultEClass;
	}",Get the IfcStructuralLoadOrResultEClass attribute of the class.
"public static void createLoadsBasedOnDescriptor(MethodVisitor mv, String descriptor, int startindex) {
		int slot = startindex;
		int descriptorpos = 1; // start after the '('
		char ch;
		while ((ch = descriptor.charAt(descriptorpos)) != ')') {
			switch (ch) {
				case '[':
					mv.visitVarInsn(ALOAD, slot);
					slot++;
					// jump to end of array, could be [[[[I
					while (descriptor.charAt(++descriptorpos) == '[') {
					}
					if (descriptor.charAt(descriptorpos) == 'L') {
						descriptorpos = descriptor.indexOf(';', descriptorpos) + 1;
					}
					else {
						// Just a primitive array
						descriptorpos++;
					}
					break;
				case 'L':
					mv.visitVarInsn(ALOAD, slot);
					slot++;
					// jump to end of 'L' signature
					descriptorpos = descriptor.indexOf(';', descriptorpos) + 1;
					break;
				case 'J':
					mv.visitVarInsn(LLOAD, slot);
					slot += 2; // double slotter
					descriptorpos++;
					break;
				case 'D':
					mv.visitVarInsn(DLOAD, slot);
					slot += 2; // double slotter
					descriptorpos++;
					break;
				case 'F':
					mv.visitVarInsn(FLOAD, slot);
					descriptorpos++;
					slot++;
					break;
				case 'I':
				case 'Z':
				case 'B':
				case 'C':
				case 'S':
					mv.visitVarInsn(ILOAD, slot);
					descriptorpos++;
					slot++;
					break;
				default:
					throw new IllegalStateException(""Unexpected type in descriptor: "" + ch);
			}
		}
	}",Creates the load instructions based on the given descriptor.
"private void copy(ByteBuf src, ByteBuffer dst) {
		// This branch is necessary, because an Exception is thrown if the
		// destination buffer has more remaining (writable) bytes than
		// currently readable from the Netty ByteBuf source.
		if (src.isReadable()) {
			if (src.readableBytes() < dst.remaining()) {
				int oldLimit = dst.limit();

				dst.limit(dst.position() + src.readableBytes());
				src.readBytes(dst);
				dst.limit(oldLimit);
			}
			else {
				src.readBytes(dst);
			}
		}
	}",Copy the contents of src to dst.
"public static Map<String, String> mergeDefaults(
        CmsObject cms,
        Map<String, CmsXmlContentProperty> propertyConfig,
        Map<String, String> properties) {

        Map<String, String> result = new HashMap<String, String>();
        if (propertyConfig != null) {
            for (Map.Entry<String, CmsXmlContentProperty> entry : propertyConfig.entrySet()) {
                CmsXmlContentProperty prop = entry.getValue();
                String value = getPropValueIds(cms, prop.getType(), prop.getDefault());
                if (value != null) {
                    result.put(entry.getKey(), value);
                }
            }
        }
        result.putAll(properties);
        return result;
    }",Merge the default values of the content type and property configuration.
"@GwtIncompatible // NavigableSet
  public static <E> NavigableSet<E> unmodifiableNavigableSet(NavigableSet<E> set) {
    if (set instanceof ImmutableSortedSet || set instanceof UnmodifiableNavigableSet) {
      return set;
    }
    return new UnmodifiableNavigableSet<E>(set);
  }",Returns an unmodifiable view of the given NavigableSet.
"public static byte[] readBytes(File file) throws IOException {
        FileInputStream fis = null;
        ByteArrayOutputStream bos = null;
        if (file == null) {
            throw new FileNotFoundException(""No file specified"");
        }
        try {
            fis = new FileInputStream(file);
            bos = new ByteArrayOutputStream();
            byte[] buffer = new byte[BUFFER_SIZE];
            int remaining;
            while ((remaining = fis.read(buffer)) > 0) {
                bos.write(buffer, 0, remaining);
            }
            return bos.toByteArray();
        } finally {
            Closeables.closeQuietly(fis);
            Closeables.closeQuietly(bos);
        }
    }",readBytes Method.
"public GridBagLayoutBuilder appendField(Component component, int colSpan) {
        return append(component, colSpan, 1, true, false);
    }",Append a field to the end of the current line.
"public void putClass(String key, Class<?> clazz) {
		checkNotNull(key);
		checkNotNull(clazz);
		final String error = InstantiationUtil.checkForInstantiationError(clazz);
		if (error != null) {
			throw new ValidationException(""Class '"" + clazz.getName() + ""' is not supported: "" + error);
		}
		put(key, clazz.getName());
	}",Put a Class into the map.
"protected void removeSource (JComponent comp)
    {
        if (_sourceComp == comp) {
            // reset cursors
            clearComponentCursor();
            _topComp.setCursor(_topCursor);
            reset();
        }
        _draggers.remove(comp);
        comp.removeMouseListener(_sourceListener);
        comp.removeMouseMotionListener(_sourceListener);
    }",Remove a source component from the calendar.
"public static Configuration getConfFromState(State state, Optional<String> encryptedPath) {
    Config config = ConfigFactory.parseProperties(state.getProperties());
    if (encryptedPath.isPresent()) {
      config = ConfigUtils.resolveEncrypted(config, encryptedPath);
    }
    Configuration conf = newConfiguration();

    for (Entry<String, ConfigValue> entry : config.entrySet()) {
      conf.set(entry.getKey(), entry.getValue().unwrapped().toString());
    }
    return conf;
  }",Get the configuration from the state
"public void create() {
    GeneticConfiguration cfg =
      new GeneticConfiguration(config, mutation_rate, recombination_rate,
                               evolve_comparators);
    population = new ArrayList(size);
    int ix = 0;
    for (; ix < copies_of_original; ix++)
      population.add(cfg.makeCopy());
    for (; ix < size; ix++)
      population.add(cfg.makeRandomCopy());
  }

  /**
   * Returns all configurations in the current generation.
   */
  public List<GeneticConfiguration> getConfigs() {
    return population;
  }

  public void setNewGeneration(List<GeneticConfiguration> nextgen) {
    this.population = nextgen;
  }

  /**
   * Sorts the population by their achieved F-numbers.
   */
  public void sort() {
    Collections.sort(population);
    for (int ix = 0; ix < population.size(); ix++)
      population.get(ix).setRank(ix + 1);
  }

  /**
   * Returns the best configuration.
   */
  public GeneticConfiguration getBestConfiguration() {
    return population.get(0);
  }

  /**
   * Returns the worst configuration.
   */
  public GeneticConfiguration getWorstConfiguration() {
    return population.get(population.size() - 1);
  }

  /**
   * Returns a random configuration.
   */
  public GeneticConfiguration pickRandomConfig() {
    return population.get((int) Math.random() * population.size());
  }

  /**
   * Runs a tournament among k individuals to find the most fit
   * individual.
   */
  public GeneticConfiguration runTournament(int k) {
    GeneticConfiguration best = pickRandomConfig();
    for (int ix = 1; ix < k; ix++) {
      GeneticConfiguration candidate = pickRandomConfig();
      if (candidate.getFNumber() > best.getFNumber())
        best = candidate;
    }
    return best;
  }

  /**
   * Sets the size of the population.
   */
  public void setSize(int size) {
    this.size = size;
  }

  public void setMutationRate(int mutation_rate) {
    this.mutation_rate = mutation_rate;
  }

  public void setRecombinationRate(double recombination_rate) {
    this.recombination_rate = recombination_rate;
  }

  public void setEvolveComparators(boolean evolve_comparators) {
    this.evolve_comparators = evolve_comparators;
  }

  public void setCopiesOfOriginal(int copies) {
    this.copies_of_original = copies;
  }

  /**
   * Returns the size of the population.
   */
  public int size() {
    return size;
  }
}",Create the generation.
"@Override
	public CommerceVirtualOrderItem fetchByPrimaryKey(Serializable primaryKey) {
		Serializable serializable = entityCache.getResult(CommerceVirtualOrderItemModelImpl.ENTITY_CACHE_ENABLED,
				CommerceVirtualOrderItemImpl.class, primaryKey);

		if (serializable == nullModel) {
			return null;
		}

		CommerceVirtualOrderItem commerceVirtualOrderItem = (CommerceVirtualOrderItem)serializable;

		if (commerceVirtualOrderItem == null) {
			Session session = null;

			try {
				session = openSession();

				commerceVirtualOrderItem = (CommerceVirtualOrderItem)session.get(CommerceVirtualOrderItemImpl.class,
						primaryKey);

				if (commerceVirtualOrderItem != null) {
					cacheResult(commerceVirtualOrderItem);
				}
				else {
					entityCache.putResult(CommerceVirtualOrderItemModelImpl.ENTITY_CACHE_ENABLED,
						CommerceVirtualOrderItemImpl.class, primaryKey,
						nullModel);
				}
			}
			catch (Exception e) {
				entityCache.removeResult(CommerceVirtualOrderItemModelImpl.ENTITY_CACHE_ENABLED,
					CommerceVirtualOrderItemImpl.class, primaryKey);

				throw processException(e);
			}
			finally {
				closeSession(session);
			}
		}

		return commerceVirtualOrderItem;
	}",Returns the commerce virtual order item with the primary key.
"public List<U> getAll(final boolean readFromSession) {
        final LinkedHashMap<String, U> profiles = retrieveAll(readFromSession);
        return ProfileHelper.flatIntoAProfileList(profiles);
    }",Get all profiles from the cache.
"public void marshall(DescribeEventSubscriptionsRequest describeEventSubscriptionsRequest, ProtocolMarshaller protocolMarshaller) {

        if (describeEventSubscriptionsRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(describeEventSubscriptionsRequest.getSubscriptionName(), SUBSCRIPTIONNAME_BINDING);
            protocolMarshaller.marshall(describeEventSubscriptionsRequest.getFilters(), FILTERS_BINDING);
            protocolMarshaller.marshall(describeEventSubscriptionsRequest.getMaxRecords(), MAXRECORDS_BINDING);
            protocolMarshaller.marshall(describeEventSubscriptionsRequest.getMarker(), MARKER_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given request to the JSON object.
"public static double skewnessSE(FlatDataCollection flatDataCollection) {
	    int n = count(flatDataCollection);
        if(n<=2) {
            throw new IllegalArgumentException(""The provided collection must have more than 2 elements."");
        }
        
        double skewnessSE=Math.sqrt((6.0*n*(n-1.0))/((n-2.0)*(n+1.0)*(n+3.0)));
        
        return skewnessSE;
    }",Get the skewness of a collection of data.
"public void registerTaskConfig(String taskName, TedProcessorFactory tedProcessorFactory, TedRetryScheduler retryScheduler) {
		tedDriverImpl.registerTaskConfig(taskName, tedProcessorFactory, null, retryScheduler, null);
	}",Register TaskConfig method.
"public Cell<C,T> width (Value<C,T> width) {
		minWidth = width;
		prefWidth = width;
		maxWidth = width;
		return this;
	}",Sets the width of the cell.
"public ArrayList<String> getFeatures() {
		if (isFinalState())
			return null;
		ArrayList<String> featurelist = new ArrayList<String>();

		int rightFocus = leftFocus + 1;

//		ISparseVector vec = new HashSparseVector();
		//所有的联合feature
		featurelist.add(combinedFeature(""+0+1"", POS, new int[]{0, 1}));
		featurelist.add(combinedFeature(""-1+0+1"", POS, new int[]{-1, 0, 1}));
		featurelist.add(combinedFeature(""+0+1+2"", POS, new int[]{0, 1, 2}));
		featurelist.add(combinedFeature(""+1+2+3"", POS, new int[]{1, 2, 3}));
		featurelist.add(combinedFeature(""-2+3+4"", POS, new int[]{2, 3, 4}));
		featurelist.add(combinedFeature(""+0+1"", LEX, new int[]{0, 1}));
		featurelist.add(combinedFeature(""-1+0+1"", LEX, new int[]{-1, 0, 1}));
		featurelist.add(combinedFeature(""+0+1+2"", LEX, new int[]{0, 1, 2}));

		// 设定上下文窗口大小
		int l = 2;
		int r = 4;
		for (int i = 0; i <= l; i++) {
			// 特征前缀
			String posFeature = ""-"" + String.valueOf(i) + POS;
			String lexFeature = ""-"" + String.valueOf(i) + LEX;

			String lcLexFeature = ""-"" + String.valueOf(i)
					+ CH_L_LEX;
			String lcPosFeature = ""-"" + String.valueOf(i)
					+ CH_L_POS;
			String rcLexFeature = ""-"" + String.valueOf(i)
					+ CH_R_LEX;
			String rcPosFeature = ""-"" + String.valueOf(i)
					+ CH_R_POS;
			String lcDepFeature = ""-"" + String.valueOf(i)
					+ CH_L_DEP;			
			String rcDepFeature = ""-"" + String.valueOf(i)
					+ CH_R_DEP;

			if (leftFocus - i < 0) {
				featurelist.add(lexFeature + START + String.valueOf(i - leftFocus));
				featurelist.add(posFeature + START + String.valueOf(i - leftFocus));
			} else {
				featurelist.add(lexFeature + sent.words[trees.get(leftFocus - i).id]);
				featurelist.add(posFeature + sent.tags[trees.get(leftFocus - i).id]);

				if (trees.get(leftFocus - i).leftChilds.size() != 0) {
					for (int j = 0; j < trees.get(leftFocus - i).leftChilds
							.size(); j++) {
						int leftChildIndex = trees.get(leftFocus - i).leftChilds
								.get(j).id;
						featurelist.add(lcLexFeature
								+ sent.words[leftChildIndex]);
						featurelist.add(lcPosFeature
								+ sent.tags[leftChildIndex]);
						featurelist.add(lcDepFeature
								+ sent.getDepClass(leftChildIndex));
					}
				}else{
					featurelist.add(lcLexFeature + NULL);
					featurelist.add(lcPosFeature + NULL);
				}

				if (trees.get(leftFocus - i).rightChilds.size() != 0) {
					for (int j = 0; j < trees.get(leftFocus - i).rightChilds
							.size(); j++) {
						int rightChildIndex = trees.get(leftFocus - i).rightChilds
								.get(j).id;
						featurelist.add(rcLexFeature
								+ sent.words[rightChildIndex]);
						featurelist.add(rcPosFeature
								+ sent.tags[rightChildIndex]);
						featurelist.add(rcDepFeature
								+ sent.getDepClass(rightChildIndex));
					}
				}else{
					featurelist.add(rcLexFeature + NULL);
					featurelist.add(rcPosFeature + NULL);
				}
			}
		}

		for (int i = 0; i <= r; i++) {
			String posFeature = ""+"" + String.valueOf(i) + POS;
			String lexFeature = ""+"" + String.valueOf(i) + LEX;

			String lcLexFeature = ""+"" + String.valueOf(i)
					+ CH_L_LEX;
			String rcLexFeature = ""+"" + String.valueOf(i)
					+ CH_R_LEX;
			String lcPosFeature = ""+"" + String.valueOf(i)
					+ CH_L_POS;			
			String rcPosFeature = ""+"" + String.valueOf(i)
					+ CH_R_POS;
			String lcDepFeature = ""+"" + String.valueOf(i)
					+ CH_L_DEP;			
			String rcDepFeature = ""+"" + String.valueOf(i)
					+ CH_R_DEP;

			if (rightFocus + i >= trees.size()) {
				featurelist.add(lexFeature+ END+ String.valueOf(rightFocus + i- trees.size() + 3));
				featurelist.add(posFeature+ END+ String.valueOf(rightFocus + i- trees.size() + 3));
			} else {
				featurelist.add(lexFeature+ sent.words[trees.get(rightFocus + i).id]);
				featurelist.add(posFeature+ sent.tags[trees.get(rightFocus + i).id]);

				if (trees.get(rightFocus + i).leftChilds.size() != 0) {
					for (int j = 0; j < trees.get(rightFocus + i).leftChilds
							.size(); j++) {
						int leftChildIndex = trees.get(rightFocus + i).leftChilds
								.get(j).id;
						featurelist.add(lcLexFeature+ sent.words[leftChildIndex]);
						featurelist.add(lcPosFeature+ sent.tags[leftChildIndex]);
						featurelist.add(lcDepFeature+ sent.getDepClass(leftChildIndex));
					}
				}else{
					featurelist.add(lcLexFeature + NULL);
					featurelist.add(lcPosFeature + NULL);
				}

				if (trees.get(rightFocus + i).rightChilds.size() != 0) {
					for (int j = 0; j < trees.get(rightFocus + i).rightChilds
							.size(); j++) {
						int rightChildIndex = trees.get(rightFocus + i).rightChilds
								.get(j).id;
						featurelist.add(rcLexFeature+ sent.words[rightChildIndex]);
						featurelist.add(rcPosFeature+ sent.tags[rightChildIndex]);
						featurelist.add(rcDepFeature+ sent.getDepClass(rightChildIndex));
					}
				}else{
					featurelist.add(rcLexFeature + NULL);
					featurelist.add(rcPosFeature + NULL);
				}
			}
		}
		
		
		return featurelist;
	}",Returns a list of feature strings for the image.
"public JavaScriptResourceReference[] getJavaScriptResourceReferences() {
        final List<JavaScriptResourceReference> resources = new ArrayList<JavaScriptResourceReference>();

        for (final String resource : jsResources) {
            if (!resource.startsWith(""//"") && resource.startsWith(""http"")) {
                resources.add(new JavaScriptResourceReference(getResourcesRootClass(), resource));
            }
        }
        return resources.toArray(new JavaScriptResourceReference[resources.size()]);
    }",Gets the javascript resource references.
"private void initialize() {
        this.setLayout(new GridBagLayout());
        if (Model.getSingleton().getOptionsParam().getViewParam().getWmUiHandlingOption() == 0) {
            this.setSize(375, 204);
        }
        this.setName(Constant.messages.getString(""pscan.options.policy.title""));
    	JPanel passiveScannersFilterPanel = new TableFilterPanel<JXTable>(getTableTest());
        
        // 'Apply to' controls
        JPanel applyToPanel = new JPanel();
        applyToPanel.setLayout(new GridBagLayout());
        applyToPanel.add(new JLabel(Constant.messages.getString(""pscan.options.policy.apply.label"")), 
        		LayoutHelper.getGBC(0, 0, 1, 0.0, new Insets(2, 2, 2, 2)));
        applyToPanel.add(getApplyToThreshold(), LayoutHelper.getGBC(1, 0, 1, 0.0));
        applyToPanel.add(new JLabel(Constant.messages.getString(""pscan.options.policy.thresholdTo.label"")), 
        		LayoutHelper.getGBC(2, 0, 1, 0.0, new Insets(2, 2, 2, 2)));
        applyToPanel.add(getApplyToThresholdTarget(), LayoutHelper.getGBC(3, 0, 1, 0.0));
        applyToPanel.add(new JLabel(Constant.messages.getString(""pscan.options.policy.rules.label"")), LayoutHelper.getGBC(4, 0, 1, 0.0, new Insets(2, 2, 2, 2)));
        JButton applyThresholdButton = new JButton(Constant.messages.getString(""pscan.options.policy.go.button""));
        applyThresholdButton.addActionListener(new ActionListener() {
			@Override
			public void actionPerformed(ActionEvent e) {
				applyThreshold (strToThreshold((String)getApplyToThreshold().getSelectedItem()),
						(String)getApplyToThresholdTarget().getSelectedItem());
				getPassiveScanTableModel().fireTableDataChanged();
				
			}});
        applyToPanel.add(applyThresholdButton, LayoutHelper.getGBC(5, 0, 1, 0.0));
        applyToPanel.add(new JLabel(""""), LayoutHelper.getGBC(6, 0, 1, 1.0));	// Spacer
        
        
        this.add(applyToPanel,
                LayoutHelper.getGBC(0, 0, 3, 0.0D, 0.0D, GridBagConstraints.BOTH, new Insets(0, 0, 0, 0)));

        this.add(passiveScannersFilterPanel,LayoutHelper.getGBC(0, 1, 1, 1.0D, 0.0D,
                        GridBagConstraints.BOTH, GridBagConstraints.NORTHWEST, new Insets(0, 0, 0, 0)));

        this.add(getJScrollPane(), 
        		LayoutHelper.getGBC(0, 2, 1, 1.0, 1.0,
        				GridBagConstraints.BOTH, GridBagConstraints.NORTHWEST, new Insets(0, 0, 0, 0)));
    }","Initialize the controlling the controls for the
        panel."
"private void verifyPathIsOEX(File path) {
    checkNotNull(path);
    checkArgument(path.exists(), ""%s does not exist"", path.getAbsolutePath());
    checkArgument(!path.isDirectory(), ""%s is a directory"", path.getAbsolutePath());
    checkArgument(path.getName().endsWith("".oex""), ""%s does not end with .oex"", path.getName());
  }",Verify that the path is a valid OEX file.
"@Override
    public void removedBundle(Bundle bundle, BundleEvent event, List<I18nExtension> list) {
        String current = Long.toString(System.currentTimeMillis());
        for (I18nExtension extension : list) {
            synchronized (this) {
                extensions.remove(extension);
                etags.put(extension.locale(), current);
            }
        }
        LOGGER.info(""Bundle {} ({}) does not offer the {} resource bundle(s) anymore"",
                bundle.getSymbolicName(), bundle.getBundleId(), list.size());
    }",This method is called when a bundle is removed from the bundle list.
"private static byte[] toByteArray(InputStream is) throws IOException {
    try (ByteArrayOutputStream os = new ByteArrayOutputStream()) {
      byte[] buffer = new byte[0x2000];
      for (int len; (len = is.read(buffer)) != -1; )
        os.write(buffer, 0, len);
      return os.toByteArray();
    }
  }",read a byte array from an input stream
"private String insertFormats(final String pattern, final ArrayList<String> customPatterns) {
        if (!containsElements(customPatterns)) {
            return pattern;
        }
        final StringBuilder sb = new StringBuilder(pattern.length() * 2);
        final ParsePosition pos = new ParsePosition(0);
        int fe = -1;
        int depth = 0;
        while (pos.getIndex() < pattern.length()) {
            final char c = pattern.charAt(pos.getIndex());
            switch (c) {
            case QUOTE:
                appendQuotedString(pattern, pos, sb);
                break;
            case START_FE:
                depth++;
                sb.append(START_FE).append(readArgumentIndex(pattern, next(pos)));
                // do not look for custom patterns when they are embedded, e.g. in a choice
                if (depth == 1) {
                    fe++;
                    final String customPattern = customPatterns.get(fe);
                    if (customPattern != null) {
                        sb.append(START_FMT).append(customPattern);
                    }
                }
                break;
            case END_FE:
                depth--;
                //$FALL-THROUGH$
            default:
                sb.append(c);
                next(pos);
            }
        }
        return sb.toString();
    }",Insert formats into a string.
"private void setListEnabled(CmsList<? extends I_CmsListItem> list, boolean enabled, String disabledReason) {

        for (Widget child : list) {
            CmsTreeItem treeItem = (CmsTreeItem)child;
            if (enabled) {
                treeItem.getCheckBox().enable();
            } else {
                treeItem.getCheckBox().disable(disabledReason);
            }
            setListEnabled(treeItem.getChildren(), enabled, disabledReason);
        }
    }",Sets the enabled state of the list.
"public static String getVersion()
    {

        URL versionFile = SnappyLoader.class
                .getResource(""/META-INF/maven/org.xerial.snappy/snappy-java/pom.properties"");
        if (versionFile == null) {
            versionFile = SnappyLoader.class.getResource(""/org/xerial/snappy/VERSION"");
        }

        String version = ""unknown"";
        try {
            if (versionFile != null) {
                Properties versionData = new Properties();
                versionData.load(versionFile.openStream());
                version = versionData.getProperty(""version"", version);
                if (version.equals(""unknown"")) {
                    version = versionData.getProperty(""SNAPPY_VERSION"", version);
                }
                version = version.trim().replaceAll(""[^0-9M\\.]"", """");
            }
        }
        catch (IOException e) {
            System.err.println(e);
        }
        return version;
    }",Get the version of the Snappy class.
"public JBBPDslBuilder LongArray(final String name, final String sizeExpression) {
    final Item item = new Item(BinType.LONG_ARRAY, name, this.byteOrder);
    item.sizeExpression = assertExpressionChars(sizeExpression);
    this.addItem(item);
    return this;
  }",Add named long array which size calculated through expression.
"private String getOtherGroup(Tile tile, Tile neighbor)
    {
        final String group = mapGroup.getGroup(tile);
        for (final Tile shared : getSharedNeigbors(tile, neighbor))
        {
            final String sharedNeighborGroup = mapGroup.getGroup(shared);
            if (!group.equals(sharedNeighborGroup) && !isTransition(shared))
            {
                return sharedNeighborGroup;
            }
        }
        return null;
    }",Gets the other group.
"public static <T> List<T> withEagerDefault(List<T> self, Closure init) {
        return ListWithDefault.newInstance(self, false, init);
    }",Creates a list with eager default values.
"private void validateSubject(final Resource subject) {
        final String subjectURI = subject.getURI();
        // blank nodes are okay
        if (!subject.isAnon()) {
            // hash URIs with the same base as the topic are okay
            final int hashIndex = subjectURI.lastIndexOf(""#"");
            if (!(hashIndex > 0 && topic.getURI().equals(subjectURI.substring(0, hashIndex)))) {
                // the topic itself is okay
                if (!topic.equals(subject.asNode())) {
                    // it's a bad subject, but it could still be in-domain
                    if (idTranslator.inDomain(subject)) {
                        LOGGER.error(""{} is not in the topic of this RDF, which is {}."", subject, topic);
                        throw new IncorrectTripleSubjectException(subject +
                                "" is not in the topic of this RDF, which is "" + topic);
                    }
                    // it's not even in the right domain!
                    LOGGER.error(""subject ({}) is not in repository domain."", subject);
                    throw new OutOfDomainSubjectException(subject.asNode());
                }
            }
        }
    }",Validate subject.
"@Override
	public void mouseMoveOut() throws WidgetException {
		try {
	        // TODO: Need to figure out whether 10 is sufficient
	        int offsetAmount = 10;

	        WebElement elem = getWebElement();
	        Dimension dim = elem.getSize();
	        int width = dim.getWidth();
	        Actions builder = new Actions(getGUIDriver().getWrappedDriver());
	        synchronized (InteractiveElement.class) {
	            getGUIDriver().focus();
	            builder.moveToElement(getWebElement(), width + offsetAmount, 0).build().perform();
	        }
		} catch (Exception e) {
			throw new WidgetException(""Error while performing mouse move out"",
					getByLocator(), e);
		}
	}",Perform mouse move out operation.
"public Object initModelIF(EventModel em, ModelForm form, HttpServletRequest request) throws Exception {
		Object result = null;
		try {
			HandlerMetaDef hm = this.modelMapping.getHandlerMetaDef();
			String serviceName = hm.getServiceRef();
			Debug.logVerbose(""[JdonFramework] construct the CRUD method for the service:"" + serviceName, module);
			MethodMetaArgs methodMetaArgs = maFactory.createinitMethod(hm, em);
			RequestWrapper requestW = new HttpServletRequestWrapper(request);
			Service service = serviceFacade.getService(requestW.getContextHolder().getAppContextHolder());
			if (methodMetaArgs != null)
				result = service.execute(serviceName, methodMetaArgs, requestW);
		} catch (Exception e) {
			Debug.logError(""[JdonFramework] initModel error: "" + e, module);
			throw new Exception(e);
		}
		return result;
	}",initModelIF method initModelIF
"protected void updateLastCRLFInfo(int index, int pos, boolean isCR) {
        this.lastCRLFBufferIndex = index;
        this.lastCRLFPosition = pos;
        this.lastCRLFisCR = isCR;
    }",Update the last CRLF information in the cache.
"@Override
    public void closeConnection(Conversation conversation) {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.entry(this, tc, ""closeConnection"");

        try {
            conversation.close();
        } catch (SIException e) {
            FFDCFilter.processException(e,
                                        CLASS_NAME + "".rejectHandshake"",
                                        CommsConstants.SERVERTRANSPORTRECEIVELISTENER_CLOSECONN_01,
                                        this);

            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
                SibTr.debug(this, tc, ""Unable to close the conversation"", e);
        }

        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.exit(this, tc, ""closeConnection"");
    }",Close the connection.
"public java.util.List<String> getTagsToRemove() {
        if (tagsToRemove == null) {
            tagsToRemove = new com.amazonaws.internal.SdkInternalList<String>();
        }
        return tagsToRemove;
    }",Gets the value of the tagsToRemove property.
"public void setSize(DBIDRef id, int size) {
    if(csize == null) {
      csize = DataStoreUtil.makeIntegerStorage(ids, DataStoreFactory.HINT_HOT | DataStoreFactory.HINT_TEMP, 1);
    }
    csize.putInt(id, size);
  }",Set the size of a node.
"private IRingSet getRingSystemOfAtom(List ringSystems, IAtom ringAtom) {
        IRingSet ringSet = null;
        for (int f = 0; f < ringSystems.size(); f++) {
            ringSet = (IRingSet) ringSystems.get(f);
            if (ringSet.contains(ringAtom)) {
                return ringSet;
            }
        }
        return null;
    }",Get the ring system of the given atom.
"@Override
  public void eUnset(int featureID)
  {
    switch (featureID)
    {
      case SimpleExpressionsPackage.NUMBER_LITERAL__VALUE:
        setValue(VALUE_EDEFAULT);
        return;
    }
    super.eUnset(featureID);
  }",Override the eUnset method to unset the value of the CRA.
"static boolean doRetry(FrameworkMethod method, Throwable thrown, AtomicInteger retryCounter) {
        boolean doRetry = false;
        if ((retryCounter.decrementAndGet() > -1) && isRetriable(method, thrown)) {
            LOGGER.warn(""### RETRY ### {}"", method);
            doRetry = true;
        }
        return doRetry;
    }",Do retry.
"protected void registerCommandHandlers ()
    {
        MessageBundle msg = _ctx.getMessageManager().getBundle(_bundle);
        registerCommandHandler(msg, ""help"", new HelpHandler());
        registerCommandHandler(msg, ""clear"", new ClearHandler());
        registerCommandHandler(msg, ""speak"", new SpeakHandler());
        registerCommandHandler(msg, ""emote"", new EmoteHandler());
        registerCommandHandler(msg, ""think"", new ThinkHandler());
        registerCommandHandler(msg, ""tell"", new TellHandler());
        registerCommandHandler(msg, ""broadcast"", new BroadcastHandler());
    }",Registers the command handlers for the NCSCTYPE.
"public void abortDataTransfers() {
        while(!dataConnections.isEmpty()) {
            Socket socket = dataConnections.poll();
            if(socket != null) Utils.closeQuietly(socket);
        }
    }",Abort all data transfers.
"@GuardedBy(""lock"")
  private void stopIfNecessary() {
    if (!(goAwayStatus != null && streams.isEmpty() && pendingStreams.isEmpty())) {
      return;
    }
    if (stopped) {
      return;
    }
    stopped = true;

    if (keepAliveManager != null) {
      keepAliveManager.onTransportTermination();
      // KeepAliveManager should stop using the scheduler after onTransportTermination gets called.
      scheduler = SharedResourceHolder.release(TIMER_SERVICE, scheduler);
    }

    if (ping != null) {
      ping.failed(getPingFailure());
      ping = null;
    }

    if (!goAwaySent) {
      // Send GOAWAY with lastGoodStreamId of 0, since we don't expect any server-initiated
      // streams. The GOAWAY is part of graceful shutdown.
      goAwaySent = true;
      frameWriter.goAway(0, ErrorCode.NO_ERROR, new byte[0]);
    }

    // We will close the underlying socket in the writing thread to break out the reader
    // thread, which will close the frameReader and notify the listener.
    frameWriter.close();
  }",Stop the server if necessary.
"public void setScheduledActionNames(java.util.Collection<String> scheduledActionNames) {
        if (scheduledActionNames == null) {
            this.scheduledActionNames = null;
            return;
        }

        this.scheduledActionNames = new java.util.ArrayList<String>(scheduledActionNames);
    }",Sets the value of the scheduledActionNames property.
"public void setTextWithoutAnimation(CharSequence text, TextView.BufferType type) {
        mSkipAnimation = true;
        mEditText.setText(text, type);
    }",Set text without animation.
"public long getPermits(long requestedPermits, long minPermits, long timeoutMillis) {
    PermitsAndDelay permitsAndDelay = getPermitsAndDelay(requestedPermits, minPermits, timeoutMillis);
    if (permitsAndDelay.delay > 0) {
      try {
        Thread.sleep(permitsAndDelay.delay);
      } catch (InterruptedException ie) {
        return 0;
      }
    }
    return permitsAndDelay.permits;
  }",Get the number of permits that are allowed to be granted.
"public static Between betweenExclusiveMax( String property, int minimum, int maximum)
    {
    return new Between( notLessThan( property, minimum), lessThan( property, maximum));
    }",Create a Between expression from the given property name and the given minimum and maximum inclusive.
"private void V(StringBuilder buf) {

    Token t = getNextToken();
    if (t.tokenType != TokenType.VALUE) {
      throw new IllegalStateException(""Unexpected token "" + t);
    }
    buf.append(t.getValue());

    t = getNextToken();
    if (t.tokenType == TokenType.EOL) {
      return;
    } else if (t.tokenType == TokenType.TRAILING_BACKSLASH) {
      Vopt(buf);

    }
  }",Vopt.
"public void pullUpTo(Phase phase)
	{
		// get
		
		if (!phase.contains(GET))
		{
			return;
		}
		
		T targetValue = target.getValue();
		
		// validate-post-get
		
		if (!phase.contains(VALIDATE_POST_GET))
		{
			return;
		}
		
		Collection<V> oldViolations = new ArrayList<V>(violations);
		violations.clear();

		if (validate(targetValidator, targetValue) && phase.contains(CONVERT))
		{
			// convert
			
			boolean converted = true;
			S sourceValue = null;
			
			try
			{
				sourceValue = converter.unconvert(targetValue);
			}
			// TODO: catch all other exceptions and terminate too?
			catch (UnsupportedOperationException exception)
			{
				converted = false;
			}
			
			// validate-pre-set
		
			if (converted && phase.contains(VALIDATE_PRE_SET) && validate(sourceValidator, sourceValue)
				&& phase.contains(SET))
			{
				// set
				
				source.setValue(sourceValue);
			}
		}
		
		support.fireValueChanged(oldViolations, new ArrayList<V>(violations));
	}",Pulls up the target value from the target value to the target value.
"@Override
    public R visitMemberReference(MemberReferenceTree node, P p) {
        R r = scan(node.getQualifierExpression(), p);
        r = scanAndReduce(node.getTypeArguments(), p, r);
        return r;
    }",Scans a MemberReference tree for qualifier expressions and type arguments and returns the corresponding value.
"@SuppressWarnings(""unchecked"")
  public static <T> List<T> findAll(T[] array, Filter<T> filter) {

    Assert.notNull(filter, ""Filter is required"");

    return stream(nullSafeArray(array)).filter(filter::accept).collect(Collectors.toList());
  }",Find all the NCSID    objects in the array.
"@Override
    public ReturnPathTypeDataflow analyze(IAnalysisCache analysisCache, MethodDescriptor descriptor)
            throws CheckedAnalysisException {
        CFG cfg = getCFG(analysisCache, descriptor);
        DepthFirstSearch dfs = getDepthFirstSearch(analysisCache, descriptor);
        ReverseDepthFirstSearch rdfs = getReverseDepthFirstSearch(analysisCache, descriptor);
        ReturnPathTypeAnalysis analysis = new ReturnPathTypeAnalysis(cfg, rdfs, dfs);
        ReturnPathTypeDataflow dataflow = new ReturnPathTypeDataflow(cfg, analysis);

        dataflow.execute();

        return dataflow;
    }",This method is used to perform the actual analysis of the return path type analysis.
"public TouchActions scroll(WebElement onElement, int xOffset, int yOffset) {
    if (touchScreen != null) {
      action.addAction(new ScrollAction(touchScreen, (Locatable) onElement, xOffset, yOffset));
    }
    return this;
  }",Scroll the specified element.
"public static RubyRange<Double> range(double start, double end) {
    String startStr = String.valueOf(start);
    String endStr = String.valueOf(end);
    int startPrecision = startStr.length() - startStr.lastIndexOf('.') - 1;
    int endPrecision = endStr.length() - endStr.lastIndexOf('.') - 1;
    return new RubyRange<>(
        new DoubleSuccessor(Math.max(startPrecision, endPrecision)), start, end,
        Interval.CLOSED);
  }",Create a range of numbers.
"public static boolean intArrayContains(int[] array, int numToCheck) {
        for (int i = 0; i < array.length; i++) {
            if (array[i] == numToCheck) {
                return true;
            }
        }
        return false;
    }",Check if an int array contains the number
"private void onRecord(Record message, ActorRef self, ActorRef sender) {
        if (is(inProgress)) {
            // Forward to media server controller
            this.recording = true;
            this.msController.tell(message, sender);
        }
    }",Handle a record message
"protected void doTrace(HttpServletRequest req, HttpServletResponse resp) 
        throws ServletException, IOException
    {
        
        int responseLength;

        String CRLF = ""\r\n"";
        StringBuilder buffer = new StringBuilder(""TRACE "").append(req.getRequestURI())
            .append("" "").append(req.getProtocol());

        Enumeration<String> reqHeaderEnum = req.getHeaderNames();

        while( reqHeaderEnum.hasMoreElements() ) {
            String headerName = reqHeaderEnum.nextElement();
            buffer.append(CRLF).append(headerName).append("": "")
                .append(req.getHeader(headerName));
        }

        buffer.append(CRLF);

        responseLength = buffer.length();

        resp.setContentType(""message/http"");
        resp.setContentLength(responseLength);
        ServletOutputStream out = resp.getOutputStream();
        out.print(buffer.toString());
    }",Trace the request.
"private Number convert(Class<? extends Number> type, Float value) {
		if (int.class.isAssignableFrom(type) || Integer.class.isAssignableFrom(type)) {
			return value.intValue();
		}
		if (float.class.isAssignableFrom(type) || Float.class.isAssignableFrom(type)) {
			return value;
		}
		throw new IllegalArgumentException(""Use integer or float"");
	}",Convert a Float value to an Integer or Float.
"public String getPublicIdentifier() throws DocumentStoreException {
        Misc.checkState(this.isOpen(), ""Database is closed"");
        try {
            return get(queue.submit(new GetPublicIdentifierCallable()));
        } catch (ExecutionException e) {
            logger.log(Level.SEVERE, ""Failed to get public ID"", e);
            throw new DocumentStoreException(""Failed to get public ID"", e);
        }
    }",Get the public identifier of the database.
"public Serializer writeString(String value) throws IOException {
        if (null == value) return writeNull();

        writer.write('""');

        char[] chars = value.toCharArray();

        for (int i=0; i<chars.length; i++)
        {
            char c = chars[i];
            switch (c)
            {
                case  '""': writer.write(""\\\""""); break;
                case '\\': writer.write(""\\\\""); break;
                case    0: writer.write(""\\u0000""); break;
                case '\b': writer.write(""\\b""); break;
                case '\t': writer.write(""\\t""); break;
                case '\n': writer.write(""\\n""); break;
                case '\f': writer.write(""\\f""); break;
                case '\r': writer.write(""\\r""); break;
                case '/': writer.write(""\\/""); break;
                default:
                    if ((c >= 32) && (c <= 126))
                    {
                        writer.write(c);
                    }
                    else
                    {
                        writer.write(""\\u"");
                        writer.write(rightAlignedZero(Integer.toHexString(c),4));
                    }
            }
        }

        writer.write('""');

        return this;
    }",Write a string to the output stream.
"protected Response buildAuthenticationResponse(final OpenIdService service,
                                                   final Map<String, String> parameters,
                                                   final boolean successFullAuthentication,
                                                   final String id,
                                                   final ParameterList parameterList) {
        val response = serverManager.authResponse(parameterList, id, id, successFullAuthentication, true);
        parameters.putAll(response.getParameterMap());
        LOGGER.debug(""Parameters passed for the OpenID response are [{}]"", parameters.keySet());
        return buildRedirect(service, parameters);
    }",Build authentication response.
"public void setSynchronized(boolean newSynchronized)
	{
		boolean oldSynchronized = synchronized_;
		synchronized_ = newSynchronized;
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, TypesPackage.JVM_OPERATION__SYNCHRONIZED, oldSynchronized, synchronized_));
	}",Sets the synchronized flag.
"public String[] segmenterExceptions(final String[] lines) {
    final List<String> sentences = new ArrayList<>();
    for (final String line : lines) {
      final String segmentedLine = segmenterNonBreaker(line);
      final String[] lineSentences = segmentedLine.split(""\n"");
      for (final String lineSentence : lineSentences) {
        sentences.add(lineSentence);
      }
    }
    return sentences.toArray(new String[sentences.size()]);
  }",Segmenter exceptions.
"@Nonnull
  public static GenericodeWriter <com.helger.genericode.v04.CodeListDocument> gc04CodeList ()
  {
    return new GenericodeWriter<> (EGenericodeDocumentType.GC04_CODE_LIST);
  }",Create a writer for CGC04 code list.
"private void setupUI(final String labelText) {
		WButton dupBtn = new WButton(""Duplicate"");
		dupBtn.setAction(new DuplicateAction());

		WButton clrBtn = new WButton(""Clear"");
		clrBtn.setAction(new ClearAction());

		add(new WLabel(labelText, textFld));
		add(textFld);
		add(dupBtn);
		add(clrBtn);
		add(new WAjaxControl(dupBtn, this));
		add(new WAjaxControl(clrBtn, this));
	}",Setup the UI for the duplicate and clear buttons.
"public static Intent newSmsIntent(Context context, String body, String phoneNumber) {
        return newSmsIntent(context, body, new String[]{phoneNumber});
    }",Create an Intent to send an SMS message to the user.
"public static boolean cs_lsolve(DZcs L, DZcsa x)
	{
		int p, j, n, Lp[], Li[] ;
		DZcsa Lx = new DZcsa() ;
		if (!CS_CSC (L) || x == null) return (false);	/* check inputs */
		n = L.n ; Lp = L.p ; Li = L.i ; Lx.x = L.x ;
		for (j = 0 ; j < n ; j++)
		{
			x.set(j, cs_cdiv(x.get(j), Lx.get(Lp [j]))) ;
			for (p = Lp [j]+1 ; p < Lp [j+1] ; p++)
			{
				x.set(Li [p], cs_cminus(x.get(Li [p]), cs_cmult(Lx.get(p), x.get(j)))) ;
			}
		}
		return (true) ;
	}",L - solve x = L.
"private static <E> List<E> toList(Iterable<E> iterable)
	{
		List<E> list = new ArrayList<>();
		iterable.forEach(list::add);
		return list;
	}",Converts an iterable to a list of entities.
"public static Map<String, String> transformMap(final Map<String, Object> paramMap) {
        final Map<String, String> paramStrMap = new LinkedHashMap<String, String>();
        for (final Map.Entry<String, Object> entry : paramMap.entrySet()) {
            paramStrMap.put(entry.getKey(), entry.getValue().toString());
        }

        return paramStrMap;
    }",Transform map.
"public static int daysBetween(int year1, int month1, int day1, int year2, int month2, int day2) {
		return fixedFromGregorian(year1, month1, day1) - fixedFromGregorian(year2, month2, day2);
	}",Get the number of days between two dates.
"private Class<?> loadGeneratedClass(ClassLoader classLoader,
                                        String className,
                                        NameUtil nameUtil) throws ClassNotFoundException {
        if (className == null)
            return null;

        final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();
        Class<?> loadedClass = null;
        String loadClassName = className;

        // Exception to throw if we can not load the class and we can not
        // determine name of generated class. Not thrown if this method is
        // able to return the loaded Class object.
        ClassNotFoundException primaryException = new ClassNotFoundException(className); // F743-1752.1

        // -----------------------------------------------------------------------
        // First, try and load the class using the class name as specified.
        //
        // This is different than previous releases, where the hash suffix
        // was first added for EJB 1.1 classes.  Instead, the hash suffix
        // is being added automatically by NameUtil for EJB 1.1 class names,
        // so it doesn't need to be done here any more.
        // -----------------------------------------------------------------------
        if (isTraceOn && tc.isDebugEnabled())
            Tr.debug(tc, ""loadGeneratedClass: Loading class = "" + loadClassName);

        try {
            loadedClass = classLoader.loadClass(loadClassName);
        } catch (ClassNotFoundException cnfe) {
            // Do not FFDC log this, as this is a normal exception when the
            // class was generated with an older version of EJBDeploy
            // FFDCFilter.processException(ex, CLASS_NAME + "".loadGeneratedClass"", ""4458"");
            primaryException = cnfe;
            if (isTraceOn && tc.isDebugEnabled())
                Tr.debug(tc, ""loadGeneratedClass: load failed: "" + cnfe);
        }

        // -----------------------------------------------------------------------
        // Second, try and load the class using the modified BuzzHash suffix.
        //
        // For performance, the call to NameUtil to get the modified hash suffix
        // will change the state of the NameUtil instance so that subsequent
        // names obtained for this EJB will use the modified suffix... and the
        // subsequent classes will be loaded by the first attempt above,
        // reducing the number of ClassNotFoundExceptions.
        // -----------------------------------------------------------------------
        if (loadedClass == null) {
            loadClassName = nameUtil.updateFilenameHashCode(loadClassName);
            if (loadClassName != null) {
                if (isTraceOn && tc.isDebugEnabled())
                    Tr.debug(tc, ""loadGeneratedClass: Loading class = "" + loadClassName);
                try {
                    loadedClass = classLoader.loadClass(loadClassName);
                } catch (ClassNotFoundException cnfe) {
                    // Do not FFDC log this, as this is a normal exception when the
                    // class was generated with an older version of EJBDeploy
                    // FFDCFilter.processException(ex, CLASS_NAME + "".loadGeneratedClass"", ""378"");
                    primaryException = cnfe; // F743-1752.1
                    if (isTraceOn && tc.isDebugEnabled())
                        Tr.debug(tc, ""loadGeneratedClass: load failed: "" + cnfe);
                }
            }
        }

        // -----------------------------------------------------------------------
        // Third, try and load the class using the EJB 1.1 original class name
        // (i.e. contained no hashcode suffix). The updated name will be null
        // for EJB 2.0 and later module levels.
        //
        // For performance, the call to NameUtil to remove the hash suffix
        // will change the state of the NameUtil instance so that subsequent
        // names obtained for this EJB will contain no suffix... and the
        // subsequent classes will be loaded by the first attempt above,
        // reducing the number of ClassNotFoundExceptions.
        // -----------------------------------------------------------------------
        if (loadedClass == null) {
            loadClassName = nameUtil.updateFilenameHashCode(loadClassName);
            if (loadClassName != null) {
                if (isTraceOn && tc.isDebugEnabled())
                    Tr.debug(tc, ""loadGeneratedClass: Loading class = "" + loadClassName);
                try {
                    loadedClass = classLoader.loadClass(loadClassName);
                } catch (ClassNotFoundException cnfe) {
                    // Do not FFDC log this, as it will be logged by the caller
                    // FFDCFilter.processException(ex, CLASS_NAME + "".loadGeneratedClass"", ""4520"");
                    primaryException = cnfe; // F743-1752.1
                    if (isTraceOn && tc.isDebugEnabled())
                        Tr.debug(tc, ""loadGeneratedClass: load failed: "" + cnfe);
                }
            }
        }

        // -----------------------------------------------------------------------
        // Finally, insure an exception is thrown if none of the class load
        // attempts were successful.
        // -----------------------------------------------------------------------
        if (loadedClass == null) {
            if (isTraceOn && tc.isDebugEnabled())
                Tr.debug(tc, ""loadGeneratedClass: all attempts failed: "" + primaryException);

            throw primaryException;
        }

        return loadedClass;

    }",Load the generated class using the specified name.
"protected <T extends Persistable, ID extends Serializable> SimpleEbeanRepository<T, ID> getTargetRepository(
            RepositoryInformation information, EbeanServer ebeanServer) {

        return getTargetRepositoryViaReflection(information, information.getDomainType(), ebeanServer);
    }",Get a target repository via reflection.
"public void init(EvaluatePP inst, long nrf)
	{
		instance = inst;
		act = new long[(int) nrf];
		fin = new long[(int) nrf];
		req = new long[(int) nrf];
		active = new long[(int) nrf];
		waiting = new long[(int) nrf];
	}",Initialize the object.
"@Override
    public QAnd prepare(final AbstractTypeQuery _query,
                        final AbstractQPart _part)
        throws EFapsException
    {
        for (final AbstractQPart part : this.parts) {
            part.prepare(_query, this);
        }
        return this;
    }",Method to prepare the result.
"public static void deleteCommerceNotificationQueueEntry(
		long commerceNotificationQueueEntryId)
		throws com.liferay.portal.kernel.exception.PortalException {
		getService()
			.deleteCommerceNotificationQueueEntry(commerceNotificationQueueEntryId);
	}",Deletes the commerce notification queue entry with the primary key from the database. Also notifies the appropriate model listeners.
"public void info(Marker marker, String msg) {
        if (!logger.isInfoEnabled(marker))
            return;
        if (instanceofLAL) {
            ((LocationAwareLogger) logger).log(marker, fqcn, LocationAwareLogger.INFO_INT, msg, null, null);
        } else {
            logger.info(marker, msg);
        }
    }",Log a message at the INFO level.
"public static String escapeForXML(String source) {
        Args.nullNotPermitted(source, ""source"");
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < source.length(); i++) {
            char c = source.charAt(i);
            switch (c) {
                case '<' : {
                    sb.append(""&lt;"");
                    break;
                } 
                case '>' : {
                    sb.append(""&gt;"");
                    break;
                } 
                case '&' : {
                    String next = source.substring(i, Math.min(i + 6, 
                            source.length()));
                    if (next.startsWith(""&lt;"") || next.startsWith(""&gt;"") 
                            || next.startsWith(""&amp;"") 
                            || next.startsWith(""&apos;"")
                            || next.startsWith(""&quot;"")) {
                        sb.append(c); 
                    } else {
                        sb.append(""&amp;"");
                    }
                    break;
                } 
                case '\'' : {
                    sb.append(""&apos;"");
                    break;
                } 
                case '\""' : {
                    sb.append(""&quot;"");
                    break;
                } 
                default : sb.append(c);
            }
        }
        return sb.toString();
    }",Escape for XML.
"@Override
    public String getValue(ParsedCommandLine args, boolean required) throws CommandFormatException {
        if(!required) {
            return null;
        }
        if(isPresent(args)) {
            return null;
        }
        throw new CommandFormatException(""Required argument '"" + fullName + ""' is missing value."");
    }",Get the value of the CIDIVACTYPE command.
"private void flushBuffer() {	
		if (vertIndex == 0) {
			return;
		}
		if (currentType == NONE) {
			return;
		}
		
		if (vertIndex < TOLERANCE) {
			GL11.glBegin(currentType);
			for (int i=0;i<vertIndex;i++) {
				GL11.glColor4f(cols[(i*4)+0], cols[(i*4)+1], cols[(i*4)+2], cols[(i*4)+3]);
				GL11.glTexCoord2f(texs[(i*2)+0], texs[(i*2)+1]);
				GL11.glVertex3f(verts[(i*3)+0], verts[(i*3)+1], verts[(i*3)+2]);
			}
			GL11.glEnd();
			currentType = NONE;
			return;
		}
		vertices.clear();
		colors.clear();
		textures.clear();
		
		vertices.put(verts,0,vertIndex*3);
		colors.put(cols,0,vertIndex*4);
		textures.put(texs,0,vertIndex*2);
		
		vertices.flip(); 
		colors.flip(); 
		textures.flip(); 
		
		GL11.glVertexPointer(3,0,vertices);     
		GL11.glColorPointer(4,0,colors);     
		GL11.glTexCoordPointer(2,0,textures);     
		
		GL11.glDrawArrays(currentType, 0, vertIndex);
		currentType = NONE;
	}",Flush the buffer.
"public FrustumIntersection set(Matrix4fc m, boolean allowTestSpheres) {
        float invl;
        nxX = m.m03() + m.m00(); nxY = m.m13() + m.m10(); nxZ = m.m23() + m.m20(); nxW = m.m33() + m.m30();
        if (allowTestSpheres) {
            invl = (float) (1.0 / Math.sqrt(nxX * nxX + nxY * nxY + nxZ * nxZ));
            nxX *= invl; nxY *= invl; nxZ *= invl; nxW *= invl;
        }
        planes[0].set(nxX, nxY, nxZ, nxW);
        pxX = m.m03() - m.m00(); pxY = m.m13() - m.m10(); pxZ = m.m23() - m.m20(); pxW = m.m33() - m.m30();
        if (allowTestSpheres) {
            invl = (float) (1.0 / Math.sqrt(pxX * pxX + pxY * pxY + pxZ * pxZ));
            pxX *= invl; pxY *= invl; pxZ *= invl; pxW *= invl;
        }
        planes[1].set(pxX, pxY, pxZ, pxW);
        nyX = m.m03() + m.m01(); nyY = m.m13() + m.m11(); nyZ = m.m23() + m.m21(); nyW = m.m33() + m.m31();
        if (allowTestSpheres) {
            invl = (float) (1.0 / Math.sqrt(nyX * nyX + nyY * nyY + nyZ * nyZ));
            nyX *= invl; nyY *= invl; nyZ *= invl; nyW *= invl;
        }
        planes[2].set(nyX, nyY, nyZ, nyW);
        pyX = m.m03() - m.m01(); pyY = m.m13() - m.m11(); pyZ = m.m23() - m.m21(); pyW = m.m33() - m.m31();
        if (allowTestSpheres) {
            invl = (float) (1.0 / Math.sqrt(pyX * pyX + pyY * pyY + pyZ * pyZ));
            pyX *= invl; pyY *= invl; pyZ *= invl; pyW *= invl;
        }
        planes[3].set(pyX, pyY, pyZ, pyW);
        nzX = m.m03() + m.m02(); nzY = m.m13() + m.m12(); nzZ = m.m23() + m.m22(); nzW = m.m33() + m.m32();
        if (allowTestSpheres) {
            invl = (float) (1.0 / Math.sqrt(nzX * nzX + nzY * nzY + nzZ * nzZ));
            nzX *= invl; nzY *= invl; nzZ *= invl; nzW *= invl;
        }
        planes[4].set(nzX, nzY, nzZ, nzW);
        pzX = m.m03() - m.m02(); pzY = m.m13() - m.m12(); pzZ = m.m23() - m.m22(); pzW = m.m33() - m.m32();
        if (allowTestSpheres) {
            invl = (float) (1.0 / Math.sqrt(pzX * pzX + pzY * pzY + pzZ * pzZ));
            pzX *= invl; pzY *= invl; pzZ *= invl; pzW *= invl;
        }
        planes[5].set(pzX, pzY, pzZ, pzW);
        return this;
    }",Sets the intersection of this frustum from the given matrix.
"public void decrypt(File src, File dest) throws GeneralSecurityException, IOException {
		InputStream is = null;
		OutputStream os = null;
		try {
			is = encryptor.wrapInputStream(new FileInputStream(src));
			os = new FileOutputStream(dest);
			copy(is, os);
		} finally {
			if(is != null) {
				is.close();
			}
			if(os != null) {
				os.close();
			}
		}
	}",Decrypt a file.
"public final void mRIGHT_PAREN() throws RecognitionException {
		try {
			int _type = RIGHT_PAREN;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// src/main/resources/org/drools/compiler/lang/DRL5Lexer.g:242:9: ( ')' )
			// src/main/resources/org/drools/compiler/lang/DRL5Lexer.g:242:11: ')'
			{
			match(')'); if (state.failed) return;
			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}",start INSIDE RIGHT_PAREN
"public static GoogleCloudStorageItemInfo createNotFound(StorageResourceId resourceId) {
    checkArgument(resourceId != null, ""resourceId must not be null"");
    // Bucket or StorageObject.
    return new GoogleCloudStorageItemInfo(
        resourceId,
        /* creationTime= */ 0,
        /* size= */ -1,
        /* location= */ null,
        /* storageClass= */ null);
  }",Creates a new empty missing item info.
"public void open(String strKeyArea, int iOpenMode, boolean bDirection, String strFields, Object objInitialKey, Object objEndKey, byte[] byBehaviorData) throws DBException, RemoteException
    {
        try   {
            synchronized (this.getTask())
            {   // In case two tasks are calling here
                this.getMainRecord().close();

        // FROM is automatic, since the remote BaseRecord is exactly the same as this one
        // ORDER BY
                KeyArea keyArea =  this.getMainRecord().getKeyArea();
                if (strKeyArea != null)
                {
                    this.getMainRecord().setKeyArea(strKeyArea);
                    keyArea = this.getMainRecord().getKeyArea(-1);
                    // This next set of code deals with a special case where the caller wants a non-key area order
                    if (this.getMainRecord().getDefaultOrder() == Constants.MAIN_KEY_AREA)
                        if (!keyArea.getKeyName().equals(strKeyArea))
                            if (!Constants.PRIMARY_KEY.equals(strKeyArea))
                    {
                        BaseField field = this.getMainRecord().getField(strKeyArea);
                        if (field != null)
                        {
                            KeyArea tempKeyStart = this.getMainRecord().makeIndex(DBConstants.NOT_UNIQUE, null);  // Add temp key
                            tempKeyStart.addKeyField(field, bDirection);
                            this.getMainRecord().setKeyArea(this.getMainRecord().getKeyAreaCount() - 1);
                        }
                    }
                    keyArea.setKeyOrder(bDirection);
                }
        // Open mode
                this.getMainRecord().setOpenMode(iOpenMode);
        // SELECT (fields to select)
                if (strFields != null)
                    this.getMainRecord().setSelected(strFields);    // Select these fields
                else
                {
                    Record recordBase = this.getMainRecord().getTable().getCurrentTable().getRecord();
                    int iFieldTypes = this.getFieldTypes(recordBase);
                    if (iFieldTypes == BaseBuffer.PHYSICAL_FIELDS)
                        this.getMainRecord().setSelected(true);   // Select these fields (otherwise leave the selection alone)
                }
        // WHERE XYZ >=
                FileListener listener = null;
                listener = (FileListener)this.getMainRecord().getListener();
                while (listener != null)
                {   // Clear inited flag from all Linked behaviors
                    if ((listener.getMasterSlaveFlag() & FileListener.LINKED_TO_SLAVE) != 0)
                        listener.setMasterSlaveFlag(listener.getMasterSlaveFlag() & ~FileListener.INITED_IN_SLAVE);    // Clear inited flag
                    listener = (FileListener)listener.getNextListener();
                }
                if (objInitialKey != null)
                {
                    VectorBuffer recBuff = new VectorBuffer((Vector)objInitialKey);
                    int iLastModified = -1;
                    keyArea.reverseKeyBuffer(recBuff, DBConstants.FILE_KEY_AREA);
                    String strLastModified = recBuff.getNextString();
                    try {
                        if (strLastModified != null)
                            iLastModified = Integer.parseInt(strLastModified);
                    } catch (NumberFormatException ex)  {
                        iLastModified = -1;
                    }
                    this.getMainRecord().addListener(listener = new SubCurrentFilter(iLastModified, true, false));   // Use current
                    listener.setMasterSlaveFlag(listener.getMasterSlaveFlag() | FileListener.INITED_IN_SLAVE | FileListener.LINKED_TO_SLAVE | FileListener.RUN_IN_SLAVE);
                }
        // WHERE XYZ >=
                if (objEndKey != null)
                {
                    VectorBuffer recBuff = new VectorBuffer((Vector)objEndKey);
                    keyArea.reverseKeyBuffer(recBuff, DBConstants.FILE_KEY_AREA);
                    int iLastModified = -1;
                    String strLastModified = recBuff.getNextString();
                    try {
                        if (strLastModified != null)
                            iLastModified = Integer.parseInt(strLastModified);
                    } catch (NumberFormatException ex)  {
                        iLastModified = -1;
                    }
                    this.getMainRecord().addListener(listener = new SubCurrentFilter(iLastModified, false, true));   // Use current
                    listener.setMasterSlaveFlag(listener.getMasterSlaveFlag() | FileListener.INITED_IN_SLAVE | FileListener.LINKED_TO_SLAVE | FileListener.RUN_IN_SLAVE);
                }
        // WHERE XYZ
        // The following code replicates the Behaviors for the server class.
        // If the listener doesn't exist, it is created and the current params are set.
        // If the listener does exist, the current params are set.
        // Note: There is a special section of code to see that if two behaviors with the same
        // name exist, they are set separately.
                if (byBehaviorData != null)
                {
                    ByteArrayInputStream baIn = new ByteArrayInputStream(byBehaviorData);
                    ObjectInputStream daIn = new ObjectInputStream(baIn);
                    String strBehaviorName = null;
                    try   {
                            strBehaviorName = daIn.readUTF();
                        } catch (IOException ex)    {
                            strBehaviorName = null;
                        }
                    while (strBehaviorName != null)
                    {
                        listener = (FileListener)this.getMainRecord().getListener(strBehaviorName);
                        while (listener != null)
                        {   // Already set up this listener, find the next one or null
                            if ((listener.getMasterSlaveFlag() & FileListener.LINKED_TO_SLAVE) != 0)
                                if ((listener.getMasterSlaveFlag() & FileListener.INITED_IN_SLAVE) == 0)
                                    break;      // Use this listener (Linked, but not inited)
                            listener = (FileListener)listener.getListener(strBehaviorName);
                        }
                        if (listener == null)
                        {
                        	listener = (FileListener)ClassServiceUtility.getClassService().makeObjectFromClassName(strBehaviorName);
                        }
                        else
                        {
                            this.getMainRecord().removeListener(listener, false);
                        }
                        listener.initRemoteSkel(daIn);
                        this.getMainRecord().addListener(listener);
                        listener.setMasterSlaveFlag(listener.getMasterSlaveFlag() | FileListener.INITED_IN_SLAVE | FileListener.LINKED_TO_SLAVE);
                        try   {
                            strBehaviorName = daIn.readUTF();
                        } catch (IOException ex)    {
                            strBehaviorName = null;
                        }
                    }
                    daIn.close();
                    baIn.close();
                }
                listener = (FileListener)this.getMainRecord().getListener();
                while (listener != null)
                {   // Remove old created behaviors (linked, but not inited)
                    FileListener behaviorToRemove = listener;
                    listener = (FileListener)listener.getNextListener();
                    if ((behaviorToRemove.getMasterSlaveFlag() & FileListener.LINKED_TO_SLAVE) != 0)
                        if ((behaviorToRemove.getMasterSlaveFlag() & FileListener.INITED_IN_SLAVE) == 0)
                            this.getMainRecord().removeListener(behaviorToRemove, true);
                }
        // End
                Utility.getLogger().info(""EJB Open key: "" + strKeyArea);
                this.getMainRecord().open();
            }
        } catch (DBException ex)    {
            throw ex;
        } catch (Exception ex)  {
            ex.printStackTrace();
            throw new DBException(ex.getMessage());
        }
    }",Open the record.
"public final void setUsagePolicy(Callback<Integer, Usage> policy) {
        Objects.requireNonNull(policy);
        this.usagePolicy.set(policy);
    }",Sets the usage policy.
"private static Object initializeEmbedded(EmbeddedMetadata embeddedMetadata, Object target) {
    try {
      // If instantiation of Entity instantiated the embeddable, we will
      // use the pre-initialized embedded object.
      Object embeddedObject = embeddedMetadata.getReadMethod().invoke(target);
      if (embeddedObject == null) {
        // Otherwise, we will instantiate the embedded object, which
        // could be a Builder
        embeddedObject = IntrospectionUtils.instantiate(embeddedMetadata);
        ConstructorMetadata constructorMetadata = embeddedMetadata.getConstructorMetadata();
        if (constructorMetadata.isBuilderConstructionStrategy()) {
          // Build the Builder
          embeddedObject = constructorMetadata.getBuildMethodHandle().invoke(embeddedObject);
        } else {
          // TODO we should not be doing this?? There is no equivalent
          // of this for builder pattern
          embeddedMetadata.getWriteMethod().invoke(target, embeddedObject);
        }
      }
      return embeddedObject;
    } catch (Throwable t) {
      throw new EntityManagerException(t);
    }
  }",Initialize the embedded object.
"public PathTemplate subTemplate(String varName) {
    List<Segment> sub = Lists.newArrayList();
    boolean inBinding = false;
    for (Segment seg : segments) {
      if (seg.kind() == SegmentKind.BINDING && seg.value().equals(varName)) {
        inBinding = true;
      } else if (inBinding) {
        if (seg.kind() == SegmentKind.END_BINDING) {
          return PathTemplate.create(toSyntax(sub, true), urlEncoding);
        } else {
          sub.add(seg);
        }
      }
    }
    throw new ValidationException(
        String.format(""Variable '%s' is undefined in template '%s'"", varName, this.toRawString()));
  }",Returns a sub template of this template.
"public void doLogout( StaplerRequest req, StaplerResponse rsp ) throws IOException, ServletException {
        String user = getAuthentication().getName();
        securityRealm.doLogout(req, rsp);
        SecurityListener.fireLoggedOut(user);
    }",Logout the user.
"public Packer setContainer(final Container cont) throws IllegalAccessException {
        if (container != null) {
            final Packer p = (Packer) clone();
            container.setLayout(p);
        }
        container = cont;
        cont.setLayout(this);
        return this;
    }",Sets the container.
"public void readArray(double[] data) throws IOException {
        int size = data.length;
        for (int i = 0; i < size; ++i)
            data[i] = getDouble();
    }",readArray Method.
"public Iterable<long[]> availableCoordinates() {
		List<long[]> coordinates = new ArrayList<long[]>();
		for (Long r : rows.keySet()) {
			Matrix m = rows.get(r);
			for (long[] c : m.availableCoordinates()) {
				coordinates.add(Coordinates.plus(c, new long[] { r, 0 }));
			}
		}
		return coordinates;
	}",Returns the coordinates of the available coordinates in this matrix.
"public Actions keyDown(WebElement target, CharSequence key) {
    if (isBuildingActions()) {
      action.addAction(new KeyDownAction(jsonKeyboard, jsonMouse, (Locatable) target, asKeys(key)));
    }
    return focusInTicks(target)
        .addKeyAction(key, codepoint -> tick(defaultKeyboard.createKeyDown(codepoint)));
  }",KeyDown action.
"@Override
    public ResourceSet<Task> read(final TwilioRestClient client) {
        return new ResourceSet<>(this, client, firstPage(client));
    }","Example of reading a
    resource."
"public static List<DiscoveryIncomingMessage> sendQueryAndCollectAnswers(DiscoveryOutgoingMessage pOutMsg,
                                                                            int pTimeout,
                                                                            LogHandler pLogHandler) throws IOException {
        final List<Future<List<DiscoveryIncomingMessage>>> futures = sendDiscoveryRequests(pOutMsg, pTimeout, pLogHandler);
        return collectIncomingMessages(pTimeout, futures, pLogHandler);
    }",Send query and collect answers.
"public Job insertJobOrFetchDuplicate(String projectId, Job job) throws IOException {
    Preconditions.checkArgument(
        job.getJobReference() != null && job.getJobReference().getJobId() != null,
        ""Require non-null JobReference and JobId inside; getJobReference() == '%s'"",
        job.getJobReference());
    Insert insert = service.jobs().insert(projectId, job);
    Job response = null;
    try {
      response = insert.execute();
      logger.atFine().log(""Successfully inserted job '%s'. Response: '%s'"", job, response);
    } catch (IOException ioe) {
      if (errorExtractor.itemAlreadyExists(ioe)) {
        logger.atInfo().withCause(ioe).log(
            ""Fetching existing job after catching exception for duplicate jobId '%s'"",
            job.getJobReference().getJobId());
        response = service.jobs().get(projectId, job.getJobReference().getJobId()).execute();
      } else {
        throw new IOException(
            String.format(""Unhandled exception trying to insert job '%s'"", job), ioe);
      }
    }
    checkJobIdEquality(job, response);
    return response;
  }",Insert a job into the database or fetch a duplicate.
"@Override
    protected final Set<RegData> extendedLoad(FileInputStream fis) {
        Set<RegData> regData = new HashSet<RegData>();
        BufferedReader br = null;
        try {
            br = new BufferedReader(createReader(fis));
            // Check magic sequence.
            if (isMagicCorrect(br)) {
                // If magic is correct, load data.
                State state = newState();
                while (true) {
                    String line = br.readLine();
                    if (line == null) {
                        break;
                    }
                    RegData regDatum = parseLine(state, line);
                    // regDatum can be null if one line does not correspond to
                    // one resource.
                    if (regDatum != null) {
                        regData.add(regDatum);
                    }
                }
            }
        } catch (Exception ex) {
            Log.e(""Loading coverage not successful"", ex);
            // Make sure that test is rerun.
            regData.clear();
        } finally {
            FileUtil.closeAndIgnoreExceptions(br);
        }
        return regData;
    }",Override the extended load method.
"public Observable<ServiceResponse<ResourceHealthMetadataInner>> getBySiteSlotWithServiceResponseAsync(String resourceGroupName, String name, String slot) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");
        }
        if (name == null) {
            throw new IllegalArgumentException(""Parameter name is required and cannot be null."");
        }
        if (slot == null) {
            throw new IllegalArgumentException(""Parameter slot is required and cannot be null."");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");
        }
        return service.getBySiteSlot(resourceGroupName, name, slot, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ResourceHealthMetadataInner>>>() {
                @Override
                public Observable<ServiceResponse<ResourceHealthMetadataInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<ResourceHealthMetadataInner> clientResponse = getBySiteSlotDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }",Get the resource health metadata for a specific resource slot.
"@XmlElementDecl(namespace = ""http://www.opengis.net/citygml/generics/1.0"", name = ""intAttribute"", substitutionHeadNamespace = ""http://www.opengis.net/citygml/generics/1.0"", substitutionHeadName = ""_genericAttribute"")
    public JAXBElement<IntAttributeType> createIntAttribute(IntAttributeType value) {
        return new JAXBElement<IntAttributeType>(_IntAttribute_QNAME, IntAttributeType.class, null, value);
    }",Create an instance of the int attribute feature.
"public MessageApp getMessageApplication(boolean bCreateIfNotFound, Map<String, Object> properties)
    {
    	String strDBPrefix = null;
    	String strSubSystem = null;
    	String strDomain = null;
    	if (properties != null)
    		strDomain = (String)properties.get(DBParams.DOMAIN);
    	Map<String,Object> propDomain = null;
		if (this.getDefaultApplication() instanceof MainApplication)
		{
	    	if (strDomain == null)
	    		strDomain = this.getDefaultApplication().getProperty(DBParams.DOMAIN);	// Default domain
			propDomain = ((MainApplication)this.getDefaultApplication()).getDomainProperties(strDomain);
			if (propDomain != null)
			{
				strDBPrefix = (String)propDomain.get(DBConstants.DB_USER_PREFIX);
				strSubSystem = (String)propDomain.get(DBConstants.SYSTEM_NAME);
			}
	        if ((properties != null) && (strDBPrefix == null))
	            strDBPrefix = (String)properties.get(DBConstants.DB_USER_PREFIX);
            if ((properties != null) && (strSubSystem == null))
                strSubSystem = (String)properties.get(DBConstants.SYSTEM_NAME);
            if (strSubSystem != null)
                strSubSystem = Utility.getSystemSuffix(strSubSystem, this.getProperty(DBConstants.DEFAULT_SYSTEM_NAME));
		}
		MessageApp messageApplication = this.getMessageApplication(strDBPrefix, strSubSystem);
        if (bCreateIfNotFound)
    		if (messageApplication == null)
        {
    		MessageApp defaultMessageApplication = this.getMessageApplication(null, null);
            synchronized (this)
            {
            	messageApplication = this.getMessageApplication(strDBPrefix, strSubSystem);
        		if (messageApplication != null)
        			return messageApplication;
            	Map<String,Object> propTemp = new HashMap<String,Object>();
    			if (defaultMessageApplication != null)
    				if (defaultMessageApplication.getProperties() != null)
    					propTemp.putAll(defaultMessageApplication.getProperties());
        		if (properties != null)
					propTemp.putAll(properties);
    			if (propDomain != null)
					propTemp.putAll(propDomain);
    			properties = propTemp;
    			String className = MessageInfoModel.THICK_APPLICATION;
    			messageApplication = (MessageApp)ClassServiceUtility.getClassService().makeObjectFromClassName(className);
    			messageApplication.init(this, properties, null);
                //messageApplication = new MessageInfoApplication(this, properties, null);
                if (this.getDefaultApplication() != null)
                    if (this.getDefaultApplication() != messageApplication)
                        if ((!DBConstants.TRUE.equalsIgnoreCase(messageApplication.getProperty(DBParams.MESSAGE_SERVER))) // JMSServer has no server
                            && (!DBParams.LOCAL.equalsIgnoreCase(messageApplication.getProperty(DBParams.MESSAGE_SERVER))))
                {   // (remote)
                    RemoteTask server = (RemoteTask)messageApplication.getRemoteTask(null);
                    RemoteTask appServer = (RemoteTask)this.getDefaultApplication().getRemoteTask(null, null, false);
                    if ((server != null) && (appServer != null))
                    {
                        try {
                            // Tell the remote session who my main session is
                            // so it can know where not to send server record
                            // messages (to eliminate echos in the client).
                            appServer.setRemoteMessageTask(server); // Should have done all the apps in this env!
                        } catch (RemoteException ex)    {
                            ex.printStackTrace();
                        }
                    }
                }
            }
        }
        return messageApplication;
    }",Get the MessageApplication.
"public static void initEnvironment() {
		// init logging system if not specified
		if (System.getProperty(""org.apache.commons.logging.Log"") == null)
			System.setProperty(""org.apache.commons.logging.Log"", ""net.lecousin.framework.log.bridges.ApacheCommonsLogging"");
		
		// register protocols
		String protocols = System.getProperty(""java.protocol.handler.pkgs"");
		if (protocols == null) protocols = """";
		if (!protocols.contains(""net.lecousin.framework.protocols"")) {
			if (protocols.length() > 0) protocols += ""|"";
			protocols += ""net.lecousin.framework.protocols"";
			System.setProperty(""java.protocol.handler.pkgs"", protocols);
		}
	}",Initialize the environment.
"public static void localListenByLine(    int port,
                                            Map<String, SocketAction> actions,
                                            ExecutorService service) {
        localListen(port, actions, service, SocketAtom.class);
    }",Listen by line.
"protected JSONArray callMethod(String method, Object ... args) throws Exception {
        return new QueryBuilder().retrieveResult(storedId).call(method, args).storeResult(""LAST_"" + getStoredId()).execute();
    }",Call a method on the class.
"public static Object invokeMethodN(Class senderClass, Object receiver, String messageName, Object[] messageArguments) throws Throwable {
        try {    
            return InvokerHelper.invokeMethod(receiver, messageName, messageArguments);
        } catch (GroovyRuntimeException gre) {
            throw unwrap(gre);
        }
    }",Invoke a method on a class object.
"public void freeFiltersWithSource(Object objSource)
    {
        if (m_messageMap != null)
        {
            for (BaseMessageQueue messageQueue : m_messageMap.values())
            {
                if (messageQueue != null)
                    messageQueue.freeFiltersWithSource(objSource);
            }
        }
    }",Free the filters that have been set for this source object.
"public static String getString(Object from, Field field)
    {
        PropertyAccessor<?> accessor = PropertyAccessorFactory.getPropertyAccessor(field);
        Object object = getObject(from, field);
        return object != null ? accessor.toString(object) : null;
    }","Gets the string value of
   ."
"public static double getEstimate(final Memory srcMem) {
    checkIfValidThetaSketch(srcMem);
    return Sketch.estimate(getThetaLong(srcMem), getRetainedEntries(srcMem), getEmpty(srcMem));
  }",Gets the estimated value of the Nth theta of the given Memory.
"public void initialize(@Observes @Initialized(ApplicationScoped.class) Object ignore) {
        log.debugf(""Initializing [%s]"", this.getClass().getName());
        try {
            feedSessionListenerProducer = new BiFunction<String, Session, WsSessionListener>() {
                @Override
                public WsSessionListener apply(String key, Session session) {
                    // In the future, if we need other queues/topics that need to be listened to, we add them here.
                    final Endpoint endpoint = Constants.FEED_COMMAND_QUEUE;
                    BasicMessageListener<BasicMessage> busEndpointListener = new FeedBusEndpointListener(session, key,
                            endpoint);
                    return new BusWsSessionListener(Constants.HEADER_FEEDID, key, endpoint, busEndpointListener);
                }
            };
            wsEndpoints.getFeedSessions().addWsSessionListenerProducer(feedSessionListenerProducer);

            uiClientSessionListenerProducer = new BiFunction<String, Session, WsSessionListener>() {
                @Override
                public WsSessionListener apply(String key, Session session) {
                    // In the future, if we need other queues/topics that need to be listened to, we add them here.
                    final Endpoint endpoint = Constants.UI_COMMAND_QUEUE;
                    BasicMessageListener<BasicMessage> busEndpointListener = new UiClientBusEndpointListener(
                            commandContextFactory, busCommands, endpoint);
                    return new BusWsSessionListener(Constants.HEADER_UICLIENTID, key, endpoint, busEndpointListener);
                }
            };
            wsEndpoints.getUiClientSessions().addWsSessionListenerProducer(uiClientSessionListenerProducer);
        } catch (Exception e) {
            log.errorCouldNotInitialize(e, this.getClass().getName());
        }

    }",Initialize the application scoped services.
"@Override
	public CPDefinitionSpecificationOptionValue findByCPSpecificationOptionId_First(
		long CPSpecificationOptionId,
		OrderByComparator<CPDefinitionSpecificationOptionValue> orderByComparator)
		throws NoSuchCPDefinitionSpecificationOptionValueException {
		CPDefinitionSpecificationOptionValue cpDefinitionSpecificationOptionValue =
			fetchByCPSpecificationOptionId_First(CPSpecificationOptionId,
				orderByComparator);

		if (cpDefinitionSpecificationOptionValue != null) {
			return cpDefinitionSpecificationOptionValue;
		}

		StringBundler msg = new StringBundler(4);

		msg.append(_NO_SUCH_ENTITY_WITH_KEY);

		msg.append(""CPSpecificationOptionId="");
		msg.append(CPSpecificationOptionId);

		msg.append(""}"");

		throw new NoSuchCPDefinitionSpecificationOptionValueException(msg.toString());
	}",Returns the cp definition specification option value in the ordered set where cp specification option value in the ordered set.
"private void connectInSameElement(List<LineSegment2D_F32> lines ) {
		for( int i = 0; i < lines.size(); i++ ) {
			LineSegment2D_F32 a = lines.get(i);

			int index = findBestCompatible(a,lines,i+1);
			if( index == -1 )
				continue;

			// remove the line from the index which it is being connected to
			LineSegment2D_F32 b = lines.remove(index);

			// join the two lines by connecting the farthest points from each other
			Point2D_F32 pt0 = farthestIndex < 2 ? a.a : a.b;
			Point2D_F32 pt1 = (farthestIndex %2) == 0 ? b.a : b.b;

			a.a.set(pt0);
			a.b.set(pt1);
		}
	}",Connect the lines in the same element.
"private String computeShortClassName() {
        String name = this.getClass().getSimpleName();
        if (name.endsWith(APP_SUFFIX_CLASSNAME)) {
            name = name.substring(0, name.indexOf(APP_SUFFIX_CLASSNAME));
        }
        return name;
    }",Compute the short class name.
"public ServiceFuture<VirtualNetworkInner> getByResourceGroupAsync(String resourceGroupName, String virtualNetworkName, final ServiceCallback<VirtualNetworkInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, virtualNetworkName), serviceCallback);
    }",Gets a virtual network. Gets a virtual network.
"public Observable<PolicySetDefinitionInner> createOrUpdateAtManagementGroupAsync(String policySetDefinitionName, String managementGroupId, PolicySetDefinitionInner parameters) {
        return createOrUpdateAtManagementGroupWithServiceResponseAsync(policySetDefinitionName, managementGroupId, parameters).map(new Func1<ServiceResponse<PolicySetDefinitionInner>, PolicySetDefinitionInner>() {
            @Override
            public PolicySetDefinitionInner call(ServiceResponse<PolicySetDefinitionInner> response) {
                return response.body();
            }
        });
    }",Creates or updates a policy set definition in an existing management group.
"public Matrix4f setRotationXYZ(float angleX, float angleY, float angleZ) {
        float sinX = (float) Math.sin(angleX);
        float cosX = (float) Math.cosFromSin(sinX, angleX);
        float sinY = (float) Math.sin(angleY);
        float cosY = (float) Math.cosFromSin(sinY, angleY);
        float sinZ = (float) Math.sin(angleZ);
        float cosZ = (float) Math.cosFromSin(sinZ, angleZ);
        float m_sinX = -sinX;
        float m_sinY = -sinY;
        float m_sinZ = -sinZ;

        // rotateX
        float nm11 = cosX;
        float nm12 = sinX;
        float nm21 = m_sinX;
        float nm22 = cosX;
        // rotateY
        float nm00 = cosY;
        float nm01 = nm21 * m_sinY;
        float nm02 = nm22 * m_sinY;
        this._m20(sinY);
        this._m21(nm21 * cosY);
        this._m22(nm22 * cosY);
        // rotateZ
        this._m00(nm00 * cosZ);
        this._m01(nm01 * cosZ + nm11 * sinZ);
        this._m02(nm02 * cosZ + nm12 * sinZ);
        this._m10(nm00 * m_sinZ);
        this._m11(nm01 * m_sinZ + nm11 * cosZ);
        this._m12(nm02 * m_sinZ + nm12 * cosZ);
        properties = properties & ~(PROPERTY_PERSPECTIVE | PROPERTY_IDENTITY | PROPERTY_TRANSLATION);
        return this;
    }",Sets the rotation of the image from X to Y and Z.
"@Override
  public Long getValue(int pollerIndex) {
    final long cnt = count.getCurrentCount(pollerIndex);
    final long value = (long) (getTotal(pollerIndex) / cnt);
    return (cnt == 0) ? 0L : value;
  }",Gets the value of the node with the given index.
"private static void registerRouteRoot(IRouteRoot routeRoot) {
        markRegisteredByPlugin();
        if (routeRoot != null) {
            routeRoot.loadInto(Warehouse.groupsIndex);
        }
    }",Register the route root.
"private static Object tupleFieldToSingleField(FieldDescriptor fieldDescriptor, Object tupleField) {
    // type convertion should match with ProtobufToPig.getPigScriptDataType
    switch (fieldDescriptor.getType()) {
    case ENUM:
      return toEnumValueDescriptor(fieldDescriptor, (String) tupleField);
    case BOOL:
      return Boolean.valueOf((Integer)tupleField != 0);
    case BYTES:
      return ByteString.copyFrom(((DataByteArray)tupleField).get());
    default:
      return tupleField;
    }
  }",Convert a tuple field to a single field.
"public void free()
    {
        if (m_sessionObjectParent != null)
            ((BaseSession)m_sessionObjectParent).removeSessionObject(this);   // Have my parent remove me from their list.
        // Remove all the session objects that I am responsible for
        if (m_vSessionObjectList != null)
        {
            while (m_vSessionObjectList.size() > 0)
            {
                BaseSession sessionObject = (BaseSession)m_vSessionObjectList.elementAt(0);
                sessionObject.free(); // They will automatically call me.removeSessionObject(them);
            } 
            m_vSessionObjectList.removeAllElements();
            m_vSessionObjectList = null;
        }
        super.free();
    }",Free the session object.
"protected Converter createConverter(FaceletContext ctx)
    {
        if (this.converterId == null)
        {
            throw new TagException(this.tag,
                                   ""Default behavior invoked of requiring a converter-id passed in the constructor, ""
                                   + ""must override ConvertHandler(ConverterConfig)"");
        }
        return ctx.getFacesContext().getApplication().createConverter(this.converterId);
    }",Create a converter instance.
"private boolean containsAnyInFactor(final String[] searchChars, final boolean ignoreCase) {
        
        for(Token token : tokens) {
            if(!(token instanceof Token.Factor)) {
                continue;
            }
            
            final Token.Factor factor = token.asFactor();
            if(Utils.containsAny(factor.getValue(), searchChars, ignoreCase)) {
                return true;
            }
            
        }
        
        return false;
    }",Checks if any of the tokens in the factor are contained in the searchChars.
"private void appendOptionGroup(StringBuffer buff, OptionGroup group)
    {
        if (!group.isRequired())
        {
            buff.append(""["");
        }

        List<Option> optList = new ArrayList<Option>(group.getOptions());
        if (getOptionComparator() != null)
        {
            Collections.sort(optList, getOptionComparator());
        }
        // for each option in the OptionGroup
        for (Iterator<Option> it = optList.iterator(); it.hasNext();)
        {
            // whether the option is required or not is handled at group level
            appendOption(buff, it.next(), true);

            if (it.hasNext())
            {
                buff.append("" | "");
            }
        }

        if (!group.isRequired())
        {
            buff.append(""]"");
        }
    }",Append the option group to the StringBuffer.
"public void marshall(CodeGenNodeArg codeGenNodeArg, ProtocolMarshaller protocolMarshaller) {

        if (codeGenNodeArg == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(codeGenNodeArg.getName(), NAME_BINDING);
            protocolMarshaller.marshall(codeGenNodeArg.getValue(), VALUE_BINDING);
            protocolMarshaller.marshall(codeGenNodeArg.getParam(), PARAM_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given CodeGenNodeArg to the given protocolMarshaller.
"public static <T> Collection<T> addAll(Collection<T> collection, Iterator<T> iterator) {
		if (null != collection && null != iterator) {
			while (iterator.hasNext()) {
				collection.add(iterator.next());
			}
		}
		return collection;
	}",Adds all the items from the iterator to the collection.
"public static String getRecurlySignature(String privateJsKey, List<String> extraParams) {
        final long unixTime = System.currentTimeMillis() / 1000L;
        final String uuid = UUID.randomUUID().toString().replaceAll(""-"", """");
        return getRecurlySignature(privateJsKey, unixTime, uuid, extraParams);
    }",Gets the curly signature.
"protected String getPropStringValue(String aPropName, String aDefaultValue) {
        return dbPoolingProperties.getProperty(aPropName,
                aDefaultValue);
    }",Get the value of the property with the specified name.
"public static Expression opacify(Generator generator, FunctionCall input) {
        Color color = input.getExpectedColorParam(0);
        float amount = input.getExpectedFloatParam(1);
        return new Color(color.getR(), color.getG(), color.getB(), color.getA() + amount);
    }",Opacifies a color.
"public static base_responses add(nitro_service client, streamidentifier resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			streamidentifier addresources[] = new streamidentifier[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new streamidentifier();
				addresources[i].name = resources[i].name;
				addresources[i].selectorname = resources[i].selectorname;
				addresources[i].interval = resources[i].interval;
				addresources[i].samplecount = resources[i].samplecount;
				addresources[i].sort = resources[i].sort;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}",Use this API to add streamidentifier resources.
"@Override
	public CPOption removeByG_K(long groupId, String key)
		throws NoSuchCPOptionException {
		CPOption cpOption = findByG_K(groupId, key);

		return remove(cpOption);
	}",Removes the cp option with the primary key from the database. Also notifies the appropriate model listeners.
"public void setSecondaryArtifactsOverride(java.util.Collection<ProjectArtifacts> secondaryArtifactsOverride) {
        if (secondaryArtifactsOverride == null) {
            this.secondaryArtifactsOverride = null;
            return;
        }

        this.secondaryArtifactsOverride = new java.util.ArrayList<ProjectArtifacts>(secondaryArtifactsOverride);
    }",Sets the value of the secondaryArtifactsOverride property.
"private void processEntity(Entity entity, double latitude, double longitude) {
        // Only add entities that fall within the bounding box (if set)
        BoundingBox bb = this.configuration.getBboxConfiguration();
        if (bb != null && !bb.contains(latitude, longitude)) {
            return;
        }

        // Only add entities that have data
        if (entity.getTags().isEmpty()) {
            return;
        }

        // Only add named entities (if set)
        if (this.configuration.isNames()) {
            String name = getTagValue(entity.getTags(), ""name"");
            if (name == null || name.isEmpty()) {
                return;
            }
        }

        // Process entity
        Map<String, String> tagMap = new TreeMap<>();
        Set<PoiCategory> categories = new HashSet<>();
        for (Tag tag : entity.getTags()) {
            String key = tag.getKey().toLowerCase(Locale.ENGLISH);
            if (this.tagMappingResolver.getMappingTags().contains(key)) {
                // Check if there is a POI category for this tag and add POI to DB
                String tagStr = key + ""="" + tag.getValue();
                try {
                    // Get categories from tag
                    List<PoiCategory> pcs = this.tagMappingResolver.getCategoriesFromTag(tagStr);

                    // Get categories from key, if tag wasn't matched
                    // Note: key categories should be parents of their value categories
                    if (pcs == null) {
                        pcs = this.tagMappingResolver.getCategoriesFromTag(key);
                    }

                    if (pcs != null) {
                        for (PoiCategory pc : pcs) {
                            // Add entity if its category matches
                            if (this.categoryFilter.isAcceptedCategory(pc)) {
                                // Collect the POI tags in a sorted manner (once)
                                if (tagMap.isEmpty()) {
                                    for (Tag t : entity.getTags()) {
                                        tagMap.put(t.getKey().toLowerCase(Locale.ENGLISH), t.getValue());
                                    }
                                }
                                categories.add(pc);
                            }
                        }
                    }
                } catch (UnknownPoiCategoryException e) {
                    LOGGER.warning(""The '"" + tagStr + ""' tag refers to a POI that does not exist: "" + e.getMessage());
                }
            }
        }

        // Store POI
        if (!tagMap.isEmpty()) {
            writePOI(this.poiAdded++, latitude, longitude, tagMap, categories);
        }
    }",Process the entity.
"public QueryParameters set(int index, QueryParameters element) {
        QueryParameters params = null;

        if (getMaxCacheSize() != -1) {
            throw new MjdbcRuntimeException(ERROR_NOT_ALLOWED + "". Cache update is allowed when Cache is not limited (used by Cached output handlers)"");
        }

        if (valueCached(index) == true) {
            params = readCachedValue(index);
            updateCache(index, element);
        } else {
            throw new MjdbcRuntimeException(ERROR_NOT_ALLOWED + "". Only cached(read) values can be replaced"");
        }

        return params;
    }",Sets the value of the specified element in the cache.
"public static AbstractMessage.Builder addDefaultInstanceToRepeatedField(final int repeatedFieldNumber, final AbstractMessage.Builder builder) throws CouldNotPerformException {
        return addDefaultInstanceToRepeatedField(builder.getDescriptorForType().findFieldByNumber(repeatedFieldNumber), builder);
    }",Add a new instance of the type of the repeated field to the builder.
"public final EObject entryRuleJvmWildcardTypeReference() throws RecognitionException {
        EObject current = null;

        EObject iv_ruleJvmWildcardTypeReference = null;


        try {
            // InternalXbaseWithAnnotations.g:6322:65: (iv_ruleJvmWildcardTypeReference= ruleJvmWildcardTypeReference EOF )
            // InternalXbaseWithAnnotations.g:6323:2: iv_ruleJvmWildcardTypeReference= ruleJvmWildcardTypeReference EOF
            {
            if ( state.backtracking==0 ) {
               newCompositeNode(grammarAccess.getJvmWildcardTypeReferenceRule()); 
            }
            pushFollow(FOLLOW_1);
            iv_ruleJvmWildcardTypeReference=ruleJvmWildcardTypeReference();

            state._fsp--;
            if (state.failed) return current;
            if ( state.backtracking==0 ) {
               current =iv_ruleJvmWildcardTypeReference; 
            }
            match(input,EOF,FOLLOW_2); if (state.failed) return current;

            }

        }

            catch (RecognitionException re) {
                recover(input,re);
                appendSkippedTokens();
            }
        finally {
        }
        return current;
    }",Gets the content of a ruleJvmWildcardTypeReference
"@Override
    protected void destroyRepository() {

        final RepositoryImpl repository = (RepositoryImpl) getRepository();
        repository.shutdown();
        LOG.info(""Destroyed repository at {}"", repository.getConfig().getHomeDir());
    }",Destroy the repository.
"public void marshall(Datastore datastore, ProtocolMarshaller protocolMarshaller) {

        if (datastore == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(datastore.getName(), NAME_BINDING);
            protocolMarshaller.marshall(datastore.getArn(), ARN_BINDING);
            protocolMarshaller.marshall(datastore.getStatus(), STATUS_BINDING);
            protocolMarshaller.marshall(datastore.getRetentionPeriod(), RETENTIONPERIOD_BINDING);
            protocolMarshaller.marshall(datastore.getCreationTime(), CREATIONTIME_BINDING);
            protocolMarshaller.marshall(datastore.getLastUpdateTime(), LASTUPDATETIME_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given datastore to the JSON object.
"@Nullable
  public static String[] convertToNames(UfsStatus[] children) {
    if (children == null) {
      return null;
    }
    String[] ret = new String[children.length];
    for (int i = 0; i < children.length; ++i) {
      ret[i] = children[i].getName();
    }
    return ret;
  }",Converts a list of UFSStatus objects to a list of names.
"public boolean columnValueIsBinary(String namespace, String storeName) {
        Boolean cachedValue = getCachedValueIsBinary(namespace, storeName);
        if(cachedValue != null) return cachedValue.booleanValue();
        
        String cqlKeyspace = CQLService.storeToCQLName(namespace);
        String tableName = CQLService.storeToCQLName(storeName);
        KeyspaceMetadata ksMetadata = m_cluster.getMetadata().getKeyspace(cqlKeyspace);
        TableMetadata tableMetadata = ksMetadata.getTable(tableName);
        ColumnMetadata colMetadata = tableMetadata.getColumn(""value"");
        boolean isBinary = colMetadata.getType().equals(DataType.blob());
        
        putCachedValueIsBinary(namespace, storeName, isBinary);
        return isBinary;
    }",Check if the column value is binary.
"private void ensureMetaCharsetElement() {
        if (updateMetaCharset) {
            OutputSettings.Syntax syntax = outputSettings().syntax();

            if (syntax == OutputSettings.Syntax.html) {
                Element metaCharset = select(""meta[charset]"").first();

                if (metaCharset != null) {
                    metaCharset.attr(""charset"", charset().displayName());
                } else {
                    Element head = head();

                    if (head != null) {
                        head.appendElement(""meta"").attr(""charset"", charset().displayName());
                    }
                }

                // Remove obsolete elements
                select(""meta[name=charset]"").remove();
            } else if (syntax == OutputSettings.Syntax.xml) {
                Node node = childNodes().get(0);

                if (node instanceof XmlDeclaration) {
                    XmlDeclaration decl = (XmlDeclaration) node;

                    if (decl.name().equals(""xml"")) {
                        decl.attr(""encoding"", charset().displayName());

                        final String version = decl.attr(""version"");

                        if (version != null) {
                            decl.attr(""version"", ""1.0"");
                        }
                    } else {
                        decl = new XmlDeclaration(""xml"", false);
                        decl.attr(""version"", ""1.0"");
                        decl.attr(""encoding"", charset().displayName());

                        prependChild(decl);
                    }
                } else {
                    XmlDeclaration decl = new XmlDeclaration(""xml"", false);
                    decl.attr(""version"", ""1.0"");
                    decl.attr(""encoding"", charset().displayName());

                    prependChild(decl);
                }
            }
        }
    }",Ensure the meta charset element.
"public Pipeline<T> set(String name, Predicate<T> predicate) {
		return set(stages.size(), name, predicate);
	}",Set a pipeline to be executed.
"public static <T> ImmutableListJsonDeserializer<T> newInstance( JsonDeserializer<T> deserializer ) {
        return new ImmutableListJsonDeserializer<T>( deserializer );
    }",Create an immutable instance of the given deserializer.
"public Observable<ServiceResponse<NameAvailabilityResponseInner>> checkChildrenNameAvailabilityWithServiceResponseAsync(String groupName, String serviceName, NameAvailabilityRequest parameters) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");
        }
        if (groupName == null) {
            throw new IllegalArgumentException(""Parameter groupName is required and cannot be null."");
        }
        if (serviceName == null) {
            throw new IllegalArgumentException(""Parameter serviceName is required and cannot be null."");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");
        }
        if (parameters == null) {
            throw new IllegalArgumentException(""Parameter parameters is required and cannot be null."");
        }
        Validator.validate(parameters);
        return service.checkChildrenNameAvailability(this.client.subscriptionId(), groupName, serviceName, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<NameAvailabilityResponseInner>>>() {
                @Override
                public Observable<ServiceResponse<NameAvailabilityResponseInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<NameAvailabilityResponseInner> clientResponse = checkChildrenNameAvailabilityDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }",Check the name availability of the specified service.
"public com.google.api.ads.admanager.axis.v201811.CompanionDeliveryOption getCompanionDeliveryOption() {
        return companionDeliveryOption;
    }",Gets the companionDeliveryOption value for this BaseProductPackageItem.
"public static void fillPayMap(Map<String, Object> map, String key) {
        // 首先确保有随机数
        map.put(""nonce_str"", """" + R.random(10000000, 100000000));

        // 填充签名
        String sign = genPaySignMD5(map, key);
        map.put(""sign"", sign);
    }",Fill pay map with nonce_str and sign
"public static String unqualify(String qualifiedName, char separator) {
        return qualifiedName.substring(qualifiedName.lastIndexOf(separator) + 1);
    }",Unqualify a class name.
"public WrappedByteBuffer putIntAt(int index, int v) {
        _checkForWriteAt(index, 4);
        _buf.putInt(index, v);
        return this;
    }",Puts an int into the buffer at the specified index.
"public void applyToSourceUnits(SourceUnitOperation body) throws CompilationFailedException {
        for (String name : names) {
            SourceUnit source = sources.get(name);
            if ((source.phase < phase) || (source.phase == phase && !source.phaseComplete)) {
                try {
                    body.call(source);
                } catch (CompilationFailedException e) {
                    throw e;
                } catch (Exception e) {
                    GroovyBugError gbe = new GroovyBugError(e);
                    changeBugText(gbe, source);
                    throw gbe;
                } catch (GroovyBugError e) {
                    changeBugText(e, source);
                    throw e;
                }
            }
        }


        getErrorCollector().failIfErrors();
    }",Apply a given operation to all the SourceUnits in this SourceUnit.
"public List<PendingEvent> refreshSegmentEventWriters(Consumer<Segment> segmentSealedCallBack) {
        log.info(""Refreshing segments for stream {}"", stream);
        return updateSegments(Futures.getAndHandleExceptions(
                controller.getCurrentSegments(stream.getScope(), stream.getStreamName()), RuntimeException::new),
                segmentSealedCallBack);
    }",Refreshes the event writers for the given stream.
"@SuppressWarnings(""unchecked"")
	protected void executeOnCollections(List<IN> inputData, RuntimeContext ctx, ExecutionConfig executionConfig) throws Exception {
		OutputFormat<IN> format = this.formatWrapper.getUserCodeObject();
		TypeInformation<IN> inputType = getInput().getOperatorInfo().getOutputType();

		if (this.localOrdering != null) {
			int[] sortColumns = this.localOrdering.getFieldPositions();
			boolean[] sortOrderings = this.localOrdering.getFieldSortDirections();

			final TypeComparator<IN> sortComparator;
			if (inputType instanceof CompositeType) {
				sortComparator = ((CompositeType<IN>) inputType).createComparator(sortColumns, sortOrderings, 0, executionConfig);
			} else if (inputType instanceof AtomicType) {
				sortComparator = ((AtomicType<IN>) inputType).createComparator(sortOrderings[0], executionConfig);
			} else {
				throw new UnsupportedOperationException(""Local output sorting does not support type ""+inputType+"" yet."");
			}

			Collections.sort(inputData, new Comparator<IN>() {
				@Override
				public int compare(IN o1, IN o2) {
					return sortComparator.compare(o1, o2);
				}
			});
		}

		if(format instanceof InitializeOnMaster) {
			((InitializeOnMaster)format).initializeGlobal(1);
		}
		format.configure(this.parameters);

		if(format instanceof RichOutputFormat){
			((RichOutputFormat<?>) format).setRuntimeContext(ctx);
		}
		format.open(0, 1);
		for (IN element : inputData) {
			format.writeRecord(element);
		}
		
		format.close();
		
		if(format instanceof FinalizeOnMaster) {
			((FinalizeOnMaster)format).finalizeGlobal(1);
		}
	}",Execute on collections.
"@Override
	public EEnum getIfcCoilTypeEnum() {
		if (ifcCoilTypeEnumEEnum == null) {
			ifcCoilTypeEnumEEnum = (EEnum) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI).getEClassifiers()
					.get(935);
		}
		return ifcCoilTypeEnumEEnum;
	}",Get the IfcCoilTypeEnum attribute of the interface.
"public static HtmlTree META(String name, String content) {
        HtmlTree htmltree = new HtmlTree(HtmlTag.META);
        htmltree.addAttr(HtmlAttr.NAME, nullCheck(name));
        htmltree.addAttr(HtmlAttr.CONTENT, nullCheck(content));
        return htmltree;
    }",Generates a META tag with name and content attributes.
"private boolean hasScopeAnnotation(final Class<?> type, final boolean hkManaged) {
        boolean found = false;
        for (Annotation ann : type.getAnnotations()) {
            final Class<? extends Annotation> annType = ann.annotationType();
            if (annType.isAnnotationPresent(Scope.class)) {
                found = true;
                break;
            }
            // guice has special marker annotation
            if (!hkManaged && annType.isAnnotationPresent(ScopeAnnotation.class)) {
                found = true;
                break;
            }
        }
        return found;
    }",Checks if the class has a scope annotation.
"public ServerBuilder accessLogger(String loggerName) {
        requireNonNull(loggerName, ""loggerName"");
        return accessLogger(LoggerFactory.getLogger(loggerName));
    }",Sets the logger to use.
"static TarArchiveEntry defaultFileEntryWithName( final String fileName ) {
        TarArchiveEntry entry = new TarArchiveEntry(fileName, true);
        entry.setUserId(ROOT_UID);
        entry.setUserName(ROOT_NAME);
        entry.setGroupId(ROOT_UID);
        entry.setGroupName(ROOT_NAME);
        entry.setMode(TarArchiveEntry.DEFAULT_FILE_MODE);
        return entry;
    }",Create a default file entry with the given name.
"@Override
    protected void populateColumnSchema(ArrayList<VoltTable.ColumnInfo> columns) {
        super.populateColumnSchema(columns);
        columns.add(new ColumnInfo(VoltSystemProcedure.CNAME_SITE_ID, VoltSystemProcedure.CTYPE_ID));
        columns.add(new ColumnInfo(""PARTITION_ID"",  VoltType.INTEGER));
        columns.add(new ColumnInfo(""CACHE1_LEVEL"",  VoltType.INTEGER));
        columns.add(new ColumnInfo(""CACHE2_LEVEL"",  VoltType.INTEGER));
        columns.add(new ColumnInfo(""CACHE1_HITS"",   VoltType.BIGINT));
        columns.add(new ColumnInfo(""CACHE2_HITS"",   VoltType.BIGINT));
        columns.add(new ColumnInfo(""CACHE_MISSES"",  VoltType.BIGINT));
        columns.add(new ColumnInfo(""PLAN_TIME_MIN"", VoltType.BIGINT));
        columns.add(new ColumnInfo(""PLAN_TIME_MAX"", VoltType.BIGINT));
        columns.add(new ColumnInfo(""PLAN_TIME_AVG"", VoltType.BIGINT));
        columns.add(new ColumnInfo(""FAILURES"",      VoltType.BIGINT));
    }",Add the columns for the tenant table.
"public EnableEnhancedMonitoringResult withDesiredShardLevelMetrics(String... desiredShardLevelMetrics) {
        if (this.desiredShardLevelMetrics == null) {
            setDesiredShardLevelMetrics(new com.amazonaws.internal.SdkInternalList<String>(desiredShardLevelMetrics.length));
        }
        for (String ele : desiredShardLevelMetrics) {
            this.desiredShardLevelMetrics.add(ele);
        }
        return this;
    }",Sets the desired shard level metrics.
"public void normalize(Model model) {
		
		if(model.getLevel() != BioPAXLevel.L3)
			throw new IllegalArgumentException(""Not Level3 model. "" +
				""Consider converting it first (e.g., with the PaxTools)."");
		
		//if set, update the xml:base
		if(xmlBase != null && !xmlBase.isEmpty())
			model.setXmlBase(xmlBase);

		// Normalize/merge xrefs, first, and then CVs
		// (also because some of original xrefs might have ""normalized"" URIs 
		// that, in fact, must be used for other biopax types, such as CV or ProteinReference)
		log.info(""Normalizing xrefs..."" + description);
		normalizeXrefs(model);
		
		// fix displayName where possible
		if(fixDisplayName) {
			log.info(""Normalizing display names..."" + description);
			fixDisplayName(model);
		}
			
		log.info(""Normalizing CVs..."" + description);
		normalizeCVs(model);
		
		//normalize BioSource objects (better, as it is here, go after Xrefs and CVs)
		log.info(""Normalizing organisms..."" + description);
		normalizeBioSources(model);

		// auto-generate missing entity references:
		for(SimplePhysicalEntity spe : new HashSet<SimplePhysicalEntity>(model.getObjects(SimplePhysicalEntity.class))) {
			//it skips if spe has entityReference or memberPE already
			ModelUtils.addMissingEntityReference(model, spe);
		}

		log.info(""Normalizing entity references..."" + description);
		normalizeERs(model);
		
		// find/add lost (in replace) children
		log.info(""Repairing..."" + description);
		model.repair(); // it does not remove dangling utility class objects (can be done separately, later, if needed)
		
		log.info(""Optional tasks (reasoning)..."" + description);
	}",Normalizes the BioPAX model.
"public Observable<Page<VaultInner>> listByResourceGroupNextAsync(final String nextPageLink) {
        return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<VaultInner>>, Page<VaultInner>>() {
                @Override
                public Page<VaultInner> call(ServiceResponse<Page<VaultInner>> response) {
                    return response.body();
                }
            });
    }",Gets a list of a vault.
"public static Builder newBuilder(BucketInfo bucketInfo, String name) {
    return newBuilder(bucketInfo.getName(), name);
  }",Returns a builder for a CID    given bucket info and name.
"public Aggregate DISTINCT() {
		ReturnExpression rx = (ReturnExpression)this.astNode;
		ReturnAggregate ra = (ReturnAggregate) rx.getReturnValue();
		ra.setDistinct();
		Aggregate ret = new Aggregate(rx);
		return ret;
	}",Sets the DISTINCT attribute of the ReturnExpression.
"private boolean loadPagesIfNecessary(PagesSupplier pagesSupplier, DataSize maxSize)
    {
        checkState(!Thread.holdsLock(this), ""Can not load pages while holding a lock on this"");

        boolean dataAddedOrNoMorePages;
        List<SerializedPageReference> pageReferences;
        synchronized (this) {
            if (noMorePages) {
                return false;
            }

            if (!pages.isEmpty()) {
                return false;
            }

            // The page supplier has incremented the page reference count, and addPages below also increments
            // the reference count, so we need to drop the page supplier reference. The call dereferencePage
            // is performed outside of synchronized to avoid making a callback while holding a lock.
            pageReferences = pagesSupplier.getPages(maxSize);

            // add the pages to this buffer, which will increase the reference count
            addPages(pageReferences);

            // check for no more pages
            if (!pagesSupplier.mayHaveMorePages()) {
                noMorePages = true;
            }
            dataAddedOrNoMorePages = !pageReferences.isEmpty() || noMorePages;
        }

        // sent pages will have an initial reference count, so drop it
        pageReferences.forEach(SerializedPageReference::dereferencePage);

        return dataAddedOrNoMorePages;
    }",Load pages if necessary.
"public String readLineSkippingComments(boolean trim) throws IOException {
        for (;;) {
            String line = readLine();
            if (line == null) {
                return line;
            }
            // Skip over white space
            int pos = PatternProps.skipWhiteSpace(line, 0);
            // Ignore blank lines and comment lines
            if (pos == line.length() || line.charAt(pos) == '#') {
                continue;
            }
            // Process line
            if (trim) line = line.substring(pos);
            return line;
        }
    }",Read a line of text skipping comments.
"public ApiResponse<ApiSuccessResponse> mediaStopMonitoringWithHttpInfo(String mediatype, MediaStopMonitoringData mediaStopMonitoringData) throws ApiException {
        com.squareup.okhttp.Call call = mediaStopMonitoringValidateBeforeCall(mediatype, mediaStopMonitoringData, null, null);
        Type localVarReturnType = new TypeToken<ApiSuccessResponse>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }",Stop Session Stop Session Session
"@Override
    public void registerInstanceMethod(String name, Closure closure) {
        expandableDelegate().registerInstanceMethod(name, closure);
    }",Override this method to register an instance method.
"public void addRouter(final Class<?> routeType, Object controller) {

        Method[] methods = routeType.getDeclaredMethods();
        if (BladeKit.isEmpty(methods)) {
            return;
        }

        String nameSpace = null, suffix = null;
        if (null != routeType.getAnnotation(Path.class)) {
            nameSpace = routeType.getAnnotation(Path.class).value();
            suffix = routeType.getAnnotation(Path.class).suffix();
        }

        if (null == nameSpace) {
            log.warn(""Route [{}] not path annotation"", routeType.getName());
            return;
        }

        for (Method method : methods) {

            com.blade.mvc.annotation.Route mapping     = method.getAnnotation(com.blade.mvc.annotation.Route.class);
            GetRoute                       getRoute    = method.getAnnotation(GetRoute.class);
            PostRoute                      postRoute   = method.getAnnotation(PostRoute.class);
            PutRoute                       putRoute    = method.getAnnotation(PutRoute.class);
            DeleteRoute                    deleteRoute = method.getAnnotation(DeleteRoute.class);

            this.parseRoute(RouteStruct.builder().mapping(mapping)
                    .getRoute(getRoute).postRoute(postRoute)
                    .putRoute(putRoute).deleteRoute(deleteRoute)
                    .nameSpace(nameSpace)
                    .suffix(suffix).routeType(routeType)
                    .controller(controller).method(method)
                    .build());
        }
    }",Add router.
"public static CalendarPicker<PersianCalendar> persian(
        Locale locale,
        Supplier<PersianCalendar> todaySupplier
    ) {

        return CalendarPicker.create(
            PersianCalendar.axis(),
            new FXCalendarSystemPersian(),
            locale,
            todaySupplier
        );

    }",Gets a calendar picker for the FX calendar system.
"@Override
  public JobDetail getJobDetail(String jobKey) throws SchedulerException {

    validateState();

    return quartzSchedulerResources.getJobStore().retrieveJob(jobKey);
  }",Get the job detail for the given jobKey.
"public Collection<V> values() {
       Set<Map.Entry<K, V>> s = entrySet();
       ArrayList l = new ArrayList(s.size());
       for (Map.Entry e : s) 
           l.add(e.getValue());
       return l;
    }


    /**
     * Return a filtered set of keys.
     * @see Map.keySet
     */
    public Set<K> keySet() {
       Set<Map.Entry<K, V>> s = entrySet();
       HashSet keys = new HashSet(s.size());
       for (Map.Entry e : mBackingMap.entrySet())
           keys.add(e.getKey());
       return keys;
    }


    /**
     * Delegates to backing map.
     * @see java.util.Map.clear()
     */
    public void clear() { 
        mBackingMap.clear(); 
    }


    /**
     * Delegates to backing map.
     * @see java.util.Map.containsKey
     */
    public boolean containsKey(Object key) { 
        return mBackingMap.containsKey(key); 
    }


    /**
     * Delegates to backing map.
     * @see java.util.Map.containsValue
     */
    public boolean containsValue(Object value) {
       return mBackingMap.containsValue(value);
    }

    
    /**
     * Delegates to backing map.
     * @see Object.equals.
     */
    public boolean equals(Object o) {
       return mBackingMap.equals(o);
    }


    /**
     * Delegates to backing map.
     * @see Object.hashCode
     */
    public int hashCode() {
       return mBackingMap.hashCode();
    }


    /**
     * Delegates to backing map.
     * @see java.util.Map.get
     */
    public V get(Object key) {
       return mBackingMap.get(key);
    }

    
    /**
     * Delegates to backing map.
     * @see java.util.Map.isEmpty
     */
    public boolean isEmpty() {
       return mBackingMap.isEmpty();
    }


    /**
     * Delegates to backing map.
     * @see java.util.Map.put
     */
    public V put(K key, V value) {
        return mBackingMap.put(key, value);
    }


    /**
     * Delegates to backing map.
     * @see java.util.Map.putAll
     */
    public void putAll(Map<? extends K,? extends V> m) {
        mBackingMap.putAll(m);
    }
    

    /**
     * Delegates to backing map.
     * @see java.util.Map.remove
     */
    public V remove(Object key) {
        return mBackingMap.remove(key);
    }


    /**
     * Delegates to backing map.
     * @see java.util.Map.size
     */
    public int size() {
        return mBackingMap.size();
    }


    /**
     * Filter interface.
     */
    public interface Filter {
        /**
         * Returns true if the given entry should be included.
         */
        public boolean accept(Map.Entry e);
    }


}",Returns a collection of all values in this map.
"private void copyFiles(String fromDir, String toDir) throws MojoExecutionException {
        getLog().debug(""fromDir="" + fromDir + ""; toDir="" + toDir);
        try {
            File fromDirFile = new File(fromDir);
            if (fromDirFile.exists()) {
                Iterator<File> files = FileUtils.iterateFiles(new File(fromDir), null, false);
                while (files.hasNext()) {
                    File file = files.next();
                    if (file.exists()) {
                        FileUtils.copyFileToDirectory(file, new File(toDir));
                    } else {
                        getLog().error(""File '"" + file.getAbsolutePath() + ""' does not exist. Skipping copy"");
                    }
                }
            }
        } catch (IOException e) {
            throw new MojoExecutionException(""Unable to copy file "" + e.getMessage(), e);
        }
    }",Copy files from the given directory to the given directory.
"private static ObjectName getObjectName(Cache<?, ?> cache, MBeanType type) {
    String cacheManagerName = sanitize(cache.getCacheManager().getURI().toString());
    String cacheName = sanitize(cache.getName());

    try {
      String name = String.format(""javax.cache:type=Cache%s,CacheManager=%s,Cache=%s"",
          type, cacheManagerName, cacheName);
      return new ObjectName(name);
    } catch (MalformedObjectNameException e) {
      String msg = String.format(""Illegal ObjectName for cacheManager=[%s], cache=[%s]"",
          cacheManagerName, cacheName);
      throw new CacheException(msg, e);
    }
  }",Get the ObjectName for a cache and type
"public static void loadCompressedTexture(final GVRContext gvrContext,
            ResourceCache<GVRImage> textureCache,
            final CompressedTextureCallback callback,
            final GVRAndroidResource resource) {
        loadCompressedTexture(gvrContext, textureCache, callback, resource,
                              GVRCompressedImage.DEFAULT_QUALITY);
    }",Load compressed texture.
"public static Appendable render(final String input, Appendable target) throws IOException {

        int i = 0;
        int j, k;

        while (true) {
            j = input.indexOf(BEGIN_TOKEN, i);
            if (j == -1) {
                if (i == 0) {
                    target.append(input);
                    return target;
                }
                target.append(input.substring(i, input.length()));
                return target;
            }
            target.append(input.substring(i, j));
            k = input.indexOf(END_TOKEN, j);

            if (k == -1) {
                target.append(input);
                return target;
            }
            j += BEGIN_TOKEN_LEN;
            String spec = input.substring(j, k);

            String[] items = spec.split(CODE_TEXT_SEPARATOR, 2);
            if (items.length == 1) {
                target.append(input);
                return target;
            }
            String replacement = render(items[1], items[0].split(CODE_LIST_SEPARATOR));

            target.append(replacement);

            i = k + END_TOKEN_LEN;
        }
    }",Render the input string to the target Appendable.
"public MatchResponse merge(MatchResponse matchResponse) {
        if (matchResponse == null || matchResponse == this) {
            return this;
        } else {
            boolean mergedSSLRequired = mergeSSLRequired(matchResponse.isSSLRequired());
            boolean mergedAccessPrecluded = mergeAccessPrecluded(matchResponse.isAccessPrecluded());
            List<String> mergedRoles = mergeRoles(matchResponse.getRoles(), mergedAccessPrecluded);
            return new MatchResponse(mergedRoles, mergedSSLRequired, mergedAccessPrecluded);
        }
    }",Merge the two MatchResponse objects into one.
"public static StatisticsPageListResult statisticsPageList(
            String accessToken, StatisticsPageList statisticsPageList) {
        return statisticsPageList(accessToken,
                JsonUtil.toJSONString(statisticsPageList));
    }",This method will return a StatisticsPageListResult instance with the specified access token and statisticsPageList JSON string.
"public static <T> Level0ArrayOperator<T[],T> onArrayOf(final Type<T> type) {
        return new Level0ArrayOperator<T[],T>(type, ExecutionTarget.forFn(Normalisation.ARRAY(type.getRawClass())));
    }",Creates an instance of the generic class that represents an array of the specified type.
"@Override
    public Map<String, Object> getPayload() {
        HashMap<String, Object> payload = new HashMap<>();
        payload.put(""fun"", getFunction());
        kwargs.ifPresent(payload::putAll);
        return payload;
    }",Get the payload.
"@Override
	public CPDefinitionGroupedEntry findByUuid_Last(String uuid,
		OrderByComparator<CPDefinitionGroupedEntry> orderByComparator)
		throws NoSuchCPDefinitionGroupedEntryException {
		CPDefinitionGroupedEntry cpDefinitionGroupedEntry = fetchByUuid_Last(uuid,
				orderByComparator);

		if (cpDefinitionGroupedEntry != null) {
			return cpDefinitionGroupedEntry;
		}

		StringBundler msg = new StringBundler(4);

		msg.append(_NO_SUCH_ENTITY_WITH_KEY);

		msg.append(""uuid="");
		msg.append(uuid);

		msg.append(""}"");

		throw new NoSuchCPDefinitionGroupedEntryException(msg.toString());
	}",Returns the last cp definition grouped entry in the ordered set where uuid = &#63 ; and orderByComparator = null.
"private BucketShards computeMerged()
            throws SQLException
    {
        if (resultSet.isAfterLast()) {
            return endOfData();
        }
        if (first) {
            first = false;
            if (!resultSet.next()) {
                return endOfData();
            }
        }

        int bucketNumber = resultSet.getInt(""bucket_number"");
        ImmutableSet.Builder<ShardNodes> shards = ImmutableSet.builder();

        do {
            UUID shardUuid = uuidFromBytes(resultSet.getBytes(""shard_uuid""));
            int bucket = resultSet.getInt(""bucket_number"");
            Set<String> nodeIdentifiers = ImmutableSet.of(getBucketNode(bucket));

            shards.add(new ShardNodes(shardUuid, nodeIdentifiers));
        }
        while (resultSet.next() && resultSet.getInt(""bucket_number"") == bucketNumber);

        return new BucketShards(OptionalInt.of(bucketNumber), shards.build());
    }",Compute merged bucket shards.
"@Override
    public final String getElementText() throws XMLStreamException {
        XMLEvent event = this.previousEvent;
        if (event == null) {
            throw new XMLStreamException(
                    ""Must be on START_ELEMENT to read next text, element was null"");
        }
        if (!event.isStartElement()) {
            throw new XMLStreamException(
                    ""Must be on START_ELEMENT to read next text"", event.getLocation());
        }

        final StringBuilder text = new StringBuilder();
        while (!event.isEndDocument()) {
            switch (event.getEventType()) {
                case XMLStreamConstants.CHARACTERS:
                case XMLStreamConstants.SPACE:
                case XMLStreamConstants.CDATA:
                    {
                        final Characters characters = event.asCharacters();
                        text.append(characters.getData());
                        break;
                    }
                case XMLStreamConstants.ENTITY_REFERENCE:
                    {
                        final EntityReference entityReference = (EntityReference) event;
                        final EntityDeclaration declaration = entityReference.getDeclaration();
                        text.append(declaration.getReplacementText());
                        break;
                    }
                case XMLStreamConstants.COMMENT:
                case XMLStreamConstants.PROCESSING_INSTRUCTION:
                    {
                        // Ignore
                        break;
                    }
                default:
                    {
                        throw new XMLStreamException(
                                ""Unexpected event type '""
                                        + XMLStreamConstantsUtils.getEventName(event.getEventType())
                                        + ""' encountered. Found event: ""
                                        + event,
                                event.getLocation());
                    }
            }

            event = this.nextEvent();
        }

        return text.toString();
    }",This method returns the text of the current element.
"@SuppressWarnings({""checkstyle:magicnumber"", ""checkstyle:npathcomplexity"", ""static-method""})
	protected IStatus submit(Charset charset, String title, String body, String login, String password, IProgressMonitor progress) throws Exception {
		final SubMonitor subMonitor = SubMonitor.convert(progress, 10);

		subMonitor.setTaskName(Messages.SubmitEclipseLogWizard_15);
		final Gson gson = new GsonBuilder().create();
		final String json = gson.toJson(new GithubIssueJson(title, body));
		subMonitor.setWorkRemaining(9);

		subMonitor.setTaskName(Messages.SubmitEclipseLogWizard_2);
		final ServiceTracker<IProxyService, IProxyService> proxyTracker = new ServiceTracker<>(
				SARLEclipsePlugin.getDefault().getBundle().getBundleContext(),
				IProxyService.class,
				null);
		proxyTracker.open();
		if (subMonitor.isCanceled()) {
			return Status.CANCEL_STATUS;
		}
		final URL url;
		try {
			final URI uri = new URI(GITHUB_URL);

			final IProxyData[] proxyDataForHost = proxyTracker.getService().select(uri);
			for (final IProxyData data : proxyDataForHost) {
				if (data.getHost() != null) {
					System.setProperty(""http.proxySet"", ""true""); //$NON-NLS-1$ //$NON-NLS-2$
					System.setProperty(""http.proxyHost"", data.getHost()); //$NON-NLS-1$
				}
				if (data.getHost() != null) {
					System.setProperty(""http.proxyPort"", String.valueOf(data //$NON-NLS-1$
							.getPort()));
				}
				if (subMonitor.isCanceled()) {
					return Status.CANCEL_STATUS;
				}
			}

			url = uri.toURL();
		} finally {
			proxyTracker.close();
		}
		subMonitor.setWorkRemaining(8);
		if (subMonitor.isCanceled()) {
			return Status.CANCEL_STATUS;
		}

		subMonitor.setTaskName(Messages.SubmitEclipseLogWizard_3);
		final HttpURLConnection con = (HttpURLConnection) url.openConnection();
		subMonitor.setWorkRemaining(7);
		if (subMonitor.isCanceled()) {
			return Status.CANCEL_STATUS;
		}

		//add request header
		subMonitor.setTaskName(Messages.SubmitEclipseLogWizard_4);
		con.setRequestMethod(""POST""); //$NON-NLS-1$
		con.setRequestProperty(""User-Agent"", ""SARL IDE""); //$NON-NLS-1$ //$NON-NLS-2$
		// Auth
		final String auth = Base64.getEncoder().encodeToString((login + "":"" + password).getBytes()); //$NON-NLS-1$
		con.setRequestProperty(""Authorization"", ""Basic "" + auth); //$NON-NLS-1$ //$NON-NLS-2$

		con.setDoOutput(true);
		con.setDoInput(true);
		subMonitor.setWorkRemaining(6);
		if (subMonitor.isCanceled()) {
			return Status.CANCEL_STATUS;
		}

		// Send post request
		try (DataOutputStream writer = new DataOutputStream(con.getOutputStream())) {
			writer.writeBytes(json);
			writer.flush();
		}
		subMonitor.setWorkRemaining(3);
		if (subMonitor.isCanceled()) {
			return Status.CANCEL_STATUS;
		}

		//final int responseCode = con.getResponseCode();
		subMonitor.setTaskName(Messages.SubmitEclipseLogWizard_6);
		final int responseCode = con.getResponseCode();
		final StringBuffer response = new StringBuffer();
		try (BufferedReader reader = new BufferedReader(new InputStreamReader(con.getInputStream()))) {
			String inputLine;
			while ((inputLine = reader.readLine()) != null) {
				response.append(inputLine);
				if (subMonitor.isCanceled()) {
					return Status.CANCEL_STATUS;
				}
			}
		}
		subMonitor.setWorkRemaining(0);
		if (subMonitor.isCanceled()) {
			return Status.CANCEL_STATUS;
		}

		if (responseCode != RESPONSE_CODE) {
			return SARLEclipsePlugin.getDefault().createStatus(IStatus.ERROR,
					Messages.SubmitEclipseLogWizard_14,
					new Exception(response.toString()));
		}
		//System.out.println(responseCode);
		//Display.getDefault().asyncExec(() -> {
		//	final Shell shell = new Shell((Shell) null, SWT.SHELL_TRIM);
		//	shell.setLayout(new FillLayout());
		//	final Browser browser = new Browser(shell, SWT.NONE);
		//	browser.setText(response.toString());
		//	shell.layout();
		//	shell.open();

		return Status.OK_STATUS;
	}",Submit an issue to the Github log wizard.
"@Override
	public List<CommerceVirtualOrderItem> getCommerceVirtualOrderItemsByUuidAndCompanyId(
		String uuid, long companyId) {
		return commerceVirtualOrderItemPersistence.findByUuid_C(uuid, companyId);
	}",Returns the commerce virtual order items matching the UUID and company.
"public int getParameters(char[] array, int currentIndex, StringBuffer velocityBlock, char endingChar,
        VelocityParserContext context)
    {
        char beginChar = array[currentIndex];

        int i = currentIndex + 1;

        int depth = 1;

        while (i < array.length) {
            if (array[i] == endingChar) {
                --depth;
                if (depth == 0) {
                    ++i;
                    break;
                }
            } else if (array[i] == beginChar) {
                ++depth;
            } else if (array[i] == '""' || array[i] == '\'') {
                i = getEscape(array, i, null, context);
                continue;
            }

            ++i;
        }

        if (velocityBlock != null) {
            velocityBlock.append(array, currentIndex, i - currentIndex);
        }

        return i;
    }",getParameters Method.
"public static <T extends V, V> ScoredValue<V> fromNullable(double score, T value) {

        if (value == null) {
            return new ScoredValue<V>(score, null);
        }

        return new ScoredValue<V>(score, value);
    }",Create a ScoredValue from a Nullable value.
"boolean casNext(Node<K,V> cmp, Node<K,V> val) {
            return nextUpdater.compareAndSet(this, cmp, val);
        }",CAS next.
"public static void updateBeanValue(final WComponent component, final boolean visibleOnly) {
		// Do not process if component is invisble and ignore visible is true. Will ignore entire branch from this point.
		if (!component.isVisible() && visibleOnly) {
			return;
		}

		if (component instanceof WBeanComponent) {
			((WBeanComponent) component).updateBeanValue();
		}

		// These components recursively update bean values themselves,
		// as they have special requirements due to repeating data.
		if (component instanceof WDataTable || component instanceof WTable || component instanceof WRepeater) {
			return;
		}

		if (component instanceof Container) {
			for (int i = ((Container) component).getChildCount() - 1; i >= 0; i--) {
				updateBeanValue(((Container) component).getChildAt(i), visibleOnly);
			}
		}
	}",Updates the bean value of the given component.
"public int
getFootprint() {
	if (footprint >= 0)
		return footprint;

	int foot = 0;

	DNSOutput out = new DNSOutput();
	rrToWire(out, null, false);
	byte [] rdata = out.toByteArray();

	if (alg == DNSSEC.Algorithm.RSAMD5) {
		int d1 = rdata[rdata.length - 3] & 0xFF;
		int d2 = rdata[rdata.length - 2] & 0xFF;
		foot = (d1 << 8) + d2;
	}
	else {
		int i; 
		for (i = 0; i < rdata.length - 1; i += 2) {
			int d1 = rdata[i] & 0xFF;
			int d2 = rdata[i + 1] & 0xFF;
			foot += ((d1 << 8) + d2);
		}
		if (i < rdata.length) {
			int d1 = rdata[i] & 0xFF;
			foot += (d1 << 8);
		}
		foot += ((foot >> 16) & 0xFFFF);
	}
	footprint = (foot & 0xFFFF);
	return footprint;
}",Get the footprint of the record.
"private void assertSortedByDistance(DoubleDBIDList results) {
    // TODO: sort results instead?
    double dist = -1.0;
    boolean sorted = true;
    for(DoubleDBIDListIter it = results.iter(); it.valid(); it.advance()) {
      double qr = it.doubleValue();
      if(qr < dist) {
        sorted = false;
      }
      dist = qr;
    }
    if(!sorted) {
      try {
        ModifiableDoubleDBIDList.class.cast(results).sort();
      }
      catch(ClassCastException | UnsupportedOperationException e) {
        LoggingUtil.warning(""WARNING: results not sorted by distance!"", e);
      }
    }
  }",Assert that the results are sorted by distance.
"protected final void wakeUpLocalConsumers()
    {
        try
        {
        	List<AbstractSession> sessionsSnapshot = new ArrayList<>(sessions.size());
            synchronized (sessions)
            {
            	sessionsSnapshot.addAll(sessions.values());
            }
            for(int n=0;n<sessionsSnapshot.size();n++)
            {
                AbstractSession session = sessionsSnapshot.get(n);
                session.wakeUpConsumers();
            }
        }
        catch (JMSException e)
        {
        	ErrorTools.log(e, log);
        }
    }",wake up consumers in local session
"protected void validate(String operationType) throws Exception
	{
		super.validate(operationType);

		MPSString id_validator = new MPSString();
		id_validator.setConstraintIsReq(MPSConstants.DELETE_CONSTRAINT, true);
		id_validator.setConstraintIsReq(MPSConstants.MODIFY_CONSTRAINT, true);
		id_validator.validate(operationType, id, ""\""id\"""");
		
		MPSString profile_name_validator = new MPSString();
		profile_name_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);
		profile_name_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);
		profile_name_validator.setConstraintIsReq(MPSConstants.ADD_CONSTRAINT, true);
		profile_name_validator.validate(operationType, profile_name, ""\""profile_name\"""");
		
		MPSInternetHost server_name_validator = new MPSInternetHost();
		server_name_validator.setConstraintIsReq(MPSConstants.ADD_CONSTRAINT, true);
		server_name_validator.validate(operationType, server_name, ""\""server_name\"""");
		
		MPSString to_list_validator = new MPSString();
		to_list_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 6);
		to_list_validator.validate(operationType, to_list, ""\""to_list\"""");
		
		MPSString cc_list_validator = new MPSString();
		cc_list_validator.validate(operationType, cc_list, ""\""cc_list\"""");
		
		MPSString bcc_list_validator = new MPSString();
		bcc_list_validator.validate(operationType, bcc_list, ""\""bcc_list\"""");
		
	}","Validates the
 operation."
"public static void writeOutContent(final byte[] data, final String filename, final String mime) {
        writeOutContent(data, filename, mime, true);
    }",Write out the content of a sequence of bytes.
"public static boolean isNotAutoRefreshParam(final ResourceParams params) {
        return !(params instanceof ObjectParameter && CoreParameters.AUTO_REFRESH_NAME.equals(((ObjectParameter<?>) params).name()));
    }",Is not auto refresh param.
"public static String getSuffix(String path) {
        if (null == path)
            return null;
        int p0 = path.lastIndexOf('.');
        int p1 = path.lastIndexOf('/');
        if (-1 == p0 || p0 < p1)
            return """";
        return path.substring(p0);
    }",Returns the suffix of the path.
"protected List<EmvTransactionRecord> extractLogEntry(final byte[] pLogEntry) throws CommunicationException {
		List<EmvTransactionRecord> listRecord = new ArrayList<EmvTransactionRecord>();
		// If log entry is defined
		if (template.get().getConfig().readTransactions && pLogEntry != null) {
			List<TagAndLength> tals = getLogFormat();
			if (tals != null && !tals.isEmpty()) {
				// read all records
				for (int rec = 1; rec <= pLogEntry[1]; rec++) {
					byte[] response = template.get().getProvider()
							.transceive(new CommandApdu(CommandEnum.READ_RECORD, rec, pLogEntry[0] << 3 | 4, 0).toBytes());
					// Extract data
					if (ResponseUtils.isSucceed(response)) {
						try {
							EmvTransactionRecord record = new EmvTransactionRecord();
							record.parse(response, tals);

							if (record.getAmount() != null) {
								// Fix artifact in EMV VISA card
								if (record.getAmount() >= 1500000000) {
									record.setAmount(record.getAmount() - 1500000000);
								}

								// Skip transaction with null amount
								if (record.getAmount() == null || record.getAmount() <= 1) {
									continue;
								}
							}

							if (record != null) {
								// Unknown currency
								if (record.getCurrency() == null) {
									record.setCurrency(CurrencyEnum.XXX);
								}
								listRecord.add(record);
							}
						} catch (Exception e) {
							LOGGER.error(""Error in transaction format: "" + e.getMessage(), e);
						}
					} else {
						// No more transaction log or transaction disabled
						break;
					}
				}
			}
		}
		return listRecord;
	}",Extract a log entry from the response.
"int computeFieldInfoSize() {
    // The access_flags, name_index, descriptor_index and attributes_count fields use 8 bytes.
    int size = 8;
    // For ease of reference, we use here the same attribute order as in Section 4.7 of the JVMS.
    if (constantValueIndex != 0) {
      // ConstantValue attributes always use 8 bytes.
      symbolTable.addConstantUtf8(Constants.CONSTANT_VALUE);
      size += 8;
    }
    // Before Java 1.5, synthetic fields are represented with a Synthetic attribute.
    if ((accessFlags & Opcodes.ACC_SYNTHETIC) != 0
        && symbolTable.getMajorVersion() < Opcodes.V1_5) {
      // Synthetic attributes always use 6 bytes.
      symbolTable.addConstantUtf8(Constants.SYNTHETIC);
      size += 6;
    }
    if (signatureIndex != 0) {
      // Signature attributes always use 8 bytes.
      symbolTable.addConstantUtf8(Constants.SIGNATURE);
      size += 8;
    }
    // ACC_DEPRECATED is ASM specific, the ClassFile format uses a Deprecated attribute instead.
    if ((accessFlags & Opcodes.ACC_DEPRECATED) != 0) {
      // Deprecated attributes always use 6 bytes.
      symbolTable.addConstantUtf8(Constants.DEPRECATED);
      size += 6;
    }
    if (firstAttribute != null) {
      size += firstAttribute.computeAttributesSize(symbolTable);
    }
    return size;
  }",Compute the size of the field info.
"private int getTagIndex(final String tag) {
		if (tag == null) {
			return 0;
		} else {
			int index = knownTags.indexOf(tag);
			return index == -1 ? knownTags.size() + 1 : index + 1;
		}
	}",Gets the tag index.
"public static String jsonifyEvent(Object event, String eventType, String serverName, String wlpUserDir, String serverHostName, String[] tags,
                                      int maxFieldLength) {

        if (eventType.equals(CollectorConstants.GC_EVENT_TYPE)) {

            if (event instanceof GCData) {

                return jsonifyGCEvent(wlpUserDir, serverName, serverHostName, event, tags);

            } else {

                return jsonifyGCEvent(-1, wlpUserDir, serverName, serverHostName, CollectorConstants.GC_EVENT_TYPE, event, tags);

            }

        } else if (eventType.equals(CollectorConstants.MESSAGES_LOG_EVENT_TYPE)) {

            return jsonifyTraceAndMessage(maxFieldLength, wlpUserDir, serverName, serverHostName, CollectorConstants.MESSAGES_LOG_EVENT_TYPE, event, tags);

        } else if (eventType.equals(CollectorConstants.TRACE_LOG_EVENT_TYPE)) {

            return jsonifyTraceAndMessage(maxFieldLength, wlpUserDir, serverName, serverHostName, CollectorConstants.TRACE_LOG_EVENT_TYPE, event, tags);

        } else if (eventType.equals(CollectorConstants.FFDC_EVENT_TYPE)) {

            return jsonifyFFDC(maxFieldLength, wlpUserDir, serverName, serverHostName, event, tags);

        } else if (eventType.equals(CollectorConstants.ACCESS_LOG_EVENT_TYPE)) {

            return jsonifyAccess(wlpUserDir, serverName, serverHostName, event, tags);

        } else if (eventType.equals(CollectorConstants.AUDIT_LOG_EVENT_TYPE)) {

            return jsonifyAudit(wlpUserDir, serverName, serverHostName, event, tags);

        }
        return """";

    }",This method is called to generate a JSON response for an event.
"@Override
    public void pause(String targets) throws PauseableComponentControllerRequestFailedException {

        Tr.info(tc, ""info.server.pause.request.received"", targets);

        Set<String> foundTargets = new HashSet<String>();

        Set<String> targetList = createTargetList(targets);

        if (targetList.isEmpty()) {
            Tr.warning(tc, ""warning.server.pause.invalid.targets"");
            throw new PauseableComponentControllerRequestFailedException(Tr.formatMessage(tc, ""warning.server.pause.invalid.targets""));
        }

        Set<String> failed = new HashSet<String>();

        //Add each pauseable component to this list. If the tracked values get modified
        //while we are iterating and we start over, skip anyone already in this list
        Set<PauseableComponent> processedList = new HashSet<PauseableComponent>();

        // Sync with other methods changing/querying states for PauseableComponents
        synchronized (this) {
            while (true) {
                try {
                    for (PauseableComponent pauseableComponent : tracker.getTracked().values()) {

                        if (processedList.add(pauseableComponent)) {

                            if (targetList.contains(pauseableComponent.getName())) {
                                foundTargets.add(pauseableComponent.getName());

                                try {
                                    pauseableComponent.pause();

                                } catch (Throwable t) {
                                    // Catch anything and mark a failed Add it to the failed list.
                                    failed.add(pauseableComponent.getName());
                                }
                            }
                        }
                    }

                    break;
                } catch (Throwable t) {
                    // Someone modified our list of services. Retry.
                }
            }
        }

        //Check which (if any) targets were not found
        boolean targetsNotFound = false;
        targetList.removeAll(foundTargets);
        if (!targetList.isEmpty()) {
            targetsNotFound = true;
            Tr.warning(tc, ""warning.server.pause.missing.targets"", Arrays.toString(targetList.toArray()));
        }

        //Check if we had any failures and throw an exception back with a list of failed pauseable components.
        if (!failed.isEmpty()) {

            Tr.error(tc, ""error.server.pause.failed"", Arrays.toString(failed.toArray()));

            throw new PauseableComponentControllerRequestFailedException(Tr.formatMessage(tc, ""error.server.pause.failed"", Arrays.toString(failed.toArray())));

        } else {
            Tr.info(tc, ""info.server.pause.request.completed"");

            if (targetsNotFound) {
                throw new PauseableComponentControllerRequestFailedException(Tr.formatMessage(tc, ""warning.server.pause.missing.targets"", Arrays.toString(targetList.toArray())));
            }
        }

    }",Method to pause the specified targets.
"public VisualizerBuilder setColor(ColorableItem key, Color color) {
		settings.colorMap.put(key, color);
		return this;
	}",Sets the color for the colorable item.
"public static double getFloatingPointDateFromDate(LocalDateTime referenceDate, LocalDateTime date) {
		Duration duration = Duration.between(referenceDate, date);
		return ((double)duration.getSeconds()) / SECONDS_PER_DAY;
	}",Get floating point date from date.
"public void containsKey(Object key) {
    checkNotNull(key, ""AtomicLongMap does not support null keys"");
    check(""asMap().keySet()"").that(actual().asMap().keySet()).contains(key);
  }",Checks if the map contains the specified key.
"public static <T> T getInstance(Class<T> clazz, boolean accessible,
			Class<?>[] parameterTypes, Object[] paramValue) {
		if (clazz == null)
			return null;

		T t = null;

		try {
			if (parameterTypes != null && paramValue != null) {
				Constructor<T> constructor = clazz
						.getDeclaredConstructor(parameterTypes);
				Object[] obj = new Object[parameterTypes.length];

				System.arraycopy(paramValue, 0, obj, 0, parameterTypes.length);
				constructor.setAccessible(accessible);
				t = constructor.newInstance(obj);
			}

		} catch (SecurityException e) {
			log.error(""{}"",e.getMessage(),e);
		} catch (NoSuchMethodException e) {
			log.error(""{}"",e.getMessage(),e);
		} catch (IllegalArgumentException e) {
			log.error(""{}"",e.getMessage(),e);
		} catch (InstantiationException e) {
			log.error(""{}"",e.getMessage(),e);
		} catch (IllegalAccessException e) {
			log.error(""{}"",e.getMessage(),e);
		} catch (InvocationTargetException e) {
			log.error(""{}"",e.getMessage(),e);
		}

		return t;
	}",Gets the instance of the specified class using reflection.
"private ProducerSession internalCreateProducerSession(
                                                          SIDestinationAddress destAddress,
                                                          DestinationType destinationType,
                                                          boolean system,
                                                          SecurityContext secContext,
                                                          boolean keepSecurityUserid,
                                                          boolean fixedMessagePoint,
                                                          boolean preferLocal,
                                                          boolean clearPubSubFingerprints,
                                                          String discriminator)
                    throws SIConnectionUnavailableException, SIConnectionDroppedException,
                    SIErrorException,
                    SITemporaryDestinationNotFoundException, SIIncorrectCallException, SIResourceException, SINotPossibleInCurrentConfigurationException
    {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.entry(
                        tc,
                        ""internalCreateProducerSession"",
                        new Object[] { destAddress,
                                      destinationType,
                                      system,
                                      secContext,
                                      keepSecurityUserid,
                                      fixedMessagePoint,
                                      preferLocal,
                                      clearPubSubFingerprints });

        String destinationName = destAddress.getDestinationName();
        String busName = destAddress.getBusName();
        DestinationHandler destination =
                        _destinationManager.getDestination(destinationName, busName, false, true);

        // Check the destination type
        checkDestinationType(destinationType, destAddress, destination, system);

        // Check authority to produce to destination
        // If security is disabled then we'll bypass the check
        // Security changes for Liberty Messaging: Sharath Start
        // Remove the If condition, since the proxy class handles it
        checkDestinationAuthority(destination, MessagingSecurityConstants.OPERATION_TYPE_SEND, discriminator);
        // Security changes for Liberty Messaging: Sharath End

        ProducerSession producer = null;

        // Synchronize on the close object, we don't want the connection closing
        // while we try to add the producer.
        synchronized (this)
        {
            // See if this connection has been closed
            checkNotClosed();

            producer =
                            new ProducerSessionImpl(destAddress,
                                            destination,
                                            this,
                                            secContext,
                                            keepSecurityUserid,
                                            fixedMessagePoint,
                                            preferLocal,
                                            clearPubSubFingerprints);

            synchronized (_producers)
            {
                //store a reference to that producer session so that we can close
                //it again later if needed
                _producers.add(producer);
            }
        }

        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.exit(tc, ""internalCreateProducerSession"", producer);
        return producer; //169892
    }",Internal method to create a ProducerSession object.
"public byte[] convertToXmlByteArray(BucketAccelerateConfiguration accelerateConfiguration) {
        XmlWriter xml = new XmlWriter();
        xml.start(""AccelerateConfiguration"", ""xmlns"", Constants.XML_NAMESPACE);
        xml.start(""Status"").value(accelerateConfiguration.getStatus()).end();
        xml.end();
        return xml.getBytes();
    }",Converts the given AccelerateConfiguration to an XML byte array.
"Statement detachForCall(final Expression callRender) {
    checkArgument(callRender.resultType().equals(RENDER_RESULT_TYPE));
    final Label reattachRender = new Label();
    final SaveRestoreState saveRestoreState = variables.saveRestoreState();
    // We pass NULL statement for the restore logic since we handle that ourselves below
    int state = addState(reattachRender, Statement.NULL_STATEMENT);
    final Statement saveState =
        stateField.putInstanceField(thisExpr, BytecodeUtils.constant(state));
    return new Statement() {
      @Override
      protected void doGen(CodeBuilder adapter) {
        // Legend: RR = RenderResult, Z = boolean
        callRender.gen(adapter); // Stack: RR
        adapter.dup(); // Stack: RR, RR
        MethodRef.RENDER_RESULT_IS_DONE.invokeUnchecked(adapter); // Stack: RR, Z
        // if isDone goto Done
        Label end = new Label();
        adapter.ifZCmp(Opcodes.IFNE, end); // Stack: RR

        saveRestoreState.save().gen(adapter);
        saveState.gen(adapter);
        adapter.returnValue();

        adapter.mark(reattachRender);
        callRender.gen(adapter); // Stack: RR
        adapter.dup(); // Stack: RR, RR
        MethodRef.RENDER_RESULT_IS_DONE.invokeUnchecked(adapter); // Stack: RR, Z
        // if isDone goto restore
        Label restore = new Label();
        adapter.ifZCmp(Opcodes.IFNE, restore); // Stack: RR
        // no need to save or restore anything
        adapter.returnValue();
        adapter.mark(restore); // Stack: RR
        saveRestoreState.restore().gen(adapter);
        adapter.mark(end); // Stack: RR
        adapter.pop(); // Stack:
      }
    };
  }",Create a statement that detaches the context from a call to a context.
"public String getFileContentsAsString(final File file, final String encoding)
			throws IOException {
		LOG.info(""Getting files contents as string: "" + file);
		BufferedReader br = null;
		try {
			br = new BufferedReader(new InputStreamReader(new FileInputStream(
					file), encoding));

			StringBuilder builder = new StringBuilder();

			String line = null;
			while ((line = br.readLine()) != null) {
				builder.append(line);
			}

			LOG.debug(""File contents: "" + builder);
			return builder.toString();
		} finally {
			if (br != null) {
				br.close();
			}
		}
	}",Gets the contents of the file as a string.
"static int parseInt(String key, @Nullable String value) {
    requireArgument((value != null) && !value.isEmpty(), ""value of key %s was omitted"", key);
    try {
      return Integer.parseInt(value);
    } catch (NumberFormatException e) {
      throw new IllegalArgumentException(String.format(
          ""key %s value was set to %s, must be an integer"", key, value), e);
    }
  }",Parses an integer value.
"private Function1D getDerivativeFunc(final RegressionDataSet backingResidsList, final Regressor h)
    {
        final Function1D fhPrime = (double x) ->
        {
            double c1 = x;//c2=c1-eps
            double eps = 1e-5;
            double c1Pc2 = c1 * 2 - eps;//c1+c2 = c1+c1-eps
            double result = 0;
            /*
            * Computing the estimate of the derivative directly, f'(x) approx = f(x)-f(x-eps)
            *
            * hEst is the output of the new regressor, target is the true residual target value
            *
            * So we have several
            * (hEst_i   c1 - target)^2 - (hEst_i   c2 -target)^2   //4 muls, 3 subs
            * Where c2 = c1-eps
            * Which simplifies to
            * (c1 - c2) hEst ((c1 + c2) hEst - 2 target)
            * =
            * eps hEst (c1Pc2 hEst - 2 target)//3 muls, 1 sub, 1 shift (mul by 2)
            *
            * because eps is on the outside and independent of each
            * individual summation, we can move it out and do the eps
            * multiplicatio ont he final result.  Reducing us to
            *
            * 2 muls, 1 sub, 1 shift (mul by 2)
            *
            * per loop
            *
            * Which reduce computation, and allows us to get the result
            * in one pass of the data
            */
            
            for(int i = 0; i < backingResidsList.size(); i++)
            {
                double hEst = h.regress(backingResidsList.getDataPoint(i));
                double target = backingResidsList.getTargetValue(i);
                
                result += hEst * (c1Pc2 * hEst - 2 * target);
            }
            
            return result * eps;
        };

        return fhPrime;
    }",Get the derivative function.
"public static void runExample(AdWordsServicesInterface adWordsServices, AdWordsSession session,
      Long campaignId) throws RemoteException {
    // Get the CampaignSharedSetService.
    CampaignSharedSetServiceInterface campaignSharedSetService =
        adWordsServices.get(session, CampaignSharedSetServiceInterface.class);

    // First, retrieve all shared sets associated with the campaign.
    int offset = 0;
    SelectorBuilder selectorBuilder = new SelectorBuilder()
      .fields(
          CampaignSharedSetField.SharedSetId,
          CampaignSharedSetField.CampaignId,
          CampaignSharedSetField.SharedSetName,
          CampaignSharedSetField.SharedSetType)
      .equals(CampaignSharedSetField.CampaignId, campaignId.toString())
      .in(
          CampaignSharedSetField.SharedSetType,
          SharedSetType.NEGATIVE_KEYWORDS.getValue(),
          SharedSetType.NEGATIVE_PLACEMENTS.getValue())
      .limit(PAGE_SIZE);
    
    List<Long> sharedSetIds = new ArrayList<>();
    CampaignSharedSetPage campaignSharedSetPage;
    do {
      selectorBuilder.offset(offset);
      campaignSharedSetPage = campaignSharedSetService.get(selectorBuilder.build());
      for (CampaignSharedSet campaignSharedSet : campaignSharedSetPage.getEntries()) {
        sharedSetIds.add(campaignSharedSet.getSharedSetId());
        System.out.printf(""Campaign shared set ID %d and name '%s' found for campaign ID %d.%n"",
            campaignSharedSet.getSharedSetId(), campaignSharedSet.getSharedSetName(),
            campaignSharedSet.getCampaignId());
      }
      offset += PAGE_SIZE;
    } while (offset < campaignSharedSetPage.getTotalNumEntries());

    if (sharedSetIds.isEmpty()) {
      System.out.printf(""No shared sets found for campaign ID %d.%n"", campaignId);
      return;
    }

    // Next, retrieve criterion IDs for all found shared sets.
    SharedCriterionServiceInterface sharedCriterionService =
        adWordsServices.get(session, SharedCriterionServiceInterface.class);

    // Transform shared set IDs to strings.
    String[] sharedSetIdStrings = Collections2.transform(sharedSetIds, Functions.toStringFunction())
        .toArray(new String[sharedSetIds.size()]);
    
    offset = 0;
    selectorBuilder = new SelectorBuilder()
      .fields(""SharedSetId"", ""Id"", ""KeywordText"", ""KeywordMatchType"", ""PlacementUrl"")
      .in(""SharedSetId"", sharedSetIdStrings)
      .limit(PAGE_SIZE);
    
    List<SharedCriterionOperation> removeCriterionOperations = new ArrayList<>();
    SharedCriterionPage sharedCriterionPage;
    do {
      selectorBuilder.offset(offset);
      sharedCriterionPage = sharedCriterionService.get(selectorBuilder.build());
      for (SharedCriterion sharedCriterion : sharedCriterionPage.getEntries()) {
        if (CriterionType.KEYWORD.equals(sharedCriterion.getCriterion().getType())) {
          Keyword keyword = (Keyword) sharedCriterion.getCriterion();
          System.out.printf(""Shared negative keyword with ID %d and text '%s' was found.%n"",
              keyword.getId(), keyword.getText());
        } else if (CriterionType.PLACEMENT.equals(sharedCriterion.getCriterion().getType())) {
          Placement placement = (Placement) sharedCriterion.getCriterion();
          System.out.printf(""Shared negative placement with ID %d and URL '%s' was found.%n"",
              placement.getId(), placement.getUrl());
        } else {
          System.out.printf(""Shared criterion with ID %d was found.%n"",
              sharedCriterion.getCriterion().getId());
        }

        // Create an operation to remove this criterion.
        SharedCriterionOperation removeCriterionOperation = new SharedCriterionOperation();
        removeCriterionOperation.setOperator(Operator.REMOVE);
        
        SharedCriterion sharedCriterionToRemove = new SharedCriterion();
        
        Criterion criterionToRemove = new Criterion();
        criterionToRemove.setId(sharedCriterion.getCriterion().getId());
        
        sharedCriterionToRemove.setCriterion(criterionToRemove);
        sharedCriterionToRemove.setSharedSetId(sharedCriterion.getSharedSetId());
        
        removeCriterionOperation.setOperand(sharedCriterionToRemove);

        removeCriterionOperations.add(removeCriterionOperation);
      }
      offset += PAGE_SIZE;
    } while (offset < sharedCriterionPage.getTotalNumEntries());

    // Finally, remove the criteria.
    if (removeCriterionOperations.isEmpty()) {
      System.out.printf(""No shared criteria to remove.%n"");
    } else {
      SharedCriterionReturnValue sharedCriterionReturnValue =
          sharedCriterionService.mutate(removeCriterionOperations.toArray(
              new SharedCriterionOperation[removeCriterionOperations.size()]));
      for (SharedCriterion removedCriterion : sharedCriterionReturnValue.getValue()) {
        System.out.printf(
            ""Shared criterion ID %d was successfully removed from shared set ID %d.%n"",
            removedCriterion.getCriterion().getId(), removedCriterion.getSharedSetId());
      }
    }
  }",Example of getting all the shared sets for a given campaign.
"@Override
    public R visitSerialField(SerialFieldTree node, P p) {
        return defaultAction(node, p);
    }",Visit a SerialFieldTree. This implementation just calls the default action.
"public final void setHeaderColorStyle(HeaderColorStyle headerColorStyle) {
        this.headerColorStyle = headerColorStyle;

        if (!headerColorStyle.getColorStyle().isEmpty()) {
            this.getHeaderLabel().setStyle(headerColorStyle.getColorStyle());

            // It's either DEFAULT or CUSTOM value (all empty values)
            // If it is DEFAULT, it sets the default style color
            // Otherwise if it is CUSTOM, by default no style is applied 
            // (default css ""generic"" color is in play), user has
            // to manually set it via setCustomHeaderColorStyle(String colorStyle)
        } else {
            if (headerColorStyle == HeaderColorStyle.DEFAULT) {
                switch (this.dialogType) {
                    case INFORMATION:
                        this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_INFO);
                        break;
                    case ERROR:
                        this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_ERROR);
                        break;
                    case WARNING:
                        this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_WARNING);
                        break;
                    case CONFIRMATION:
                        this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_CONFIRM);
                        break;
                    case CONFIRMATION_ALT1:
                        this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_CONFIRM);
                        break;
                    case CONFIRMATION_ALT2:
                        this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_CONFIRM);
                        break;
                    case EXCEPTION:
                        this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_EXCEPTION);
                        break;
                    case INPUT_TEXT:
                        this.updateHeaderColorStyle(HeaderColorStyle.GLOSS_INPUT);
                        break;
                    default:
                        this.updateHeaderColorStyle(HeaderColorStyle.GENERIC);
                        break;
                }
            }
        }

    }",Sets the header color style.
"@Deprecated
    public Iterable<BoxItem.Info> search(final String query) {
        return new Iterable<BoxItem.Info>() {
            @Override
            public Iterator<BoxItem.Info> iterator() {
                QueryStringBuilder builder = new QueryStringBuilder();
                builder.appendParam(""query"", query);
                builder.appendParam(""ancestor_folder_ids"", getID());

                URL url = SEARCH_URL_TEMPLATE.buildWithQuery(getAPI().getBaseURL(), builder.toString());
                return new BoxItemIterator(getAPI(), url);
            }
        };
    }",Returns an iterable of the items that match the specified query.
"public void start() throws Exception
    {
        Preconditions.checkState(state.compareAndSet(State.LATENT, State.STARTED));

        //Try to restore data from backup before zookeeper will be started
        backupManager.restoreAll();

        activityQueue.start();
        configManager.start();
        monitorRunningInstance.start();
        cleanupManager.start();
        backupManager.start();
        autoInstanceManagement.start();
        if ( servoMonitoring != null )
        {
            servoMonitoring.start();
        }

        configManager.addConfigListener
        (
            new ConfigListener()
            {
                @Override
                public void configUpdated()
                {
                    try
                    {
                        resetLocalConnection();
                    }
                    catch ( IOException e )
                    {
                        log.add(ActivityLog.Type.ERROR, ""Resetting connection"", e);
                    }
                }
            }
        );
    }",Start the application.
"public void purge() {
        SortedQueue queue = getQueue();
        _eventStore.purge(_writeChannel);
        queue.clear();
        _eventStore.purge(_readChannel);
    }",Purge all the records from the cache.
"public void addPointToTail( int x , int y ) {
		int index = tail.start + tail.length*2;

		int block[];
		int blockIndex = tail.block + index/blockLength;
		if( blockIndex == blocks.size ) {
			tailBlockSize = 0;
			block = blocks.grow();
		} else {
			block = blocks.get( blockIndex );
		}
		tailBlockSize += 2;
		index %= blockLength;

		block[index ] = x;
		block[index+1 ] = y;
		tail.length += 1;
	}",Adds a point to the tail.
"@Override
	public Set<Entry<Pair<T, I>, V>> entrySet() {
		return new AbstractSet<Entry<Pair<T, I>, V>>() {
			@Override
			public boolean add(Entry<Pair<T, I>, V> e) {
				V res = PairMap.this.put(e.getKey(), e.getValue());
				return res != e.getValue();
			}

			@Override
			public void clear() {
				PairMap.this.clear();
			}

			@Override
			public boolean contains(Object o) {
				return o != null
						&& o instanceof Entry<?, ?>
						&& PairMap.this.containsKey(((Entry<?, ?>) o).getKey())
						&& PairMap.this.containsValue(((Entry<?, ?>) o).getValue());
			}

			@Override
			public boolean isEmpty() {
				return keys.isEmpty();
			}

			@Override
			public Iterator<Entry<Pair<T, I>, V>> iterator() {
				return new Iterator<Entry<Pair<T, I>, V>>() {
					final Iterator<Pair<T, I>> keyItr = keys.iterator();
					int valueIndex = -1;

					@Override
					public boolean hasNext() {
						return keyItr.hasNext();
					}

					@Override
					public Entry<Pair<T, I>, V> next() {
						final Pair<T, I> key = keyItr.next();
						valueIndex++;

						return new Entry<Pair<T, I>, V>() {
							@Override
							public Pair<T, I> getKey() {
								return key;
							}

							@Override
							public V getValue() {
								return values.get(valueIndex);
							}

							@Override
							public V setValue(V value) {
								return values.set(valueIndex, value);
							}
							
							@Override
							public String toString() {
								return ""{"" + getKey() + ""="" + getValue() + ""}"";
							}
						};
					}

					@Override
					public void remove() {
						throw new UnsupportedOperationException();
					}
				};
			}

			@Override
			public boolean remove(Object o) {
				throw new UnsupportedOperationException();
			}

			@Override
			public int size() {
				return keys.size();
			}
		};
	}",Override the EntrySet interface.
"static private Type resolveTypeVariable (Class fromClass, Class current, Type type, boolean first) {
		Type genericSuper = current.getGenericSuperclass();
		if (!(genericSuper instanceof ParameterizedType)) return type; // No type arguments passed to super class.

		// Search fromClass to current inclusive, using the call stack to traverse the class hierarchy in super class first order.
		Class superClass = current.getSuperclass();
		if (superClass != fromClass) {
			Type resolved = resolveTypeVariable(fromClass, superClass, type, false);
			if (resolved instanceof Class) return (Class)resolved; // Resolved in a super class.
			type = resolved;
		}

		// Match the type variable name to the super class parameter.
		String name = type.toString(); // Java 8: getTypeName
		TypeVariable[] params = superClass.getTypeParameters();
		for (int i = 0, n = params.length; i < n; i++) {
			TypeVariable param = params[i];
			if (param.getName().equals(name)) {
				// Use the super class' type variable index to find the actual class in the sub class declaration.
				Type arg = ((ParameterizedType)genericSuper).getActualTypeArguments()[i];

				// Success, the type variable was explicitly declared.
				if (arg instanceof Class) return (Class)arg;
				if (arg instanceof ParameterizedType) return resolveType(fromClass, current, arg);

				if (arg instanceof TypeVariable) {
					if (first) return type; // Failure, no more sub classes.
					return arg; // Look for the new type variable in the next sub class.
				}
			}
		}

		// If this happens, there is a case we need to handle.
		throw new KryoException(""Unable to resolve type variable: "" + type);
	}",Resolves a type variable in the given class.
"public boolean lint(String s) {
        // return true if either the specific option is enabled, or
        // they are all enabled without the specific one being
        // disabled
        return
            isSet(XLINT_CUSTOM, s) ||
            (isSet(XLINT) || isSet(XLINT_CUSTOM, ""all"")) &&
                isUnset(XLINT_CUSTOM, ""-"" + s);
    }",Check if the specified string is a valid CML record.
"private boolean verifySignature(Signature signature, String providedSignature) {
        // We can only make one call to Signature#verify here.
        // Since we need to potentially check two values (one decoded from hex, the other decoded from base64),
        // try hex first: It's almost certainly going to fail decoding if a base64 string was passed.
        // It is extremely unlikely for base64 strings to be a valid hex string.
        // This way, if it's base64, the #verify call will be skipped, and we continue with the #verify for decoded base64.
        // This approach might look unnecessarily clever, but short of having redundant Signature instances,
        // there doesn't seem to be a better approach for this.
        try {
            if (signature.verify(Hex.decodeHex(providedSignature.toCharArray()))) {
                return true;
            }
        } catch (SignatureException|DecoderException ignore) {
            // ignore
        }

        try {
            if (signature.verify(Base64.getDecoder().decode(providedSignature))) {
                return true;
            }
        } catch (SignatureException|IllegalArgumentException ignore) {
            // ignore
        }
        return false;
    }",Verify a signature.
"public static String getStringForSign(PayReq request) {

        Map<String, Object>  params = new HashMap<String, Object>();

        // 必选参数
        params.put(HwPayConstant.KEY_MERCHANTID, request.getMerchantId());
        params.put(HwPayConstant.KEY_APPLICATIONID, request.getApplicationID());
        params.put(HwPayConstant.KEY_PRODUCTNAME, request.getProductName());
        params.put(HwPayConstant.KEY_PRODUCTDESC, request.getProductDesc());
        params.put(HwPayConstant.KEY_REQUESTID, request.getRequestId());
        params.put(HwPayConstant.KEY_AMOUNT, request.getAmount());

        // 可选参数
        params.put(HwPayConstant.KEY_PARTNER_IDS, request.getPartnerIDs());
        params.put(HwPayConstant.KEY_CURRENCY, request.getCurrency());
        params.put(HwPayConstant.KEY_COUNTRY, request.getCountry());
        params.put(HwPayConstant.KEY_URL, request.getUrl());
        params.put(HwPayConstant.KEY_URLVER, request.getUrlVer());
        params.put(HwPayConstant.KEY_EXPIRETIME, request.getExpireTime());
        params.put(HwPayConstant.KEY_SDKCHANNEL, request.getSdkChannel());

        return getNoSign(params, false);
    }",Gets the String for sign.
"protected <T extends TokenBase> List<T> createTokenList(String text) {

        if (!split) {
            return createTokenList(0, text);
        }

        List<Integer> splitPositions = getSplitPositions(text);

        if (splitPositions.isEmpty()) {
            return createTokenList(0, text);
        }

        ArrayList<T> result = new ArrayList<>();

        int offset = 0;

        for (int position : splitPositions) {
            result.addAll(this.<T>createTokenList(offset, text.substring(offset, position + 1)));
            offset = position + 1;
        }

        if (offset < text.length()) {
            result.addAll(this.<T>createTokenList(offset, text.substring(offset)));
        }

        return result;
    }",Create a list of tokens from the text.
"private int readInt() throws IOException {
    latestRead = (int)SerializationUtils.readIntegerType(input, WriterImpl.INT_BYTE_SIZE,
                                                         true, input.useVInts());
    return latestRead;
  }",read an int from the stream
"protected static String formatMessage(String message, byte[] hostData,
            int start, int curPos, int bytesLen) {

        StringBuilder sb = new StringBuilder();
        sb.append(message);
        if (hostData != null && hostData.length > 0 && curPos < hostData.length
                && curPos >= start && bytesLen > 0
                && start + bytesLen <= hostData.length) {
            sb.append("". Error at offset "");
            sb.append(curPos);
            sb.append("" : [0x"");
            int spyStart = Math.max(start - SPYBUF_MAX_LEN, 0);
            appendData(sb, hostData, spyStart, start - spyStart);
            sb.append(start > spyStart ? ""->"" : """");
            if (curPos > start) {
                appendData(sb, hostData, start, curPos - start);
                sb.append(""^"");
                appendData(sb, hostData, curPos, bytesLen + start - curPos);
            } else {
                appendData(sb, hostData, start, bytesLen);
            }
            int spyStop = Math.min(start + bytesLen + SPYBUF_MAX_LEN,
                    hostData.length);
            sb.append(spyStop > start + bytesLen ? ""<-"" : """");
            appendData(sb, hostData, start + bytesLen, spyStop - start
                    - bytesLen);
            sb.append(""]"");
        } else {
            sb.append("". Position is "");
            sb.append(curPos);
        }
        return sb.toString();

    }",Format message.
"public ToolScreen addToolbars()
    {
        super.addToolbars();
        
        ToolScreen toolbar = new EmptyToolbar(null, this, null, ScreenConstants.DONT_DISPLAY_FIELD_DESC, null);
        
        Record mainFile = this.getMainRecord();
        
        BaseField field = this.getScreenRecord().getField(ClassVars.CLASS_KEY);
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.FLUSH_LEFT, ScreenConstants.SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Description"", MenuConstants.FORM, ""5"", null);
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Logic"", MenuConstants.GROUP, ""0"", null);
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Fields"", MenuConstants.DISTRIBUTION, ""1"", null);
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Keys"", MenuConstants.GROUP, ""2"", null);
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Members"", MenuConstants.DISTRIBUTION, ""3"", null);
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Screen"", MenuConstants.GROUP, ""4"", null);
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""File header"", MenuConstants.FORMLINK, ""9"", null);
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Resources"", MenuConstants.DISTRIBUTION, ""7"", null);
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Help Desc"", MenuConstants.HELP, ""6"", null);
        //new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Issues"", MenuConstants.CLONE, ""8"", null);
        
        JavaButton pJavaButton = new JavaButton(toolbar.getNextLocation(ScreenConstants.FLUSH_LEFT, ScreenConstants.SET_ANCHOR), toolbar, null, ScreenConstants.DISPLAY_FIELD_DESC);
        pJavaButton.setClassInfo((ClassInfo)mainFile);
        //new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, null, ScreenConstants.DEFAULT_DISPLAY, null, ""File header"", MenuConstants.FORM, ""?screen="" + FileHdrScreen.class.getName(), null);
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, null, ScreenConstants.DEFAULT_DISPLAY, null, ""Database info"", MenuConstants.FORM, ""?screen="" + DatabaseInfoScreen.class.getName(), null);
        //new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, null, ScreenConstants.DEFAULT_DISPLAY, null, ""Layout"", MenuConstants.FORM, ""?screen="" + LayoutScreen.class.getName(), null);
        
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, field, ScreenConstants.DEFAULT_DISPLAY, null, ""Import/Export"", ""Export"", ""10"", null);
        
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, null, ScreenConstants.DEFAULT_DISPLAY, null, ""Maintenance"", MenuConstants.FORM, ""?screen="" + org.jbundle.app.program.access.AccessGridScreen.class.getName(), null);
        String strJob = null;
        strJob = Utility.addURLParam(strJob, DBParams.TASK, DBConstants.SAPPLET); // Screen class
        strJob = Utility.addURLParam(strJob, DBParams.SCREEN, "".app.program.manual.util.process.CopyHelpInfo"");    // Screen class
        new SCannedBox(toolbar.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), toolbar, null, ScreenConstants.DEFAULT_DISPLAY, null, ""Scan Help"", MenuConstants.RUN, strJob, null);
        
        return toolbar;
    }","Add the toolbars for the
   ."
"private boolean setProperty(String propertyName, int propertyValueNew) {
		if(propertyName == null) return false;
		Object propertyValueOld = getProperty(propertyName);
		if(propertyValueOld instanceof Integer) {
			int valueOld = ((Integer)propertyValueOld).intValue();
			if (valueOld==propertyValueNew) return true;
		} 
		beforeChange(propertyName);
		properties.put(propertyName, Integer.valueOf(propertyValueNew));
		afterChange(propertyName);
		setModified(propertyName, true);
		return true;
	}",Sets the value of the specified property in the entity.
"public void setSorting(boolean value) {
        model.setSortingCategories(value);
        model.setSortingProperties(value);
        sortButton.setSelected(value);
    }",Sets the sorting mode.
"public JNDIContentRepositoryBuilder withContextProperty(final String name, final Object value) {

        contextProperties.put(name, value);
        return this;
    }",Add a context property.
"public EClass getGCBEZRG() {
		if (gcbezrgEClass == null) {
			gcbezrgEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(492);
		}
		return gcbezrgEClass;
	}",Get the GCBEZRG EClass.
"@Override
  public JsonElement serialize(Period src, Type typeOfSrc, JsonSerializationContext context)
  {
    final PeriodFormatter fmt = ISOPeriodFormat.standard();
    return new JsonPrimitive(fmt.print(src));
  }","Override to provide customization of the
"
"public EClass getSCFL() {
		if (scflEClass == null) {
			scflEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(335);
		}
		return scflEClass;
	}",Get the SCFL.
"public <T> T performGetRequest(String url, Class<T> returnType, Map<String, String> uriVariables) {

        int tryNumber = 1;
        while(tryNumber <= API_RETRY) {
            try {
                return restTemplate.getForObject(url, returnType, uriVariables);
            } catch (HttpStatusCodeException error) {
                boolean isTooManyRequestsError = handleHttpStatusCodeError(uriVariables, tryNumber, error);
                if (isTooManyRequestsError) {
                    try {
                        Thread.sleep(1000);
                    } catch (InterruptedException e) {
                        log.error(""Error in performGetRequest"", e);
                    }
                } else {
                    tryNumber++;
                }
            } catch (Exception e) {
                handleApiError(tryNumber, e);
                tryNumber++;
            }
        }

        throw new RestApiException(""Error getting "" + returnType.getSimpleName() + "" url variables "" + uriVariables.toString());

    }",Perform a GET request to the specified URL.
"public void setActions(com.google.api.ads.admanager.axis.v201902.ProgressAction[] actions) {
        this.actions = actions;
    }",Sets the actions value for this BaseProgressRule.
"public WebSocketContext messageReceived(String receivedMessage) {
        this.stringMessage = S.string(receivedMessage).trim();
        isJson = stringMessage.startsWith(""{"") || stringMessage.startsWith(""]"");
        tryParseQueryParams();
        return this;
    }",Called when a message is received from the server.
"@Override
    public java.util.concurrent.Future<ListVerifiedEmailAddressesResult> listVerifiedEmailAddressesAsync(
            com.amazonaws.handlers.AsyncHandler<ListVerifiedEmailAddressesRequest, ListVerifiedEmailAddressesResult> asyncHandler) {

        return listVerifiedEmailAddressesAsync(new ListVerifiedEmailAddressesRequest(), asyncHandler);
    }",Simplified method form for invoking the ListVerifiedEmailAddresses operation with an AsyncHandler.
"private Node<T> min(Node<T> x) {
    	do {
    		if (x.left == null) return x;
    		x = x.left;
    	} while (true);
    }",Returns the node with the smallest left value.
"public Matrix3d set(Matrix4fc mat) {
        m00 = mat.m00();
        m01 = mat.m01();
        m02 = mat.m02();
        m10 = mat.m10();
        m11 = mat.m11();
        m12 = mat.m12();
        m20 = mat.m20();
        m21 = mat.m21();
        m22 = mat.m22();
        return this;
    }",Sets the matrix to be the same as the matrix.
"@TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
	public int getTotalPaddingStart (){
		if(Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1)
			return getPaddingStart() + mInputView.getTotalPaddingStart();

		return getTotalPaddingLeft();
	}",Returns the total padding start of the view.
"@Nonnull
  public PSTitle readTitleFromXML (@Nonnull final IMicroElement eTitle)
  {
    final PSTitle ret = new PSTitle ();

    eTitle.forAllAttributes ( (sNS, sAttrName, sVal) -> {
      final String sAttrValue = _getAttributeValue (sVal);
      _warn (ret, ""Unsupported attribute '"" + sAttrName + ""'='"" + sAttrValue + ""'"");
    });

    eTitle.forAllChildren (aTitleChild -> {
      switch (aTitleChild.getType ())
      {
        case TEXT:
          ret.addText (((IMicroText) aTitleChild).getNodeValue ());
          break;
        case ELEMENT:
          final IMicroElement eElement = (IMicroElement) aTitleChild;
          if (CSchematron.NAMESPACE_SCHEMATRON.equals (eElement.getNamespaceURI ()))
          {
            final String sLocalName = eElement.getLocalName ();
            if (sLocalName.equals (CSchematronXML.ELEMENT_DIR))
              ret.addDir (readDirFromXML (eElement));
            else
              _warn (ret, ""Unsupported Schematron element '"" + sLocalName + ""'"");
          }
          else
            _warn (ret, ""Unsupported namespace URI '"" + eElement.getNamespaceURI () + ""'"");

          break;
        case COMMENT:
          // Ignore comments
          break;
        default:
          _warn (ret, ""Unsupported child node: "" + aTitleChild);
      }
    });
    return ret;
  }",Read the title from the XML.
"@Override
	public String getText() {

		// sets text from input if not text directly available
		text = super.getText();

		int t;
		try {
			t = typeMapper.inverse().get(type);
		} catch (NullPointerException e) {
			return text;
		}
		switch (t) {
			case FUNCTION:
				return text.substring(0, text.length()-1);
			case URI:
				return extractURI(text);
            case UNCLOSED_URI:
                return extractUNCLOSEDURI(text);
			case STRING:
				return extractSTRING(text);
			case UNCLOSED_STRING:
				return extractUNCLOSEDSTRING(text);
			case CLASSKEYWORD:
				return extractCLASSKEYWORD(text);
			case HASH:
				return extractHASH(text);
			default:
				return text;
		}

	}",Returns the text of the sequence.
"public void showFeedback(String feedbackText) {
        feedbackSpan.setText(feedbackText);
        new MaterialAnimation().transition(Transition.FADEINUP).duration(400).animate(feedbackSpan);
        MaterialLoader.loading(true, getCurrentStep().getDivBody());
        add(divFeedback);
    }",Show a feedback span.
"private String expandMessage(final BuildEvent event, final String message) {
        final HashMap<String,String> data=new HashMap<String, String>();

        final String user = retrieveUserName(event);
        if(null!=user){
            data.put(""user"", user);
        }
        final String node = retrieveNodeName(event);
        if(null!=node){
            data.put(""node"", node);
        }
        data.put(""level"", logLevelToString(event.getPriority()));
        if(null!=formatter){

            return formatter.reformat(data, message);
        }else {
            return message;
        }
    }",Expands the message to include the user node and priority information.
"private SearchControls getCallerSearchControls() {
        String[] attrIds = { idStoreDefinition.getCallerNameAttribute() };
        long limit = Long.valueOf(idStoreDefinition.getMaxResults());
        int timeOut = idStoreDefinition.getReadTimeout();
        int scope = getSearchScope(idStoreDefinition.getCallerSearchScope());
        return new SearchControls(scope, limit, timeOut, attrIds, false, false);
    }",Get the caller search controls.
"public void execute( EnforcerRuleHelper theHelper )
        throws EnforcerRuleException
    {
        List<String> missingProfiles = new ArrayList<String>();
        try
        {
            MavenProject project = (MavenProject) theHelper.evaluate( ""${project}"" );
            if ( StringUtils.isNotEmpty( profiles ) )
            {
                String[] profs = profiles.split( "","" );
                for ( String profile : profs )
                {
                    if ( !isProfileActive( project, profile ) )
                    {
                        missingProfiles.add( profile );
                    }
                }

                boolean fail = false;
                if ( !missingProfiles.isEmpty() )
                {
                    fail = true;
                    // if (all && missingProfiles.size() != profs.length)
                    // {
                    // fail = true;
                    // }
                    // else
                    // {
                    // if (!all && missingProfiles.size() >= (profs.length -1))
                    // {
                    // fail = true;
                    // }
                    // }
                }

                if ( fail )
                {
                    String message = getMessage();
                    StringBuilder buf = new StringBuilder();
                    if ( message != null )
                    {
                        buf.append( message + ""\n"" );
                    }

                    for ( String profile : missingProfiles )
                    {
                        buf.append( ""Profile \"""" + profile + ""\"" is not activated.\n"" );
                    }

                    throw new EnforcerRuleException( buf.toString() );
                }

            }

        }
        catch ( ExpressionEvaluationException e )
        {
            throw new EnforcerRuleException( ""Unable to retrieve the project."", e );
        }

    }",Execute the rule.
"public static int listFindIgnoreEmpty(String list, String value, char delimiter) {
	if (list == null) return -1;
	int len = list.length();
	if (len == 0) return -1;
	int last = 0;
	int count = 0;

	for (int i = 0; i < len; i++) {
	    if (list.charAt(i) == delimiter) {
		if (last < i) {
		    if (list.substring(last, i).equals(value)) return count;
		    count++;
		}
		last = i + 1;
	    }
	}
	if (last < len) {
	    if (list.substring(last).equals(value)) return count;
	}
	return -1;
    }",Find the first occurrence of value in the list ignoring empty elements.
"@Pure
	public RoadSegment getConnectableSegmentToLastPoint(RoadPath path) {
		assert path != null;
		if (path.isEmpty()) {
			return null;
		}
		RoadConnection last1 = getLastPoint();
		RoadConnection first2 = path.getFirstPoint();
		RoadConnection last2 = path.getLastPoint();
		last1 = last1.getWrappedRoadConnection();
		first2 = first2.getWrappedRoadConnection();
		last2 = last2.getWrappedRoadConnection();
		if (last1.equals(first2)) {
			return path.getFirstSegment();
		}
		if (last1.equals(last2)) {
			return path.getLastSegment();
		}
		return null;
	}",Replies the connectable segment to the last point of the path.
"private static void setSystemClassLoaderClassPath() throws Exception {
        Log.d(""Setting classpath"");
        // We use agent class as we do not extract this class in newly created
        // jar (otherwise we may end up creating one -magic jar from another);
        // also it will exist even without JUnit classes).
        URL url = EkstaziAgent.class.getResource(EkstaziAgent.class.getSimpleName() + "".class"");
        String origPath = url.getFile().replace(""file:"", """").replaceAll("".jar!.*"", "".jar"");
        File junitJar = new File(origPath);
        File xtsJar = new File(origPath.replaceAll("".jar"", ""-magic.jar""));

        boolean isCreated = false;
        // If extracted (Tool) jar is newer than junit*.jar, there is no reason
        // to extract files again, so just return in that case.
        if (FileUtil.isSecondNewerThanFirst(junitJar, xtsJar)) {
            // We cannot return here, as we have to include jar on the path.
            isCreated = true;
        } else {
            // Extract new jar as junit.jar is newer.
            String[] includePrefixes = { Names.EKSTAZI_PACKAGE_BIN };
            String[] excludePrefixes = { EkstaziAgent.class.getName() };
            isCreated = JarXtractor.extract(junitJar, xtsJar, includePrefixes, excludePrefixes);
        }

        // Add jar to classpath if it was successfully created, otherwise throw
        // an exception.
        if (isCreated) {
            addURL(xtsJar.toURI().toURL());
        } else {
            throw new RuntimeException(""Could not extract Tool classes in separate jar."");
        }
    }",Set the system class loader classpath.
"private QueryBuilderKraken parseCreate()
  {
    Token token;

    // TableBuilderKraken factory = null;// = _database.createTableFactory();

    if ((token = scanToken()) != Token.TABLE)
      throw error(""expected TABLE at '{0}'"", token);

    if ((token = scanToken()) != Token.IDENTIFIER)
      throw error(""expected identifier at '{0}'"", token);
    
    String name = _lexeme;
    String pod = null;
    
    while (peekToken() == Token.DOT) {
      scanToken();
      
      if ((token = scanToken()) != Token.IDENTIFIER) {
        throw error(""expected identifier at '{0}'"", token);
      }
    
      if (pod == null) {
        pod = name;
      }
      else {
        pod = pod + '.' + name;
      }
      
      name = _lexeme;
    }
    
    if (pod == null) {
      pod = getPodName();
    }

    TableBuilderKraken factory = new TableBuilderKraken(pod, name, _sql);
    // factory.startTable(_lexeme);

    if ((token = scanToken()) != Token.LPAREN) {
      throw error(""expected '(' at '{0}'"", token);
    }

    do {
      token = scanToken();

      switch (token) {
      case IDENTIFIER:
        parseCreateColumn(factory, _lexeme);
        break;

        /*
      case UNIQUE:
        token = scanToken();
        
        if (token != KEY) {
          _token = token;
        }
        
        factory.addUnique(parseColumnNames());
        break;
        */

      case PRIMARY:
        token = scanToken();
        if (token != Token.KEY)
          throw error(""expected 'key' at {0}"", token);

        factory.addPrimaryKey(parseColumnNames());
        break;

      case KEY:
        //String key = parseIdentifier();

        factory.addPrimaryKey(parseColumnNames()); // factory.addPrimaryKey(parseColumnNames());
        break;

        /*
      case CHECK:
        if ((token = scanToken()) != '(')
          throw error(L.l(""Expected '(' at '{0}'"", tokenName(token)));

        parseExpr();

        if ((token = scanToken()) != ')')
          throw error(L.l(""Expected ')' at '{0}'"", tokenName(token)));
        break;
        */

      default:
        throw error(""unexpected token '{0}'"", token);
      }

      token = scanToken();
    } while (token == Token.COMMA);

    if (token != Token.RPAREN) {
      throw error(""expected ')' at '{0}'"", token);
    }
    
    token = scanToken();
    
    HashMap<String,String> propMap = new HashMap<>();
    
    if (token == Token.WITH) {
      do {
        String key = parseIdentifier();
        ExprKraken expr = parseExpr();

        if (! (expr instanceof LiteralExpr)) {
          throw error(""WITH expression must be a literal at '{0}'"", expr);
        }
        
        String value = expr.evalString(null);
        
        propMap.put(key, value);
      } while ((token = scanToken()) == Token.COMMA);
    }
    
    if (token != Token.EOF) {
      throw error(""Expected end of file at '{0}'"", token);
    }

    return new CreateQueryBuilder(_tableManager, factory, _sql, propMap);
  }",Parse create table.
"public void debug(Object message, Throwable exception) {
    log(Level.DEBUG, message, exception);
  }",Log a message and exception with a CID    log level.
"@Override
    public DetachVolumeResult detachVolume(DetachVolumeRequest request) {
        request = beforeClientExecution(request);
        return executeDetachVolume(request);
    }",Detaches an existing AZ volume from an app.
"public void setTransformDef( File transformDef)
    {
    options_.setTransformDef( transformDef);
    if( transformDef != null)
      {
      options_.setTransformType( Options.TransformType.CUSTOM);
      }
    }",Sets the transformDef.
"void setAttribute(File file, String attribute, Object value) {
    state.checkOpen();
    // TODO(cgdecker): Change attribute stuff to avoid the sad boolean parameter
    attributes.setAttribute(file, attribute, value, false);
  }",Sets an attribute on a CID    file.
"private BT advanceAndRead(BT reuse) throws IOException {
		if (!partitions.hasNext()) {
			return null;
		}
		currentPartition = partitions.next();
		currentPartition.setReadPosition(0);

		try {
			reuse = serializer.deserialize(reuse, currentPartition);
		} catch (EOFException e) {
			reuse = advanceAndRead(reuse);
		}
		return reuse;
	}",Reads the next BT from the input stream.
"private Record parseResponse(InputStream response) throws StageException {
    Record record = null;
    if (conf.httpMethod == HttpMethod.HEAD) {
      // Head will have no body so can't be parsed.   Return an empty record.
      record = getContext().createRecord("""");
      record.set(Field.create(new HashMap()));

    } else if (response != null) {
      try (DataParser parser = parserFactory.getParser("""", response, ""0"")) {
        // A response may only contain a single record, so we only parse it once.
        record = parser.parse();
        if (conf.dataFormat == DataFormat.TEXT) {
          // Output is placed in a field ""/text"" so we remove it here.
          record.set(record.get(""/text""));
        }
      } catch (IOException | DataParserException e) {
        errorRecordHandler.onError(Errors.HTTP_00, e.toString(), e);
      }
    }
    return record;
  }",Parses the response.
"public static <T> String toXml(T obj, XAlias[] xAlias,
                                   XAliasField[] xAliasFields, XAliasAttribute[] xAliasAttributes,
                                   XOmitField[] xOmitFields) {

        return toXml(obj, xAlias, xAliasFields, xAliasAttributes, xOmitFields,
                null, null, null);
    }",Converts a CID resource object to an XML string.
"private final void replaceAll(final Element root,
            final Map<String, String> replacements) {
        String selector;    // Iterated selector
        String replacement; // Iterated HTML replacement
        Element replacementElem; // Iterated replacement
        Collection<Element> elements; // Selected elements
        Element replacementBody; // Body of the replacement

        for (final Entry<String, String> replacementEntry : replacements
                .entrySet()) {
            selector = replacementEntry.getKey();
            replacement = replacementEntry.getValue();

            elements = root.select(selector);
            if (!elements.isEmpty()) {
                // There are elements to replace

                // Processes the replacement
                replacementBody = Jsoup.parse(replacement).body();
                if (!replacementBody.children().isEmpty()) {
                    replacementElem = replacementBody.child(0);

                    // Replaces the elements
                    for (final Element element : elements) {
                        element.replaceWith(replacementElem.clone());
                    }
                }
            }
        }
    }",Replaces the elements in the root with the replacement elements.
"public <T> List<T> querySingleRowTypedResults(String sql, String[] args) {
		return db.querySingleRowTypedResults(sql, args);
	}",Query for typed rows.
"private synchronized static Pattern getPattern(String tagName,
			String attrName) {

		String key = tagName + ""    "" + attrName;
		Pattern pc = pcPatterns.get(key);
		if (pc == null) {

			String tagPatString = ""<\\s*"" + tagName + ""\\s+[^>]*\\b"" + attrName
					+ ""\\s*=\\s*("" + ANY_ATTR_VALUE + "")(?:\\s|>)?"";

			pc = Pattern.compile(tagPatString, Pattern.CASE_INSENSITIVE);
			pcPatterns.put(key, pc);
		}
		return pc;
	}",Gets the Pattern object for a given tag name and attribute name.
"public void marshall(JobWatermark jobWatermark, ProtocolMarshaller protocolMarshaller) {

        if (jobWatermark == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(jobWatermark.getPresetWatermarkId(), PRESETWATERMARKID_BINDING);
            protocolMarshaller.marshall(jobWatermark.getInputKey(), INPUTKEY_BINDING);
            protocolMarshaller.marshall(jobWatermark.getEncryption(), ENCRYPTION_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given jobWatermark to the JSON object.
"public byte[] toBytes()
    {
        if (tc.isEntryEnabled()) Tr.entry(tc, ""toBytes"");

        final byte[] result = new byte[16];

        final int t1 = (int)(_timestamp >> 32 & 0xFFFFFFFFL);
        final int t2 = (int)(_timestamp & 0xFFFFFFFFL);
        Util.setBytesFromInt(result, 0, 4, t1);
        Util.setBytesFromInt(result, 4, 4, t2);
        Util.setBytesFromInt(result, 8, 4, _epochNumber);
        Util.setBytesFromInt(result,12, 4, _sequenceNumber);

        if (tc.isEntryEnabled()) Tr.exit(tc, ""toBytes"", Util.toHexString(result));
        return result;
    }",Returns the bytes of this record header.
"public static MemoryCache createMemoryCache(Context context, int memoryCacheSize) {
		if (memoryCacheSize == 0) {
			ActivityManager am = (ActivityManager) context.getSystemService(Context.ACTIVITY_SERVICE);
			int memoryClass = am.getMemoryClass();
			if (hasHoneycomb() && isLargeHeap(context)) {
				memoryClass = getLargeMemoryClass(am);
			}
			memoryCacheSize = 1024 * 1024 * memoryClass / 8;
		}
		return new LruMemoryCache(memoryCacheSize);
	}",Creates a MemoryCache with the given size.
"public OperationFuture<Database, CreateDatabaseMetadata> createDatabase(
      String databaseId, Iterable<String> statements) throws SpannerException {
    return dbClient.createDatabase(instanceId(), databaseId, statements);
  }",Create a database with the specified ID and statements.
"public static String parseDate( String text )
	{
		// loads the script if not loaded yet
		if( !loaded )
		{
			loaded = true;

			String scriptContent = null;
			if( LocaleInfo.getCurrentLocale().getLocaleName().startsWith( ""fr"" ) )
			{
				DateFrJSBundle bundle = GWT.create( DateFrJSBundle.class );
				scriptContent = bundle.DateJsFr().getText();
			}
			else
			{
				DateJSBundle bundle = GWT.create( DateJSBundle.class );
				scriptContent = bundle.DateJs().getText();
			}

			Document doc = Document.get();
			ScriptElement sqljs = doc.createScriptElement();
			sqljs.setAttribute( ""type"", ""text/javascript"" );
			sqljs.setInnerText( scriptContent );
			doc.getDocumentElement().getFirstChildElement().appendChild( sqljs );
		}

		JavaScriptObject date = create( text );
		if( date == null )
			return null;

		String res = toConformity( date );

		return res;
	}",Parse a date from a string.
"@RequirePOST
    public HttpResponse doApproveAll() throws IOException {
        StringBuilder buf = new StringBuilder();
        for (Class c : rejected.get()) {
            buf.append(c.getName()).append('\n');
        }
        whitelisted.append(buf.toString());

        return HttpResponses.ok();
    }",Approve all the classes in the service.
"public void writeTo(OutputStream out) throws IOException
	{
		if (mLength > mBufferSizeLimit)
		{
			throw new IllegalStateException(""Can't write after a buffer overflow."");
		}

		if (mLength == 0)
		{
			// nothing to do
			return;
		}

		// write all previous chunks
		int count = mCurrentChunkIndex;
		for (int i = 0; i < count; ++i)
		{
			out.write(mChunkList.get(i));
		}

		// write the current partial chunk
		out.write(mCurrentChunk, 0, mPosInChunk);
	}",Writes the contents of this buffer to the given output stream.
"public void shutdown() {
        for (Connection connection : _connectionMap.values()) {
            connection.shutdown();
        }

        for (Connection connection : _privilegedConnectionMap.values()) {
            connection.shutdown();
        }

        _factory.releaseExternalResources();
    }",Shutdown all the resources associated with this application.
"public WebSocketContext sendToUser(String message, String username) {
        return sendToConnections(message, username, manager.usernameRegistry(), true);
    }",Send message to user
"@Override
    public PutApprovalResultResult putApprovalResult(PutApprovalResultRequest request) {
        request = beforeClientExecution(request);
        return executePutApprovalResult(request);
    }",Updates an approval result for an app.
"public static <C extends Collection<String>> C splitString(String line, char delim, C words) {
		return splitString(line, 0, line.length(), delim, words);
	}",Splits a string into words.
"public void addOrUpdateReceiver(ActivityInfo receiverInfo) {
    addComponent(
        receiverFilters,
        p -> p.receivers,
        (p, a) -> p.receivers = a,
        new ActivityInfo(receiverInfo),
        true);
  }",Adds or updates the receiver.
"public static Map<String, List<String>> toHashMap(final String aFilePath, final String aPattern,
            final String... aIgnoreList) throws FileNotFoundException {
        final String filePattern = aPattern != null ? aPattern : WILDCARD;
        final RegexFileFilter filter = new RegexFileFilter(filePattern);
        final Map<String, List<String>> fileMap = new HashMap<>();
        final File source = new File(aFilePath);

        for (final File file : listFiles(source, filter, true, aIgnoreList)) {
            final String fileName = file.getName();
            final String filePath = file.getAbsolutePath();

            if (fileMap.containsKey(fileName)) {
                final List<String> paths = fileMap.get(fileName);

                if (!paths.contains(filePath)) {
                    paths.add(filePath);
                } else {
                    throw new I18nRuntimeException(BUNDLE_NAME, MessageCodes.UTIL_034);
                }
            } else {
                final ArrayList<String> pathList = new ArrayList<>();
                pathList.add(filePath);
                fileMap.put(fileName, pathList);
            }
        }

        return Collections.unmodifiableMap(fileMap);
    }",To HashMap.
"static public void skip(InputStream is, int size) throws IOException {
	    long n;
		while (size > 0) {
	        n = is.skip(size);
	        if (n <= 0)
	            break;
			size -= n;
		}
	}",Skips the specified number of bytes from the specified input stream.
"private int parseContentLength(int maxPostDataSize, String length) {
        if(length!=null) {
            try {
                int size = Integer.parseInt(length);
                if(size>maxPostDataSize) return -1;
                else return size;
            } catch(NumberFormatException e) {
                // should never occur.  invalid content length i.e. abc, is usually
                // caught by the container.  However, a user could specify a Content-Length with
                // a value larger than an int max size
                return -1;
            }
        } else {
            return -2;
        }
    }",Parse the content length.
"public static PhantomJSDriverService createDefaultService(Capabilities desiredCapabilities) {
        // Look for Proxy configuration within the Capabilities
        Proxy proxy = null;
        if (desiredCapabilities != null) {
            proxy = Proxy.extractFrom(desiredCapabilities);
        }

        // Find PhantomJS executable
        File phantomjsfile = findPhantomJS(desiredCapabilities, PHANTOMJS_DOC_LINK, PHANTOMJS_DOWNLOAD_LINK);

        // Find GhostDriver main JavaScript file
        File ghostDriverfile = findGhostDriver(desiredCapabilities, GHOSTDRIVER_DOC_LINK, GHOSTDRIVER_DOWNLOAD_LINK);

        // Build & return service
        return new Builder().usingPhantomJSExecutable(phantomjsfile)
                .usingGhostDriver(ghostDriverfile)
                .usingAnyFreePort()
                .withProxy(proxy)
                .withLogFile(findLogFile())
                .withAcceptSslCerts(findAcceptSslCerts(desiredCapabilities))
                .usingCommandLineArguments(
                        findCLIArgumentsFromCaps(desiredCapabilities, PHANTOMJS_CLI_ARGS))
                .usingGhostDriverCommandLineArguments(
                        findCLIArgumentsFromCaps(desiredCapabilities, PHANTOMJS_GHOSTDRIVER_CLI_ARGS))
                .build();
    }",Creates a new instance of the PhantomJSDriverService class.
"private static int parseNanos(String value) throws ParseException {
    int result = 0;
    for (int i = 0; i < 9; ++i) {
      result = result * 10;
      if (i < value.length()) {
        if (value.charAt(i) < '0' || value.charAt(i) > '9') {
          throw new ParseException(""Invalid nanoseconds."", 0);
        }
        result += value.charAt(i) - '0';
      }
    }
    return result;
  }",Parse the nanoseconds value.
"public static Iterator<Object> getValues(Object[] array)
    {
        if (array == null)
        {
            return null;
        }
        ArrayList<Object> valueList = new ArrayList<Object>();
        int i = array.length - 1;
        while (i >= 0)
        {
            valueList.add(array[i]);
            i = i - 2;
        }
        return valueList.iterator();
    }",Get the value list of a CRACTYPE array.
"protected void layoutCharts() {
        //Pre-sort charts by group column
        MultiValuedMap<DJGroup, DJChart> mmap = new ArrayListValuedHashMap<DJGroup, DJChart>();
        for (DJChart djChart : getReport().getCharts()) {
            mmap.put(djChart.getColumnsGroup(), djChart);
        }

        for (DJGroup key : mmap.keySet()) {
            Collection<DJChart> charts = mmap.get(key);
            List<DJChart> l = new ArrayList<DJChart>(charts);
            //Reverse iteration of the charts to meet insertion order
            for (int i = l.size(); i > 0; i--) {
                DJChart djChart = l.get(i - 1);
                JRDesignChart chart = createChart(djChart);

                //Charts has their own band, so they are added in the band at Y=0
                JRDesignBand band = createGroupForChartAndGetBand(djChart);
                band.addElement(chart);
            }
        }

        //Pre-sort charts by group column
        MultiValuedMap<PropertyColumn, ar.com.fdvs.dj.domain.chart.DJChart> mmap2 = new ArrayListValuedHashMap<PropertyColumn, ar.com.fdvs.dj.domain.chart.DJChart>();
        for (ar.com.fdvs.dj.domain.chart.DJChart djChart : getReport().getNewCharts()) {
            mmap2.put(djChart.getDataset().getColumnsGroup(), djChart);
        }

        for (PropertyColumn key : mmap2.keySet()) {
            Collection<ar.com.fdvs.dj.domain.chart.DJChart> charts = mmap2.get(key);
            ArrayList<ar.com.fdvs.dj.domain.chart.DJChart> l = new ArrayList<ar.com.fdvs.dj.domain.chart.DJChart>(charts);
            //Reverse iteration of the charts to meet insertion order
            for (int i = l.size(); i > 0; i--) {
                ar.com.fdvs.dj.domain.chart.DJChart djChart = l.get(i - 1);
                String name = ""chart_"" + (i - 1) + new Date().getTime();
                JRDesignChart chart = createChart(djChart, name);

                if (djChart.getLink() != null)
                    HyperLinkUtil.applyHyperLinkToElement((DynamicJasperDesign) getDesign(), djChart.getLink(), chart, name + ""_hyperlink"");

                //Charts has their own band, so they are added in the band at Y=0
                JRDesignBand band = createGroupForChartAndGetBand(djChart);
                band.addElement(chart);
            }
        }
    }",Layout charts.
"private byte buildFlagsByte() {

		byte flag = 0;

		// Add the binary type to bit 5, 0 for standard and 1 for extended
		int binaryType = extended ? 1 : 0;
		flag += (binaryType << 5);

		// Add the empty geometry flag to bit 4, 0 for non-empty and 1 for
		// empty
		int emptyValue = empty ? 1 : 0;
		flag += (emptyValue << 4);

		// Add the envelope contents indicator code (3-bit unsigned integer to
		// bits 3, 2, and 1)
		int envelopeIndicator = envelope == null ? 0 : getIndicator(envelope);
		flag += (envelopeIndicator << 1);

		// Add the byte order to bit 0, 0 for Big Endian and 1 for Little
		// Endian
		int byteOrderValue = (byteOrder == ByteOrder.BIG_ENDIAN) ? 0 : 1;
		flag += byteOrderValue;

		return flag;
	}",Build the flags byte.
"@Override
    public void removeAppender(String name) {
        if (name == null || aai == null) {
            return;
        }
        Appender appender = aai.getAppender(name);
        aai.removeAppender(name);
        if (appender != null) {
            fireRemoveAppenderEvent(appender);
        }
    }",Removes an appender from the log.
"public List<Object> find(Object locator, boolean required) throws ReferenceException {
		return find(Object.class, locator, required);
	}",Find all objects matching the locator.
"private <T> GroupBuilder<T> convertFields(GroupBuilder<T> groupBuilder, List<FieldDescriptor> fieldDescriptors) {
    for (FieldDescriptor fieldDescriptor : fieldDescriptors) {
      groupBuilder =
          addField(fieldDescriptor, groupBuilder)
          .id(fieldDescriptor.getNumber())
          .named(fieldDescriptor.getName());
    }
    return groupBuilder;
  }",Convert fields to a group builder.
"public int getState()
   {
      boolean hasSuspendedComponents = false;
      boolean hasResumedComponents = false;
      List<Suspendable> suspendableComponents = getComponentInstancesOfType(Suspendable.class);
      for (Suspendable component : suspendableComponents)
      {
         if (component.isSuspended())
         {
            hasSuspendedComponents = true;
         }
         else
         {
            hasResumedComponents = true;
         }
      }

      if (hasSuspendedComponents && !hasResumedComponents)
      {
         return ManageableRepository.SUSPENDED;
      }
      else if (!hasSuspendedComponents)
      {
         return ManageableRepository.ONLINE;
      }
      else
      {
         return ManageableRepository.UNDEFINED;
      }
   }",Get the state of the repository.
"public static String getDefaultPort(SystemInfo.BoardType board) throws UnsupportedBoardType {
        switch (board){
            // ------------------------
            // ALL RASPBERRY PI MODELS
            // (except Model 3B)
            // ------------------------
            case RaspberryPi_A:
            case RaspberryPi_B_Rev1:
            case RaspberryPi_B_Rev2:
            case RaspberryPi_A_Plus:
            case RaspberryPi_B_Plus:
            case RaspberryPi_ComputeModule:
            case RaspberryPi_2B:
            case RaspberryPi_Zero:
            case RaspberryPi_ComputeModule3:
            case RaspberryPi_ZeroW:
            case RaspberryPi_Alpha:
            case RaspberryPi_Unknown: {
                return RaspberryPiSerial.DEFAULT_COM_PORT;
            }

            // ---------------------------
            // RASPBERRY PI MODEL 3B, 3B+
            // ---------------------------
            case RaspberryPi_3B:
            case RaspberryPi_3B_Plus: {
                // if the /dev/ttyS0 port exists, then use it as the default serial port
                File s0ComPort = new File(RaspberryPiSerial.S0_COM_PORT);
                if((s0ComPort.exists())){
                    return RaspberryPiSerial.S0_COM_PORT;
                }
                return RaspberryPiSerial.DEFAULT_COM_PORT;
            }

            // ------------------------
            // BANANAPI and BANANAPRO
            // ------------------------
            case BananaPi: {
                return BananaPiSerial.DEFAULT_COM_PORT;
            }
            case BananaPro: {
                return BananaProSerial.DEFAULT_COM_PORT;
            }

            // ------------------------
            // BPI
            // ------------------------
            // TODO : Implement serial for BPI boards
			case Bpi_M1:
				break;
			case Bpi_M1P:
				break;
			case Bpi_M2:
				break;
			case Bpi_M2M:
				break;
			case Bpi_M2P:
				break;
			case Bpi_M2P_H2_Plus:
				break;
			case Bpi_M2P_H5:
				break;
			case Bpi_M2U:
				break;
			case Bpi_M2U_V40:
				break;
			case Bpi_M3:
				break;
			case Bpi_M64:
				break;
			case Bpi_R1:
				break;

            // ------------------------
            // NANOPI
            // ------------------------
            // TODO : Implement serial for NanoPi boards
			case NanoPi_A64:
				break;
			case NanoPi_K2:
				break;
			case NanoPi_M1:
				break;
			case NanoPi_M1_Plus:
				break;
			case NanoPi_M3:
				break;
			case NanoPi_NEO:
				break;
			case NanoPi_NEO2:
				break;
			case NanoPi_NEO2_Plus:
				break;
			case NanoPi_NEO_Air:
				break;
			case NanoPi_S2:
				break;

            // ------------------------
            // ODROID
            // ------------------------
            // TODO : Implement serial for Odroid boards

			case Odroid:
				break;

            // ------------------------
            // ORANGEPI
            // ------------------------
            // TODO : Implement serial for OrangePi boards
			case OrangePi:
				break;

            // ------------------------
            // UNKNOWN
            // ------------------------
			case UNKNOWN:
				break;
			default:
				break;
        }

        // unknown board type, return null
        throw new UnsupportedBoardType();
	}",Returns the default serial port for the given board.
"public static void downloadFile(final String url, final File file) throws IOException {
		try (
			InputStream inputStream = new URL(url).openStream();
			ReadableByteChannel rbc = Channels.newChannel(inputStream);
			FileChannel fileChannel = FileChannel.open(
				file.toPath(),
				StandardOpenOption.CREATE,
				StandardOpenOption.TRUNCATE_EXISTING,
				StandardOpenOption.WRITE)
		) {
			fileChannel.transferFrom(rbc, 0, Long.MAX_VALUE);
		}
	}",Download a file from the given URL.
"public void marshall(JobLogs jobLogs, ProtocolMarshaller protocolMarshaller) {

        if (jobLogs == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(jobLogs.getJobCompletionReportURI(), JOBCOMPLETIONREPORTURI_BINDING);
            protocolMarshaller.marshall(jobLogs.getJobSuccessLogURI(), JOBSUCCESSLOGURI_BINDING);
            protocolMarshaller.marshall(jobLogs.getJobFailureLogURI(), JOBFAILURELOGURI_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given JobLogs object to the JSON object.
"public JSONArray optJSONArray(int index) {
		Object object = opt(index);
		return object instanceof JSONArray ? (JSONArray) object : null;
	}",Get the optional JSONArray associated with an index.
"public SourceUnit addSource(File file) {
        return addSource(new SourceUnit(file, configuration, classLoader, getErrorCollector()));
    }",Add a source to the source unit.
"protected String findString(String expr, String field, String errorMsg) {
    if (expr == null) {
      throw fieldError(field, errorMsg, null);
    } else {
      return findString(expr);
    }
  }",Find a string in the sequence.
"protected void validate(String operationType) throws Exception
	{
		super.validate(operationType);

		MPSInternetHost dest_server_validator = new MPSInternetHost();
		dest_server_validator.setConstraintIsReq(MPSConstants.DELETE_CONSTRAINT, true);
		dest_server_validator.setConstraintIsReq(MPSConstants.ADD_CONSTRAINT, true);
		dest_server_validator.setConstraintIsReq(MPSConstants.MODIFY_CONSTRAINT, true);
		dest_server_validator.validate(operationType, dest_server, ""\""dest_server\"""");
		
		MPSInt dest_port_validator = new MPSInt();
		dest_port_validator.setConstraintMaxValue(MPSConstants.GENERIC_CONSTRAINT, 65535);
		dest_port_validator.validate(operationType, dest_port, ""\""dest_port\"""");
		
		MPSString community_validator = new MPSString();
		community_validator.setConstraintCharSetRegEx(MPSConstants.GENERIC_CONSTRAINT,""[ a-zA-Z0-9_#.:@=-]+"");
		community_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);
		community_validator.validate(operationType, community, ""\""community\"""");
		
	}","Validates the
 operation."
"public static <T> boolean all(Iterable<T> iterable, Predicate<? super T> predicate) {
    return Iterators.all(iterable.iterator(), predicate);
  }",Returns true if all elements of the iterable satisfy the predicate.
"public float getPixel(int x, int y) {
		float pixel = -1;
		if (rasters == null) {
			readPixels();
		}
		if (rasters != null) {
			pixel = rasters.getFirstPixelSample(x, y).floatValue();
		} else {
			throw new GeoPackageException(""Could not retrieve pixel value"");
		}
		return pixel;
	}",Get the pixel value of the pixel at the x y
"static AttrAccept createFromString(final String str)
    throws BOSHException {
        if (str == null) {
            return null;
        } else {
            return new AttrAccept(str);
        }
    }",Create an AttrAccept object from a string.
"@Override
	public String getName(String languageId, boolean useDefault) {
		return _commerceCurrency.getName(languageId, useDefault);
	}",Returns the localized name of this commerce currency in the language optionally using the default language if no localization exists for the requested language.
"public static ColumnText duplicate(ColumnText org) {
        ColumnText ct = new ColumnText(null);
        ct.setACopy(org);
        return ct;
    }",Duplicate a ColumnText object.
"public boolean isDone() {
    if (status() == Status.DONE) {
      return true;
    }
    ChangeRequest updated = reload(Dns.ChangeRequestOption.fields(Dns.ChangeRequestField.STATUS));
    return updated == null || updated.status() == Status.DONE;
  }",Checks if the change request is done.
"public GeometryIndexType getType(GeometryIndex index) {
		if (index.hasChild()) {
			return getType(index.getChild());
		}
		return index.getType();
	}",Get the type of the GeometryIndex
"@Override
  public final String escape(String s) {
    checkNotNull(s); // GWT specific check (do not optimize).
    for (int i = 0; i < s.length(); i++) {
      char c = s.charAt(i);
      if ((c < replacementsLength && replacements[c] != null) || c > safeMax || c < safeMin) {
        return escapeSlow(s, i);
      }
    }
    return s;
  }",Override the escape method to allow for non - null strings.
"public static OpenImmoDocument createDocument(InputStream input) throws SAXException, IOException, ParserConfigurationException {
        return createDocument(XmlUtils.newDocument(input, true));
    }",Create an OpenImmoDocument from an input stream.
"public void write(Collection<?> objects, boolean allOrNothing, OutputStream out) {
		try {
			JsonGenerator jg = objectMapper.getFactory().createGenerator(out, JsonEncoding.UTF8);
			jg.writeStartObject();
			if (allOrNothing) {
				jg.writeBooleanField(""all_or_nothing"", true);
			}
			jg.writeArrayFieldStart(""docs"");
			for (Object o : objects) {
				jg.writeObject(o);
			}
			jg.writeEndArray();
			jg.writeEndObject();
			jg.flush();
			jg.close();
		} catch (Exception e) {
			throw Exceptions.propagate(e);
		} finally {
			IOUtils.closeQuietly(out);
		}
	}",Write a collection of objects to an output stream.
"public static int getSurplusQueuedTaskCount() {
        /*
         * The aim of this method is to return a cheap heuristic guide
         * for task partitioning when programmers, frameworks, tools,
         * or languages have little or no idea about task granularity.
         * In essence by offering this method, we ask users only about
         * tradeoffs in overhead vs expected throughput and its
         * variance, rather than how finely to partition tasks.
         *
         * In a steady state strict (tree-structured) computation,
         * each thread makes available for stealing enough tasks for
         * other threads to remain active. Inductively, if all threads
         * play by the same rules, each thread should make available
         * only a constant number of tasks.
         *
         * The minimum useful constant is just 1. But using a value of
         * 1 would require immediate replenishment upon each steal to
         * maintain enough tasks, which is infeasible.  Further,
         * partitionings/granularities of offered tasks should
         * minimize steal rates, which in general means that threads
         * nearer the top of computation tree should generate more
         * than those nearer the bottom. In perfect steady state, each
         * thread is at approximately the same level of computation
         * tree. However, producing extra tasks amortizes the
         * uncertainty of progress and diffusion assumptions.
         *
         * So, users will want to use values larger, but not much
         * larger than 1 to both smooth over transient shortages and
         * hedge against uneven progress; as traded off against the
         * cost of extra task overhead. We leave the user to pick a
         * threshold value to compare with the results of this call to
         * guide decisions, but recommend values such as 3.
         *
         * When all threads are active, it is on average OK to
         * estimate surplus strictly locally. In steady-state, if one
         * thread is maintaining say 2 surplus tasks, then so are
         * others. So we can just use estimated queue length.
         * However, this strategy alone leads to serious mis-estimates
         * in some non-steady-state conditions (ramp-up, ramp-down,
         * other stalls). We can detect many of these by further
         * considering the number of ""idle"" threads, that are known to
         * have zero queued tasks, so compensate by a factor of
         * (#idle/#active) threads.
         */
        ForkJoinWorkerThread wt =
            (ForkJoinWorkerThread)Thread.currentThread();
        return wt.workQueue.queueSize() - wt.pool.idlePerActive();
    }",Get the total number of queued tasks that are currently queued.
"public java.util.List<Service> getServices() {
        if (services == null) {
            services = new com.amazonaws.internal.SdkInternalList<Service>();
        }
        return services;
    }",Gets the value of the services property.
"public String getText(String key) throws MissingResourceException {
        initBundles();

        if (docletBundle.containsKey(key))
            return docletBundle.getString(key);

        return commonBundle.getString(key);
    }",Gets the text from the resource bundle.
"public final void dump(final LDAPInterface connection,
                           final String base,
                           final String filter,
                           final OutputStream outputStream,
                           final FormatLogger logger) {
        final FormatWriter ldapWriter = createWriter(outputStream, logger);
        if (ldapWriter == null) {
            logger.logError(""Error creating writer for output stream"");
        } else {
            try {
                try {
                    final SearchRequest request = new SearchRequest(base, SearchScope.SUB, Filter.create(filter));
                    final SearchResult result = connection.search(request);
                    if (result.getResultCode() == ResultCode.SUCCESS) {
                        final List<SearchResultEntry> entries = result.getSearchEntries();
                        if (entries != null) {
                            for (final SearchResultEntry entry : entries) {
                                ldapWriter.printEntry(entry);
                            }
                        } else {
                            logger.logInfo(""Search did not return any directory entries"");
                        }
                    } else {
                        logger.logError(""Search operation failed"");
                    }
                } catch (final LDAPException e) {
                    logger.logError(""Error searching the LDAP directory"", e);
                } finally {
                    ldapWriter.close();
                }
            } catch (final IOException e) {
                logger.logError(""Error writing directory entry to the output stream"", e);
            }
        }
    }",Dump a directory.
"public boolean clashesWith(MapElementContainer other) {
        // if either of the elements is always drawn, the elements do not clash
        if (Display.ALWAYS == this.display || Display.ALWAYS == other.display) {
            return false;
        }
        return this.getBoundaryAbsolute().intersects(other.getBoundaryAbsolute());
    }",Checks if the two map elements intersect.
"private void evaluateConstraints(DoubleSolution solution)  {
    double[] constraint = new double[this.getNumberOfConstraints()];

    double x1,x2,x3,x4,x5,x6;
    x1 = solution.getVariableValue(0);
    x2 = solution.getVariableValue(1);
    x3 = solution.getVariableValue(2);
    x4 = solution.getVariableValue(3);
    x5 = solution.getVariableValue(4);
    x6 = solution.getVariableValue(5);

    constraint[0] = (x1 + x2)/2.0 - 1.0;
    constraint[1] = (6.0 - x1 - x2)/6.0;
    constraint[2] = (2.0 - x2 + x1)/2.0;
    constraint[3] = (2.0 - x1 + 3.0*x2)/2.0;
    constraint[4] = (4.0 - (x3-3.0)*(x3-3.0) - x4)/4.0;
    constraint[5] = ((x5-3.0)*(x5-3.0) +x6 - 4.0)/4.0;

    double overallConstraintViolation = 0.0;
    int violatedConstraints = 0;
    for (int i = 0; i < getNumberOfConstraints(); i++) {
      if (constraint[i]<0.0){
        overallConstraintViolation+=constraint[i];
        violatedConstraints++;
      }
    }

    overallConstraintViolationDegree.setAttribute(solution, overallConstraintViolation);
    numberOfViolatedConstraints.setAttribute(solution, violatedConstraints);
  }",Evaluate the constraints of the MCS
"private static void choosePreviewSize(Camera.Parameters parms, int width, int height) {
        // We should make sure that the requested MPEG size is less than the preferred
        // size, and has the same aspect ratio.
        Camera.Size ppsfv = parms.getPreferredPreviewSizeForVideo();
        if (ppsfv != null && VERBOSE) {
            Log.d(TAG, ""Camera preferred preview size for video is "" +
                    ppsfv.width + ""x"" + ppsfv.height);
        }

        for (Camera.Size size : parms.getSupportedPreviewSizes()) {
            if (size.width == width && size.height == height) {
                parms.setPreviewSize(width, height);
                return;
            }
        }

        Log.w(TAG, ""Unable to set preview size to "" + width + ""x"" + height);
        if (ppsfv != null) {
            parms.setPreviewSize(ppsfv.width, ppsfv.height);
        }
        // else use whatever the default size is
    }",Choose the preview size for the camera.
"private synchronized void addResolved( String path )
    {
        for ( int index = path.lastIndexOf( '/' ); index > 0; index = path.lastIndexOf( '/' ) )
        {
            String name = path.substring( index + 1 );
            path = path.substring( 0, index );
            Map<String, Artifact> artifactMapper = this.children.get( path );
            if ( artifactMapper == null )
            {
                artifactMapper = new HashMap<String, Artifact>();
                this.children.put( path, artifactMapper );
            }
            artifactMapper.put( name, null );
        }
        if ( !StringUtils.isEmpty( path ) )
        {
            Map<String, Artifact> artifactMapper = this.children.get( """" );
            if ( artifactMapper == null )
            {
                artifactMapper = new HashMap<String, Artifact>();
                this.children.put( """", artifactMapper );
            }
            artifactMapper.put( path, null );
        }
    }",Add a path to the list of resolved URIs.
"public ServletHolder newServletHolder(String name,
                                          String servletClass)
    {
        return newServletHolder(name,servletClass,null);
    }",Create a new servlet holder.
"private String getSourceName(final String property) {
        if (propertyNameMap.containsKey(property)) {
            return propertyNameMap.get(property);
        } else {
            return property;
        }
    }",Gets the source name.
"public Subject createSubject() {
        // If a authenticationContext was defined on the subsystem use that context, otherwise use capture the current
        // configuration.
        final Subject subject = this.createSubject(getAuthenticationContext());
        if (ROOT_LOGGER.isTraceEnabled()) {
            ROOT_LOGGER.subject(subject, Integer.toHexString(System.identityHashCode(subject)));
        }
        return subject;
    }",Create a subject using the authentication context.
"public ResultList<Artwork> getEpisodeImages(int tvID, int seasonNumber, int episodeNumber) throws MovieDbException {
        return tmdbEpisodes.getEpisodeImages(tvID, seasonNumber, episodeNumber);
    }",Get the images for a specific episode.
"protected UserApiKey createApiKeyInternal(final String name) {
    final StitchAuthDocRequest.Builder reqBuilder = new StitchAuthDocRequest.Builder();
    reqBuilder
            .withMethod(Method.POST)
            .withPath(this.getBaseRoute())
            .withDocument(new Document(ApiKeyFields.NAME, name))
            .withRefreshToken();
    return getRequestClient().doAuthenticatedRequest(
            reqBuilder.build(),
            new UserApiKeyDecoder()
    );
  }",Create a user api key.
"@Override
	@Nullable
	public String getMapping(Class<?> type, Method method) {

		Assert.notNull(type, ""Type must not be null!"");
		Assert.notNull(method, ""Method must not be null!"");

		String[] mapping = getMappingFrom(findMergedAnnotation(method, annotationType));
		String typeMapping = getMapping(type);

		if (mapping.length == 0) {
			return typeMapping;
		}

		return typeMapping == null || ""/"".equals(typeMapping) ? mapping[0] : join(typeMapping, mapping[0]);
	}",Get the mapping for the given type and method.
"private boolean isMinuteTerm(final int currentTermIdx, final List<Term<Calendar>> terms) {
        
        final int termSize = terms.size();
        
        // 直前の項のチェック
        if(currentTermIdx -1 > 0) {
            DateTerm beforeTerm = null;
            for(int i=currentTermIdx-1; i >= 0; i--) {
                final Term<Calendar> term = terms.get(i);
                if(term instanceof DateTerm) {
                    beforeTerm = (DateTerm) term;
                    break;
                }
                
            }
            
            if(beforeTerm != null) {
                if(beforeTerm instanceof DateTerm.HourTerm || beforeTerm instanceof DateTerm.ElapsedHourTerm) {
                    return true;
                }
            }
            
        }
        
        // 直後の項のチェック
        if(currentTermIdx +1 < termSize) {
            DateTerm afterTerm = null;
            for(int i=currentTermIdx+1; i < termSize; i++) {
                final Term<Calendar> term = terms.get(i);
                if(term instanceof DateTerm) {
                    afterTerm = (DateTerm) term;
                    break;
                }
            }
            
            if(afterTerm != null) {
                if(afterTerm instanceof DateTerm.SecondTerm || afterTerm instanceof DateTerm.ElapsedSecondTerm) {
                    return true;
                }
            }
        }
        
        return false;
    }",Checks if the current term is a minute term.
"public ListMultimap<Class<?>, Object> getParamsForType() {
		ArrayListMultimap<Class<?>, Object> retVal = ArrayListMultimap.create();
		myParams.entries().forEach(entry -> retVal.put(entry.getKey(), unwrapValue(entry.getValue())));
		return Multimaps.unmodifiableListMultimap(retVal);
	}",Returns a multimap of parameters for the given type.
"private int calculateTileLevel() {
		double baseX = layerBounds.getWidth();
		double baseY = layerBounds.getHeight();
		// choose the tile level so the area is between minimumTileSize and the next level (minimumTileSize * 4)
		double baseArea = baseX * baseY;
		double scale = layer.getMapModel().getMapView().getCurrentScale();
		double osmArea = preferredTileSize / (scale * scale);
		int tileLevel = (int) Math.round(Math.log(baseArea / osmArea) / Math.log(4.0));
		if (tileLevel < 0) {
			tileLevel = 0;
		}
		return tileLevel;
	}",Calculate the tile level
"public static void addSpoiler(Message message, String hint) {
        message.addExtension(new SpoilerElement(null, hint));
    }",Add a Spoiler extension to the message.
"public static INDArray amin(INDArray x, INDArray y, INDArray z, int... dimensions) {
        if(dimensions == null || dimensions.length == 0) {
            validateShapesNoDimCase(x,y,z);
            return Nd4j.getExecutioner().exec(new AMin(x,y,z));
        }

        return Nd4j.getExecutioner().exec(new BroadcastAMin(x,y,z,dimensions));
    }",Compute the AMIN of the specified dimensions
"public void marshall(DescribeStreamRequest describeStreamRequest, ProtocolMarshaller protocolMarshaller) {

        if (describeStreamRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(describeStreamRequest.getStreamId(), STREAMID_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given request to the JSON - compatible parameter object.
"public static void prune(List<Point3D_F64> cloud , int minNeighbors , double radius ) {
		if( minNeighbors < 0 )
			throw new IllegalArgumentException(""minNeighbors must be >= 0"");
		NearestNeighbor<Point3D_F64> nn = FactoryNearestNeighbor.kdtree(new KdTreePoint3D_F64() );
		NearestNeighbor.Search<Point3D_F64> search = nn.createSearch();

		nn.setPoints(cloud,false);
		FastQueue<NnData<Point3D_F64>> results = new FastQueue(NnData.class,true);

		// It will always find itself
		minNeighbors += 1;

		// distance is Euclidean squared
		radius *= radius;

		for( int i = cloud.size()-1; i >= 0; i-- ) {
			search.findNearest(cloud.get(i),radius,minNeighbors,results);

			if( results.size < minNeighbors ) {
				cloud.remove(i);
			}
		}
	}",Prunes the given list of points from the cloud.
"public static Caffeine<Object, Object> from(Config config) {
    CaffeineParser parser = new CaffeineParser(config);
    config.entrySet().stream().map(Map.Entry::getKey).forEach(parser::parse);
    return parser.cacheBuilder;
  }",Creates a Caffeine object from the given config.
"public EngineResult engineResult(HttpRequestBase request) {
        EngineResult engineResult = new EngineResult();
        try {
            HttpResponse response = httpClient.execute(request);
            if (response != null) {
                engineResult.responseCode = response.getStatusLine().getStatusCode();
                HttpEntity responseEntity = response.getEntity();
                long contentLength = responseEntity.getContentLength();
                if (contentLength < 0) {
                    contentLength = 0;
                }
                ByteArrayOutputStream bOut = new ByteArrayOutputStream((int) contentLength);
                InputStream in = responseEntity.getContent();
                int read;
                byte[] tmpBuf = new byte[8192];
                while ((read = in.read(tmpBuf)) != -1) {
                    bOut.write(tmpBuf, 0, read);
                }
                in.close();
                bOut.close();
                engineResult.response = bOut.toByteArray();
                switch (engineResult.responseCode) {
                case 200:
                    engineResult.parse(xmlValidator);
                    in = new ByteArrayInputStream(engineResult.response);
                    engineResult.engine = Engine.unmarshall(in);
                    in.close();
                    engineResult.status = ResultStatus.OK;
                    break;
                case 404:
                    engineResult.status = ResultStatus.NOT_FOUND;
                    break;
                case 500:
                    engineResult.status = ResultStatus.INTERNAL_ERROR;
                    break;
                default:
                    engineResult.status = ResultStatus.NO_RESPONSE;
                    break;
                }
            } else {
                engineResult.status = ResultStatus.NO_RESPONSE;
            }
        } catch (NoHttpResponseException e) {
            engineResult.status = ResultStatus.OFFLINE;
            engineResult.t = e;
        } catch (ClientProtocolException e) {
            engineResult.status = ResultStatus.RESPONSE_EXCEPTION;
            engineResult.t = e;
        } catch (IOException e) {
            engineResult.status = ResultStatus.RESPONSE_EXCEPTION;
            engineResult.t = e;
        } catch (JAXBException e) {
            engineResult.status = ResultStatus.JAXB_EXCEPTION;
            engineResult.t = e;
        } catch (XMLStreamException e) {
            engineResult.status = ResultStatus.XML_EXCEPTION;
            engineResult.t = e;
        }
        return engineResult;
    }",Method engineResult.
"public void stop(String logicalQueueName) {
		stopQueue(logicalQueueName);

		try {
			if (isRunning(logicalQueueName)) {
				Future<?> future = this.scheduledFutureByQueue.remove(logicalQueueName);
				if (future != null) {
					future.get(this.queueStopTimeout, TimeUnit.MILLISECONDS);
				}
			}
		}
		catch (InterruptedException e) {
			Thread.currentThread().interrupt();
		}
		catch (ExecutionException | TimeoutException e) {
			getLogger().warn(""Error stopping queue with name: '"" + logicalQueueName + ""'"",
					e);
		}
	}",Stops the specified queue.
"@Override
    public void onMessageReceived(MessageReceivedEvent event)
    {
        //These are provided with every event in JDA
        JDA jda = event.getJDA();                       //JDA, the core of the api.
        long responseNumber = event.getResponseNumber();//The amount of discord events that JDA has received since the last reconnect.

        //Event specific information
        User author = event.getAuthor();                //The user that sent the message
        Message message = event.getMessage();           //The message that was received.
        MessageChannel channel = event.getChannel();    //This is the MessageChannel that the message was sent to.
                                                        //  This could be a TextChannel, PrivateChannel, or Group!

        String msg = message.getContentDisplay();              //This returns a human readable version of the Message. Similar to
                                                        // what you would see in the client.

        boolean bot = author.isBot();                    //This boolean is useful to determine if the User that
                                                        // sent the Message is a BOT or not!

        if (event.isFromType(ChannelType.TEXT))         //If this message was sent to a Guild TextChannel
        {
            //Because we now know that this message was sent in a Guild, we can do guild specific things
            // Note, if you don't check the ChannelType before using these methods, they might return null due
            // the message possibly not being from a Guild!

            Guild guild = event.getGuild();             //The Guild that this message was sent in. (note, in the API, Guilds are Servers)
            TextChannel textChannel = event.getTextChannel(); //The TextChannel that this message was sent to.
            Member member = event.getMember();          //This Member that sent the message. Contains Guild specific information about the User!

            String name;
            if (message.isWebhookMessage())
            {
                name = author.getName();                //If this is a Webhook message, then there is no Member associated
            }                                           // with the User, thus we default to the author for name.
            else
            {
                name = member.getEffectiveName();       //This will either use the Member's nickname if they have one,
            }                                           // otherwise it will default to their username. (User#getName())

            System.out.printf(""(%s)[%s]<%s>: %s\n"", guild.getName(), textChannel.getName(), name, msg);
        }
        else if (event.isFromType(ChannelType.PRIVATE)) //If this message was sent to a PrivateChannel
        {
            //The message was sent in a PrivateChannel.
            //In this example we don't directly use the privateChannel, however, be sure, there are uses for it!
            PrivateChannel privateChannel = event.getPrivateChannel();

            System.out.printf(""[PRIV]<%s>: %s\n"", author.getName(), msg);
        }
        else if (event.isFromType(ChannelType.GROUP))   //If this message was sent to a Group. This is CLIENT only!
        {
            //The message was sent in a Group. It should be noted that Groups are CLIENT only.
            Group group = event.getGroup();
            String groupName = group.getName() != null ? group.getName() : """";  //A group name can be null due to it being unnamed.

            System.out.printf(""[GRP: %s]<%s>: %s\n"", groupName, author.getName(), msg);
        }


        //Now that you have a grasp on the things that you might see in an event, specifically MessageReceivedEvent,
        // we will look at sending / responding to messages!
        //This will be an extremely simplified example of command processing.

        //Remember, in all of these .equals checks it is actually comparing
        // message.getContentDisplay().equals, which is comparing a string to a string.
        // If you did message.equals() it will fail because you would be comparing a Message to a String!
        if (msg.equals(""!ping""))
        {
            //This will send a message, ""pong!"", by constructing a RestAction and ""queueing"" the action with the Requester.
            // By calling queue(), we send the Request to the Requester which will send it to discord. Using queue() or any
            // of its different forms will handle ratelimiting for you automatically!

            channel.sendMessage(""pong!"").queue();
        }
        else if (msg.equals(""!roll""))
        {
            //In this case, we have an example showing how to use the Success consumer for a RestAction. The Success consumer
            // will provide you with the object that results after you execute your RestAction. As a note, not all RestActions
            // have object returns and will instead have Void returns. You can still use the success consumer to determine when
            // the action has been completed!

            Random rand = new Random();
            int roll = rand.nextInt(6) + 1; //This results in 1 - 6 (instead of 0 - 5)
            channel.sendMessage(""Your roll: "" + roll).queue(sentMessage ->  //This is called a lambda statement. If you don't know
            {                                                               // what they are or how they work, try google!
                if (roll < 3)
                {
                    channel.sendMessage(""The roll for messageId: "" + sentMessage.getId() + "" wasn't very good... Must be bad luck!\n"").queue();
                }
            });
        }
        else if (msg.startsWith(""!kick""))   //Note, I used ""startsWith, not equals.
        {
            //This is an admin command. That means that it requires specific permissions to use it, in this case
            // it needs Permission.KICK_MEMBERS. We will have a check before we attempt to kick members to see
            // if the logged in account actually has the permission, but considering something could change after our
            // check we should also take into account the possibility that we don't have permission anymore, thus Discord
            // response with a permission failure!
            //We will use the error consumer, the second parameter in queue!

            //We only want to deal with message sent in a Guild.
            if (message.isFromType(ChannelType.TEXT))
            {
                //If no users are provided, we can't kick anyone!
                if (message.getMentionedUsers().isEmpty())
                {
                    channel.sendMessage(""You must mention 1 or more Users to be kicked!"").queue();
                }
                else
                {
                    Guild guild = event.getGuild();
                    Member selfMember = guild.getSelfMember();  //This is the currently logged in account's Member object.
                                                                // Very similar to JDA#getSelfUser()!

                    //Now, we the the logged in account doesn't have permission to kick members.. well.. we can't kick!
                    if (!selfMember.hasPermission(Permission.KICK_MEMBERS))
                    {
                        channel.sendMessage(""Sorry! I don't have permission to kick members in this Guild!"").queue();
                        return; //We jump out of the method instead of using cascading if/else
                    }

                    //Loop over all mentioned users, kicking them one at a time. Mwauahahah!
                    List<User> mentionedUsers = message.getMentionedUsers();
                    for (User user : mentionedUsers)
                    {
                        Member member = guild.getMember(user);  //We get the member object for each mentioned user to kick them!

                        //We need to make sure that we can interact with them. Interacting with a Member means you are higher
                        // in the Role hierarchy than they are. Remember, NO ONE is above the Guild's Owner. (Guild#getOwner())
                        if (!selfMember.canInteract(member))
                        {
                            // use the MessageAction to construct the content in StringBuilder syntax using append calls
                            channel.sendMessage(""Cannot kick member: "")
                                   .append(member.getEffectiveName())
                                   .append("", they are higher in the hierarchy than I am!"")
                                   .queue();
                            continue;   //Continue to the next mentioned user to be kicked.
                        }

                        //Remember, due to the fact that we're using queue we will never have to deal with RateLimits.
                        // JDA will do it all for you so long as you are using queue!
                        guild.getController().kick(member).queue(
                            success -> channel.sendMessage(""Kicked "").append(member.getEffectiveName()).append(""! Cya!"").queue(),
                            error ->
                            {
                                //The failure consumer provides a throwable. In this case we want to check for a PermissionException.
                                if (error instanceof PermissionException)
                                {
                                    PermissionException pe = (PermissionException) error;
                                    Permission missingPermission = pe.getPermission();  //If you want to know exactly what permission is missing, this is how.
                                                                                        //Note: some PermissionExceptions have no permission provided, only an error message!

                                    channel.sendMessage(""PermissionError kicking ["")
                                           .append(member.getEffectiveName()).append(""]: "")
                                           .append(error.getMessage()).queue();
                                }
                                else
                                {
                                    channel.sendMessage(""Unknown error while kicking ["")
                                           .append(member.getEffectiveName())
                                           .append(""]: <"").append(error.getClass().getSimpleName()).append("">: "")
                                           .append(error.getMessage()).queue();
                                }
                            });
                    }
                }
            }
            else
            {
                channel.sendMessage(""This is a Guild-Only command!"").queue();
            }
        }
        else if (msg.equals(""!block""))
        {
            //This is an example of how to use the complete() method on RestAction. The complete method acts similarly to how
            // JDABuilder's awaitReady() works, it waits until the request has been sent before continuing execution.
            //Most developers probably wont need this and can just use queue. If you use complete, JDA will still handle ratelimit
            // control, however if shouldQueue is false it won't queue the Request to be sent after the ratelimit retry after time is past. It
            // will instead fire a RateLimitException!
            //One of the major advantages of complete() is that it returns the object that queue's success consumer would have,
            // but it does it in the same execution context as when the request was made. This may be important for most developers,
            // but, honestly, queue is most likely what developers will want to use as it is faster.

            try
            {
                //Note the fact that complete returns the Message object!
                //The complete() overload queues the Message for execution and will return when the message was sent
                //It does handle rate limits automatically
                Message sentMessage = channel.sendMessage(""I blocked and will return the message!"").complete();
                //This should only be used if you are expecting to handle rate limits yourself
                //The completion will not succeed if a rate limit is breached and throw a RateLimitException
                Message sentRatelimitMessage = channel.sendMessage(""I expect rate limitation and know how to handle it!"").complete(false);

                System.out.println(""Sent a message using blocking! Luckly I didn't get Ratelimited... MessageId: "" + sentMessage.getId());
            }
            catch (RateLimitedException e)
            {
                System.out.println(""Whoops! Got ratelimited when attempting to use a .complete() on a RestAction! RetryAfter: "" + e.getRetryAfter());
            }
            //Note that RateLimitException is the only checked-exception thrown by .complete()
            catch (RuntimeException e)
            {
                System.out.println(""Unfortunately something went wrong when we tried to send the Message and .complete() threw an Exception."");
                e.printStackTrace();
            }
        }
    }",This method is called by the event handler to process a message received event.
"public boolean isScaleAndShift(double tol) {
		return xy * xy + yx * yx < (xx * xx + yy * yy) * tol;
	}",Returns true if the matrix is scale and shift.
"public static void xmlGlobalInexistent(Class<?> aClass) {
		throw new XmlMappingGlobalDoesNotExistException(MSG.INSTANCE.message(xmlMappingGlobalDoesNotExistException, aClass.getSimpleName()));
	}",Thrown when a global class is missing.
"public void marshall(CancelSchemaExtensionRequest cancelSchemaExtensionRequest, ProtocolMarshaller protocolMarshaller) {

        if (cancelSchemaExtensionRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(cancelSchemaExtensionRequest.getDirectoryId(), DIRECTORYID_BINDING);
            protocolMarshaller.marshall(cancelSchemaExtensionRequest.getSchemaExtensionId(), SCHEMAEXTENSIONID_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",Handles the given CancelSchemaExtensionRequest.
"private List<AdvancedModelWrapper> convertOpenEngSBModelList(List<OpenEngSBModel> models) {
        List<AdvancedModelWrapper> wrappers = new ArrayList<AdvancedModelWrapper>();
        for (OpenEngSBModel model : models) {
            wrappers.add(AdvancedModelWrapper.wrap(model));
        }
        return wrappers;
    }",Converts a list of OpenEngSBModel objects to a list of AdvancedModelWrappers.
"public void acceptCertificate() {
        String action = ""Clicking override link to accept ssl certificate"";
        String result = ""Override link clicked"";
        //for IE and Edge
        if (browser.getName() == BrowserName.INTERNETEXPLORER || browser.getName() == BrowserName.EDGE) {
            Element overrideLink = newElement(Locator.ID, ""overridelink"");
            if (overrideLink.is().present()) {
                try {
                    if (browser.getName() == BrowserName.EDGE) {
                        newElement(Locator.ID, ""moreInformationDropdownSpan"").getWebElement().click();
                    }
                    overrideLink.getWebElement().click();
                    reporter.pass(action, result, result);
                } catch (Exception e) {
                    reporter.fail(action, result, ""Unable to click override link. ""
                            + e.getMessage());
                    log.warn(e);
                }
            }
        }
    }",Clicking override link to accept SSL certificate.
"@Nonnull
  public static Error fail(@Nullable final String message) {
    final AssertionError error = new AssertionError(GetUtils.ensureNonNull(message, ""failed""));
    MetaErrorListeners.fireError(""Asserion error"", error);
    if (true) {
      throw error;
    }
    return error;
  }",Throw an AssertionError if the error is not an error.
"static public TypedDataset open( FeatureType datatype, String location, ucar.nc2.util.CancelTask task, StringBuilder errlog) throws IOException {
    DatasetUrl durl = DatasetUrl.findDatasetUrl(location);
    NetcdfDataset ncd = NetcdfDataset.acquireDataset(durl, true, task);
    return open( datatype, ncd, task, errlog);
  }",Open a typed dataset from a location.
"public ServiceFuture<Void> updatePropertiesAsync(String poolId, PoolUpdatePropertiesParameter poolUpdatePropertiesParameter, final ServiceCallback<Void> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(updatePropertiesWithServiceResponseAsync(poolId, poolUpdatePropertiesParameter), serviceCallback);
    }",Updates the properties of an App Service Environment.
"protected String parseUserId(String securityName) {
        int idx = securityName.indexOf(TOKEN_DELIMETER); // Don't use String.split() - way too expensive.
        if (idx > 0) {
            return securityName.substring(0, idx);
        } else {
            return securityName;
        }
    }",Parse the user id from the security name.
"public List<Message> requestArtistMenuFrom(final SlotReference slotReference, final int sortOrder)
            throws Exception {

        ConnectionManager.ClientTask<List<Message>> task = new ConnectionManager.ClientTask<List<Message>>() {
            @Override
            public List<Message> useClient(Client client) throws Exception {
                if (client.tryLockingForMenuOperations(MetadataFinder.MENU_TIMEOUT, TimeUnit.SECONDS)) {
                    try {
                        logger.debug(""Requesting Artist menu."");
                        Message response = client.menuRequest(Message.KnownType.ARTIST_MENU_REQ, Message.MenuIdentifier.MAIN_MENU, slotReference.slot,
                                new NumberField(sortOrder));
                        return client.renderMenuItems(Message.MenuIdentifier.MAIN_MENU, slotReference.slot, CdjStatus.TrackType.REKORDBOX, response);
                    } finally {
                        client.unlockForMenuOperations();
                    }
                } else {
                    throw new TimeoutException(""Unable to lock player for menu operations."");
                }
            }
        };

        return ConnectionManager.getInstance().invokeWithClientSession(slotReference.player, task, ""requesting artist menu"");
    }",Request artist menu from a player.
"void applyGaussian(GrayF32 input, GrayF32 output, Kernel1D kernel) {
		tempBlur.reshape(input.width, input.height);
		GConvolveImageOps.horizontalNormalized(kernel, input, tempBlur);
		GConvolveImageOps.verticalNormalized(kernel, tempBlur,output);
	}",Applies the Gaussian kernel to the input image and writes the result to output image.
"public Coordinate getIntersection(LineSegment lineSegment) { // may not be on either one of the line segments.
		// http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/
		double x1 = this.x1();
		double y1 = this.y1();
		double x2 = this.x2();
		double y2 = this.y2();
		double x3 = lineSegment.x1();
		double y3 = lineSegment.y1();
		double x4 = lineSegment.x2();
		double y4 = lineSegment.y2();

		double denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
		double u1 = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;

		double x = x1 + u1 * (x2 - x1);
		double y = y1 + u1 * (y2 - y1);
		return new Coordinate(x, y);
	}",Get the intersection of this line segment and the given line segment.
"protected Criteria createDistinctRootEntityCriteria(Criterion... criterion) {
        Criteria criteria = getSession().createCriteria(entityClass);
        addCriterionsToCriteria(criteria, criterion);
        criteria.setResultTransformer(Criteria.DISTINCT_ROOT_ENTITY);
        criteria.setCacheable(this.useQueryCache);
        return criteria;
    }",Create a distinct root entity criteria.
"public void delete(String resourceGroupName, String virtualWANName) {
        deleteWithServiceResponseAsync(resourceGroupName, virtualWANName).toBlocking().last().body();
    }",Deletes a CDN image. Deletes an CDN image.
"protected CatalogBuilder makeCatalogFiles(URI catURI, State localState, List<String> filenames, boolean addLatest) throws IOException {
    Catalog parentCatalog = parent.getParentCatalog();

    CatalogBuilder result = new CatalogBuilder();
    result.setName(makeFullName(parent));
    result.setVersion(parentCatalog.getVersion());
    result.setBaseURI(catURI);
    result.addService(orgService);

    DatasetBuilder top = new DatasetBuilder(null);
    top.transferInheritedMetadata(parent); // make all inherited metadata local
    top.setName(FILES);

    // add Variables, GeospatialCoverage, TimeCoverage
    ThreddsMetadata tmi = top.getInheritableMetadata();
    tmi.set(Dataset.TimeCoverage, null);      // LOOK
    if (localState.coverage != null) {
      tmi.set(Dataset.GeospatialCoverage, localState.coverage);
    }
    tmi.set(Dataset.ServiceName, orgService.getName());
    result.addDataset(top);

    if (addLatest) {
      DatasetBuilder latest = new DatasetBuilder(top);
      latest.setName(getLatestFileName());
      latest.put(Dataset.UrlPath, LATEST_DATASET_CATALOG);
      latest.put(Dataset.Id, LATEST_DATASET_CATALOG);
      latest.put(Dataset.ServiceName, latestService.getName());
      latest.addServiceToCatalog(latestService);
      top.addDataset(latest);
    }

    // sort copy of files
    List<String> sortedFilenames = new ArrayList<>(filenames);
    Collections.sort(sortedFilenames, String.CASE_INSENSITIVE_ORDER);

    // if not increasing (i.e. we WANT newest file listed first), reverse sort
    if (!this.config.getSortFilesAscending()) {
      Collections.reverse(sortedFilenames);
    }

    for (String f : sortedFilenames) {
      if (!f.startsWith(topDirectory))
        logger.warn(""File {} doesnt start with topDir {}"", f, topDirectory);

      DatasetBuilder ds = new DatasetBuilder(top);

      String fname = f.substring(topDirectory.length() + 1);
      ds.setName(fname);

      String lpath = this.configPath + ""/"" + FILES + ""/"" + fname;
      // String lpath = getPath() + ""/"" + FILES + ""/"" + fname;
      ds.put(Dataset.UrlPath, lpath);
      ds.put(Dataset.Id, lpath);
      ds.put(Dataset.VariableMapLinkURI, new ThreddsMetadata.UriResolved(makeMetadataLink(lpath, VARIABLES), catURI));

      File file = new File(f);
      ds.put(Dataset.DataSize, file.length());
      top.addDataset(ds);
    }

    return result;
  }",Create a catalog from a list of filenames.
"public void stopThreads() {
		// 停止连接测试线程
		TaskEngine.getInstance().cancelScheduledTask(thriftConnectionTesterThread);

		// 停止连接最大时间检测线程
		TaskEngine.getInstance().cancelScheduledTask(thriftConnectionMaxAgeThread);

		// 停止分区检测线程
		poolWatchThread.stop();
		this.poolWatchThreadSignalQueue.offer(new Object());
	}",Stop all threads.
"public boolean ok() {
        Object okValue = get(""ok"");
        if (okValue instanceof Boolean) {
            return (Boolean) okValue;
        } else if (okValue instanceof Number) {
            return ((Number) okValue).intValue() == 1;
        } else {
            return false;
        }
    }",Gets the value ok.
"public ConversionHandler to(MappedField destinationMappedField){
		this.destinationField = destinationMappedField.getValue(); 
		placeholders.put(destinationTypePattern, destinationField.getType().getName());
		placeholders.put(destinationNamePattern, destinationField.getName());
		placeholders.put(destinationGetPattern, destinationMappedField.getMethod());
		placeholders.put(destinationSetPattern, destinationMappedField.setMethod());
		return this;
	}",Add destination field to this handler.
"@SuppressWarnings(""unchecked"")
  public static void addAnnotation(Field field, Annotation annotation) {
    field.getAnnotation(Annotation.class);// prevent declaredAnnotations haven't initialized
    Map<Class<? extends Annotation>, Annotation> annos;
    try {
      annos = (Map<Class<? extends Annotation>, Annotation>) Field_Field_DeclaredAnnotations.get(field);
    } catch (IllegalAccessException e) {
      throw new IllegalStateException(e);
    }
    if (annos.getClass() == Collections.EMPTY_MAP.getClass()) {
      annos = new HashMap<>();
      try {
        Field_Field_DeclaredAnnotations.set(field, annos);
      } catch (IllegalAccessException e) {
        throw new IllegalStateException(e);
      }
    }
    annos.put(annotation.annotationType(), annotation);
  }",Adds an annotation to a field.
"public HeaderDefinition getHeaderDefinition() {
    JSONArray jsonArray = null;
    try {
      jsonArray = _jsonObject.getJSONArray(COLUMN_NAMES_FIELD);
      List<String> columnNames = new ArrayList<String>(jsonArray.length());
      for (int i = 0; i < jsonArray.length(); i++) {
        columnNames.add(jsonArray.getString(i));
      }
      return HeaderDefinition.of(columnNames);
    } catch (JSONException ex) {
      s_logger.error(""Metadata had unexpected structure - could not extract column_names field. Was:\n{}"", _jsonObject.toString());
      throw new QuandlRuntimeException(""Metadata had unexpected structure"", ex);
    }
  }",Gets the header definition.
"private List<ObjectType> buildParametersSection(MarkupDocBuilder markupDocBuilder, PathOperation operation) {

        List<ObjectType> inlineDefinitions = new ArrayList<>();

        parameterTableComponent.apply(markupDocBuilder, ParameterTableComponent.parameters(
                operation,
                inlineDefinitions,
                getSectionTitleLevel()
        ));

        return inlineDefinitions;
    }",Build the parameters section.
"@SuppressWarnings(""NonConstantStringShouldBeStringBuffer"")
	protected void acceptActionClass(final Class<?> actionClass) {

		if (actionClass == null) {
			return;
		}

		if (!checkClass(actionClass)) {
			return; 
		}

		if (actionClass.getAnnotation(MadvocAction.class) == null) {
			return;
		}

		ClassDescriptor cd = ClassIntrospector.get().lookup(actionClass);

		MethodDescriptor[] allMethodDescriptors = cd.getAllMethodDescriptors();
		for (MethodDescriptor methodDescriptor : allMethodDescriptors) {
			if (!methodDescriptor.isPublic()) {
				continue;
			}
			// just public methods
			final Method method = methodDescriptor.getMethod();

			final boolean hasAnnotation = actionConfigManager.hasActionAnnotationOn(method);

			if (!hasAnnotation) {
				continue;
			}

			webappConfigurations.add(() -> actionsManager.registerAction(actionClass, method, null));
		}
	}",Adds the action class to the list of actions.
"public static ChunksManifest createManifestFrom(InputStream xml) {
        try {
            ChunksManifestDocument doc = ChunksManifestDocument.Factory.parse(
                xml);
            return ManifestElementReader.createManifestFrom(doc);
        } catch (XmlException e) {
            throw new DuraCloudRuntimeException(e);
        } catch (IOException e) {
            throw new DuraCloudRuntimeException(e);
        }
    }",Create a ChunksManifest from the specified XML input stream.
"public void setSrcPath(String in) throws IOException {
    srcPath= new Path(in);
    if (!srcPath.isAbsolute() || !srcPath.toUri().isAbsolute()) {
      throw new IOException(""Path "" + in +  "" is not absolute."");
    }
  }",Sets the src path.
"public static ExternalSessionKey fromResponseBody(String responseBody) throws NewSessionException {
    if (responseBody != null && responseBody.startsWith(""OK,"")) {
      return new ExternalSessionKey(responseBody.replace(""OK,"", """"));
    }
    throw new NewSessionException(""The server returned an error : ""+responseBody);
  }",Create an ExternalSessionKey object from a response body.
"private JScrollPane getDefaultPane() {
		if (defaultPane == null) {
			defaultPane = new JScrollPane();
			defaultPane.setViewportView(getDefaultOutput());
			defaultPane.setName(""defaultPane"");
			defaultPane.setHorizontalScrollBarPolicy(javax.swing.JScrollPane.HORIZONTAL_SCROLLBAR_NEVER);
		}
		return defaultPane;
	}",This method initializes the defaultPane property.
"public Matrix3 setToTransform (IVector translation, double rotation, double scale) {
        return setToRotation(rotation).set(m00 * scale, m10 * scale, translation.x(),
                                           m01 * scale, m11 * scale, translation.y(),
                                           0f, 0f, 1f);
    }",Sets the translation matrix to be a translation matrix.
"@Override
   public Object[] toArray() {
      // Estimate size of array; be prepared to see more or fewer elements
      Object[] r = new Object[size()];
      try (CloseableIterator<O> it = iterator()) {
         for (int i = 0; i < r.length; i++) {
            if (! it.hasNext()) // fewer elements than expected
               return Arrays.copyOf(r, i);
            r[i] = it.next();
         }
         return it.hasNext() ? finishToArray(r, it) : r;
      }
   }",Method toArray.
"private String buildCreateDDLQuery(TableInfo tableInfo)
    {
        String statement;
        boolean flag = false;
        StringBuilder compoundKeys = null;
        StringBuilder builder = new StringBuilder();
        builder.append(""CREATE TABLE "");
        builder.append(tableInfo.getTableName());
        builder.append(Constants.OPEN_ROUND_BRACKET);

        if (!tableInfo.getTableIdType().isAnnotationPresent(Embeddable.class))
        {
            builder.append(tableInfo.getIdColumnName());
            builder.append(Constants.SPACE);
            String idType = tableInfo.getTableIdType().getSimpleName().toLowerCase();
            builder.append(OracleNoSQLValidationClassMapper.getValidIdType(idType));
            builder.append(Constants.COMMA);
        }

        for (ColumnInfo columnInfo : tableInfo.getColumnMetadatas())
        {
            builder.append(columnInfo.getColumnName());
            builder.append(Constants.SPACE);
            String coulmnType = columnInfo.getType().getSimpleName().toLowerCase();
            builder.append(OracleNoSQLValidationClassMapper.getValidType(coulmnType));
            builder.append(Constants.COMMA);
        }
        for (EmbeddedColumnInfo embeddedColumnInfo : tableInfo.getEmbeddedColumnMetadatas())
        {
            if (tableInfo.getIdColumnName().equals(embeddedColumnInfo.getEmbeddedColumnName()))
            {
                compoundKeys = new StringBuilder();
                flag = true;
            }
            for (ColumnInfo columnInfo : embeddedColumnInfo.getColumns())
            {
                builder.append(columnInfo.getColumnName());
                builder.append(Constants.SPACE);
                String coulmnType = columnInfo.getType().getSimpleName().toLowerCase();
                builder.append(OracleNoSQLValidationClassMapper.getValidType(coulmnType));
                builder.append(Constants.COMMA);
                if (flag)
                {
                    compoundKeys.append(columnInfo.getColumnName());
                    compoundKeys.append(Constants.COMMA);
                }
            }
            flag = false;
        }

        builder.append(""PRIMARY KEY"");
        builder.append(Constants.OPEN_ROUND_BRACKET);

        if (!tableInfo.getTableIdType().isAnnotationPresent(Embeddable.class))
        {
            builder.append(tableInfo.getIdColumnName());
        }
        else
        {
            compoundKeys.deleteCharAt(compoundKeys.length() - 1);
            builder.append(compoundKeys.toString());
        }

        builder.append(Constants.CLOSE_ROUND_BRACKET);
        builder.append(Constants.CLOSE_ROUND_BRACKET);

        statement = builder.toString();
        return statement;
    }",Build CREATE DDL query for a CUCENT RECORD.
"public LDAPQuery setAttributes(List<String> attributes) {
		if(attributes != null && attributes.size() > 0) {
			this.attributes = new String[attributes.size()];
			int i = 0;
			for(String attribute : attributes) {
				this.attributes[i++] = attribute;
			}
		} else {
			this.attributes = ALL_ATTRIBUTES;
		}
		return this;
	}",Sets the attributes of the query.
"public static PackageIndex<Integer> createPackageIndex(String resourceName) {
        PackageIndex<Integer> packageIndex = new PackageIndex<Integer>();

        BufferedReader br = null;
        try {
            br = getLibertyTraceListReader(resourceName);
            addFiltersAndValuesToIndex(br, packageIndex);
        } catch (IOException e) {
            System.err.println(""Unable to load "" + resourceName);
        } finally {
            tryToCloseReader(br);
        }

        packageIndex.compact();
        return packageIndex;
    }",Create a PackageIndex object from the specified resource name.
"public static TimeOfDay fromDateFields(Date date) {
        if (date == null) {
            throw new IllegalArgumentException(""The date must not be null"");
        }
        return new TimeOfDay(
            date.getHours(),
            date.getMinutes(),
            date.getSeconds(),
            (((int) (date.getTime() % 1000)) + 1000) % 1000
        );
    }",This method is a convenience method to create a TimeOfDay object from a Date object.
"@Override
	public boolean eIsSet(int featureID) {
		switch (featureID) {
			case AfplibPackage.EXTENSION_FONT__GCSGID:
				return GCSGID_EDEFAULT == null ? gcsgid != null : !GCSGID_EDEFAULT.equals(gcsgid);
		}
		return super.eIsSet(featureID);
	}",Replies if the feature is set to a value.
"private void parseBody(Node parent, String tag, String bodyType) 
        throws JasperException 
    {
        if( bodyType.equalsIgnoreCase( TagInfo.BODY_CONTENT_TAG_DEPENDENT ) ) {
            parseTagDependentBody( parent, tag );
        }
        else if( bodyType.equalsIgnoreCase( TagInfo.BODY_CONTENT_EMPTY ) ) {
            if( !reader.matchesETag( tag ) ) {
		err.jspError(start, ""jasper.error.emptybodycontent.nonempty"",
			     tag);
            }
        }
        else if( bodyType == JAVAX_BODY_CONTENT_PLUGIN ) {
            // (note the == since we won't recognize JAVAX_* 
            // from outside this module).
            parsePluginTags(parent);
            if( !reader.matchesETag( tag ) ) {
                err.jspError( reader.mark(), ""jsp.error.unterminated"",
                    ""&lt;"" + tag  );
            }
        }
        else if( bodyType.equalsIgnoreCase( TagInfo.BODY_CONTENT_JSP ) ||
            bodyType.equalsIgnoreCase( TagInfo.BODY_CONTENT_SCRIPTLESS ) ||
            (bodyType == JAVAX_BODY_CONTENT_PARAM) ||
            (bodyType == JAVAX_BODY_CONTENT_TEMPLATE_TEXT) )
        {
            while (reader.hasMoreInput()) {
                if (reader.matchesETag(tag)) {
                    return;
                }
                
                // Check for nested jsp:body or jsp:attribute
                if (tag.equals(""jsp:body"") || tag.equals(""jsp:attribute"")) {
                    if (reader.matches(""<jsp:attribute"")) {
                        err.jspError(reader.mark(), ""jsp.error.nested.jspattribute"");
                    }
                    else if (reader.matches(""<jsp:body"")) {
                        err.jspError(reader.mark(), ""jsp.error.nested.jspbody"");
                    }
                }

                if( bodyType.equalsIgnoreCase( TagInfo.BODY_CONTENT_JSP ) ) {
                    parseElements( parent );
                }
                else if( bodyType.equalsIgnoreCase( 
                    TagInfo.BODY_CONTENT_SCRIPTLESS ) ) 
                {
                    parseElementsScriptless( parent );
                }
                else if( bodyType == JAVAX_BODY_CONTENT_PARAM ) {
                    // (note the == since we won't recognize JAVAX_* 
                    // from outside this module).
                    reader.skipSpaces();
                    parseParam( parent );
                }
		else if (bodyType == JAVAX_BODY_CONTENT_TEMPLATE_TEXT) {
		    parseElementsTemplateText(parent);
		}
            }
            err.jspError(start, ""jsp.error.unterminated"", ""&lt;""+tag );
        }
        else {
            err.jspError(start, ""jsp.error.tld.badbodycontent"", bodyType,
                         tag);
        }
    }",Parse the body of a page.
"public void setCosts(Costs nodeCosts) {
		// add the costs from the step function
		nodeCosts.addCosts(this.solutionSetDeltaPlanNode.getCumulativeCostsShare());
		nodeCosts.addCosts(this.nextWorkSetPlanNode.getCumulativeCostsShare());

		super.setCosts(nodeCosts);
	}",Add costs from the solution set delta and next work set costs to the node costs
"public Connection getConnection(String name) throws ExecutionException {
        Connection connection = null;
        synchronized (connections) {
            if (connections.containsKey(name)) {
                connection = connections.get(name);
            } else {

                String msg = ""The connection ["" + name + ""] does not exist"";
                logger.error(msg);
                throw new ExecutionException(msg);
            }
        }
        return connection;
    }",Gets a connection from the cache.
"public Observable<ServiceResponse<Map<String, String>>> listEndpointsWithServiceResponseAsync(UUID appId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException(""Parameter this.client.endpoint() is required and cannot be null."");
        }
        if (appId == null) {
            throw new IllegalArgumentException(""Parameter appId is required and cannot be null."");
        }
        String parameterizedHost = Joiner.on("", "").join(""{Endpoint}"", this.client.endpoint());
        return service.listEndpoints(appId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Map<String, String>>>>() {
                @Override
                public Observable<ServiceResponse<Map<String, String>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Map<String, String>> clientResponse = listEndpointsDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }",List the endpoints for an App Service Environment.
"@Override
	public EClass getIfcLaborResourceType() {
		if (ifcLaborResourceTypeEClass == null) {
			ifcLaborResourceTypeEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)
					.getEClassifiers().get(334);
		}
		return ifcLaborResourceTypeEClass;
	}",Get the IfcLaborResourceTypeEClass for the ifcLaborResourceType.
"@Override
	public List<CommerceAddress> findByG_C_C_DB(long groupId, long classNameId,
		long classPK, boolean defaultBilling, int start, int end) {
		return findByG_C_C_DB(groupId, classNameId, classPK, defaultBilling,
			start, end, null);
	}",Returns a range of commerce addresses where groupId = &#63 ; and classNameId = &#63 ; and classPK = &#63 ;.
"@Generated(value = ""com.sun.tools.xjc.Driver"", date = ""2018-10-12T02:54:50+02:00"", comments = ""JAXB RI v2.2.11"")
    public List<Wohnung> getWohnung() {
        if (wohnung == null) {
            wohnung = new ArrayList<Wohnung>();
        }
        return this.wohnung;
    }",Gets the value of the wohnung property.
"public void delete(HTableInterface hTable, Object rowKey, String columnFamily)
    {
        try
        {
            byte[] rowBytes = HBaseUtils.getBytes(rowKey);
            Delete delete = new Delete(rowBytes);
            byte[] family = HBaseUtils.getBytes(columnFamily);
            delete.deleteFamily(family);
            hTable.delete(delete);
        }
        catch (IOException e)
        {
            log.error(""Error while delete on hbase for : "" + rowKey);
            throw new PersistenceException(e);
        }
    }",Delete a single record from HBase.
"public void setMessageException(Throwable ex)
    {
        String strErrorMessage = ex.getMessage();
        BaseMessage message = this.getMessage();
        if ((message != null) && (message.getMessageHeader() instanceof TrxMessageHeader))
            ((TrxMessageHeader)message.getMessageHeader()).put(TrxMessageHeader.MESSAGE_ERROR, strErrorMessage);
        else
            ex.printStackTrace();
    }",Set the message exception.
"public static List<Filter<File>> createExcludeFilterList(final Log log,
            final String... patterns) {
        return createFilterList(log, false, patterns);
    }",Create exclude filter list.
"public EnvironmentResourceDescription withLaunchConfigurations(LaunchConfiguration... launchConfigurations) {
        if (this.launchConfigurations == null) {
            setLaunchConfigurations(new com.amazonaws.internal.SdkInternalList<LaunchConfiguration>(launchConfigurations.length));
        }
        for (LaunchConfiguration ele : launchConfigurations) {
            this.launchConfigurations.add(ele);
        }
        return this;
    }",Sets the launch configurations.
"private void writeObject(final java.io.ObjectOutputStream out)
     throws IOException {
     out.writeObject(inequalitySymbol);
     out.writeLong(timeStamp);
   }",Write the object in the CIS file.
"public int size() {
        if (pad_bits == 0) {
            return bin.length;
        }
        if (bin.length == 0) {
            throw new java.lang.IllegalStateException(""Impossible length"");
        }
        return bin.length - 1;
    }",Returns the size of the set of bytes in this set.
"public Reader asReader() {
        Reader r = getReader();
        if (r != null) return r;
        String s = getString();
        if (s != null) return new StringReader(s);
        InputStream is = fromStreamOrBufferOrUrl();
        if (is != null) return readerFrom(is);
        throw resourceUnaccessible();
    }",Returns a Reader object that represents this image.
"public int getNameIndex(CharSequence name)
    {
        for (ConstantInfo ci : listConstantInfo(Utf8.class))
        {
            Utf8 utf8 = (Utf8) ci;
            String str = utf8.getString();
            if (str.contentEquals(name))
            {
                return constantPoolIndexMap.get(ci);
            }
        }
        return -1;
    }",Get the index of a name in the class.
"private String getFulltextStatement(QueryRootNode aqt) throws RepositoryException
   {
      final String[] stmt = new String[1];
      aqt.accept(new TraversingQueryNodeVisitor()
      {
         @Override
         public Object visit(RelationQueryNode node, Object o) throws RepositoryException
         {
            if (stmt[0] == null && node.getOperation() == RelationQueryNode.OPERATION_SPELLCHECK)
            {
               stmt[0] = node.getStringValue();
            }
            return super.visit(node, o);
         }
      }, null);
      return stmt[0];
   }",getFulltextStatement Method.
"public boolean removeValue(Object value) {
		try {
			boolean result = false;
			if (isCluster(groupName)) {
				result = getBinaryJedisClusterCommands(groupName).lrem(keyBytes, 0, valueSerialize(value)) >= 1;
			} else {
				result = getBinaryJedisCommands(groupName).lrem(keyBytes, 0, valueSerialize(value)) >= 1;
			}
			return result;
		} finally {
			getJedisProvider(groupName).release();
		}
	}",Removes the value from the specified key.
"@Override
	public final void lock(int handle) throws DataStoreException 
    {
        if (SAFE_MODE) checkHandle(handle);
        if (!locks.flip(handle))
        {
            locks.flip(handle); // Restore state
            throw new DataStoreException(""Handle already locked : ""+handle);
        }
    }",Lock a single entity.
"static public Value floatValue (String name, final float currentValue, final float min, final float max,
		final String description) {
		return new DefaultValue(name, String.valueOf(currentValue)) {
			public void showDialog () {
				JSpinner spinner = new JSpinner(new SpinnerNumberModel(currentValue, min, max, 0.1f));
				if (showValueDialog(spinner, description)) value = String.valueOf(((Double)spinner.getValue()).floatValue());
			}

			public Object getObject () {
				return Float.valueOf(value);
			}
		};
	}",Creates a Value object that represents the float value of the specified property.
"public static Date parseW3CDateTime(String sDate, final Locale locale) {
        // if sDate has time on it, it injects 'GTM' before de TZ displacement to allow the
        // SimpleDateFormat parser to parse it properly
        final int tIndex = sDate.indexOf(""T"");
        if (tIndex > -1) {
            if (sDate.endsWith(""Z"")) {
                sDate = sDate.substring(0, sDate.length() - 1) + ""+00:00"";
            }
            int tzdIndex = sDate.indexOf(""+"", tIndex);
            if (tzdIndex == -1) {
                tzdIndex = sDate.indexOf(""-"", tIndex);
            }
            if (tzdIndex > -1) {
                String pre = sDate.substring(0, tzdIndex);
                final int secFraction = pre.indexOf("","");
                if (secFraction > -1) {
                    pre = pre.substring(0, secFraction);
                }
                final String post = sDate.substring(tzdIndex);
                sDate = pre + ""GMT"" + post;
            }
        } else {
            sDate += ""T00:00GMT"";
        }
        return parseUsingMask(W3CDATETIME_MASKS, sDate, locale);
    }",Parse a W3C date time string.
"@SuppressWarnings(""unchecked"")
    private E[] leafNodeArrayFor(int i) {
        // i is the index into this vector.  Each 5 bits represent an index into an array.  The
        // highest 5 bits (that are less than the shift value) are the index into the top-level
        // array. The lowest 5 bits index the the leaf.  The guts of this method indexes into the
        // array at each level, finally indexing into the leaf node.

        if (i >= 0 && i < size) {
            if (i >= tailoff()) {
                return tail;
            }
            Node node = root;
            for (int level = shift; level > 0; level -= NODE_LENGTH_POW_2) {
                node = (Node) node.array[(i >>> level) & LOW_BITS];
            }
            return (E[]) node.array;
        }
        throw new IndexOutOfBoundsException();
    }",Returns the array of the leaf nodes for the given index.
"public void consumeExpectedSymbol(String symbol) {
        if (current().matches(Token.TokenType.SYMBOL, symbol)) {
            consume();
        } else {
            addError(current(), ""Unexpected token: '%s'. Expected: '%s'"", current().getSource(), symbol);
        }
    }",Consumes the token until the expected symbol is found.
"public void set(String name, Object obj) throws IOException {
        if (!(obj instanceof Boolean)) {
            throw new IOException(""Attribute must be of type Boolean."");
        }
        boolean val = ((Boolean)obj).booleanValue();
        if (name.equalsIgnoreCase(DIGITAL_SIGNATURE)) {
            set(0,val);
        } else if (name.equalsIgnoreCase(NON_REPUDIATION)) {
            set(1,val);
        } else if (name.equalsIgnoreCase(KEY_ENCIPHERMENT)) {
            set(2,val);
        } else if (name.equalsIgnoreCase(DATA_ENCIPHERMENT)) {
            set(3,val);
        } else if (name.equalsIgnoreCase(KEY_AGREEMENT)) {
            set(4,val);
        } else if (name.equalsIgnoreCase(KEY_CERTSIGN)) {
            set(5,val);
        } else if (name.equalsIgnoreCase(CRL_SIGN)) {
            set(6,val);
        } else if (name.equalsIgnoreCase(ENCIPHER_ONLY)) {
            set(7,val);
        } else if (name.equalsIgnoreCase(DECIPHER_ONLY)) {
            set(8,val);
        } else {
          throw new IOException(""Attribute name not recognized by""
                                + "" CertAttrSet:KeyUsage."");
        }
        encodeThis();
    }",Set an attribute in the certificate set from the specified object.
"void rainbow(Nfa nfa, int type, short but, State from, State to) {
        ColorDesc cd;
        short co;

        for (co = 0; co < colorDescs.size(); co++) {
            cd = colorDescs.get(co);
            if (cd != null
                    && cd.sub != co
                    && co != but
                    && !cd.pseudo()) {
                nfa.newarc(type, co, from, to);
            }
        }
    }",RAINBOW Method.
"@Override
  public boolean isFlowRunning(final int projectId, final String flowId) {
    boolean isRunning = false;
    try {
      isRunning = isFlowRunningHelper(projectId, flowId,
          this.executorLoader.fetchUnfinishedFlows().values());

    } catch (final ExecutorManagerException e) {
      logger.error(
          ""Failed to check if the flow is running for project "" + projectId + "", flow "" + flowId,
          e);
    }
    return isRunning;
  }",Check if a flow is running.
"public int getCount (K key)
    {
        CountEntry<K> entry = _backing.get(key);
        return (entry == null) ? 0 : entry.count;
    }",Gets the count of the record for the given key.
"private static SerializerFactory getInstance() {
    if (instance == null) {
      String className = JacksonSerializerFactory.class.getName();
      try {
        className = System.getProperty(SERIALIZER_FACTORY_CLASS_NAME);
      } catch (Exception e) {
      }

      if (className != null) {
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        try {
          Class<?> clazz = loader.loadClass(className);
          instance = (SerializerFactory) clazz.newInstance();
        } catch (Exception e) {
          throw new IllegalArgumentException(""Error instantiating serializer factory."");
        }
      } else {
        instance = new JacksonSerializerFactory();
      }
    }
    return instance;
  }",Get the instance of the serializer factory.
"protected SofaResponse doInvokeSync(SofaRequest request, int timeout) throws InterruptedException,
        ExecutionException, TimeoutException {
        HttpResponseFuture future = new HttpResponseFuture(request, timeout);
        AbstractHttpClientHandler callback = new SyncInvokeClientHandler(transportConfig.getConsumerConfig(),
            transportConfig.getProviderInfo(), future, request, RpcInternalContext.getContext(),
            ClassLoaderUtils.getCurrentClassLoader());
        future.setSentTime();
        doSend(request, callback, timeout);
        future.setSentTime();
        return future.getSofaResponse(timeout, TimeUnit.MILLISECONDS);
    }",Invoke a synchronous SofaRequest.
"public final double getScore(int s, int t, int d, int ic) {
        return scores[getIndex(s, t, d, ic)];
    }",Gets the score of a pair of words.
"protected String getDefaultString() {
        final StringBuilder outBuilder = new StringBuilder();
        if (!namespace.isEmpty()) {
            outBuilder.append(namespace).append(""\n"");
        }
        if (!qvarMapVariable.isEmpty() && addQvarMap) {
            outBuilder.append(qvarMapVariable).append(""\n"");
        }
        outBuilder.append(""for $m in "").append(pathToRoot).append("" return\n"")
                .append(""for $x in $m//*:"").append(NonWhitespaceNodeList.getFirstChild(mainElement).getLocalName())
                .append(""\n"").append(exactMatchXQuery);
        if (!lengthConstraint.isEmpty() || !qvarConstraint.isEmpty()) {
            outBuilder.append(""\n"").append(""where"").append(""\n"");
            if (lengthConstraint.isEmpty()) {
                outBuilder.append(qvarConstraint);
            } else {
                outBuilder.append(lengthConstraint)
                        .append(qvarConstraint.isEmpty() ? """" : ""\n and "").append(qvarConstraint);
            }
        }
        outBuilder.append(""\n\n"").append(""return"").append(""\n"").append(returnFormat);
        return outBuilder.toString();
    }",Get the default string for the result set.
"@Nonnull
  public static String getAsCompleteDisplayName (@Nonnull final IPersonName aName)
  {
    if (isFirstNameFirst ())
      return getAsCompleteDisplayNameFirstNameFirst (aName);
    return getAsCompleteDisplayNameLastNameFirst (aName);
  }",Get the complete display name of the passed name.
"static void log(Task action, String msg) {
        log(action.event.getKey(), action.method, msg);
    }",Log an action.
"public void end() {
    final OClass vClass = db.getMetadata().getSchema().getClass(vertexClass);

    try {

      runningThreads = new AtomicInteger(parallel);
      for (int i = 0; i < parallel - 1; i++) {
        Thread t = new BatchImporterJob(i, vClass);
        t.start();
      }
      Thread t = new BatchImporterJob(parallel - 1, vClass);
      t.run();

      if (runningThreads.get() > 0) {
        synchronized (runningThreads) {
          while (runningThreads.get() > 0) {
            try {
              runningThreads.wait();
            } catch (InterruptedException e) {
            }
          }
        }
      }

    } finally {
      db.activateOnCurrentThread();
      db.declareIntent(null);
      db.close();
      if (walActive)
        OGlobalConfiguration.USE_WAL.setValue(true);
    }
  }",End the batch import.
"public static HttpClientContext newClientContext(HttpClientSettings settings,
                                                     Map<String, ? extends Object>
                                                             attributes) {
        final HttpClientContext clientContext = new HttpClientContext();

        if (attributes != null && !attributes.isEmpty()) {
            for (Map.Entry<String, ?> entry : attributes.entrySet()) {
                clientContext.setAttribute(entry.getKey(), entry.getValue());
            }
        }

        addPreemptiveAuthenticationProxy(clientContext, settings);

        clientContext.setAttribute(HttpContextUtils.DISABLE_SOCKET_PROXY_PROPERTY, settings.disableSocketProxy());
        return clientContext;

    }",Create a new HttpClientContext with the attributes.
"private PropertySource<?> loadSettingsByApplicationProfiles(final Environment environment, final File config) {
        val profiles = ConfigurationPropertiesLoaderFactory.getApplicationProfiles(environment);
        val resources = scanForConfigurationResources(config, profiles);
        val composite = new CompositePropertySource(""applicationProfilesCompositeProperties"");
        LOGGER.info(""Configuration files found at [{}] are [{}] under profile(s) [{}]"", config, resources, profiles);
        resources.forEach(Unchecked.consumer(f -> {
            LOGGER.debug(""Loading configuration file [{}]"", f);
            val loader = configurationPropertiesLoaderFactory.getLoader(f, ""applicationProfilesProperties-"" + f.getFilename());
            composite.addFirstPropertySource(loader.load());
        }));

        return composite;
    }",Load settings by application profiles.
"final public void exclusiveOrExpression() throws ParseException {
    andExpression();
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 11:
      case 12:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_5;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 11:
        jj_consume_token(11);
        break;
      case 12:
        jj_consume_token(12);
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                     ASTXor jjtn001 = new ASTXor(JJTXOR);
                                     boolean jjtc001 = true;
                                     jjtree.openNodeScope(jjtn001);
      try {
        andExpression();
      } catch (Throwable jjte001) {
                                     if (jjtc001) {
                                       jjtree.clearNodeScope(jjtn001);
                                       jjtc001 = false;
                                     } else {
                                       jjtree.popNode();
                                     }
                                     if (jjte001 instanceof RuntimeException) {
                                       {if (true) throw (RuntimeException)jjte001;}
                                     }
                                     if (jjte001 instanceof ParseException) {
                                       {if (true) throw (ParseException)jjte001;}
                                     }
                                     {if (true) throw (Error)jjte001;}
      } finally {
                                     if (jjtc001) {
                                       jjtree.closeNodeScope(jjtn001,  2);
                                     }
      }
    }
  }",11. 2 exclusive or expression
"public String getToolTip() {
        StringBuilder message = new StringBuilder();
        message.append(""<p>"");
        message.append(Messages.DRY_Duplications_Header());
        message.append(""<ul>"");
        for (DuplicateCode duplication : links) {
            message.append(""<li>"");
            message.append(String.format(""<a href=\""link.%s.%s/#%s\"">%s (%s)</a>"",
                    getKey(), duplication.getKey(), duplication.getPrimaryLineNumber(),
                    duplication.getLinkName(), duplication.getPrimaryLineNumber()));
            message.append(""</li>"");
        }
        message.append(""</ul>"");
        message.append(""</p>"");
        return message.toString();
    }",Get the tooltip for the DRY duplications page.
"@SuppressWarnings({""PMD.UseObjectForClearerAPI""})
    // CHECKSTYLE:ON
    private static void logDefault(final String key,
                                   final String invalidValue,
                                   final String validationError,
                                   final String defaultValue) {

        if (LOG.isWarnEnabled()) {
            final StringBuilder msg = new StringBuilder(""Invalid value ('"")
                    .append(invalidValue)
                    .append(""', "")
                    .append(validationError)
                    .append("") for key '"")
                    .append(key)
                    .append(""', using default instead ('"");
            if (defaultValue == null) {
                msg.append(""null')"");
            } else {
                msg.append(defaultValue).append(""')"");
            }
            LOG.warn(msg.toString());
        }
    }",LOG_WARNING - Default method.
"public static MediaPlayer createMediaPlayer(String filenameOrURL) {
        // create mediaplayer instance
        MediaPlayer mediaPlayer = new MediaPlayer();
        try {
            mediaPlayer.setDataSource(filenameOrURL);
            mediaPlayer.prepare();
        } catch (IOException e) {
            e.printStackTrace();
            return null;
        }

        return mediaPlayer;
    }",Create a media player instance.
"@Override
    public Request<ReplaceTransitGatewayRouteRequest> getDryRunRequest() {
        Request<ReplaceTransitGatewayRouteRequest> request = new ReplaceTransitGatewayRouteRequestMarshaller().marshall(this);
        request.addParameter(""DryRun"", Boolean.toString(true));
        return request;
    }",Returns a request configured to delete a resource from the cache.
"private ExecutionMessage createTerminatedExecutionMessage(Execution nextStepExecution) {
        Payload payload = converter.createPayload(nextStepExecution); //we need the payload
        ExecutionMessage finalMessage = (ExecutionMessage) executionMessage.clone();
        finalMessage.setStatus(ExecStatus.TERMINATED); //in queue it is checked and finish flow is called
        finalMessage.incMsgSeqId();
        finalMessage.setPayload(payload);
        return finalMessage;
    }",Create terminated execution message
"public List<Integer> getTrackIds() {
        ArrayList<Integer> results = new ArrayList<Integer>(trackCount);
        Enumeration<? extends ZipEntry> entries = zipFile.entries();
        while (entries.hasMoreElements()) {
            ZipEntry entry = entries.nextElement();
            if (entry.getName().startsWith(CACHE_METADATA_ENTRY_PREFIX)) {
                String idPart = entry.getName().substring(CACHE_METADATA_ENTRY_PREFIX.length());
                if (idPart.length() > 0) {
                    results.add(Integer.valueOf(idPart));
                }
            }
        }

        return Collections.unmodifiableList(results);
    }",Gets the trackIds of the cache metadata.
"public void skip(long n) throws IOException {
		if (capacity == 0) {
			// aligned
			while (n != 0) {
				n -= istream.skip(n);
			}
		} else {
			// not aligned, grrr
			for (int i = 0; i < n; n++) {
				readBits(8);
			}
		}
	}",Skips n bytes from the underlying stream.
"AlignmentPattern find() throws NotFoundException {
    int startX = this.startX;
    int height = this.height;
    int maxJ = startX + width;
    int middleI = startY + (height / 2);
    // We are looking for black/white/black modules in 1:1:1 ratio;
    // this tracks the number of black/white/black modules seen so far
    int[] stateCount = new int[3];
    for (int iGen = 0; iGen < height; iGen++) {
      // Search from middle outwards
      int i = middleI + ((iGen & 0x01) == 0 ? (iGen + 1) / 2 : -((iGen + 1) / 2));
      stateCount[0] = 0;
      stateCount[1] = 0;
      stateCount[2] = 0;
      int j = startX;
      // Burn off leading white pixels before anything else; if we start in the middle of
      // a white run, it doesn't make sense to count its length, since we don't know if the
      // white run continued to the left of the start point
      while (j < maxJ && !image.get(j, i)) {
        j++;
      }
      int currentState = 0;
      while (j < maxJ) {
        if (image.get(j, i)) {
          // Black pixel
          if (currentState == 1) { // Counting black pixels
            stateCount[1]++;
          } else { // Counting white pixels
            if (currentState == 2) { // A winner?
              if (foundPatternCross(stateCount)) { // Yes
                AlignmentPattern confirmed = handlePossibleCenter(stateCount, i, j);
                if (confirmed != null) {
                  return confirmed;
                }
              }
              stateCount[0] = stateCount[2];
              stateCount[1] = 1;
              stateCount[2] = 0;
              currentState = 1;
            } else {
              stateCount[++currentState]++;
            }
          }
        } else { // White pixel
          if (currentState == 1) { // Counting black pixels
            currentState++;
          }
          stateCount[currentState]++;
        }
        j++;
      }
      if (foundPatternCross(stateCount)) {
        AlignmentPattern confirmed = handlePossibleCenter(stateCount, i, maxJ);
        if (confirmed != null) {
          return confirmed;
        }
      }

    }

    // Hmm, nothing we saw was observed and confirmed twice. If we had
    // any guess at all, return it.
    if (!possibleCenters.isEmpty()) {
      return possibleCenters.get(0);
    }

    throw NotFoundException.getNotFoundInstance();
  }",Find the alignment pattern.
"private ClassLoader getDefaultClassLoader() {
        ClassLoader classLoader;
        try {
            classLoader = Thread.currentThread().getContextClassLoader();
        } catch (Throwable ex) {
            classLoader = null;
        }
        if (classLoader == null) {
            classLoader = ClassPathResource.class.getClassLoader();
        }
        return classLoader;
    }",Get the default class loader.
"public final void ruleOpAdd() throws RecognitionException {

        		int stackSize = keepStackSize();
        	
        try {
            // InternalXbase.g:446:2: ( ( ( rule__OpAdd__Alternatives ) ) )
            // InternalXbase.g:447:2: ( ( rule__OpAdd__Alternatives ) )
            {
            // InternalXbase.g:447:2: ( ( rule__OpAdd__Alternatives ) )
            // InternalXbase.g:448:3: ( rule__OpAdd__Alternatives )
            {
            if ( state.backtracking==0 ) {
               before(grammarAccess.getOpAddAccess().getAlternatives()); 
            }
            // InternalXbase.g:449:3: ( rule__OpAdd__Alternatives )
            // InternalXbase.g:449:4: rule__OpAdd__Alternatives
            {
            pushFollow(FOLLOW_2);
            rule__OpAdd__Alternatives();

            state._fsp--;
            if (state.failed) return ;

            }

            if ( state.backtracking==0 ) {
               after(grammarAccess.getOpAddAccess().getAlternatives()); 
            }

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {

            	restoreStackSize(stackSize);

        }
        return ;
    }",start rule__OpAdd
"public static com.liferay.commerce.model.CommerceShipmentItem deleteCommerceShipmentItem(
		com.liferay.commerce.model.CommerceShipmentItem commerceShipmentItem) {
		return getService().deleteCommerceShipmentItem(commerceShipmentItem);
	}",Deletes the commerce shipment item from the database. Also notifies the appropriate model listeners.
"protected List<WsByteBuffer> compress(List<WsByteBuffer> list, WsByteBuffer buffer) {
        if (null == buffer) {
            return null;
        }
        int dataSize = buffer.remaining();
        if (0 == dataSize) {
            return list;
        }
        byte[] input = null;
        int initOffset = 0;
        if (buffer.hasArray()) {
            input = buffer.array();
            initOffset = buffer.arrayOffset() + buffer.position();
            buffer.position(buffer.limit());
        } else {
            input = new byte[dataSize];
            buffer.get(input);
        }
        this.deflater.setInput(input, initOffset, dataSize);

        // keep compressing data until we use up the input amount
        int offset = 0;
        while (!this.deflater.needsInput()) {
            int len = this.deflater.deflate(this.buf, offset, this.buf.length - offset);
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""Compressed amount="" + len + "" read="" + this.deflater.getBytesRead() + "" written="" + this.deflater.getBytesWritten());
            }
            if (0 == len) {
                break; // out of while
            }
            offset += len;
            if (offset == this.buf.length) {
                list.add(makeBuffer(offset));
                offset = 0;
            }
        }
        // if we generated output, put it into a buffer on the list
        if (0 < offset) {
            list.add(makeBuffer(offset));
        }
        return list;
    }",Compress the data in the buffer into the list.
"@Override
	public EClass getIfcRevolvedAreaSolidTapered() {
		if (ifcRevolvedAreaSolidTaperedEClass == null) {
			ifcRevolvedAreaSolidTaperedEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)
					.getEClassifiers().get(576);
		}
		return ifcRevolvedAreaSolidTaperedEClass;
	}",Get the IfcRevolvedAreaSolidTaperedEClass method.
"private boolean isRequestURLEqualsExitPageHost(HttpServletRequest req, String logoutURLhost) {
        boolean acceptURL = false;
        try {
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
                Tr.debug(tc, ""about to attempt matching the logout exit url with the domain of the request."");
            StringBuffer requestURLString = req.getRequestURL();
            URL requestURL = new URL(new String(requestURLString));
            String requestURLhost = requestURL.getHost();
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
                Tr.debug(tc, "" host of the request url is: "" + requestURLhost + "" and the host of the logout URL is: "" + logoutURLhost);
            if (logoutURLhost != null && requestURLhost != null && logoutURLhost.equalsIgnoreCase(requestURLhost)) {
                acceptURL = true;
            }
        } catch (MalformedURLException e) {
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""caught Exception trying to form request URL object: "" + e.getMessage());
            }
        }
        return acceptURL;
    }",isRequestURLEqualsExitPageHost returns true if the request URL matches the logout exit page host.
"public static <T> CompletableFuture<List<T>> allOf(List<CompletableFuture<T>> futures) {
    return AtomixFuture.wrap(CompletableFuture.allOf(futures.toArray(new CompletableFuture[futures.size()]))
        .thenApply(v -> futures.stream()
            .map(CompletableFuture::join)
            .collect(Collectors.toList())));
  }",A CompletableFuture that completes when all of the given CompletableFuture complete.
"private ArrayList<ArrayDBIDs> buildOneDimIndexes(Relation<? extends NumberVector> relation) {
    final int dim = RelationUtil.dimensionality(relation);
    ArrayList<ArrayDBIDs> subspaceIndex = new ArrayList<>(dim + 1);

    SortDBIDsBySingleDimension comp = new VectorUtil.SortDBIDsBySingleDimension(relation);
    for(int i = 0; i < dim; i++) {
      ArrayModifiableDBIDs amDBIDs = DBIDUtil.newArray(relation.getDBIDs());
      comp.setDimension(i);
      amDBIDs.sort(comp);
      subspaceIndex.add(amDBIDs);
    }

    return subspaceIndex;
  }",Build one - dimensional index list.
"private SSLSocketFactory getSSLSocketFactory() throws Exception {
        SSLSocketFactory sslSF = null;
        Object sslConfig = this.sslConfig.getService();
        if(sslConfig != null) {
            // Reflectively invoke this operation to a helper class because the classes needed to perform
            // this operation are dynamically imported, depending on if the ssl-1.0 feature is enabled.
            Class<?> SSLHelper = Class.forName(""com.ibm.ws.cloudant.internal.SSLHelper"");
            sslSF = (SSLSocketFactory) SSLHelper.getMethod(""getSSLSocketFactory"", Object.class).invoke(null, sslConfig);
        }
        return sslSF;
    }",Get the SSLSocketFactory from the SSLConfig.
"public void setWorldRotations(float[] rotations)
    {
        if (rotations.length != mBones.length * 4)
        {
            throw new IllegalArgumentException(""Source array is the wrong size"");
        }
        mNeedSync = true;
        for (int i = 0; i < mBones.length; ++i)
        {
            Bone bone = mBones[i];
            int t = i * 4;

            bone.setWorldRotation(rotations[t], rotations[t + 1], rotations[t + 2], rotations[t + 3]);
            bone.Changed |= WORLD_ROT;

            calcLocal(bone, mSkeleton.getParentBoneIndex(i));

            if (sDebug)
            {
                Log.d(""BONE"", ""setWorldRotation: %s %s"", mSkeleton.getBoneName(i), bone.toString());
            }
        }
    }",Sets the world rotation of all bones in the skeleton.
"public Binder varargs(int index, Class<?> type) {
        return new Binder(this, new Varargs(type(), index, type));
    }",Create a vararg argument expression.
"@Override
	protected boolean doHandleRequest(final Request request) {
		boolean selected = getRequestValue(request);
		boolean current = getValue();

		boolean changed = current != selected;

		if (changed) {
			setData(selected);
		}

		return changed;
	}",Override to handle the request.
"public int getLearnerToUse(int predMode) {
		int predictionMode = predMode;
		if (predictionMode == 0) {
			double perceptronError= this.perceptron.getCurrentError();
			double meanTargetError =this.targetMean.getCurrentError();
			if (perceptronError < meanTargetError)
				predictionMode = 1; //PERCEPTRON
			else
				predictionMode = 2; //TARGET MEAN
		}
		return predictionMode;
	}",Get the learner to use.
"public final void addAll (final SettingsMap textKeys) {

        for (Map.Entry<OperationalTextKey , String> e : textKeys.entrySet()) {
            add(e.getKey(), e.getValue());
        }

        isDirty = true;
    }",Add all the attributes from the given settings map.
"private File getFileForEvent(File collectionDir, Calendar timestamp) throws IOException {
        int counter = 0;
        File eventFile = getNextFileForEvent(collectionDir, timestamp, counter);
        while (eventFile.exists()) {
            eventFile = getNextFileForEvent(collectionDir, timestamp, counter);
            counter++;
        }
        return eventFile;
    }",Gets the File for the event.
"private void createPathQuery(String path, int operation)
   {
      MergingPathQueryNode pathNode =
         new MergingPathQueryNode(operation, factory.createPathQueryNode(null).getValidJcrSystemNodeTypeNames());
      pathNode.setAbsolute(true);

      if (path.equals(""/""))
      {
         pathNode.addPathStep(factory.createLocationStepQueryNode(pathNode));
         pathConstraints.add(pathNode);
         return;
      }

      String[] names = path.split(""/"");

      for (int i = 0; i < names.length; i++)
      {
         if (names[i].length() == 0)
         {
            if (i == 0)
            {
               // root
               pathNode.addPathStep(factory.createLocationStepQueryNode(pathNode));
            }
            else
            {
               // descendant '//' -> invalid path
               // todo throw or ignore?
               // we currently do not throw and add location step for an
               // empty name (which is basically the root node)
               pathNode.addPathStep(factory.createLocationStepQueryNode(pathNode));
            }
         }
         else
         {
            int idx = names[i].indexOf('[');
            String name;
            int index = LocationStepQueryNode.NONE;
            if (idx > -1)
            {
               // contains index
               name = names[i].substring(0, idx);
               String suffix = names[i].substring(idx);
               String indexStr = suffix.substring(1, suffix.length() - 1);
               if (indexStr.equals(""%""))
               {
                  // select all same name siblings
                  index = LocationStepQueryNode.NONE;
               }
               else
               {
                  try
                  {
                     index = Integer.parseInt(indexStr);
                  }
                  catch (NumberFormatException e)
                  {
                     log.warn(""Unable to parse index for path element: "" + names[i]);
                  }
               }
               if (name.equals(""%""))
               {
                  name = null;
               }
            }
            else
            {
               // no index specified
               // - index defaults to 1 if there is an explicit name test
               // - index defaults to NONE if name test is %
               name = names[i];
               if (name.equals(""%""))
               {
                  name = null;
               }
               else
               {
                  index = 1;
               }
            }
            InternalQName qName = null;
            if (name != null)
            {
               try
               {
                  qName = resolver.parseJCRName(name).getInternalName();
               }
               catch (NamespaceException e)
               {
                  throw new IllegalArgumentException(""Illegal name: "" + name, e);
               }
               catch (RepositoryException e)
               {
                  throw new IllegalArgumentException(""Illegal name: "" + name, e);
               }

            }
            // if name test is % this means also search descendants
            boolean descendant = name == null;
            LocationStepQueryNode step = factory.createLocationStepQueryNode(pathNode);
            step.setNameTest(qName);
            step.setIncludeDescendants(descendant);
            if (index > 0)
            {
               step.setIndex(index);
            }
            pathNode.addPathStep(step);
         }
      }
      pathConstraints.add(pathNode);
   }",Create a path query node.
"public static base_response add(nitro_service client, cmppolicylabel resource) throws Exception {
		cmppolicylabel addresource = new cmppolicylabel();
		addresource.labelname = resource.labelname;
		addresource.type = resource.type;
		return addresource.add_resource(client);
	}",Use this API to add cmppolicylabel.
"public Point3d[] calculate3DCoordinates1(Point3d aPoint, Point3d bPoint, Point3d cPoint, int nwanted,
            double length, double angle) {
        Point3d points[] = new Point3d[nwanted];
        // BA vector
        Vector3d ba = new Vector3d(aPoint);
        ba.sub(bPoint);
        ba.normalize();
        // if no cPoint, generate a random reference
        if (cPoint == null) {
            Vector3d cVector = getNonColinearVector(ba);
            cPoint = new Point3d(cVector);
        }
        // CB vector
        Vector3d cb = new Vector3d(bPoint);
        cb.sub(cPoint);
        cb.normalize();
        // if A, B, C colinear, replace C by random point
        double cbdotba = cb.dot(ba);
        if (cbdotba > 0.999999) {
            Vector3d cVector = getNonColinearVector(ba);
            cPoint = new Point3d(cVector);
            cb = new Vector3d(bPoint);
            cb.sub(cPoint);
        }
        // cbxba = c x b
        Vector3d cbxba = new Vector3d();
        cbxba.cross(cb, ba);
        cbxba.normalize();
        // create three perp axes ba, cbxba, and ax
        Vector3d ax = new Vector3d();
        ax.cross(cbxba, ba);
        ax.normalize();
        double drot = Math.PI * 2.0 / (double) nwanted;
        for (int i = 0; i < nwanted; i++) {
            double rot = (double) i * drot;
            points[i] = new Point3d(aPoint);
            Vector3d vx = new Vector3d(ba);
            vx.scale(-Math.cos(angle) * length);
            Vector3d vy = new Vector3d(ax);
            vy.scale(Math.cos(rot) * length);
            Vector3d vz = new Vector3d(cbxba);
            vz.scale(Math.sin(rot) * length);
            points[i].add(vx);
            points[i].add(vy);
            points[i].add(vz);
        }
        /*
         * ax = null; cbxba = null; ba = null; cb = null;
         */
        return points;
    }",Calculate 3D coordinates 1.
"public static Date parseTimestamp(String date) {
		try {
			return hasText(date) ? timestampParser.parse(date) : null;
		} catch (ParseException e) {
			logger.log(Level.WARNING, ""parseTimestamp - ParseException caught."", e);
		}

		return null;
	}",Parses a string representation of a timestamp.
"private String getSqlName(final Path path) {
		StringBuilder builder = new StringBuilder();

		boolean dialectFlag = true;
		for (Path part : relativePath(path)) {
			String s = part.toString();
			if (dialectFlag) {
				// loadPathの直下がdialectと一致する場合はその下のフォルダから名前を付ける
				dialectFlag = false;
				if (dialects.contains(s.toLowerCase())) {
					continue;
				}
			}
			builder.append(s).append(""/"");
		}

		return builder.substring(0, builder.length() - (fileExtension.length() + 1));
	}",Get the sql name from the path.
"public List<T> collect() throws Exception {
		final String id = new AbstractID().toString();
		final TypeSerializer<T> serializer = getType().createSerializer(getExecutionEnvironment().getConfig());

		this.output(new Utils.CollectHelper<>(id, serializer)).name(""collect()"");
		JobExecutionResult res = getExecutionEnvironment().execute();

		ArrayList<byte[]> accResult = res.getAccumulatorResult(id);
		if (accResult != null) {
			try {
				return SerializedListAccumulator.deserializeList(accResult, serializer);
			} catch (ClassNotFoundException e) {
				throw new RuntimeException(""Cannot find type class of collected data type."", e);
			} catch (IOException e) {
				throw new RuntimeException(""Serialization error while deserializing collected data"", e);
			}
		} else {
			throw new RuntimeException(""The call to collect() could not retrieve the DataSet."");
		}
	}",Collect the data set.
"public DeviceDescription withAttributes(java.util.Map<String, String> attributes) {
        setAttributes(attributes);
        return this;
    }",Sets the attributes for the device description.
"private void addTranslationJacobian( DMatrixRMaj R ,
										 Point3D_F64 cameraPt )
	{
		double z = cameraPt.z;
		double z2 = z*z;

		// partial T.x
		output[indexX++] = R.get(0,0)/cameraPt.z - R.get(2,0)/z2*cameraPt.x;
		output[indexY++] = R.get(1,0)/cameraPt.z - R.get(2,0)/z2*cameraPt.y;
		// partial T.y
		output[indexX++] = R.get(0,1)/cameraPt.z - R.get(2,1)/z2*cameraPt.x;
		output[indexY++] = R.get(1,1)/cameraPt.z - R.get(2,1)/z2*cameraPt.y;
		// partial T.z
		output[indexX++] = R.get(0,2)/cameraPt.z - R.get(2,2)/z2*cameraPt.x;
		output[indexY++] = R.get(1,2)/cameraPt.z - R.get(2,2)/z2*cameraPt.y;
	}",Adds the translation Jacobian to the matrix.
"private boolean hasBidirectionalAssociation(Class clazz)
    {
        ClassDescriptor cdesc;
        Collection refs;
        boolean hasBidirAssc;

        if (_withoutBidirAssc.contains(clazz))
        {
            return false;
        }

        if (_withBidirAssc.contains(clazz))
        {
            return true;
        }

        // first time we meet this class, let's look at metadata
        cdesc = _pb.getClassDescriptor(clazz);
        refs = cdesc.getObjectReferenceDescriptors();
        hasBidirAssc = false;
        REFS_CYCLE:
        for (Iterator it = refs.iterator(); it.hasNext(); )
        {
            ObjectReferenceDescriptor ord;
            ClassDescriptor relCDesc;
            Collection relRefs;

            ord = (ObjectReferenceDescriptor) it.next();
            relCDesc = _pb.getClassDescriptor(ord.getItemClass());
            relRefs = relCDesc.getObjectReferenceDescriptors();
            for (Iterator relIt = relRefs.iterator(); relIt.hasNext(); )
            {
                ObjectReferenceDescriptor relOrd;

                relOrd = (ObjectReferenceDescriptor) relIt.next();
                if (relOrd.getItemClass().equals(clazz))
                {
                    hasBidirAssc = true;
                    break REFS_CYCLE;
                }
            }
        }
        if (hasBidirAssc)
        {
            _withBidirAssc.add(clazz);
        }
        else
        {
            _withoutBidirAssc.add(clazz);
        }

        return hasBidirAssc;
    }",Returns true if the class has a single association between the two classes.
"public String words(int count) {
		StringBuilder s = new StringBuilder();
		while (count-- > 0)
			s.append(randomWord()).append("" "");
		return s.toString().trim();
	}",Returns a string of words from the random string.
"@Override
	public <T> List<T> search(String base, String filter, int searchScope, AttributesMapper<T> mapper) {
		return search(base, filter, searchScope, ALL_ATTRIBUTES, mapper);
	}",Override this method to return a list of attributes matching the filter and scope.
"public void init(Configuration configuration) throws Exception {
        if (configuration.getBootstrapPropertyResolver().getProperty(CONTEXT_TIMEOUT_NAME) != null) {
            log.debug(""Configuring context timeout with value "", configuration.getBootstrapPropertyResolver().getProperty(CONTEXT_TIMEOUT_NAME));
            try {
                contextTimeout = Long.parseLong(configuration.getBootstrapPropertyResolver().getProperty(CONTEXT_TIMEOUT_NAME));
            } catch (NumberFormatException e) {
                log.warn(""Init parameter "", CONTEXT_TIMEOUT_NAME, "" is not a parsable long, timeout will be "", "" instead"");
                contextTimeout = DEFAULT_CONTEXT_TIMEOUT;
            }
        }
    }",Initialize the context timeout.
"private BioPAXElement getIdentical(BioPAXElement bpe)
	{
		int key = bpe.hashCode();
		List<BioPAXElement> list = equivalenceMap.get(key);
		if (list != null)
		{
			for (BioPAXElement other : list)
			{
				if (other.equals(bpe))
				{
					return other;
				}
			}
		}
		return null;
	}",Gets the identical BioPAXElement.
"public boolean isOlderThan(SetElement other) {
    if (other == null) {
      return true;
    }
    return this.timestamp.isOlderThan(other.timestamp);
  }",Checks if this set element is older than other set element.
"@Override
    public StartThingRegistrationTaskResult startThingRegistrationTask(StartThingRegistrationTaskRequest request) {
        request = beforeClientExecution(request);
        return executeStartThingRegistrationTask(request);
    }",Start a Thing Registration Task.
"public ArrayList<STUNService> loadSTUNServers(java.io.InputStream stunConfigStream) {
        ArrayList<STUNService> serversList = new ArrayList<>();
        String serverName;
        int serverPort;

        try {
            XmlPullParser parser = XmlPullParserFactory.newInstance().newPullParser();
            parser.setFeature(XmlPullParser.FEATURE_PROCESS_NAMESPACES, true);
            parser.setInput(stunConfigStream, ""UTF-8"");

            int eventType = parser.getEventType();
            do {
                if (eventType == XmlPullParser.START_TAG) {

                    // Parse a STUN server definition
                    if (parser.getName().equals(""stunServer"")) {

                        serverName = null;
                        serverPort = -1;

                        // Parse the hostname
                        parser.next();
                        parser.next();
                        serverName = parser.nextText();

                        // Parse the port
                        parser.next();
                        parser.next();
                        try {
                            serverPort = Integer.parseInt(parser.nextText());
                        }
                        catch (Exception e) {
                        }

                        // If we have a valid hostname and port, add
                        // it to the list.
                        if (serverName != null && serverPort != -1) {
                            STUNService service = new STUNService(serverName, serverPort);

                            serversList.add(service);
                        }
                    }
                }
                eventType = parser.next();

            }
            while (eventType != XmlPullParser.END_DOCUMENT);

        }
        catch (XmlPullParserException e) {
            LOGGER.log(Level.SEVERE, ""Exception"", e);
        }
        catch (IOException e) {
            LOGGER.log(Level.SEVERE, ""Exception"", e);
        }

        currentServer = bestSTUNServer(serversList);

        return serversList;
    }",Load STUN servers from a stream of STUN configuration.
"public void clearCommand(Command command) {
		List controls = getControlsFor(command);
		
		for (int i=0;i<controls.size();i++) {
	    	unbindCommand((Control) controls.get(i));
	    }
	}",Clear the command.
"public void validateFile(MultipartFile file, long maxLength, String[] allowExtName) {

        if (file.isEmpty()) {
            throw new FieldException(""file"", ""您没有上传文件"", null);
        }

        // 文件大小
        if (file.getSize() < 0 || file.getSize() > maxLength) {

            throw new FieldException(""file"", ""文件不允许超过"" + String.valueOf(maxLength), null);
        }

        //
        // 处理不选择文件点击上传时，也会有MultipartFile对象，在此进行过滤
        //
        String filename = file.getOriginalFilename();

        if (filename == """") {
            throw new FieldException(""file"", ""文件名不能为空"", null);
        }

        //
        // 文件名后缀
        //
        /*
        if (filename.contains(""."")) {

            String extName = filename.substring(filename.lastIndexOf(""."")).toLowerCase();
            if (allowExtName == null || allowExtName.length == 0 || Arrays.binarySearch(allowExtName, extName) >= 0) {
            } else {
                //throw new FieldException(""file"", ""文件后缀不允许"", null);
            }
        } else {
            //throw new FieldException(""file"", ""文件后缀不允许"", null);
        }*/
    }",ValidateFile Method.
"public final EObject ruleJvmParameterizedTypeReference() throws RecognitionException {
        EObject current = null;

        Token otherlv_1=null;
        Token otherlv_3=null;
        Token otherlv_5=null;
        Token otherlv_7=null;
        Token otherlv_9=null;
        Token otherlv_11=null;
        Token otherlv_13=null;
        EObject lv_arguments_2_0 = null;

        EObject lv_arguments_4_0 = null;

        EObject lv_arguments_10_0 = null;

        EObject lv_arguments_12_0 = null;



        	enterRule();

        try {
            // InternalXtype.g:270:2: ( ( ( ( ruleQualifiedName ) ) ( ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )* )? ) )
            // InternalXtype.g:271:2: ( ( ( ruleQualifiedName ) ) ( ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )* )? )
            {
            // InternalXtype.g:271:2: ( ( ( ruleQualifiedName ) ) ( ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )* )? )
            // InternalXtype.g:272:3: ( ( ruleQualifiedName ) ) ( ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )* )?
            {
            // InternalXtype.g:272:3: ( ( ruleQualifiedName ) )
            // InternalXtype.g:273:4: ( ruleQualifiedName )
            {
            // InternalXtype.g:273:4: ( ruleQualifiedName )
            // InternalXtype.g:274:5: ruleQualifiedName
            {
            if ( state.backtracking==0 ) {

              					if (current==null) {
              						current = createModelElement(grammarAccess.getJvmParameterizedTypeReferenceRule());
              					}
              				
            }
            if ( state.backtracking==0 ) {

              					newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getTypeJvmTypeCrossReference_0_0());
              				
            }
            pushFollow(FOLLOW_9);
            ruleQualifiedName();

            state._fsp--;
            if (state.failed) return current;
            if ( state.backtracking==0 ) {

              					afterParserOrEnumRuleCall();
              				
            }

            }


            }

            // InternalXtype.g:288:3: ( ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )* )?
            int alt10=2;
            int LA10_0 = input.LA(1);

            if ( (LA10_0==16) && (synpred2_InternalXtype())) {
                alt10=1;
            }
            switch (alt10) {
                case 1 :
                    // InternalXtype.g:289:4: ( ( '<' )=>otherlv_1= '<' ) ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) ) (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )* otherlv_5= '>' ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )*
                    {
                    // InternalXtype.g:289:4: ( ( '<' )=>otherlv_1= '<' )
                    // InternalXtype.g:290:5: ( '<' )=>otherlv_1= '<'
                    {
                    otherlv_1=(Token)match(input,16,FOLLOW_10); if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      					newLeafNode(otherlv_1, grammarAccess.getJvmParameterizedTypeReferenceAccess().getLessThanSignKeyword_1_0());
                      				
                    }

                    }

                    // InternalXtype.g:296:4: ( (lv_arguments_2_0= ruleJvmArgumentTypeReference ) )
                    // InternalXtype.g:297:5: (lv_arguments_2_0= ruleJvmArgumentTypeReference )
                    {
                    // InternalXtype.g:297:5: (lv_arguments_2_0= ruleJvmArgumentTypeReference )
                    // InternalXtype.g:298:6: lv_arguments_2_0= ruleJvmArgumentTypeReference
                    {
                    if ( state.backtracking==0 ) {

                      						newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsJvmArgumentTypeReferenceParserRuleCall_1_1_0());
                      					
                    }
                    pushFollow(FOLLOW_11);
                    lv_arguments_2_0=ruleJvmArgumentTypeReference();

                    state._fsp--;
                    if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      						if (current==null) {
                      							current = createModelElementForParent(grammarAccess.getJvmParameterizedTypeReferenceRule());
                      						}
                      						add(
                      							current,
                      							""arguments"",
                      							lv_arguments_2_0,
                      							""org.eclipse.xtext.xbase.Xtype.JvmArgumentTypeReference"");
                      						afterParserOrEnumRuleCall();
                      					
                    }

                    }


                    }

                    // InternalXtype.g:315:4: (otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) ) )*
                    loop6:
                    do {
                        int alt6=2;
                        int LA6_0 = input.LA(1);

                        if ( (LA6_0==13) ) {
                            alt6=1;
                        }


                        switch (alt6) {
                    	case 1 :
                    	    // InternalXtype.g:316:5: otherlv_3= ',' ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) )
                    	    {
                    	    otherlv_3=(Token)match(input,13,FOLLOW_10); if (state.failed) return current;
                    	    if ( state.backtracking==0 ) {

                    	      					newLeafNode(otherlv_3, grammarAccess.getJvmParameterizedTypeReferenceAccess().getCommaKeyword_1_2_0());
                    	      				
                    	    }
                    	    // InternalXtype.g:320:5: ( (lv_arguments_4_0= ruleJvmArgumentTypeReference ) )
                    	    // InternalXtype.g:321:6: (lv_arguments_4_0= ruleJvmArgumentTypeReference )
                    	    {
                    	    // InternalXtype.g:321:6: (lv_arguments_4_0= ruleJvmArgumentTypeReference )
                    	    // InternalXtype.g:322:7: lv_arguments_4_0= ruleJvmArgumentTypeReference
                    	    {
                    	    if ( state.backtracking==0 ) {

                    	      							newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsJvmArgumentTypeReferenceParserRuleCall_1_2_1_0());
                    	      						
                    	    }
                    	    pushFollow(FOLLOW_11);
                    	    lv_arguments_4_0=ruleJvmArgumentTypeReference();

                    	    state._fsp--;
                    	    if (state.failed) return current;
                    	    if ( state.backtracking==0 ) {

                    	      							if (current==null) {
                    	      								current = createModelElementForParent(grammarAccess.getJvmParameterizedTypeReferenceRule());
                    	      							}
                    	      							add(
                    	      								current,
                    	      								""arguments"",
                    	      								lv_arguments_4_0,
                    	      								""org.eclipse.xtext.xbase.Xtype.JvmArgumentTypeReference"");
                    	      							afterParserOrEnumRuleCall();
                    	      						
                    	    }

                    	    }


                    	    }


                    	    }
                    	    break;

                    	default :
                    	    break loop6;
                        }
                    } while (true);

                    otherlv_5=(Token)match(input,17,FOLLOW_12); if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      				newLeafNode(otherlv_5, grammarAccess.getJvmParameterizedTypeReferenceAccess().getGreaterThanSignKeyword_1_3());
                      			
                    }
                    // InternalXtype.g:344:4: ( ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )? )*
                    loop9:
                    do {
                        int alt9=2;
                        int LA9_0 = input.LA(1);

                        if ( (LA9_0==18) && (synpred3_InternalXtype())) {
                            alt9=1;
                        }


                        switch (alt9) {
                    	case 1 :
                    	    // InternalXtype.g:345:5: ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) ) ( ( ruleValidID ) ) ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )?
                    	    {
                    	    // InternalXtype.g:345:5: ( ( ( () '.' ) )=> ( () otherlv_7= '.' ) )
                    	    // InternalXtype.g:346:6: ( ( () '.' ) )=> ( () otherlv_7= '.' )
                    	    {
                    	    // InternalXtype.g:352:6: ( () otherlv_7= '.' )
                    	    // InternalXtype.g:353:7: () otherlv_7= '.'
                    	    {
                    	    // InternalXtype.g:353:7: ()
                    	    // InternalXtype.g:354:8: 
                    	    {
                    	    if ( state.backtracking==0 ) {

                    	      								current = forceCreateModelElementAndSet(
                    	      									grammarAccess.getJvmParameterizedTypeReferenceAccess().getJvmInnerTypeReferenceOuterAction_1_4_0_0_0(),
                    	      									current);
                    	      							
                    	    }

                    	    }

                    	    otherlv_7=(Token)match(input,18,FOLLOW_13); if (state.failed) return current;
                    	    if ( state.backtracking==0 ) {

                    	      							newLeafNode(otherlv_7, grammarAccess.getJvmParameterizedTypeReferenceAccess().getFullStopKeyword_1_4_0_0_1());
                    	      						
                    	    }

                    	    }


                    	    }

                    	    // InternalXtype.g:366:5: ( ( ruleValidID ) )
                    	    // InternalXtype.g:367:6: ( ruleValidID )
                    	    {
                    	    // InternalXtype.g:367:6: ( ruleValidID )
                    	    // InternalXtype.g:368:7: ruleValidID
                    	    {
                    	    if ( state.backtracking==0 ) {

                    	      							if (current==null) {
                    	      								current = createModelElement(grammarAccess.getJvmParameterizedTypeReferenceRule());
                    	      							}
                    	      						
                    	    }
                    	    if ( state.backtracking==0 ) {

                    	      							newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getTypeJvmTypeCrossReference_1_4_1_0());
                    	      						
                    	    }
                    	    pushFollow(FOLLOW_14);
                    	    ruleValidID();

                    	    state._fsp--;
                    	    if (state.failed) return current;
                    	    if ( state.backtracking==0 ) {

                    	      							afterParserOrEnumRuleCall();
                    	      						
                    	    }

                    	    }


                    	    }

                    	    // InternalXtype.g:382:5: ( ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>' )?
                    	    int alt8=2;
                    	    int LA8_0 = input.LA(1);

                    	    if ( (LA8_0==16) && (synpred4_InternalXtype())) {
                    	        alt8=1;
                    	    }
                    	    switch (alt8) {
                    	        case 1 :
                    	            // InternalXtype.g:383:6: ( ( '<' )=>otherlv_9= '<' ) ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) ) (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )* otherlv_13= '>'
                    	            {
                    	            // InternalXtype.g:383:6: ( ( '<' )=>otherlv_9= '<' )
                    	            // InternalXtype.g:384:7: ( '<' )=>otherlv_9= '<'
                    	            {
                    	            otherlv_9=(Token)match(input,16,FOLLOW_10); if (state.failed) return current;
                    	            if ( state.backtracking==0 ) {

                    	              							newLeafNode(otherlv_9, grammarAccess.getJvmParameterizedTypeReferenceAccess().getLessThanSignKeyword_1_4_2_0());
                    	              						
                    	            }

                    	            }

                    	            // InternalXtype.g:390:6: ( (lv_arguments_10_0= ruleJvmArgumentTypeReference ) )
                    	            // InternalXtype.g:391:7: (lv_arguments_10_0= ruleJvmArgumentTypeReference )
                    	            {
                    	            // InternalXtype.g:391:7: (lv_arguments_10_0= ruleJvmArgumentTypeReference )
                    	            // InternalXtype.g:392:8: lv_arguments_10_0= ruleJvmArgumentTypeReference
                    	            {
                    	            if ( state.backtracking==0 ) {

                    	              								newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsJvmArgumentTypeReferenceParserRuleCall_1_4_2_1_0());
                    	              							
                    	            }
                    	            pushFollow(FOLLOW_11);
                    	            lv_arguments_10_0=ruleJvmArgumentTypeReference();

                    	            state._fsp--;
                    	            if (state.failed) return current;
                    	            if ( state.backtracking==0 ) {

                    	              								if (current==null) {
                    	              									current = createModelElementForParent(grammarAccess.getJvmParameterizedTypeReferenceRule());
                    	              								}
                    	              								add(
                    	              									current,
                    	              									""arguments"",
                    	              									lv_arguments_10_0,
                    	              									""org.eclipse.xtext.xbase.Xtype.JvmArgumentTypeReference"");
                    	              								afterParserOrEnumRuleCall();
                    	              							
                    	            }

                    	            }


                    	            }

                    	            // InternalXtype.g:409:6: (otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) ) )*
                    	            loop7:
                    	            do {
                    	                int alt7=2;
                    	                int LA7_0 = input.LA(1);

                    	                if ( (LA7_0==13) ) {
                    	                    alt7=1;
                    	                }


                    	                switch (alt7) {
                    	            	case 1 :
                    	            	    // InternalXtype.g:410:7: otherlv_11= ',' ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) )
                    	            	    {
                    	            	    otherlv_11=(Token)match(input,13,FOLLOW_10); if (state.failed) return current;
                    	            	    if ( state.backtracking==0 ) {

                    	            	      							newLeafNode(otherlv_11, grammarAccess.getJvmParameterizedTypeReferenceAccess().getCommaKeyword_1_4_2_2_0());
                    	            	      						
                    	            	    }
                    	            	    // InternalXtype.g:414:7: ( (lv_arguments_12_0= ruleJvmArgumentTypeReference ) )
                    	            	    // InternalXtype.g:415:8: (lv_arguments_12_0= ruleJvmArgumentTypeReference )
                    	            	    {
                    	            	    // InternalXtype.g:415:8: (lv_arguments_12_0= ruleJvmArgumentTypeReference )
                    	            	    // InternalXtype.g:416:9: lv_arguments_12_0= ruleJvmArgumentTypeReference
                    	            	    {
                    	            	    if ( state.backtracking==0 ) {

                    	            	      									newCompositeNode(grammarAccess.getJvmParameterizedTypeReferenceAccess().getArgumentsJvmArgumentTypeReferenceParserRuleCall_1_4_2_2_1_0());
                    	            	      								
                    	            	    }
                    	            	    pushFollow(FOLLOW_11);
                    	            	    lv_arguments_12_0=ruleJvmArgumentTypeReference();

                    	            	    state._fsp--;
                    	            	    if (state.failed) return current;
                    	            	    if ( state.backtracking==0 ) {

                    	            	      									if (current==null) {
                    	            	      										current = createModelElementForParent(grammarAccess.getJvmParameterizedTypeReferenceRule());
                    	            	      									}
                    	            	      									add(
                    	            	      										current,
                    	            	      										""arguments"",
                    	            	      										lv_arguments_12_0,
                    	            	      										""org.eclipse.xtext.xbase.Xtype.JvmArgumentTypeReference"");
                    	            	      									afterParserOrEnumRuleCall();
                    	            	      								
                    	            	    }

                    	            	    }


                    	            	    }


                    	            	    }
                    	            	    break;

                    	            	default :
                    	            	    break loop7;
                    	                }
                    	            } while (true);

                    	            otherlv_13=(Token)match(input,17,FOLLOW_12); if (state.failed) return current;
                    	            if ( state.backtracking==0 ) {

                    	              						newLeafNode(otherlv_13, grammarAccess.getJvmParameterizedTypeReferenceAccess().getGreaterThanSignKeyword_1_4_2_3());
                    	              					
                    	            }

                    	            }
                    	            break;

                    	    }


                    	    }
                    	    break;

                    	default :
                    	    break loop9;
                        }
                    } while (true);


                    }
                    break;

            }


            }


            }

            if ( state.backtracking==0 ) {

              	leaveRule();

            }
        }

            catch (RecognitionException re) {
                recover(input,re);
                appendSkippedTokens();
            }
        finally {
        }
        return current;
    }",Capture the contents of a DOT rule in the sequence of a DOT rule.
"@Deprecated
    @Override
    protected int writeDeltaTo(int jumpTarget) {
        int i=charsLength-jumpTarget;
        assert(i>=0);
        if(i<=CharsTrie.kMaxOneUnitDelta) {
            return write(i);
        }
        int length;
        if(i<=CharsTrie.kMaxTwoUnitDelta) {
            intUnits[0]=(char)(CharsTrie.kMinTwoUnitDeltaLead+(i>>16));
            length=1;
        } else {
            intUnits[0]=(char)(CharsTrie.kThreeUnitDeltaLead);
            intUnits[1]=(char)(i>>16);
            length=2;
        }
        intUnits[length++]=(char)i;
        return write(intUnits, length);
    }",Write delta to.
"public Location update(Map<String, Object> params) throws StripeException {
    return update(params, (RequestOptions) null);
  }",Updates an existing location.
"private final void donCompletion( CountedCompleter caller ) {   // Distributed completion
    assert _lo == null || _lo.isDone();
    assert _hi == null || _hi.isDone();
    // Fold up results from left & right subtrees
    if( _lo    != null ) reduce2(_lo.get());
    if( _hi    != null ) reduce2(_hi.get());
    if( _local != null ) reduce2(_local   );
    // Note: in theory (valid semantics) we could push these ""over the wire""
    // and block for them as we're blocking for the top-level initial split.
    // However, that would require sending ""isDone"" flags over the wire also.
    // MUCH simpler to just block for them all now, and send over the empty set
    // of not-yet-blocked things.
    if(_local != null && _local._fs != null )
      _local._fs.blockForPending(); // Block on all other pending tasks, also
    _keys = null;                   // Do not return _keys over wire
    if( _top_level ) postGlobal();
  }",This method is called by the completion thread.
"synchronized void setDeadLetters(final DeadLetters deadLetters) {
    if (deadLetters != null && this.deadLetters != null) {
      deadLetters.stop();
      throw new IllegalStateException(""Dead letters already exists."");
    }

    this.deadLetters = deadLetters;
  }",Sets the dead letters.
"@Override
    public CreateLoggerDefinitionVersionResult createLoggerDefinitionVersion(CreateLoggerDefinitionVersionRequest request) {
        request = beforeClientExecution(request);
        return executeCreateLoggerDefinitionVersion(request);
    }",Creates a version of a logger definition.
"public RemoteBaseSession makeRemoteSession(String strSessionClassName) throws RemoteException
    {
        BaseTransport transport = this.createProxyTransport(MAKE_REMOTE_SESSION);
        transport.addParam(NAME, strSessionClassName);
        String strClassAndID = (String)transport.sendMessageAndGetReply();
        return this.checkForSession(strClassAndID);
    }",Make this remote session.
"public static <E> Optional<E> get(final Iterable<E> iterable, final int position) {
        checkNotNull(iterable, ""Get requires an iterable"");
        if (position < 0) {
            return Optional.empty();
        }

        int iterablePosition = 0;
        for (E anIterable : iterable) {
            if (iterablePosition == position) {
                return of(anIterable);
            }
            iterablePosition++;
        }

        return Optional.empty();
    }",Gets the first element of an iterable in the collection at the specified position.
"public void copyDocFiles(Configuration configuration, PackageDoc pd) {
        Location locn = configuration.getLocationForPackage(pd);
        copyDocFiles(configuration, locn, DocPath.forPackage(pd).resolve(DocPaths.DOC_FILES));
    }",Copy the DocFiles for a package.
"private static void buildTransformers2_1_0(ResourceTransformationDescriptionBuilder builder) {
        ResourceTransformationDescriptionBuilder hornetqServer = builder.addChildResource(pathElement(HORNETQ_SERVER));
        ResourceTransformationDescriptionBuilder addressSetting = hornetqServer.addChildResource(AddressSettingDefinition.PATH);
        rejectDefinedAttributeWithDefaultValue(addressSetting, MAX_REDELIVERY_DELAY, REDELIVERY_MULTIPLIER);

        ResourceTransformationDescriptionBuilder bridge = hornetqServer.addChildResource(BridgeDefinition.PATH);
        bridge.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);


        ResourceTransformationDescriptionBuilder clusterConnection = hornetqServer.addChildResource(ClusterConnectionDefinition.PATH);
        clusterConnection.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);

        ResourceTransformationDescriptionBuilder connectionFactory = hornetqServer.addChildResource(ConnectionFactoryDefinition.PATH);
        connectionFactory.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);

        ResourceTransformationDescriptionBuilder pooledConnectionFactory = hornetqServer.addChildResource(PooledConnectionFactoryDefinition.PATH);
        pooledConnectionFactory.getAttributeBuilder().setValueConverter(new DoubleToBigDecimalConverter(), RETRY_INTERVAL_MULTIPLIER);
    }",Build the transformers for the HORNETQ 2. 0 specification.
"public Blade listen(@NonNull String address, int port) {
        Assert.greaterThan(port, 0, ""server port not is negative number."");
        this.environment.set(ENV_KEY_SERVER_ADDRESS, address);
        this.environment.set(ENV_KEY_SERVER_PORT, port);
        return this;
    }",Listen to the specified server address and port.
"protected void getAllNamesAux(final List<String> vec) {
        vec.addAll(this.variables.keySet());
        if ( methods != null )
            vec.addAll(this.methods.keySet());
        if (this.parent != null)
            this.parent.getAllNamesAux(vec);
    }",Get all names aux.
"protected RunClassInSeparateJvmMachine buildRunClassInSeparateJvmMachine(
            String name,
            String classNameWithMainToRun,
            List<String> classpath, 
            List<String> jvmArguments,
            File mavenBaseDir) {
        return new RunClassInSeparateJvmMachine(
            name,
            classNameWithMainToRun,
            classpath,
            buildJvmArguments(),
            mavenBaseDir
        );
    }",Build a RunClassInSeparateJvmMachine object.
"public SDVariable multiHeadDotProductAttention(String name, SDVariable queries, SDVariable keys, SDVariable values, SDVariable Wq, SDVariable Wk, SDVariable Wv, SDVariable Wo, SDVariable mask, boolean scaled){
        final SDVariable result = f().multiHeadDotProductAttention(queries, keys, values, Wq, Wk, Wv, Wo, mask, scaled);
        return updateVariableNameAndReference(result, name);
    }",Multi head dot product attention operation.
"@Override
	public synchronized boolean addEntry(Principal caller, Principal principal, Permission permission)
	{
		return addEntry(caller, new SecurityAccessControl(principal, permission));
	}",Add a new SecurityAccessControl entry to the list of entries.
"private void add_block_to_freelist(Block block, int ql_index)
    {
        block.next = ql_heads[ql_index].first_block;
        ql_heads[ql_index].first_block = block;
        ql_heads[ql_index].length++;
        if (ql_heads[ql_index].length == 1) {
            nonempty_lists++;
        }
    }",Add a block to the freelist.
"public String java(GeneratedPackage generatedPackage, String javaClassName) {
        generatedPackageRestriction(generatedPackage);
        return java(generatedPackage.getPackageName(), javaClassName);
    }",Get the java code for the given generated package and class name.
"public static Rectangle getBoundaryAbsolute(Tile upperLeft, Tile lowerRight) {
        return new Rectangle(upperLeft.getOrigin().x, upperLeft.getOrigin().y, lowerRight.getOrigin().x + upperLeft.tileSize, lowerRight.getOrigin().y + upperLeft.tileSize);
    }",Get the bounding rectangle absolute from the tile boundaries.
"public BaseMessageFilter createDefaultFilter(JMessageListener listener)
    {
        BaseMessageFilter messageFilter = null;
        String strQueueName = MessageConstants.RECORD_QUEUE_NAME; // Default queue name=
        String strQueueType = MessageConstants.INTRANET_QUEUE;    // Default queue type
        if (m_baseMessageQueue != null)
        {
            strQueueName = m_baseMessageQueue.getQueueName();
            strQueueType = m_baseMessageQueue.getQueueType();
        }
        messageFilter = new BaseMessageFilter(strQueueName, strQueueType, null, null);    // Take all messages
        messageFilter.addMessageListener(listener);
        //xif (bAddToReceiver)  // Already added at previous line.
        //x    this.addMessageFilter(messageFilter);
        return messageFilter;
    }",Create a default message filter.
"private static int calculateBitRate(int mpegVer, int layer, int code) {
        int[] arr = null;
        if (mpegVer == AudioFrame.MPEG_V1) {
            switch (layer) {
                case AudioFrame.LAYER_1:
                    arr = BIT_RATE_MPEG1_L1;
                    break;
                case AudioFrame.LAYER_2:
                    arr = BIT_RATE_MPEG1_L2;
                    break;
                case AudioFrame.LAYER_3:
                    arr = BIT_RATE_MPEG1_L3;
                    break;
            }
        } else {
            if (layer == AudioFrame.LAYER_1) {
                arr = BIT_RATE_MPEG2_L1;
            } else {
                arr = BIT_RATE_MPEG2_L2;
            }
        }
        return arr[code];
    }",Calculate the bit rate for a given frame.
"public static <E> Page<E> offsetPage(int offset, int limit) {
        return offsetPage(offset, limit, DEFAULT_COUNT);
    }",Create an offset page.
"private void validateInterceptorBindings() throws EJBConfigurationException
    {
        final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();
        if (isTraceOn && tc.isEntryEnabled())
        {
            Tr.entry(tc, ""validateInterceptorBindings"");
        }

        // d630872 - Build a list of methods that can be the target of an
        // interceptor.  This includes all business methods (AroundInvoke) and
        // all timer methods (AroundTimeout).
        List<Method> interceptableMethods = new ArrayList<Method>(ivEJBMethodInfoMap.keySet());
        if (ivBmd.timedMethodInfos != null) // d630872.1
        {
            for (EJBMethodInfoImpl info : ivBmd.timedMethodInfos)
            {
                interceptableMethods.add(info.getMethod());
            }
        }

        // For each InterceptorBinding from WCCM.
        for (EJBInterceptorBinding binding : ivInterceptorBinding)
        {
            String ejbName = binding.getEJBName();
            EJBInterceptorBinding.BindingStyle bindingStyle = binding.getBindingStyle();
            if (ejbName.equals(""*""))
            {
                // Style 1 binding. Is this the first style 1 InterceptorBinding?
                if (ivModuleInterceptorBinding == null)
                {
                    // Save reference to module-level binding for future use.
                    ivModuleInterceptorBinding = binding;
                }
                else
                {
                    // CNTR0245E: The {0} module of the {1) application has more than one style 1 interceptor-binding
                    // in the deployment descriptor. Only one style 1 interceptor-binding is allowed.

                    J2EEName j2eeName = ivEJBModuleMetaDataImpl.getJ2EEName();
                    String message = ""The "" + j2eeName.getModule() + "" module of the "" + j2eeName.getApplication()
                                     + "" application has more than one style 1 interceptor-binding in the deployment""
                                     + "" deployment descriptor. Only one style 1 interceptor-binding is allowed"";
                    Tr.error(tc, ""DUPLICATE_STYLE_1_INTERCEPTOR_BINDING_CNTR0245E""
                             , new Object[] { j2eeName.getModule(), j2eeName.getApplication() }); //d472939
                    throw new EJBConfigurationException(message); // d463727
                }
            }
            else
            {
                // Binding not for the module, so only process those interceptor bindings that are
                // for the EJB class specified by the caller.
                if (ejbName.equals(ivEjbName))
                {
                    if (bindingStyle == EJBInterceptorBinding.BindingStyle.STYLE2)
                    {
                        // This is a style 2 interceptor-binding that applies to the class.
                        // Is this the first style 2 interceptor binding for this EJB?
                        if (ivClassInterceptorBinding == null)
                        {
                            // Yep, save reference style 2 for future use.
                            ivClassInterceptorBinding = binding;
                        }
                        else
                        {
                            // Nope, then we need to validate and merge second style 2
                            // with the first style 2 interceptor binding.
                            EJBInterceptorBinding binding1 = ivClassInterceptorBinding; // d457352
                            ivClassInterceptorBinding = validateAndMergeStyle2Bindings(binding1, binding); // d457352
                        }
                    }
                    else if (bindingStyle == EJBInterceptorBinding.BindingStyle.STYLE3)
                    {
                        // This is a style 3 interceptor-binding that applies to all business
                        // methods with the method name specified by method-name element.
                        // Put style 3 interceptor binding into the map.
                        String methodName = binding.getMethodName();
                        EJBInterceptorBinding oldBinding = ivStyle3InterceptorBindingMap.put(methodName, binding);

                        // Did the put replace an existing map entry?
                        if (oldBinding != null)
                        {
                            // Yep, tthis was NOT the first style 3 binding for this EJB.  We need to validate and
                            // merge second style 3 with the first style 3 interceptor binding.
                            EJBInterceptorBinding merged;
                            merged = validateAndMergeStyle3Or4Bindings(methodName, null, oldBinding, binding); // d457352

                            // No exception was thrown, so merger is valid. Replace map entry with the merged binding.
                            ivStyle3InterceptorBindingMap.put(methodName, merged); // d457352
                        }
                        else
                        {
                            // Nope, this must be the first style 3 binding for this EJB. We must
                            // verify there is at least 1 business method exist by this method name.
                            boolean notFound = true;
                            for (Method m : interceptableMethods) // d630872
                            {
                                // Does method name match?
                                if (m.getName().equals(methodName))
                                {
                                    // Yep, indicate we found a business method and exit the loop.
                                    notFound = false;
                                    break;
                                }
                            }

                            // Log error and throw exception if business method was not found.
                            if (notFound)
                            {
                                if (isTraceOn && tc.isDebugEnabled())
                                {
                                    Tr.debug(tc, ""method not found for interceptor binding"");
                                    binding.dump();
                                }

                                // CNTR0244E: The {0} method name is not found in one of the business interfaces
                                // of the {1} enterprise bean. A style {2} interceptor-binding element requires
                                // the method to be a business method of the enterprise bean.
                                String j2eeName = ivJ2EEName.toString();
                                Tr.error(tc, ""BUSINESS_METHOD_NOT_FOUND_FOR_INTERCEPTOR_BINDING_CNTR0244E""
                                         , new Object[] { methodName, j2eeName, ""3"" }); //d472939

                                String message = ""The "" + methodName + "" method name is not found ""
                                                 + "" in one of the business interfaces of the "" + j2eeName
                                                 + "" enterprise bean. A style 3 interceptor-binding element requires""
                                                 + "" the method to be a business method of the enterprise bean"";
                                throw new EJBConfigurationException(message); // d463727
                            }
                        }
                    }
                    else if (bindingStyle == EJBInterceptorBinding.BindingStyle.STYLE4)
                    {
                        // This is a style 4 interceptor-binding that applies to a business method
                        // with a specific method signature. Verify it does not duplicate a style 3 binding.
                        String methodName = binding.getMethodName();
                        List<String> methodParms = binding.getMethodParms();
                        String signature = methodSignature(methodName, methodParms);
                        signature = normalizeSignature(signature.trim());

                        // d472972 start
                        // Put style 4 interceptor binding into the map.
                        EJBInterceptorBinding oldBinding = ivStyle4InterceptorBindingMap.put(signature, binding);

                        // Did the put replace an existing map entry?
                        if (oldBinding != null)
                        {
                            // Yep, this was NOT the first style 4 binding for this EJB method.  We need to validate and
                            // merge second style 4 with the first style 4 interceptor binding.
                            EJBInterceptorBinding merged;
                            merged = validateAndMergeStyle3Or4Bindings(methodName, signature, oldBinding, binding); // d457352

                            // No exception was thrown, so merger is valid. Replace map entry with the merged binding.
                            if (isTraceOn && tc.isDebugEnabled())
                            {
                                Tr.debug(tc, ""replaced style 4 for method signature: "" + signature);
                            }
                            ivStyle4InterceptorBindingMap.put(signature, merged);
                        }
                        else
                        {
                            // This is first style 4 binding for this EJB method.
                            // Verify there is a business method by this method name and signature.
                            if (isTraceOn && tc.isDebugEnabled())
                            {
                                Tr.debug(tc, ""added style 4 for method signature: "" + signature);
                            }
                            boolean notFound = true;
                            for (Method m : interceptableMethods) // d630872
                            {
                                // Does method name and signature match?
                                if (m.getName().equals(methodName))
                                {
                                    String methodSignature = MethodAttribUtils.methodSignature(m);
                                    if (signature.equals(methodSignature))
                                    {
                                        // Yep, indicate we found the business method and exit the loop.
                                        notFound = false;
                                        break;
                                    }
                                }
                            }

                            // Log error and throw exception if business method was not found.
                            if (notFound)
                            {
                                if (isTraceOn && tc.isDebugEnabled())
                                {
                                    Tr.debug(tc, ""method not found for interceptor binding"");
                                    binding.dump();
                                }

                                // CNTR0244E: The {0} method name is not found in one of the business interfaces
                                // of the {1} enterprise bean. A style {2} interceptor-binding element requires
                                // the method to be a business method of the enterprise bean.
                                String j2eeName = ivJ2EEName.toString();
                                Tr.error(tc, ""BUSINESS_METHOD_NOT_FOUND_FOR_INTERCEPTOR_BINDING_CNTR0244E""
                                         , new Object[] { methodName, j2eeName, ""4"" }); //d472939

                                String message = ""The "" + methodName + "" method name is not found ""
                                                 + "" in one of the business interfaces of the "" + j2eeName
                                                 + "" enterprise bean. A style 4 interceptor-binding element requires""
                                                 + "" the method to be a business method of the enterprise bean"";
                                throw new EJBConfigurationException(message); // d463727
                            }
                        } // d472972 end
                    }
                }
            }
        }

        if (isTraceOn && tc.isEntryEnabled())
        {
            Tr.exit(tc, ""validateInterceptorBindings"");
        }
    }",Validate the interceptor bindings.
"public void command_inout_asynch(String cmdname, CallBack cb) throws DevFailed {
        deviceProxyDAO.command_inout_asynch(this, cmdname, cb);
    }",Execute a command in the device in the device.
"public void updateMask(AclActions groupActions) {
    AclActions result = new AclActions(groupActions);

    for (Map.Entry<String, AclActions> kv : mNamedUserActions.entrySet()) {
      AclActions userAction = kv.getValue();
      result.merge(userAction);

      for (AclAction action : AclAction.values()) {
        if (result.contains(action) || userAction.contains(action)) {
          result.add(action);
        }
      }
    }

    for (Map.Entry<String, AclActions> kv : mNamedGroupActions.entrySet()) {
      AclActions userAction = kv.getValue();
      result.merge(userAction);

      for (AclAction action : AclAction.values()) {
        if (result.contains(action) || userAction.contains(action)) {
          result.add(action);
        }
      }
    }

    mMaskActions = result;
  }",Update the mask.
"public void setData(byte[] data, int offset, int length) {
        if (immutable) {
            throw new IllegalStateException(ERR_MSG_IMMUTABLE);
        }
        this.data = new byte[length];
        System.arraycopy(data, offset, this.data, 0, length);
    }",Sets the data of the record.
"public void marshall(GetContentModerationRequest getContentModerationRequest, ProtocolMarshaller protocolMarshaller) {

        if (getContentModerationRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(getContentModerationRequest.getJobId(), JOBID_BINDING);
            protocolMarshaller.marshall(getContentModerationRequest.getMaxResults(), MAXRESULTS_BINDING);
            protocolMarshaller.marshall(getContentModerationRequest.getNextToken(), NEXTTOKEN_BINDING);
            protocolMarshaller.marshall(getContentModerationRequest.getSortBy(), SORTBY_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given parameter object.
"public Criteria within(Circle circle) {

		Assert.notNull(circle, ""Circle for 'within' must not be 'null'."");
		return within(circle.getCenter(), circle.getRadius());
	}",Add a circle to the criteria.
"public <T> JavaRDD<T> createJavaRDD(
            ExtractorConfig<T> config) {
        return new DeepJavaRDD<>((DeepRDD<T, ExtractorConfig<T>>) createRDD(config));
    }",Create a JavaRDD of a CRARA instance.
"public static File getTempDir(){
        String p = System.getProperty(ND4JSystemProperties.ND4J_TEMP_DIR_PROPERTY);
        if(p == null || p.isEmpty()){
            return new File(System.getProperty(""java.io.tmpdir""));
        } else {
            return new File(p);
        }
    }",Gets the temp directory.
"private <T> Single<PollingState<T>> pollPutOrPatchSingleAsync(final PollingState<T> pollingState, final Type resourceType) {
        pollingState.withResourceType(resourceType);
        pollingState.withSerializerAdapter(restClient().serializerAdapter());
        if (pollingState.isStatusTerminal()) {
            if (pollingState.isStatusSucceeded() && pollingState.resource() == null) {
                return updateStateFromGetResourceOperationAsync(pollingState, pollingState.putOrPatchResourceUri()).toSingle();
            }
            return Single.just(pollingState);
        }
        return putOrPatchPollingDispatcher(pollingState, pollingState.putOrPatchResourceUri())
                .map(new Func1<PollingState<T>, PollingState<T>>() {
                    @Override
                    public PollingState<T> call(PollingState<T> tPollingState) {
                        tPollingState.throwCloudExceptionIfInFailedState();
                        return tPollingState;
                    }
                })
                .flatMap(new Func1<PollingState<T>, Observable<PollingState<T>>>() {
                    @Override
                    public Observable<PollingState<T>> call(PollingState<T> tPollingState) {
                        if (pollingState.isStatusSucceeded() && pollingState.resource() == null) {
                            return updateStateFromGetResourceOperationAsync(pollingState, pollingState.putOrPatchResourceUri());
                        }
                        return Observable.just(tPollingState);
                    }
                })
                .toSingle();
    }",Poll put or patch single async.
"public static long getIdlenessStartTime(Record record) {
        long lastAccessTime = record.getLastAccessTime();
        return lastAccessTime <= 0 ? record.getCreationTime() : lastAccessTime;
    }",Gets the idleness start time of a record.
"public double calculateDistance2(DoubleSolution individual, double[] lambda) {

    double distance;
    double distanceSum = 0.0;

    double[] vecInd = new double[problem.getNumberOfObjectives()];
    double[] normalizedObj = new double[problem.getNumberOfObjectives()];

    for (int i = 0; i < problem.getNumberOfObjectives(); i++) {
      distanceSum += individual.getObjective(i);
    }
    for (int i = 0; i < problem.getNumberOfObjectives(); i++) {
      normalizedObj[i] = individual.getObjective(i) / distanceSum;
    }
    for (int i = 0; i < problem.getNumberOfObjectives(); i++) {
      vecInd[i] = normalizedObj[i] - lambda[i];
    }

    distance = norm_vector(vecInd);

    return distance;
  }",Calculate the distance between two solutions
"@Override
   public CompletableFuture<Object> invokeAsync() throws Throwable {
      // make sure the get command doesn't perform a remote call
      // as our caller is already calling the ClusteredGetCommand on all the relevant nodes
      // CACHE_MODE_LOCAL is not used as it can be used when we want to ignore the ownership with respect to reads
      long flagBitSet = EnumUtil.bitSetOf(Flag.SKIP_REMOTE_LOOKUP);
      GetCacheEntryCommand command = commandsFactory.buildGetCacheEntryCommand(key, segment,
            EnumUtil.mergeBitSets(flagBitSet, getFlagsBitSet()));
      command.setTopologyId(topologyId);
      InvocationContext invocationContext = icf.createRemoteInvocationContextForCommand(command, getOrigin());
      CompletableFuture<Object> future = invoker.invokeAsync(invocationContext, command);
      return future.thenApply(rv -> {
         if (trace) log.tracef(""Return value for key=%s is %s"", key, rv);
         //this might happen if the value was fetched from a cache loader
         if (rv instanceof MVCCEntry) {
            MVCCEntry mvccEntry = (MVCCEntry) rv;
            return entryFactory.createValue(mvccEntry);
         } else if (rv instanceof InternalCacheEntry) {
            InternalCacheEntry internalCacheEntry = (InternalCacheEntry) rv;
            return internalCacheEntry.toInternalCacheValue();
         } else { // null or Response
            return rv;
         }
      });
   }",This method is invoked asynchronously.
"@Nullable
    private static ParameterizedType asParameterizedType(Type type, Class<?> expectedType) {
        ParameterizedType result = null;
        if (isParameterizedType(type)) {
            ParameterizedType parameterizedType = (ParameterizedType) type;
            if (expectedType.isAssignableFrom((Class<?>) parameterizedType.getRawType())) {
                result = parameterizedType;
            }
        }
        return result;
    }",Returns a ParameterizedType for the given type and expected type.
"protected DataSource getDataSource( HttpServletRequest request, String key )
    {
        // Return the requested data source instance
        return ( DataSource ) getServletContext().getAttribute( key + getModuleConfig().getPrefix() );
    }",Get the data source instance for the requested data source key.
"public static KeyPair generateKeyPair(String algorithm, int keySize, byte[] seed) {
		// SM2算法需要单独定义其曲线生成
		if (""SM2"".equalsIgnoreCase(algorithm)) {
			final ECGenParameterSpec sm2p256v1 = new ECGenParameterSpec(SM2_DEFAULT_CURVE);
			return generateKeyPair(algorithm, keySize, seed, sm2p256v1);
		}

		return generateKeyPair(algorithm, keySize, seed, (AlgorithmParameterSpec[]) null);
	}",Generates a KeyPair with the specified key size and seed.
"public FormInputHandler timeout(final long theTimeoutSeconds) {
		checkArgument(theTimeoutSeconds > 0, ""'theTimeoutSeconds' must be greater than zero"");
		Fields fields = new Fields(this);
		fields.finder = fields.finder.timeout(theTimeoutSeconds);
		return new FormInputHandler(fields);
	}",Sets the timeout for the input field.
"public Matrix4f rotationY(float ang) {
        float sin, cos;
        sin = (float) Math.sin(ang);
        cos = (float) Math.cosFromSin(sin, ang);
        if ((properties & PROPERTY_IDENTITY) == 0)
            MemUtil.INSTANCE.identity(this);
        this._m00(cos);
        this._m02(-sin);
        this._m20(sin);
        this._m22(cos);
        _properties(PROPERTY_AFFINE | PROPERTY_ORTHONORMAL);
        return this;
    }",Sets this to a rotation matrix for the calendar class file.
"@Override
    public CreateEgressOnlyInternetGatewayResult createEgressOnlyInternetGateway(CreateEgressOnlyInternetGatewayRequest request) {
        request = beforeClientExecution(request);
        return executeCreateEgressOnlyInternetGateway(request);
    }",Creates an EgressOnly InternetGateway.
"private boolean validOrthologousStatement(final Statement stmt) {
        // test statement is well-formed
        if (stmt.getRelationshipType() == RelationshipType.ORTHOLOGOUS
                && stmt.getObject() != null
                && stmt.getObject().getTerm() != null) {

            // test subject has only one namespace parameter
            final Term subject = stmt.getSubject();
            List<Parameter> subparams = subject.getParameters();
            if (subparams == null || subparams.size() != 1
                    || subparams.get(0).getNamespace() == null) {
                return false;
            }

            // test object has only one namespace parameter
            final Term object = stmt.getObject().getTerm();
            List<Parameter> objparams = object.getParameters();
            if (objparams == null || objparams.size() != 1
                    || objparams.get(0).getNamespace() == null) {
                return false;
            }

            return true;
        }

        return false;
    }",Checks if a statement is well - formed by the ORTHOLOGOUS Relationship Type.
"private void init() throws ConfigFileIOException {
        this.props = new Properties();
        log.info(""Reading config file: {}"", this.configFile);
        boolean ok = true;
        try {
            // El fichero esta en el CLASSPATH
            this.props.load(SystemConfig.class.getResourceAsStream(this.configFile));
        } catch (Exception e) {
            log.warn(""File not found in the Classpath"");
            try {
                this.props.load(new FileInputStream(this.configFile));
            } catch (IOException ioe) {
                log.error(""Can't open file: {}"", ioe.getLocalizedMessage());
                ok = false;
                ioe.printStackTrace();
                throw new ConfigFileIOException(ioe.getLocalizedMessage());
            }
        }
        if (ok) {
            log.info(""Configuration loaded successfully"");
            if (log.isDebugEnabled()) {
                log.debug(this.toString());
            }
        }
    }",Init method.
"public void setSpecularIntensity(float r, float g, float b, float a) {
       setVec4(""specular_intensity"", r, g, b, a);
   }",Sets the specular intensity of the light.
"@Override
    public void execute() throws BuildException {
        logger = new DITAOTAntLogger(getProject());
        final MessageBean msgBean = MessageUtils.getMessage(id, readParamValues());
        if (msgBean != null) {
            final String type = msgBean.getType();
            if (ERROR.equals(type)) {
                logger.error(msgBean.toString());
            } else if (WARN.equals(type)) {
                logger.warn(msgBean.toString());
            } else if (INFO.equals(type)) {
                logger.info(msgBean.toString());
            } else if (DEBUG.equals(type)) {
                logger.debug(msgBean.toString());
            }
        }
    }",Execute the sequence of code to execute the sequence.
"public final void mNS_PREFIX() throws RecognitionException {
        try {
            int _type = NS_PREFIX;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // BELScript.g:293:10: ( LETTER ( LETTER | DIGIT )* ':' )
            // BELScript.g:294:5: LETTER ( LETTER | DIGIT )* ':'
            {
            mLETTER(); 
            // BELScript.g:294:12: ( LETTER | DIGIT )*
            loop9:
            do {
                int alt9=2;
                int LA9_0 = input.LA(1);

                if ( ((LA9_0>='0' && LA9_0<='9')||(LA9_0>='A' && LA9_0<='Z')||(LA9_0>='a' && LA9_0<='z')) ) {
                    alt9=1;
                }


                switch (alt9) {
            	case 1 :
            	    // BELScript.g:
            	    {
            	    if ( (input.LA(1)>='0' && input.LA(1)<='9')||(input.LA(1)>='A' && input.LA(1)<='Z')||(input.LA(1)>='a' && input.LA(1)<='z') ) {
            	        input.consume();

            	    }
            	    else {
            	        MismatchedSetException mse = new MismatchedSetException(null,input);
            	        recover(mse);
            	        throw mse;}


            	    }
            	    break;

            	default :
            	    break loop9;
                }
            } while (true);

            match(':'); 

            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }",Starts the NS_PREFIX action
"public String getTopMethods(int num) {
		stopCollecting();
		CountMap<String> selfms = new CountMap<String>(selfMethods);
		CountMap<String> stackms = new CountMap<String>(stackMethods);
		StringBuilder buff = new StringBuilder();
		buff.append(""Top methods over "").append(time).append("" ms ("").append(pauseTime).append("" ms paused), with "")
				.append(total).append("" counts:"").append(LINE_SEPARATOR);
		buff.append(""Rank\tSelf\tStack\tMethod"").append(LINE_SEPARATOR);
		for (int i = 0, n = 0; selfms.size() > 0 && n < num; i++) {
			int highest = 0;
			List<Map.Entry<String, Integer>> bests = new ArrayList<Map.Entry<String, Integer>>();
			for (Map.Entry<String, Integer> el : selfms.entrySet()) {
				if (el.getValue() > highest) {
					bests.clear();
					bests.add(el);
					highest = el.getValue();
				} else if (el.getValue() == highest) {
					bests.add(el);
				}
			}
			for (Map.Entry<String, Integer> e : bests) {
				selfms.remove(e.getKey());
				int selfPercent = 100 * highest / Math.max(total, 1);
				int stackPercent = 100 * stackms.remove(e.getKey()) / Math.max(total, 1);
				buff.append(i + 1).append(""\t"").append(selfPercent).append(""%\t"").append(stackPercent).append(""%\t"")
						.append(e.getKey()).append(LINE_SEPARATOR);
				n++;
			}
		}
		return buff.toString();
	}",Returns a string with a description of how many methods are available in the database.
"public static double bachelierOptionImpliedVolatility(
			double forward,
			double optionMaturity,
			double optionStrike,
			double payoffUnit,
			double optionValue)
	{
		if(forward == optionStrike) {
			return optionValue / Math.sqrt(optionMaturity / Math.PI / 2.0) / payoffUnit;
		}

		// Limit the maximum number of iterations, to ensure this calculation returns fast, e.g. in cases when there is no such thing as an implied vol
		// TODO: An exception should be thrown, when there is no implied volatility for the given value.
		int		maxIterations	= 100;
		double	maxAccuracy		= 0.0;

		// Calculate an lower and upper bound for the volatility
		double volatilityLowerBound = 0.0;
		double volatilityUpperBound = Math.sqrt(2 * Math.PI * Math.E) * (optionValue / payoffUnit + Math.abs(forward-optionStrike)) / Math.sqrt(optionMaturity);

		// Solve for implied volatility
		GoldenSectionSearch solver = new GoldenSectionSearch(volatilityLowerBound, volatilityUpperBound);
		while(solver.getAccuracy() > maxAccuracy && !solver.isDone() && solver.getNumberOfIterations() < maxIterations) {
			double volatility = solver.getNextPoint();

			double valueAnalytic	= bachelierOptionValue(forward, volatility, optionMaturity, optionStrike, payoffUnit);

			double error = valueAnalytic - optionValue;

			solver.setValue(error*error);
		}

		return solver.getBestPoint();
	}",Bachelier option implied volatility
"public static synchronized void truncateStorage(final StorageConfiguration pConf) throws TTException {
        // check that database must be closed beforehand
        if (!STORAGEMAP.containsKey(pConf.mFile)) {
            if (existsStorage(pConf.mFile)) {
                final IStorage storage = new Storage(pConf);
                final File[] resources =
                    new File(pConf.mFile, StorageConfiguration.Paths.Data.getFile().getName()).listFiles();
                for (final File resource : resources) {
                    storage.truncateResource(new SessionConfiguration(resource.getName(), null));
                }
                storage.close();
                // instantiate the database for deletion
                IOUtils.recursiveDelete(pConf.mFile);
            }
        }
    }",Truncate the storage.
"public ClassificationModel attachLink(ClassificationModel classificationModel, LinkModel linkModel)
    {
        for (LinkModel existing : classificationModel.getLinks())
        {
            if (StringUtils.equals(existing.getLink(), linkModel.getLink()))
            {
                return classificationModel;
            }
        }
        classificationModel.addLink(linkModel);
        return classificationModel;
    }",Attach a link to a classification model.
"public static BlockInStream create(FileSystemContext context, BlockInfo info,
      WorkerNetAddress dataSource, BlockInStreamSource dataSourceType, InStreamOptions options)
      throws IOException {
    URIStatus status = options.getStatus();
    ReadType readType = ReadType.fromProto(options.getOptions().getReadType());

    long blockId = info.getBlockId();
    long blockSize = info.getLength();

    // Construct the partial read request
    ReadRequest.Builder builder =
        ReadRequest.newBuilder().setBlockId(blockId).setPromote(readType.isPromote());
    // Add UFS fallback options
    builder.setOpenUfsBlockOptions(options.getOpenUfsBlockOptions(blockId));
    AlluxioConfiguration alluxioConf = context.getClusterConf();
    boolean shortCircuit = alluxioConf.getBoolean(PropertyKey.USER_SHORT_CIRCUIT_ENABLED);
    boolean sourceSupportsDomainSocket = NettyUtils.isDomainSocketSupported(dataSource,
        alluxioConf);
    boolean sourceIsLocal = dataSourceType == BlockInStreamSource.LOCAL;

    // Short circuit
    if (sourceIsLocal && shortCircuit && !sourceSupportsDomainSocket) {
      LOG.debug(""Creating short circuit input stream for block {} @ {}"", blockId, dataSource);
      try {
        return createLocalBlockInStream(context, dataSource, blockId, blockSize, options);
      } catch (NotFoundException e) {
        // Failed to do short circuit read because the block is not available in Alluxio.
        // We will try to read via gRPC. So this exception is ignored.
        LOG.warn(""Failed to create short circuit input stream for block {} @ {}. Falling back to ""
            + ""network transfer"", blockId, dataSource);
      }
    }

    // gRPC
    LOG.debug(""Creating gRPC input stream for block {} @ {} from client {} reading through {}"",
        blockId, dataSource, NetworkAddressUtils.getClientHostName(alluxioConf), dataSource);
    return createGrpcBlockInStream(context, dataSource, dataSourceType, builder.buildPartial(),
        blockSize, options);
  }",Create a block in stream.
"@Nonnull
    public HttpHealthCheck addHealthCheck(String name, String url, int interval, long timeout) {
        if (name == null || name.trim().length() == 0) {
            throw new IllegalArgumentException(""The name must not be null or empty."");
        }

        if (url == null || url.trim().length() == 0) {
            throw new IllegalArgumentException(""The URL must not be null or empty."");
        }

        if (!Url.isUrl(url)) {
            throw new IllegalArgumentException(url + "" is not a valid URL."");
        }

        if (interval < 0) {
            throw new IllegalArgumentException(""The polling interval must be zero or a positive integer."");
        }

        if (timeout < 0) {
            throw new IllegalArgumentException(""The timeout must be zero or a positive integer."");
        }

        HttpHealthCheck healthCheck = new HttpHealthCheck(name, url, interval, timeout);
        healthChecks.add(healthCheck);

        return healthCheck;
    }",Add a new HTTP health check to the list of health checks.
"public static void lock(Lock lock, String callerClass, String callerMethod, Object... args) {
		final String sourceMethod = ""lock""; //$NON-NLS-1$
		final boolean isTraceLogging = log.isLoggable(Level.FINER);
		if (isTraceLogging) {
			log.entering(sourceClass, sourceMethod, new Object[]{Thread.currentThread(), lock, callerClass, callerMethod, args});
		}
		long start = System.currentTimeMillis();
		boolean quiesced = false, logged = false;
		try {
			while (!lock.tryLock(SIGNAL_LOG_INTERVAL_SECONDS, TimeUnit.SECONDS)) {
				if (!quiesced) {
					quiesced = logWaiting(callerClass, callerMethod, lock, start, args);
					logged = true;
				}
			}
		} catch (InterruptedException ex) {
			// InterruptedException is not thrown by Lock.lock() so convert to a
			// RuntimeException.
			throw new RuntimeException(ex);
		}
		if (logged) {
			logResuming(callerClass, callerMethod, lock, start);
		}
		if (isTraceLogging) {
			log.exiting(sourceClass, sourceMethod, Arrays.asList(Thread.currentThread(), lock, callerClass, callerMethod));
		}
		return;
	}",This method is used to acquire a lock on the system.
"private static I_Loader initLoader(String type) {

        if (TYPE_PROPERTIES.equals(type)) {
            return new CmsVfsBundleLoaderProperties();
        } else if (TYPE_XML.equals(type)) {
            return new CmsVfsBundleLoaderXml();
        } else {
            return new CmsVfsBundleLoaderXml();
        }
    }",Initializes the loader for the given type.
"public String getOtherTrackType()
	{
		final Element element = getElement(""Type"", 0);

		if (element != null)
		{
			return element.getText();
		}
		else
		{
			return null;
		}
	}",Gets the other track type.
"@Override
   public <C> CompletionStage<Void> addListenerAsync(Object listener, CacheEventFilter<? super K, ? super V> filter,
                               CacheEventConverter<? super K, ? super V, C> converter, ClassLoader classLoader) {
      return addListenerInternal(listener, DataConversion.IDENTITY_KEY, DataConversion.IDENTITY_VALUE, filter, converter, classLoader, false);
   }",Add an event listener asynchronously.
"public String[] getGeneratorFunctions()
    {
    String[] functions = new String[ generators_.size()];
    generators_.keySet().toArray( functions);
    return functions;
    }",Returns an array of all the functions that are defined in the generator.
"public <E extends Exception> void forEach(final Try.IndexedConsumer<? super T, E> action) throws E {
        N.forEach(coll, action);
    }",Performs the given action for each element of this Collection.
"public long getInstantMillis(Object object, Chronology chrono) {
        String str = (String) object;
        DateTimeFormatter p = ISODateTimeFormat.dateTimeParser();
        return p.withChronology(chrono).parseMillis(str);
    }",Gets the millis value of the specified object.
"public void complete(Element e) throws KNXMLException
	{
		if (e.isEmptyElementTag())
			return;
		final int index = openElems.lastIndexOf(e.getName());
		if (index == -1)
			throw new KNXMLException(""element tag not read before"", e.getName(), line);
		String end = null;
		final StringBuffer content = new StringBuffer(50);
		while (canRead()) {
			// read text content
			final String s = read('<');
			final boolean current = openElems.peek().equals(e.getName());
			// if character data is for current element, append it
			if (current && s.length() > 0)
				content.append(References.replace(s, false));
			// read a possible end tag
			end = read('>');
			if (skipComment(end))
				;
			else if (current && readCDATASection(end, content))
				;
			else if (end.length() > 0 && end.charAt(0) == '/') {
				// actually, no white space is allowed between '/' and tag name
				// but there might be some between end of name and '>'
				final String tag = end.substring(1).trim();
				// got end tag?
				if (!tag.equals(openElems.peek()))
					throw new KNXMLException(""element end tag does not match start tag"",
						tag, line);
				openElems.pop();
				if (tag.equals(e.getName())) {
					e.setCharacterData(content.toString());
					pos = END_TAG;
					return;
				}
			}
			else if (end.length() > 0)
				// don't push empty element tags
				if (end.charAt(end.length() - 1) != '/') {
					final String tag = splitOnSpace(end);
					if (tag.length() > 0)
						openElems.push(tag);
				}
		}
		throw new KNXMLException(""end of XML input with elements left open"", end, line);
	}",Reads the content of an element and sets the appropriate attributes of the element.
"public static double mod(double a, double b) {
		int n = (int)(a/b);
		
		a -= n*b;
		if (a < 0)
			return a + b;
		return a;
	}",mod b
"public SortedSet<AbstractPanel> getSortedPanels(PanelType panelType) {
		validateNotNull(panelType, ""panelType"");

		List<AbstractPanel> panels = getPanels(panelType);
		SortedSet<AbstractPanel> sortedPanels = new TreeSet<>(new Comparator<AbstractPanel>() {

			@Override
			public int compare(AbstractPanel abstractPanel, AbstractPanel otherAbstractPanel) {
				String name = abstractPanel.getName();
				String otherName = otherAbstractPanel.getName();
				if (name == null) {
					if (otherName == null) {
						return 0;
					}
					return -1;
				} else if (otherName == null) {
					return 1;
				}
				return name.compareTo(otherName);
			}
		});
		sortedPanels.addAll(panels);
		return sortedPanels;
	}",Returns a sorted set of all the panels of the specified type in the database.
"public static void recursivelyDelete(File f) throws IOException {
        if (!f.exists()) {
            return;
        }
        if (f.isDirectory()) {
            for (File f1 : f.listFiles()) {
                recursivelyDelete(f1);
            }
            if (!f.delete()) {
                throw new IOException(""Unable to delete directory "" + f);
            }
        }
        else {
            if (!f.delete()) {
                throw new IOException(""Unable to delete file "" + f);
            }
        }
    }",Recursively deletes a file or directory.
"public Observable<ServiceResponse<Page<StorageAccountCredentialInner>>> listByDataBoxEdgeDeviceSinglePageAsync(final String deviceName, final String resourceGroupName) {
        if (deviceName == null) {
            throw new IllegalArgumentException(""Parameter deviceName is required and cannot be null."");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");
        }
        return service.listByDataBoxEdgeDevice(deviceName, this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Page<StorageAccountCredentialInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<StorageAccountCredentialInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<StorageAccountCredentialInner>> result = listByDataBoxEdgeDeviceDelegate(response);
                        return Observable.just(new ServiceResponse<Page<StorageAccountCredentialInner>>(result.body(), result.response()));
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }",List all the Cognitive Services Identity Authentication credentials.
"public XMLString xstr(XPathContext xctxt)
          throws javax.xml.transform.TransformerException
  {
    return execute(xctxt).xstr();
  }",Execute the XPath to get the XML string.
"public static ClassInfo classInfo(final ClassLoader cl, final String className) {
        final Index index = index(cl, className);
        return index.getClassByName(DotName.createSimple(className));
    }",Get the class information for a class.
"public PropertyBuilder renderingAsPassword() {
        if (this.type != Property.Type.String) {
            throw new IllegalStateException(""stringRenderingPassword can only be applied to a String property"");
        }
        return renderingOption(StringRenderingConstants.DISPLAY_TYPE_KEY, StringRenderingConstants.DisplayType
                .PASSWORD);
    }",Sets the display type to password.
"private static int generateCompatViewId() {
        for (; ; ) {
            final int result = sNextGeneratedId.get();
            int newValue = result + 1;
            /**
             * ID number larger than 0x00FFFFFF is reserved for static views defined in the /res xml files.
             * Android doesn't want you to use 0 as a view's id, and it needs to be flipped before 0x01000000 to avoid
             * the conflicts with static resource IDs
             */
            if (newValue > 0x00FFFFFF) {
                newValue = 1; // Roll over to 1, not 0.
            }
            if (sNextGeneratedId.compareAndSet(result, newValue)) {
                return result;
            }
        }
    }",Generate a view ID for a static view.
"protected long getLogSpaceReserved() {
        if (Tracing.isAnyTracingEnabled() && trace.isEntryEnabled())
            trace.entry(this, cclass
                        , ""getLogSpaceReserved""
                          + "")"");

        if (Tracing.isAnyTracingEnabled() && trace.isEntryEnabled())
            trace.exit(this, cclass
                       , ""getLogSpaceReserved""
                       , ""returns logSpaceReserved="" + logSpaceReserved + ""(long)""
                            );
        return logSpaceReserved;
    }",Get the logSpaceReserved value.
"public static boolean hasProperty(ClassNode classNode, String propertyName) {
        if (classNode == null || !StringUtils.hasText(propertyName)) {
            return false;
        }

        final MethodNode method = classNode.getMethod(GrailsNameUtils.getGetterName(propertyName), Parameter.EMPTY_ARRAY);
        if (method != null) return true;

        // check read-only field with setter
        if( classNode.getField(propertyName) != null && !classNode.getMethods(GrailsNameUtils.getSetterName(propertyName)).isEmpty()) {
            return true;
        }

        for (PropertyNode pn : classNode.getProperties()) {
            if (pn.getName().equals(propertyName) && !pn.isPrivate()) {
                return true;
            }
        }

        return false;
    }",Checks if the given classNode has a property with the given name.
"private void createEdge(Node fromNode, ControlFlowGraph.Branch branch,
      Node toNode) {
    cfg.createNode(fromNode);
    cfg.createNode(toNode);
    cfg.connectIfNotFound(fromNode, branch, toNode);
  }",Create edge.
"public static <T> Stream<Map.Entry<Integer, T>> enumerate(Stream<T> stream) {
        Iterator<Map.Entry<Integer, T>> iterator = new Iterator<Map.Entry<Integer, T>>() {
            private int counter = 0;
            
            private final Iterator<T> internalIterator = stream.iterator();
            
            /** {@inheritDoc} */
            @Override
            public boolean hasNext() {
                return internalIterator.hasNext();
            }
            
            /** {@inheritDoc} */
            @Override
            public Map.Entry<Integer, T> next() {
                return new AbstractMap.SimpleImmutableEntry<>(counter++, internalIterator.next());
            }

            /** {@inheritDoc} */
            @Override
            public void remove() {
                throw new UnsupportedOperationException(""This is a read-only iterator, remove operation is not supported."");
            }
        };
        return stream(iterator, stream.isParallel());
    }",Enumerate the given stream.
"public static double isBetweenInclusive (final double dValue,
                                           final String sName,
                                           final double dLowerBoundInclusive,
                                           final double dUpperBoundInclusive)
  {
    if (isEnabled ())
      return isBetweenInclusive (dValue, () -> sName, dLowerBoundInclusive, dUpperBoundInclusive);
    return dValue;
  }",Checks if the value is between the specified inclusive values.
"public AssertSoapFaultBuilder faultDetailResource(Resource resource, Charset charset) {
        try {
            action.getFaultDetails().add(FileUtils.readToString(resource, charset));
        } catch (IOException e) {
            throw new CitrusRuntimeException(""Failed to read fault detail resource"", e);
        }
        return this;
    }",Add fault detail from resource.
"public <T> CloseableIterator<T> getMany(final Class<T> type, final Map<String, Object> query) {
        return getMany(type, query, false);
    }",Get a single object from the cache.
"public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException
    {
        if (e == null)
        {
            throw new IllegalArgumentException(""The 'e' parameter may not be null."");
        }

        ReentrantLock lock = this.lock;
        lock.lockInterruptibly();

        long nanos = unit.toNanos(timeout);

        try
        {
            do
            {
                if (insert(e, false))
                {
                    return true;
                }

                try
                {
                    nanos = notFull.awaitNanos(nanos);
                }
                catch (InterruptedException ie)
                {
                    // Wake up another thread waiting on notFull, as the condition may be true, but this thread
                    // was interrupted so cannot make use of it.
                    notFull.signal();

                    throw ie;
                }
            }
            while (nanos > 0);

            return false;
        }
        finally
        {
            lock.unlock();
        }
    }",Offer an element into the cache.
"public PagedList<HybridConnectionInner> listHybridConnectionsNext(final String nextPageLink) {
        ServiceResponse<Page<HybridConnectionInner>> response = listHybridConnectionsNextSinglePageAsync(nextPageLink).toBlocking().single();
        return new PagedList<HybridConnectionInner>(response.body()) {
            @Override
            public Page<HybridConnectionInner> nextPage(String nextPageLink) {
                return listHybridConnectionsNextSinglePageAsync(nextPageLink).toBlocking().single().body();
            }
        };
    }",Gets the next page of Hybrid Connections.
"private void bindProcedure(PreparedStatement stmt, ClassDescriptor cld, Object obj, ProcedureDescriptor proc)
            throws SQLException
    {
        int valueSub = 0;

        // Figure out if we are using a callable statement.  If we are, then we
        // will need to register one or more output parameters.
        CallableStatement callable = null;
        try
        {
            callable = (CallableStatement) stmt;
        }
        catch(Exception e)
        {
            m_log.error(""Error while bind values for class '"" + (cld != null ? cld.getClassNameOfObject() : null)
                    + ""', using stored procedure: ""+ proc, e);
            if(e instanceof SQLException)
            {
                throw (SQLException) e;
            }
            else
            {
                throw new PersistenceBrokerException(""Unexpected error while bind values for class '""
                        + (cld != null ? cld.getClassNameOfObject() : null) + ""', using stored procedure: ""+ proc);
            }
        }

        // If we have a return value, then register it.
        if ((proc.hasReturnValue()) && (callable != null))
        {
            int jdbcType = proc.getReturnValueFieldRef().getJdbcType().getType();
            m_platform.setNullForStatement(stmt, valueSub + 1, jdbcType);
            callable.registerOutParameter(valueSub + 1, jdbcType);
            valueSub++;
        }

        // Process all of the arguments.
        Iterator iterator = proc.getArguments().iterator();
        while (iterator.hasNext())
        {
            ArgumentDescriptor arg = (ArgumentDescriptor) iterator.next();
            Object val = arg.getValue(obj);
            int jdbcType = arg.getJdbcType();
            setObjectForStatement(stmt, valueSub + 1, val, jdbcType);
            if ((arg.getIsReturnedByProcedure()) && (callable != null))
            {
                callable.registerOutParameter(valueSub + 1, jdbcType);
            }
            valueSub++;
        }
    }",Bind a Procedure to a PreparedStatement.
"public void combine(SpdLong other) {
        if (other == null)
            return;
        if (stat.isEnabled() && other.isEnabled())
            stat.combine((CountStatisticImpl) other.getStatistic());
    }",Combine two count statistic objects.
"@Override
    public PutBotResult putBot(PutBotRequest request) {
        request = beforeClientExecution(request);
        return executePutBot(request);
    }",Creates a new CDN file in an existing CDN file.
"protected void loadLocalDatabases() {
    final List<String> dbs = new ArrayList<String>(serverInstance.getAvailableStorageNames().keySet());
    Collections.sort(dbs);

    for (final String databaseName : dbs) {
      if (messageService.getDatabase(databaseName) == null) {
        ODistributedServerLog.info(this, nodeName, null, DIRECTION.NONE, ""Opening database '%s'..."", databaseName);

        // INIT THE STORAGE
        final ODistributedStorage stg = getStorage(databaseName);

        executeInDistributedDatabaseLock(databaseName, 60000, null, new OCallable<Object, OModifiableDistributedConfiguration>() {
          @Override
          public Object call(OModifiableDistributedConfiguration cfg) {
            ODistributedServerLog.info(this, nodeName, null, DIRECTION.NONE, ""Current node started as %s for database '%s'"",
                cfg.getServerRole(nodeName), databaseName);

            final ODistributedDatabaseImpl ddb = messageService.registerDatabase(databaseName, cfg);
            ddb.resume();

            // 1ST NODE TO HAVE THE DATABASE
            cfg.addNewNodeInServerList(nodeName);

            // COLLECT ALL THE CLUSTERS WITH REMOVED NODE AS OWNER
            reassignClustersOwnership(nodeName, databaseName, cfg, true);

            try {
              ddb.getSyncConfiguration().setLastLSN(nodeName, ((OAbstractPaginatedStorage) stg.getUnderlying()).getLSN(), false);
            } catch (IOException e) {
              ODistributedServerLog
                  .error(this, nodeName, null, DIRECTION.NONE, ""Error on saving distributed LSN for database '%s' (err=%s)."",
                      databaseName, e.getMessage());
            }
            ddb.setOnline();

            return null;
          }
        });
      }
    }
  }",Load local databases.
"public static <C> Module overrideModule(
        final Class<C> configInterface,
        final Named name,
        final OverrideConsumer<C> overrideConsumer)
    {
        return overrideModule(configInterface, Optional.of(name), overrideConsumer);
    }",Override a module with a single name.
"public void addHeader( String name, String value )
    {
        headers.add( new BasicHeader( name, value ) );
    }",Add a header to the resource.
"public void setMode(final MenuMode mode) {
		// mode server mapped to mode dynamic as per https://github.com/BorderTech/wcomponents/issues/687
		getOrCreateComponentModel().mode = MenuMode.SERVER.equals(mode) ? MenuMode.DYNAMIC : mode;
	}",Sets the mode of the menu.
"@Override
    public void notifyReceiveAllowed(boolean isAllowed)
    {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.entry(tc, ""notifyReceiveAllowed"", new Object[] { Boolean.valueOf(isAllowed), this });

        this.lock();
        try
        {
            try
            {
                checkReceiveAllowed();
            } catch (SISessionUnavailableException e)
            {
                // FFDC
                FFDCFilter.processException(
                                            e,
                                            ""com.ibm.ws.sib.processor.impl.JSLocalConsumerPoint.notifyReceiveAllowed"",
                                            ""1:4287:1.22.5.1"",
                                            this);

                SibTr.exception(tc, e);
            } catch (SIResourceException e)
            {
                // FFDC
                FFDCFilter.processException(
                                            e,
                                            ""com.ibm.ws.sib.processor.impl.JSLocalConsumerPoint.notifyReceiveAllowed"",
                                            ""1:4298:1.22.5.1"",
                                            this);

                SibTr.exception(tc, e);
            }
        } finally
        {
            this.unlock();
        }

        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.exit(tc, ""notifyReceiveAllowed"");
    }",This method is called by the JSLocalConsumerPoint when a receive is allowed for a single language language.
"private static int findEndOfHeader(byte[] pBytes, int pEnd) {
        byte[] header = HTTP_HEADER_END.getBytes();

        // Normal condition, check all bytes
        for (int i = 0; i < pEnd - 4; i++) {  // Need 4 bytes to match
            if ((pBytes[i] == header[0]) && (pBytes[i + 1] == header[1]) && (pBytes[i + 2] == header[2]) && (pBytes[i + 3] == header[3])) {

                //System.err.println(""FOUND END OF HEADER!"");
                return i + 4;
            }
        }

        // Check last 3 bytes, to check if we have a partial match
        if ((pEnd - 1 >= 0) && (pBytes[pEnd - 1] == header[0])) {

            //System.err.println(""FOUND LAST BYTE"");
            return -2;  // LAST BYTE
        }
        else if ((pEnd - 2 >= 0) && (pBytes[pEnd - 2] == header[0]) && (pBytes[pEnd - 1] == header[1])) {

            //System.err.println(""FOUND LAST TWO BYTES"");
            return -3;  // LAST TWO BYTES
        }
        else if ((pEnd - 3 >= 0) && (pBytes[pEnd - 3] == header[0]) && (pBytes[pEnd - 2] == header[1]) && (pBytes[pEnd - 1] == header[2])) {

            //System.err.println(""FOUND LAST THREE BYTES"");
            return -4;  // LAST THREE BYTES
        }
        return -1;  // NO BYTES MATCH
    }",Find the end of header.
"@Override
    public DeleteNotificationResult deleteNotification(DeleteNotificationRequest request) {
        request = beforeClientExecution(request);
        return executeDeleteNotification(request);
    }",Deletes an existing CRS or CRS notification.
"private boolean blockedStorageClose(StorageType storageType) {
        DB storage = storageRegistry.get(storageType);
        if(isOpenStorage(storage)) {
            storage.commit();

            //find the underlying engine
            Engine e = storage.getEngine();
            while (EngineWrapper.class.isAssignableFrom(e.getClass())) {
                e = ((EngineWrapper) e).getWrappedEngine();
            }

            //close and wait until the close on the underlying engine is also finished
            storage.close();
            while (!e.isClosed()) {
                logger.trace(""Waiting for the engine to close"");
                try {
                    TimeUnit.MILLISECONDS.sleep(100);
                } catch (InterruptedException ex) {
                    throw new RuntimeException(ex);
                }
            }

            return true;
        }
        else {
            return false;
        }
    }",Block the open storage and wait until the engine is closed.
"public static Chainr fromFile( File chainrSpecFile, ChainrInstantiator chainrInstantiator ) {
        Object chainrSpec;
        try {
            FileInputStream fileInputStream = new FileInputStream( chainrSpecFile );
            chainrSpec = JsonUtils.jsonToObject( fileInputStream );
        } catch ( Exception e ) {
            throw new RuntimeException( ""Unable to load chainr spec file "" + chainrSpecFile.getAbsolutePath() );
        }
        return getChainr( chainrInstantiator, chainrSpec );
    }",Get a Chainr instance from the specified chainr spec file.
"@SuppressWarnings(""ReferenceEquality"")
  private void logImpl(String message, Object... args) {
    this.args = args;
    // Evaluate any (rare) LazyArg instances early. This may throw exceptions from user code, but
    // it seems reasonable to propagate them in this case (they would have been thrown if the
    // argument was evaluated at the call site anyway).
    for (int n = 0; n < args.length; n++) {
      if (args[n] instanceof LazyArg) {
        args[n] = ((LazyArg<?>) args[n]).evaluate();
      }
    }
    // Using ""!="" is fast and sufficient here because the only real case this should be skipping
    // is when we called log(String) or log(), which should not result in a template being created.
    // DO NOT replace this with a string instance which can be interned, or use equals() here,
    // since that could mistakenly treat other calls to log(String, Object...) incorrectly.
    if (message != LITERAL_VALUE_MESSAGE) {
      this.templateContext = new TemplateContext(getMessageParser(), message);
    }
    getLogger().write(this);
  }",This is the implementation of the log method.
"public void marshall(ListUserPoolsRequest listUserPoolsRequest, ProtocolMarshaller protocolMarshaller) {

        if (listUserPoolsRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(listUserPoolsRequest.getNextToken(), NEXTTOKEN_BINDING);
            protocolMarshaller.marshall(listUserPoolsRequest.getMaxResults(), MAXRESULTS_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given request to the JSON object.
"protected static int encodeInt(
      long x,
      byte[] res,
      int resOffset
  ) {
    byte i, l;
    long m;
    long mask = 0xf0000000;
    long init = x & mask;

    if (init == 0) {
      l = 8;
      for (i = 0; i < 8; i++) {
        m = mask >> (4 * i);
        if ((x & m) != 0) {
          l = i;
          break;
        }
      }
      res[resOffset] = l;
      for (i = l; i < 8; i++) {
        res[resOffset + 1 + i - l] = (byte) (0xf & (x >> (4 * (i - l))));
      }

      return 1 + 8 - l;

    } else if (init == mask) {
      l = 7;
      for (i = 0; i < 8; i++) {
        m = mask >> (4 * i);
        if ((x & m) != m) {
          l = i;
          break;
        }
      }
      res[resOffset] = (byte) (l | 8);
      for (i = l; i < 8; i++) {
        res[resOffset + 1 + i - l] = (byte) (0xf & (x >> (4 * (i - l))));
      }

      return 1 + 8 - l;

    } else {
      res[resOffset] = 0;
      for (i = 0; i < 8; i++) {
        res[resOffset + 1 + i] = (byte) (0xf & (x >> (4 * i)));
      }

      return 9;

    }
  }",Encodes a single int value from a single long value.
"public void setNotifyConfig(boolean notify) {
        addField(ConfigureNodeFields.notify_config, FormField.Type.bool);
        setAnswer(ConfigureNodeFields.notify_config.getFieldName(), notify);
    }",Sets whether notify configuration should be sent to the node.
"public Object convertToType(Object obj, Class<?> type) {

        boolean originalResolved = isPropertyResolved();
        setPropertyResolved(false);
        try {
            ELResolver resolver = getELResolver();
            if (resolver != null) {
                Object result = resolver.convertToType(this, obj, type);
                if (isPropertyResolved()) {
                    return result;
                }
            }
        } finally {
            setPropertyResolved(originalResolved);
        }

        return ELManager.getExpressionFactory().coerceToType(obj, type);
    }",This method is called to convert the given object to the given type.
"private Node parseAndRecordTypeNode(
      JsDocToken token,
      int lineno,
      int startCharno,
      boolean matchingLC,
      boolean onlyParseSimpleNames) {
    Node typeNode;

    if (onlyParseSimpleNames) {
      typeNode = parseTypeNameAnnotation(token);
    } else {
      typeNode = parseTypeExpressionAnnotation(token);
    }

    recordTypeNode(lineno, startCharno, typeNode, matchingLC);
    return typeNode;
  }",Parse and record a type node.
"@SuppressWarnings(""unchecked"")
    public static <T> T asType(String self, Class<T> c) {
        if (c == List.class) {
            return (T) toList(self);
        } else if (c == BigDecimal.class) {
            return (T) toBigDecimal(self);
        } else if (c == BigInteger.class) {
            return (T) toBigInteger(self);
        } else if (c == Long.class || c == Long.TYPE) {
            return (T) toLong(self);
        } else if (c == Integer.class || c == Integer.TYPE) {
            return (T) toInteger(self);
        } else if (c == Short.class || c == Short.TYPE) {
            return (T) toShort(self);
        } else if (c == Byte.class || c == Byte.TYPE) {
            return (T) Byte.valueOf(self.trim());
        } else if (c == Character.class || c == Character.TYPE) {
            return (T) toCharacter(self);
        } else if (c == Double.class || c == Double.TYPE) {
            return (T) toDouble(self);
        } else if (c == Float.class || c == Float.TYPE) {
            return (T) toFloat(self);
        } else if (c == File.class) {
            return (T) new File(self);
        } else if (c.isEnum()) {
            return (T) InvokerHelper.invokeMethod(c, ""valueOf"", new Object[]{ self });
        }
        return DefaultGroovyMethods.asType((Object) self, c);
    }",A method to convert a String to a Class
"@SuppressWarnings(""resource"")
	private static String parseGwtRpcMethodName(InputStream stream, String charEncoding) {
		//commented out code uses GWT-user library for a more 'proper' approach.
		//GWT-user library approach is more future-proof, but requires more dependency management.
		//				RPCRequest decodeRequest = RPC.decodeRequest(readLine);
		//				gwtmethodname = decodeRequest.getMethod().getName();

		try {
			final Scanner scanner;
			if (charEncoding == null) {
				scanner = new Scanner(stream);
			} else {
				scanner = new Scanner(stream, charEncoding);
			}
			scanner.useDelimiter(GWT_RPC_SEPARATOR_CHAR_PATTERN); //AbstractSerializationStream.RPC_SEPARATOR_CHAR

			//AbstractSerializationStreamReader.prepareToRead(...)
			scanner.next(); //stream version number
			scanner.next(); //flags

			//ServerSerializationStreamReader.deserializeStringTable()
			scanner.next(); //type name count

			//ServerSerializationStreamReader.preapreToRead(...)
			scanner.next(); //module base URL
			scanner.next(); //strong name

			//RPC.decodeRequest(...)
			scanner.next(); //service interface name
			return ""."" + scanner.next(); //service method name

			//note we don't close the scanner because we don't want to close the underlying stream
		} catch (final NoSuchElementException e) {
			LOG.debug(""Unable to parse GWT-RPC request"", e);

			//code above is best-effort - we were unable to parse GWT payload so
			//treat as a normal HTTP request
			return null;
		}
	}",Parses a GWT - RPC method name from an input stream.
"public Font getNotationFontForContext(int notationContext) {
		try {
			Font baseNotationFont = ((MusicalFont) getTemplate().getAttributeObject(
					ScoreAttribute.NOTATION_FONT)).getFont();

			switch (notationContext) {
			case NOTATION_CONTEXT_GRACENOTE:
				return baseNotationFont.deriveFont(getTemplate()
						.getAttributeSize(
								ScoreAttribute.NOTATION_GRACENOTE_SIZE));
			case NOTATION_CONTEXT_TEMPO:
				return baseNotationFont.deriveFont(getTemplate()
						.getAttributeSize(ScoreAttribute.NOTATION_TEMPO_SIZE));
			case NOTATION_CONTEXT_NOTE:
			default:
				return baseNotationFont.deriveFont(getTemplate()
						.getAttributeSize(ScoreAttribute.NOTATION_SIZE));
			}
		} catch (Exception e) {
			e.printStackTrace();
			throw new RuntimeException(e);
		}
	}",Gets the base notation font for the given notation context.
"public Map<String, String> getPathParametersEncoded(String requestUri) {
        
        Matcher m = regex.matcher(requestUri);
        
        return mapParametersFromPath(requestUri, parameters, m);
    }",Gets the path parameters encoded from the request URI.
"private IConceptSet filterEquivalents(final IConceptSet concepts) {
        int[] cArray = concepts.toArray();
        boolean[] toExclude = new boolean[cArray.length];

        for(int i = 0; i < cArray.length; i++) {
            if(toExclude[i]) continue;
            final IConceptSet iAncestors = IConceptSet.FACTORY.createConceptSet(getAncestors(no, cArray[i]));
            for(int j = i+1; j < cArray.length; j++) {
                if(iAncestors.contains(cArray[j])) {
                    final IConceptSet jAncestors = IConceptSet.FACTORY.createConceptSet(getAncestors(no, cArray[j]));
                    if(jAncestors.contains(cArray[i])) {
                        // These concepts are equivalent to mark the second concept as excluded
                        toExclude[j] = true;
                    }
                }
            }
        }

        IConceptSet res = IConceptSet.FACTORY.createConceptSet();
        for(int i = 0; i < cArray.length; i++) {
            if(!toExclude[i]) {
                res.add(cArray[i]);
            }
        }

        return res;
    }",Filter the given concepts to only include the ones that are equivalent to the first concept.
"@Override
  public void exec(Result<Object> result, Object[] args)
  {
    TableKelp tableKelp = _table.getTableKelp();
    
    RowCursor minCursor = tableKelp.cursor();
    RowCursor maxCursor = tableKelp.cursor();
    
    minCursor.clear();
    maxCursor.setKeyMax();
    
    _whereKraken.fillMinCursor(minCursor, args);
    _whereKraken.fillMaxCursor(minCursor, args);
    
    //QueryKelp whereKelp = _whereExpr.bind(args);
    // XXX: binding should be with unique
    EnvKelp whereKelp = new EnvKelp(_whereKelp, args);
    
    //tableKelp.findOne(minCursor, maxCursor, whereKelp,
    //                  new FindDeleteResult(result));
    
    _table.notifyOwner(minCursor.getKey());
    
    // result.completed(null);
    
    result.ok(null);
  }",Execute a find - delete operation.
"@Override
    public DEBBuilder setPackageName(String name)
    {
        this.name = name;
        control.setPackage(name);
        return this;
    }",Sets the package name for the generated class.
"private static String getCorrectedTimeZoneIdFrom(String value) {
        if (value != null) {
            value = value.contains(""\"""") ? value.replaceAll(""\"""", """") : value;
            if (TIMEZONE_REGISTRY.getTimeZone(value) != null) {
                return TIMEZONE_REGISTRY.getTimeZone(value).getID();
            }
            String nameCandidate = MS_TIMEZONE_NAMES.get(value);
            if (nameCandidate != null) {
                return TIMEZONE_REGISTRY.getTimeZone(nameCandidate) != null
                        ? TIMEZONE_REGISTRY.getTimeZone(nameCandidate).getID() : nameCandidate;
            }
            return MS_TIMEZONE_IDS.get(value);
        }
        return null;
    }",Get the correct timezone ID from the given value.
"public void	
    doArchive(String logListURI, String archiveDirectory)
    throws IOException
  {
    String destURL = FileSystem.getDefaultUri(fsConfig) + archiveDirectory;
    DistCp.copy(new JobConf(fsConfig), logListURI, destURL, null, true, false);
  }",Archive a single node in the log list.
"public void add(String column, Object value) {
        add(System.currentTimeMillis(), column, value);
    }",Add a value to the cache.
"public final Source createSource(OrganizationName parent, Source source) {

    CreateSourceRequest request =
        CreateSourceRequest.newBuilder()
            .setParent(parent == null ? null : parent.toString())
            .setSource(source)
            .build();
    return createSource(request);
  }",Create a source in a CrazyNam e
"@Override
	public void started(ServiceBroker broker) throws Exception {
		super.started(broker);

		// Local nodeID
		this.nodeID = broker.getNodeID();

		// Set components
		ServiceBrokerConfig cfg = broker.getConfig();
		this.executor = cfg.getExecutor();
		this.scheduler = cfg.getScheduler();
		this.strategyFactory = cfg.getStrategyFactory();
		this.contextFactory = cfg.getContextFactory();
		this.transporter = cfg.getTransporter();
		this.eventbus = cfg.getEventbus();
		this.uid = cfg.getUidGenerator();
	}",Set the components in the service broker.
"protected List<CmsPushButton> getButtons() {

        CmsPushButton workplaceButton = new CmsPushButton();
        workplaceButton.setText(getMessage(Messages.GUI_CONFIRMATION_WORKPLACE_BUTTON_0));
        workplaceButton.addClickHandler(new ClickHandler() {

            @SuppressWarnings(""synthetic-access"")
            public void onClick(ClickEvent e) {

                Window.Location.assign(m_closeLink);
            }
        });
        List<CmsPushButton> result = new ArrayList<CmsPushButton>();
        if (m_isWorkplaceUser) {
            result.add(workplaceButton);
        }
        return result;
    }",Returns the list of buttons that will be used to display the user s audit log.
"@Override
    public void
    flush()
            throws IOException
    {
        if(mode == RequestMode.DMR)
            return; // leave to close() to do this
        if(dmr8 != null) {
            sendDXR(dmr8);
            dmr8 = null;
        }
    }",Flush the output stream to the output stream.
"private boolean isCheckedException(TypeMirror t) {
        return !(env.types.isAssignable(t, env.java_lang_Error)
                || env.types.isAssignable(t, env.java_lang_RuntimeException));
    }",Checks if the type is an exception.
"public char[] getMediumCBuffer(int minSize)
    {
        char[] result = null;
        if (mMediumCBuffer != null && mMediumCBuffer.length >= minSize) {
            result = mMediumCBuffer;
            mMediumCBuffer = null;
        }
//System.err.println(""DEBUG: Alloc CMed: ""+result);
        return result;
    }",Get the Medium CBuffer.
"public static <T> String apiVersion(T item, String apiVersion) {
    if (item instanceof HasMetadata && Utils.isNotNullOrEmpty(((HasMetadata) item).getApiVersion())) {
      return trimVersion(((HasMetadata) item).getApiVersion());
    } else if (apiVersion != null && !apiVersion.isEmpty()) {
      return trimVersion(apiVersion);
    }
    return null;
  }",Get the API version of the item
"@Help(help = ""Delete the Security of a NetworkServiceDescriptor with specific id"")
  public void deleteSecurity(final String idNsd, final String idSecurity) throws SDKException {
    String url = idNsd + ""/security"" + ""/"" + idSecurity;
    requestDelete(url);
  }",Delete a Security of a NetworkServiceDescriptor.
"Stage<Void> doCollectAndDiscard(
      Collection<? extends Stage<?>> stages
  ) {
    final Completable<Void> target = completable();

    final CollectAndDiscardHelper done = new CollectAndDiscardHelper(stages.size(), target);

    for (final Stage<?> q : stages) {
      q.handle(done);
    }

    bindSignals(target, stages);
    return target;
  }",Collect and discard.
"public void copyRecord(Record recAlt, Record recMain)
    {
        recAlt.moveFields(recMain, null, true, DBConstants.READ_MOVE, false, false, true, false);
    }",Copy the record from the record to the record main.
"public Observable<Page<ResourceGroupInner>> listNextAsync(final String nextPageLink) {
        return listNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<ResourceGroupInner>>, Page<ResourceGroupInner>>() {
                @Override
                public Page<ResourceGroupInner> call(ServiceResponse<Page<ResourceGroupInner>> response) {
                    return response.body();
                }
            });
    }",Gets a list of CDNA resource groups.
"public void marshall(EnablePolicyTypeRequest enablePolicyTypeRequest, ProtocolMarshaller protocolMarshaller) {

        if (enablePolicyTypeRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(enablePolicyTypeRequest.getRootId(), ROOTID_BINDING);
            protocolMarshaller.marshall(enablePolicyTypeRequest.getPolicyType(), POLICYTYPE_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",Creates the given parameter object.
"public static boolean removeExtension(String extensionName) {
        if (extensionName == null) {
            throw new IllegalArgumentException(
                            ""Parameter 'extensionName' can not be null"");
        }
        HashMap<String, String> ext = extensions.get();
        return ext == null ? false : ext.remove(extensionName) != null;
    }",Removes an extension from the set of extensions.
"public static void setPropValue(final Object entity, final String propName, final Object propValue) {
        setPropValue(entity, propName, propValue, false);
    }",Sets the property value of a base class.
"public void doSetDataSource(DataSource dataSource) {
    if (mediaInfo.get(dataSource) == null) {
      throw new IllegalArgumentException(
          ""Don't know what to do with dataSource ""
              + dataSource
              + "" - either add an exception with addException() or media info with addMediaInfo()"");
    }
    this.dataSource = dataSource;
  }",Set the data source.
"private static void createFeedMapping(
      AdWordsServicesInterface adWordsServices, AdWordsSession session, DSAFeedDetails feedDetails)
      throws RemoteException {
    // Get the FeedMappingService.
    FeedMappingServiceInterface feedMappingService =
        adWordsServices.get(session, FeedMappingServiceInterface.class);

    // Map the FeedAttributeIds to the fieldId constants.
    AttributeFieldMapping urlFieldMapping = new AttributeFieldMapping();
    urlFieldMapping.setFeedAttributeId(feedDetails.urlAttributeId);
    urlFieldMapping.setFieldId(DSA_PAGE_URLS_FIELD_ID);
    AttributeFieldMapping labelFieldMapping = new AttributeFieldMapping();
    labelFieldMapping.setFeedAttributeId(feedDetails.labelAttributeId);
    labelFieldMapping.setFieldId(DSA_LABEL_FIELD_ID);

    // Create the FeedMapping and operation.
    FeedMapping feedMapping = new FeedMapping();
    feedMapping.setCriterionType(DSA_PAGE_FEED_CRITERION_TYPE);
    feedMapping.setFeedId(feedDetails.feedId);
    feedMapping.setAttributeFieldMappings(
        new AttributeFieldMapping[] {urlFieldMapping, labelFieldMapping});
    FeedMappingOperation operation = new FeedMappingOperation();
    operation.setOperand(feedMapping);
    operation.setOperator(Operator.ADD);

    // Add the field mapping.
    FeedMapping newFeedMapping =
        feedMappingService.mutate(new FeedMappingOperation[] {operation}).getValue(0);
    System.out.printf(
        ""Feed mapping with ID %d and criterionType %d was saved for feed with ID %d.%n"",
        newFeedMapping.getFeedMappingId(),
        newFeedMapping.getCriterionType(),
        newFeedMapping.getFeedId());
  }",Creates the feed mapping.
"private JMFType findTupleChildByName(JSTuple tup, String name) {
    for (int i = 0; i < tup.getFieldCount(); i++) {
      JMFType theField = getEffectiveType(tup.getField(i));
      String fieldName = theField.getFeatureName();
      if (fieldName != null && fieldName.equals(name))
        return theField;
    }
    return null;
  }",Find tuple child by name
"@Override
  public void write(Fields fields) throws IOException {
    delegateFieldsConsumer.write(fields);
    write(state.fieldInfos, fields);
  }",Write a sequence of bytes to the output stream.
"public static String shortenString(String text, int maxLength) {

        if (text.length() <= maxLength) {
            return text;
        }
        String newText = text.substring(0, maxLength - 1);
        if (text.startsWith(""/"")) {
            // file name?
            newText = CmsStringUtil.formatResourceName(text, maxLength);
        } else if (maxLength > 2) {
            // enough space for ellipsis?
            newText += CmsDomUtil.Entity.hellip.html();
        }
        if (CmsStringUtil.isEmptyOrWhitespaceOnly(newText)) {
            // if empty, it could break the layout
            newText = CmsDomUtil.Entity.nbsp.html();
        }
        return newText;
    }",Shorten a string to a given length.
"public static <K, V, NK, NV> Map<NK, NV> newChangedKeyValueMap(
            Map<K, V> map, Function<K, NK> changingKeyFunction,
            Function<V, NV> changingValueFunction) {
        return buildEntryStream(map).collect(toMap(
                entry -> changingKeyFunction.apply(entry.getKey()),
                entry -> changingValueFunction.apply(entry.getValue())));
    }",New changed key value map map.
"public void resetContentAndSettings() {
    if (instrumentsVersion.getMajor() < 6) {
      if (hasContentAndSettingsFolder()) {
        boolean ok = deleteRecursive(getContentAndSettingsFolder());
        if (!ok) {
          System.err.println(""cannot delete content and settings folder "" + contentAndSettingsFolder);
        }
      }

      // Wipe the system.log.
      String deviceLogDir = System.getProperty(""user.home"") +
          ""/Library/Logs/iOS Simulator/"" + exactSdkVersion + ((is64bit) ? ""-64"" : """");
      File deviceLog = new File(deviceLogDir, ""system.log"");
      if (deviceLog.exists()) {
        deviceLog.delete();
      }

      boolean ok = contentAndSettingsFolder.mkdirs();
      if (!ok) {
        System.err.println(""couldn't re-create: "" + contentAndSettingsFolder);
      }
    } else {
      if (!eraseSimulator()) {
        log.info(""Erase contents and settings failed on this device: "" + deviceUUID);
        tryToEraseSimulator();
      }
    }
  }",Reset the contents and settings folder.
"public static Validator<CharSequence> letter(@NonNull final CharSequence errorMessage,
                                                 @NonNull final Case caseSensitivity,
                                                 final boolean allowSpaces,
                                                 @NonNull final char... allowedCharacters) {
        return new LetterValidator(errorMessage, caseSensitivity, allowSpaces, allowedCharacters);
    }",Create a new letter validator.
"public Result<Void> addPerm(AuthzTrans trans, RoleDAO.Data role, PermDAO.Data perm) {
		// Note: Prepared Statements for Collection updates aren't supported
		String pencode = perm.encode();
		try {
			getSession(trans).execute(UPDATE_SP + TABLE + "" SET perms = perms + {'"" + 
				pencode + ""'} WHERE "" +
				""ns = '"" + role.ns + ""' AND name = '"" + role.name + ""';"");
		} catch (DriverException | APIException | IOException e) {
			reportPerhapsReset(trans,e);
			return Result.err(Result.ERR_Backend, CassAccess.ERR_ACCESS_MSG);
		}

		wasModified(trans, CRUD.update, role, ""Added permission "" + pencode + "" to role "" + role.fullName());
		return Result.ok();
	}",Add a permission to a role.
"public static int type(String type)
    {
        if (""request"".equalsIgnoreCase(type))
            return __REQUEST;
        if (""forward"".equalsIgnoreCase(type))
            return __FORWARD;
        if (""include"".equalsIgnoreCase(type))
            return __INCLUDE;
        if (""error"".equalsIgnoreCase(type))
            return __ERROR;
        throw new IllegalArgumentException(type);
    }",Get the type of the resource.
"public FunctionList union(FunctionList that) {
        Set<Function> combined = new LinkedHashSet<Function>();
        combined.addAll(Arrays.asList(this.functions));
        combined.addAll(Arrays.asList(that.functions));
        return new FunctionList(combined);
    }",Returns a new FunctionList that contains all of the functions in this one.
"public void writeMethod(ClassVisitor cw, boolean typeQueryRootBean) {

    // simple why to determine the property is an associated bean type
    boolean assocProperty = desc.contains(""/QAssoc"");

    if (classInfo.isLog(4)) {
      classInfo.log("" ... add method _"" + name + "" assocProperty:"" + assocProperty + "" rootBean:"" + typeQueryRootBean);
    }

    MethodVisitor mv = cw.visitMethod(ACC_PUBLIC, ""_""+name, ""()""+desc, ""()""+signature, null);
    mv.visitCode();
    Label l0 = new Label();
    mv.visitLabel(l0);
    mv.visitLineNumber(1, l0);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), name, desc);
    Label l1 = new Label();
    mv.visitJumpInsn(IFNONNULL, l1);
    Label l2 = new Label();
    mv.visitLabel(l2);
    mv.visitLineNumber(2, l2);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitTypeInsn(NEW, internalName);
    mv.visitInsn(DUP);
    mv.visitLdcInsn(name);
    mv.visitVarInsn(ALOAD, 0);

    if (assocProperty) {
      if (typeQueryRootBean) {
        mv.visitInsn(ICONST_1);
        mv.visitMethodInsn(INVOKESPECIAL, internalName, ""<init>"", ""(Ljava/lang/String;Ljava/lang/Object;I)V"", false);
      } else {
        mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), FIELD_ROOT, ""Ljava/lang/Object;"");
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), FIELD_PATH, ""Ljava/lang/String;"");
        mv.visitInsn(ICONST_1);
        mv.visitMethodInsn(INVOKESPECIAL, internalName, ""<init>"", ""(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/String;I)V"", false);
      }

    } else {
      if (typeQueryRootBean) {
        mv.visitMethodInsn(INVOKESPECIAL, internalName, ""<init>"", ""(Ljava/lang/String;Ljava/lang/Object;)V"", false);
      } else {
        mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), FIELD_ROOT, ""Ljava/lang/Object;"");
        mv.visitVarInsn(ALOAD, 0);
        mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), FIELD_PATH, ""Ljava/lang/String;"");
        mv.visitMethodInsn(INVOKESPECIAL, internalName, ""<init>"", ""(Ljava/lang/String;Ljava/lang/Object;Ljava/lang/String;)V"", false);
      }
    }

    mv.visitFieldInsn(PUTFIELD, classInfo.getClassName(), name, desc);
    mv.visitLabel(l1);
    mv.visitLineNumber(3, l1);
    mv.visitFrame(Opcodes.F_SAME, 0, null, 0, null);
    mv.visitVarInsn(ALOAD, 0);
    mv.visitFieldInsn(GETFIELD, classInfo.getClassName(), name, desc);
    mv.visitInsn(ARETURN);
    Label l3 = new Label();
    mv.visitLabel(l3);
    mv.visitLocalVariable(""this"", ""L"" + classInfo.getClassName() + "";"", null, l0, l3, 0);
    if (assocProperty) {
      if (typeQueryRootBean) {
        mv.visitMaxs(6, 1);
      } else {
        mv.visitMaxs(7, 1);
      }
    } else {
      if (typeQueryRootBean) {
        mv.visitMaxs(5, 1);
      } else {
        mv.visitMaxs(6, 1);
      }
    }
    mv.visitEnd();
  }",Write the method.
"@SuppressWarnings(""checkstyle:magicnumber"")
    void writeLong(long value) {
        if (value == Long.MIN_VALUE) {
            write(STR_LONG_MIN_VALUE);
            return;
        }

        if (value < 0) {
            write('-');
            value = -value;
        }

        int digitsWithoutComma = 0;
        tmpSb.setLength(0);
        do {
            digitsWithoutComma++;
            if (digitsWithoutComma == 4) {
                tmpSb.append(',');
                digitsWithoutComma = 1;
            }

            int mod = (int) (value % 10);
            tmpSb.append(DIGITS[mod]);
            value = value / 10;
        } while (value > 0);

        for (int k = tmpSb.length() - 1; k >= 0; k--) {
            char c = tmpSb.charAt(k);
            write(c);
        }
    }",Write a long value.
"@Override
  public void run() {
    List<CompactionVerifier> verifiers = this.suite.getMapReduceVerifiers();
    for (CompactionVerifier verifier : verifiers) {
      if (!verifier.verify(dataset).isSuccessful()) {
        log.error(""Verification {} for {} is not passed."", verifier.getName(), dataset.datasetURN());
        this.onMRTaskComplete (false, new IOException(""Compaction verification for MR is failed""));
        return;
      }
    }

    super.run();
  }",Override run to verify the MR
"protected static int klu_valid_LU(int n, int flag_test_start_ptr,
			int[] Xip, int Xip_offset, int[] Xlen, int Xlen_offset,
			double[] LU)
	{
		/*int[]*/double[] Xi ;
		double[] Xx ;
		int j, p1, p2, i, p ;
		int[] len = new int[1] ;
		int[] Xi_offset = new int[1] ;
		int[] Xx_offset = new int[1] ;

		PRINTF (""\ncolumn oriented matrix, n = %d\n"", n) ;
		if (n <= 0)
		{
			PRINTF (""n must be >= 0: %d\n"", n) ;
			return (FALSE) ;
		}
		if (flag_test_start_ptr != 0 && Xip [Xip_offset + 0] != 0)
		{
			/* column pointers must start at Xip [0] = 0*/
			PRINTF (""column 0 pointer bad\n"") ;
			return (FALSE) ;
		}

		for (j = 0 ; j < n ; j++)
		{
			p1 = Xip [Xip_offset + j] ;
			p2 = Xip [Xip_offset + j+1] ;
			PRINTF (""\nColumn: %d p1: %d p2: %d\n"", j, p1, p2) ;
			if (p1 > p2)
			{
				/* column pointers must be ascending */
				PRINTF (""column %d pointer bad\n"", j) ;
				return (FALSE) ;
			}
			Xi = Xx = GET_POINTER (LU, Xip, Xip_offset, Xlen, Xlen_offset,
					Xi_offset, Xx_offset, j, len) ;
			for (p = 0 ; p < len[0] ; p++)
			{
				i = (int) Xi [Xi_offset[0] + p] ;
				PRINTF (""row: %d"", i) ;
				if (i < 0 || i >= n)
				{
					/* row index out of range */
					PRINTF (""index out of range, col %d row %d\n"", j, i) ;
					return (FALSE) ;
				}
				if (Xx != null)
				{
					PRINT_ENTRY (Xx [Xx_offset[0] + p]) ;
				}
				PRINTF (""\n"") ;
			}
		}

		return (TRUE) ;
	}",Checks if the matrix is valid for a given number of columns.
"public Pair<String, StatusCode> sendRequest(ProjectsDetails projectsDetails) {
        // send request
        logger.info(""Initializing WhiteSource Client"");
        Collection<AgentProjectInfo> projects = projectsDetails.getProjects();

        if (checkDependenciesUpbound(projects)) {
            return new Pair<>(""Number of dependencies exceeded the maximum supported"", StatusCode.SERVER_FAILURE);
        }

        WhitesourceService service = createService();
        String resultInfo = Constants.EMPTY_STRING;
        if (offlineConfig.isOffline()) {
            resultInfo = offlineUpdate(service, projects);
            return new Pair<>(resultInfo, this.prepStepStatusCode);
        } else {
            // update type
            UpdateType updateType = UpdateType.OVERRIDE;
            String updateTypeValue = senderConfig.getUpdateTypeValue();
            try {
                updateType = UpdateType.valueOf(updateTypeValue);
            } catch (Exception e) {
                logger.info(""Invalid value {} for updateType, defaulting to {}"", updateTypeValue, UpdateType.OVERRIDE);
            }
            logger.info(""UpdateType set to {} "", updateTypeValue);

            StatusCode statusCode = StatusCode.SUCCESS;
            if (senderConfig.isEnableImpactAnalysis()) {
                runViaAnalysis(projectsDetails, service);
            } else if (!senderConfig.isEnableImpactAnalysis()) {
                //todo return logs when needed would be enabled for all WSE-342
            }
            int retries = senderConfig.getConnectionRetries();
            while (retries-- > -1) {
                try {
                    statusCode = checkPolicies(service, projects);
                    if (senderConfig.isUpdateInventory()) {
                        if (statusCode == StatusCode.SUCCESS || (senderConfig.isForceUpdate() && senderConfig.isForceUpdateFailBuildOnPolicyViolation())) {
                            resultInfo = update(service, projects);
                        }
                    }
                    break;
                } catch (WssServiceException e) {
                    if (e.getCause() != null &&
                            e.getCause().getClass().getCanonicalName().substring(0,
                                    e.getCause().getClass().getCanonicalName().lastIndexOf(Constants.DOT)).equals(Constants.JAVA_NETWORKING)) {
                        statusCode = StatusCode.CONNECTION_FAILURE;
                        logger.error(""Trying "" + (retries + 1) + "" more time"" + (retries != 0 ? ""s"" : Constants.EMPTY_STRING));
                    } else {
                        statusCode = StatusCode.SERVER_FAILURE;
                        retries = -1;
                    }
                    resultInfo = ""Failed to send request to WhiteSource server: "" + e.getMessage();
                    logger.error(resultInfo, e.getMessage());
                    logger.debug(resultInfo, e);
                    if (retries > -1) {
                        try {
                            Thread.sleep(senderConfig.getConnectionRetriesIntervals());
                        } catch (InterruptedException e1) {
                            logger.error(""Failed to sleep while retrying to connect to server "" + e1.getMessage(), e1);
                        }
                    }
                    String requestToken = e.getRequestToken();
                    if (StringUtils.isNotBlank(requestToken)) {
                        resultInfo += Constants.NEW_LINE + ""Support token: "" + requestToken;
                        logger.info(""Support token: {}"", requestToken);
                    }
                }
            }
            if (service != null) {
                service.shutdown();
            }
            if (statusCode == StatusCode.SUCCESS) {
                return new Pair<>(resultInfo, this.prepStepStatusCode);
            }
            return new Pair<>(resultInfo, statusCode);
        }
    }",Send request to WhiteSource
"public Object extractJavaFieldValue(Object object) throws SQLException {

		Object val = extractRawJavaFieldValue(object);

		// if this is a foreign object then we want its reference field
		if (foreignRefField != null && val != null) {
			val = foreignRefField.extractRawJavaFieldValue(val);
		}

		return val;
	}",Extract the value of the field from the given object.
"final static public char[] trim(char[] chars)
	{

		if (chars == null)
		{
			return null;
		}

		int start = 0, length = chars.length, end = length - 1;
		while (start < length && chars[start] == ' ')
		{
			start++;
		}
		while (end > start && chars[end] == ' ')
		{
			end--;
		}
		if (start != 0 || end != length - 1)
		{
			return subarray(chars, start, end + 1);
		}
		return chars;
	}",Trims the specified char array and returns a new array containing all whitespace characters removed.
"public void doGet(HttpServletRequest request, HttpServletResponse response)
    throws ServletException, IOException {
    NameNode.getNameNodeMetrics().numListPathsServletDoGet.inc();
    final UnixUserGroupInformation ugi = getUGI(request);
    final PrintWriter out = response.getWriter();
    final XMLOutputter doc = new XMLOutputter(out, ""UTF-8"");
    try {
      final Map<String, String> root = buildRoot(request, doc);
      final String path = root.get(""path"");
      final boolean recur = ""yes"".equals(root.get(""recursive""));
      final Pattern filter = Pattern.compile(root.get(""filter""));
      final Pattern exclude = Pattern.compile(root.get(""exclude""));
      ClientProtocol nnproxy = createNameNodeProxy(ugi);

      doc.declaration();
      doc.startTag(""listing"");
      for (Map.Entry<String,String> m : root.entrySet()) {
        doc.attribute(m.getKey(), m.getValue());
      }

      HdfsFileStatus base = nnproxy.getHdfsFileInfo(path);
      if ((base != null) && base.isDir()) {
        writeInfo(path, base, doc);
      }

      Stack<String> pathstack = new Stack<String>();
      pathstack.push(path);
      while (!pathstack.empty()) {
        String p = pathstack.pop();
        try {
          byte[] lastReturnedName = HdfsFileStatus.EMPTY_NAME;
          DirectoryListing thisListing;
          do {
            assert lastReturnedName != null;
            thisListing = nnproxy.getPartialListing(p, lastReturnedName);
            if (thisListing == null) {
              if (lastReturnedName.length == 0) {
                LOG.warn(""ListPathsServlet - Path "" + p + "" does not exist"");
              }
              break;
            }
            HdfsFileStatus[] listing = thisListing.getPartialListing();
            for (HdfsFileStatus i : listing) {
              String localName = i.getLocalName();
              if (exclude.matcher(localName).matches()
                  || !filter.matcher(localName).matches()) {
                continue;
              }
              if (recur && i.isDir()) {
                pathstack.push(new Path(p, localName).toUri().getPath());
              }
              writeInfo(p, i, doc);
            }
            lastReturnedName = thisListing.getLastName();
          } while (thisListing.hasMore());
        } catch(RemoteException re) {re.writeXml(p, doc);}
      }
      if (doc != null) {
        doc.endDocument();
      }
    } finally {
      if (out != null) {
        out.close();
      }
    }
  }",Get a list of paths from the name node.
"public static l4param get(nitro_service service) throws Exception{
		l4param obj = new l4param();
		l4param[] response = (l4param[])obj.get_resources(service);
		return response[0];
	}",Use this API to fetch all the l4param resources that are configured on netscaler.
"private int getColor(Point p1, Point p2) {
    float d = distance(p1, p2);
    float dx = (p2.getX() - p1.getX()) / d;
    float dy = (p2.getY() - p1.getY()) / d;
    int error = 0;

    float px = p1.getX();
    float py = p1.getY();

    boolean colorModel = image.get(p1.getX(), p1.getY());

    int iMax = (int) Math.ceil(d);
    for (int i = 0; i < iMax; i++) {
      px += dx;
      py += dy;
      if (image.get(MathUtils.round(px), MathUtils.round(py)) != colorModel) {
        error++;
      }
    }

    float errRatio = error / d;

    if (errRatio > 0.1f && errRatio < 0.9f) {
      return 0;
    }

    return (errRatio <= 0.1f) == colorModel ? 1 : -1;
  }",Get the color of the two points
"public void findModules() {
        ServiceLoader<ClientModuleFactory> loader = ServiceLoader.load(ClientModuleFactory.class);

        Iterator<ClientModuleFactory> iterator = loader.iterator();
        while (iterator.hasNext()) {
            ClientModuleFactory factory = iterator.next();
            Module module = factory.create();
            addModule(module);
        }

        objectMapper.findAndRegisterModules();
    }",Find all modules in the system.
"public void didInvoke(Method method, List<JsonNode> arguments, Object result, Throwable t, long duration) {
		for (InvocationListener invocationListener : invocationListeners) {
			invocationListener.didInvoke(method, arguments, result, t, duration);
		}
	}",Called by the interceptor when a method is invoked.
"public String replaceSensitiveWord(String txt,MatchType matchType,String replaceChar){
		String resultTxt = txt;
		Set<String> set = findSensitiveWord(txt, matchType);     //获取所有的敏感词
		Iterator<String> iterator = set.iterator();
		String word = null;
		String replaceString = null;
		while (iterator.hasNext()) {
			word = iterator.next();
			replaceString = getReplaceChars(replaceChar, word.length());
			resultTxt = resultTxt.replaceAll(word, replaceString);
		}
		
		return resultTxt;
	}",Replace sensitive word.
"public Object parse(String value, Class type)
    {
        if (StringUtil.isBlank(value))
        {
            return null;
        }

        return doConvert(value.trim(), type);
    }",Parse a string value into an object of the specified type.
"private static double getMinPlusMaxObject(List<? extends SpatialComparable> objs, int s, int dim) {
    SpatialComparable sobj = objs.get(s);
    return sobj.getMin(dim) + sobj.getMax(dim);
  }",Get the min + max object.
"protected UserDetailsService userDetailsService() {
		AuthenticationManagerBuilder globalAuthBuilder = context
				.getBean(AuthenticationManagerBuilder.class);
		return new UserDetailsServiceDelegator(Arrays.asList(
				localConfigureAuthenticationBldr, globalAuthBuilder));
	}",This method is called by the userDetailsServiceDelegator in order to create a UserDetailsServiceDelegator.
"@Override
  protected String getDescription(final MBeanOperationInfo op) {

    String descr = op.getDescription();
    Method m = getMethod(op);
    if (m != null) {
      MBeanInfo d = m.getAnnotation(MBeanInfo.class);
      if (d != null) {
        descr = d.value();
      }
    }
    return descr;
  }",Override the getDescription method to get the description of the MBeanOperationInfo object.
"protected byte[] fileToByteArray(File file) throws IOException
   {
      FileInputStream in = null;

      try
      {
         if (channel == null || !channel.isOpen())
         {
            in = PrivilegedFileHelper.fileInputStream(file);
            channel = in.getChannel();
         }

         ByteBuffer bb = ByteBuffer.allocate((int)channel.size());
         channel.read(bb);
         if (bb.hasArray())
         {
            return bb.array();
         }
         else
         {
            // impossible code in most cases, as we use heap backed buffer
            byte[] tmpb = new byte[bb.capacity()];
            bb.get(tmpb);
            return tmpb;
         }
      }
      finally
      {
         if (in != null)
         {
            in.close();
            if (channel != null)
            {
               channel.close();
            }
         }
      }
   }",File to byte array.
"public static String createVMJson(
			String hostIpPort,
			String id,
			String template,
			String title,
			String summary,
			String userData,
			String user,
			String password,
			Map<String,String> config,
			boolean waitForActive )
	throws TargetException {

		// Count VM creations (+ make title unique, it is used as VM ID by VMWare !)
		String uniqueTitle = title + (++vmCount);

		//TODO Expecting more interoperable implementation !
		if(config.get(CloudautomationMixins.PROVIDER_ENDPOINT) != null) {
			return createCloudAutomationVM(hostIpPort, id, template, title, summary, userData, config, false);
		} else {

			String vmId = null;
			URL url = null;
			try {
				CookieHandler.setDefault(new CookieManager(null, CookiePolicy.ACCEPT_ALL));
				url = new URL(""http://"" + hostIpPort + ""/vm/"");
			} catch (MalformedURLException e) {
				throw new TargetException(e);
			}

			HttpURLConnection httpURLConnection = null;
			DataInputStream in = null;
			DataOutputStream output = null;
			try {
				httpURLConnection = (HttpURLConnection) url.openConnection();
				httpURLConnection.setRequestMethod(""PUT"");
				httpURLConnection.setRequestProperty(""Content-Type"", ""application/json"");
				httpURLConnection.setRequestProperty(""Accept"", ""application/json"");
				httpURLConnection.setDoInput(true);
				httpURLConnection.setDoOutput(true);

				String userDataString = ""name: value"";
				if(userData != null) {
					userDataString =
							userData.replaceAll(""\n\r"", ""\\\\n"")
							.replaceAll(""\n"", ""\\\\n"")
							.replaceAll(System.lineSeparator(), ""\\\\n"");
				}

				String request = ""{\n""
						+ ""\""id\"": \"""" + id + ""\"",\n""
						+ ""\""title\"": \"""" + uniqueTitle + ""\"",\n""
						+ ""\""summary\"": \"""" + summary + ""\"",\n""
						+ ""\""kind\"": \""http://schemas.ogf.org/occi/infrastructure#compute\"",\n""
						+ ""\""mixins\"": [""
						+ ""\""http://occiware.org/occi/infrastructure/crtp/backend#vmimage\"",\n""
						+ ""\""http://occiware.org/occi/infrastructure/crtp/backend#vmwarefolders\"",\n""
						+ ""\""http://schemas.ogf.org/occi/infrastructure/compute#user_data\"",\n""
						+ ""\""http://occiware.org/occi/infrastructure/crtp/backend#credential\""\n""
						+ ""],\n""
						+ ""\""attributes\"": {\n""
						+ ""\""occi.compute.state\"": \"""" + ""active"" + ""\"",\n""
						+ ""\""occi.compute.speed\"": "" + 3 + "",\n""
						+ ""\""occi.compute.memory\"": "" + 2 + "",\n""
						+ ""\""occi.compute.cores\"": "" + 2 + "",\n""
						+ ""\""occi.compute.architecture\"": \"""" + ""x64"" + ""\"",\n""
						+ ""\""imagename\"": \"""" + template + ""\"",\n""
						+ ""\""datacentername\"": \"""" + config.get(VmwareFoldersMixin.DATACENTERNAME) + ""\"",\n""
						+ ""\""datastorename\"": \"""" + config.get(VmwareFoldersMixin.DATASTORENAME) + ""\"",\n""
						+ ""\""clustername\"": \"""" + config.get(VmwareFoldersMixin.CLUSTERNAME) + ""\"",\n""
						+ ""\""hostsystemname\"": \"""" + config.get(VmwareFoldersMixin.HOSTSYSTEMNAME) + ""\"",\n""
						+ ""\""inventorypath\"": \"""" + config.get(VmwareFoldersMixin.INVENTORYPATH) + ""\"",\n""
						+ ""\""occi.compute.userdata\"": \"""" + userDataString + ""\"",\n""
						+ ""\""user\"": \"""" + user + ""\"",\n""
						+ ""\""password\"": \"""" + password + ""\""\n""
						+ ""}\n}"";

				final Logger logger = Logger.getLogger( OcciVMUtils.class.getName());
				logger.finest(request);

				httpURLConnection.setRequestProperty(
						""Content-Length"",
						Integer.toString(request.getBytes( StandardCharsets.UTF_8 ).length));

				output = new DataOutputStream(httpURLConnection.getOutputStream());
				output.writeBytes(request);
				output.flush();
				Utils.closeQuietly(output);
				output = null;

				in = new DataInputStream(httpURLConnection.getInputStream());
				ByteArrayOutputStream out = new ByteArrayOutputStream();
				Utils.copyStreamSafely(in, out);

				// Parse JSON response to extract VM ID
				ObjectMapper objectMapper = new ObjectMapper();
				JsonResponse rsp = objectMapper.readValue(out.toString( ""UTF-8"" ), JsonResponse.class);
				vmId = rsp.getId();

				if(! Utils.isEmptyOrWhitespaces(vmId)) {
					// Wait until VM is active, if requested
					if(waitForActive) {
						int retries = 15;
						boolean active = false;
						while(! active && retries-- > 0) {
							logger.finest(""retry: "" + retries);
							try {
								Thread.sleep(10000);  // 10 seconds
							} catch (InterruptedException e) {
								// ignore
							}
							active = !Utils.isEmptyOrWhitespaces(getVMIP(hostIpPort + ""/compute"", vmId));
							//active = ""ACTIVE"".equalsIgnoreCase(getVMStatus(hostIpPort, ret));
						}
					}
				}

			} catch (IOException e) {
				throw new TargetException(e);

			}  finally {
				Utils.closeQuietly(in);
				Utils.closeQuietly(output);
				if (httpURLConnection != null) {
					httpURLConnection.disconnect();
				}
			}

			return (vmId);
		}
	}",Creates a VM in JSON format.
"private void checkAndValidateParameters(ConfigProperty configProperty) {
        LOGGER.entering(configProperty);
        try {
            switch (configProperty) {
            case SELENDROID_SERVER_START_TIMEOUT:
            case SELENDROID_EMULATOR_START_TIMEOUT: {
                // Selendroid takes timeoutEmulatorStart/serverStartTimeout in milliseconds.
                Config.getIntConfigProperty(configProperty);
                break;
            }
            case MOBILE_DRIVER_SESSION_TIMEOUT: {
                // Selendroid takes sessionTimeout in seconds.
                int receivedValue = Config.getIntConfigProperty(configProperty) / 1000;
                if (receivedValue == 0) {
                    String errorMessage = ""Insufficient value received for configuration property ""
                            + configProperty.getName() + "", probably value is less than 1000 milliseconds."";
                    throw new IllegalArgumentException(errorMessage);
                }
                break;
            }
            default: {
                throw new IllegalArgumentException(
                        ""Invalid selendroid configuration received for validation, configuration property = ""
                                + configProperty.getName());
            }
            }
        } catch (ConversionException exe) {
            String errorMessage = ""Invalid data received for configuration property "" + configProperty.getName()
                    + "", probably not an integer for milliseconds."";
            throw new IllegalArgumentException(errorMessage, exe);
        }

        LOGGER.exiting();
    }",Check if the configuration property is valid.
"private IChemFile readChemFile(IChemFile file) {
        IChemSequence chemSequence = file.getBuilder().newInstance(IChemSequence.class);
        IChemModel chemModel = file.getBuilder().newInstance(IChemModel.class);
        IAtomContainerSet setOfMolecules = file.getBuilder().newInstance(IAtomContainerSet.class);
        String info;

        StringTokenizer tokenizer;
        List<String> aroringText = new ArrayList<String>();
        List<IAtomContainer> mols = new ArrayList<IAtomContainer>();

        try {
            String line;

            // read in header info
            while (true) {
                line = input.readLine();
                if (line.startsWith(""mol"")) {
                    info = getMolName(line);
                    break;
                }
            }

            // start the actual molecule data - may be multiple molecule
            line = input.readLine();
            while (true) {
                if (line == null) break; // end of file
                if (line.startsWith("";"")) continue; // comment line

                if (line.startsWith(""mol"")) {
                    info = getMolName(line);
                    line = input.readLine();
                }
                IAtomContainer m = file.getBuilder().newInstance(IAtomContainer.class);
                m.setTitle(info);

                // Each element of cons is an ArrayList of length 3 which stores
                // the start and end indices and bond order of each bond
                // found in the HIN file. Before adding bonds we need to reduce
                // the number of bonds so as not to count the same bond twice
                List<List<Object>> cons = new ArrayList<List<Object>>();

                // read data for current molecule
                int atomSerial = 0;
                while (true) {
                    if (line == null || line.contains(""endmol"")) {
                        break;
                    }
                    if (line.startsWith("";"")) continue; // comment line

                    tokenizer = new StringTokenizer(line, "" "");

                    int ntoken = tokenizer.countTokens();
                    String[] toks = new String[ntoken];
                    for (int i = 0; i < ntoken; i++)
                        toks[i] = tokenizer.nextToken();

                    String sym = toks[3];
                    double charge = Double.parseDouble(toks[6]);
                    double x = Double.parseDouble(toks[7]);
                    double y = Double.parseDouble(toks[8]);
                    double z = Double.parseDouble(toks[9]);
                    int nbond = Integer.parseInt(toks[10]);

                    IAtom atom = file.getBuilder().newInstance(IAtom.class, sym, new Point3d(x, y, z));
                    atom.setCharge(charge);

                    IBond.Order bo = IBond.Order.SINGLE;

                    for (int j = 11; j < (11 + nbond * 2); j += 2) {
                        int s = Integer.parseInt(toks[j]) - 1; // since atoms start from 1 in the file
                        char bt = toks[j + 1].charAt(0);
                        switch (bt) {
                            case 's':
                                bo = IBond.Order.SINGLE;
                                break;
                            case 'd':
                                bo = IBond.Order.DOUBLE;
                                break;
                            case 't':
                                bo = IBond.Order.TRIPLE;
                                break;
                            case 'a':
                                bo = IBond.Order.QUADRUPLE;
                                break;
                        }
                        List<Object> ar = new ArrayList<Object>(3);
                        ar.add(atomSerial);
                        ar.add(s);
                        ar.add(bo);
                        cons.add(ar);
                    }
                    m.addAtom(atom);
                    atomSerial++;
                    line = input.readLine();
                }

                // now just store all the bonds we have
                for (List<Object> ar : cons) {
                    IAtom s = m.getAtom((Integer) ar.get(0));
                    IAtom e = m.getAtom((Integer) ar.get(1));
                    IBond.Order bo = (IBond.Order) ar.get(2);
                    if (!isConnected(m, s, e)) m.addBond(file.getBuilder().newInstance(IBond.class, s, e, bo));
                }
                mols.add(m);

                // we may not get a 'mol N' immediately since
                // the aromaticring keyword might be present
                // and doesn't seem to be located within the molecule
                // block. However, if we do see this keyword we save this
                // since it can contain aromatic specs for any molecule
                // listed in the file
                //
                // The docs do not explicitly state the the keyword comes
                // after *all* molecules. So we save and then reprocess
                // all the molecules in a second pass
                while (true) {
                    line = input.readLine();
                    if (line == null || line.startsWith(""mol"")) break;
                    if (line.startsWith(""aromaticring"")) aroringText.add(line.trim());
                }
            }

        } catch (IOException e) {
            // FIXME: should make some noise now
            file = null;
        }

        if (aroringText.size() > 0) { // process aromaticring annotations
            for (String line : aroringText) {
                String[] toks = line.split("" "");
                int natom = Integer.parseInt(toks[1]);
                int n = 0;
                for (int i = 2; i < toks.length; i += 2) {
                    int molnum = Integer.parseInt(toks[i]); // starts from 1
                    int atnum = Integer.parseInt(toks[i + 1]); // starts from 1
                    mols.get(molnum - 1).getAtom(atnum - 1).setFlag(CDKConstants.ISAROMATIC, true);
                    n++;
                }
                assert n == natom;
            }
        }

        for (IAtomContainer mol : mols)
            setOfMolecules.addAtomContainer(mol);
        chemModel.setMoleculeSet(setOfMolecules);
        chemSequence.addChemModel(chemModel);
        file.addChemSequence(chemSequence);

        return file;
    }",Reads the ChemFile from the input stream.
"public static QualifiedName of(String packageName, String topLevelType, String... nestedTypes) {
    requireNonNull(!packageName.isEmpty());
    checkArgument(!topLevelType.isEmpty());
    return new QualifiedName(
        unshadedName(packageName),  // shadowJar modifies string literals; unshade them here
        ImmutableList.<String>builder().add(topLevelType).add(nestedTypes).build());
  }",Create a QualifiedName from a package name topLevelType and nestedTypes.
"public synchronized void update() {
    SYSTEM_POWER_STATUS status = new SYSTEM_POWER_STATUS();
    Kernel32.INSTANCE.GetSystemPowerStatus(status);

    switch (status.ACLineStatus) {
    case 0: // battery
      allow(!requireAC
          && (status.BatteryLifePercent < 0 || status.BatteryLifePercent >= minBatteryLifePercent));
      break;

    case 1:  // A/C
    default:
      allow((status.BatteryFlag & 0x8) == 0 // not charging
          || (status.BatteryLifePercent < 0 || status.BatteryLifePercent >= minBatteryLifePercentWhileCharging));
      break;

    }
  }",Update the BatteryLifePercent and BatteryLifePercent
"private static org.apache.maven.model.RepositoryPolicy asMavenRepositoryPolicy(
            org.apache.maven.settings.RepositoryPolicy policy) {

        org.apache.maven.model.RepositoryPolicy mavenPolicy = new org.apache.maven.model.RepositoryPolicy();
        if (policy != null) {
            mavenPolicy.setChecksumPolicy(policy.getChecksumPolicy());
            mavenPolicy.setUpdatePolicy(policy.getUpdatePolicy());
            mavenPolicy.setEnabled(policy.isEnabled());
        }

        return mavenPolicy;
    }",As Maven Repository Policy.
"private Number calculatePercentComplete(Row row)
   {
      Number result;
      switch (PercentCompleteType.getInstance(row.getString(""complete_pct_type"")))
      {
         case UNITS:
         {
            result = calculateUnitsPercentComplete(row);
            break;
         }

         case DURATION:
         {
            result = calculateDurationPercentComplete(row);
            break;
         }

         default:
         {
            result = calculatePhysicalPercentComplete(row);
            break;
         }
      }

      return result;
   }",Calculate the percent complete value.
"@Nullable
    public MongoCredential getCredential() {
        if (getCredentialsList().size() > 1) {
            throw new IllegalStateException(""Instance constructed with more than one MongoCredential"");
        } else if (getCredentialsList().isEmpty()) {
            return null;
        } else {
            return getCredentialsList().get(0);
        }
    }",Gets the first credential in the list.
"@GwtIncompatible(""incompatible method"")
    public static void isInstanceOf(final Class<?> type, final Object obj, final String message, final Object... values) {
        // TODO when breaking BC, consider returning obj
        if (!type.isInstance(obj)) {
            throw new IllegalArgumentException(StringUtils.simpleFormat(message, values));
        }
    }",Check if an object is an instance of the specified type.
"public static String applyFromPath(String path) throws ConverterException {		
		String xml = converters.get(0).convertFromPath(path, false);						
		xml = applyFromSecond(xml);
		if (conversionDone()) {
			return converters.get(converters.size()-1).changeVersion(xml);
		} else {
			return xml;
		}
	}",Apply the conversion from the first converter to the second converter.
"static int getAnimationResource(int gravity, boolean isInAnimation) {
    if ((gravity & Gravity.TOP) == Gravity.TOP) {
      return isInAnimation ? R.anim.slide_in_top : R.anim.slide_out_top;
    }
    if ((gravity & Gravity.BOTTOM) == Gravity.BOTTOM) {
      return isInAnimation ? R.anim.slide_in_bottom : R.anim.slide_out_bottom;
    }
    if ((gravity & Gravity.CENTER) == Gravity.CENTER) {
      return isInAnimation ? R.anim.fade_in_center : R.anim.fade_out_center;
    }
    return INVALID;
  }",Get animation resource
"public void onSurfaceChanged (int pixelWidth, int pixelHeight, int orient) {
    viewportChanged(pixelWidth, pixelHeight);
    screenSize.setSize(viewSize);
    switch (orient) {
    case Configuration.ORIENTATION_LANDSCAPE:
      orientDetailM.update(OrientationDetail.LANDSCAPE_LEFT);
      break;
    case Configuration.ORIENTATION_PORTRAIT:
      orientDetailM.update(OrientationDetail.PORTRAIT);
      break;
    default: // Configuration.ORIENTATION_UNDEFINED
      orientDetailM.update(OrientationDetail.UNKNOWN);
      break;
    }
  }",Called when the surface has been changed.
"public final EntityType getEntityType(EntityTypeName name) {

    GetEntityTypeRequest request =
        GetEntityTypeRequest.newBuilder().setName(name == null ? null : name.toString()).build();
    return getEntityType(request);
  }",Gets the entity type with the specified name.
"public static boolean containsNone(final CharSequence cs, final String invalidChars) {
        if (cs == null || invalidChars == null) {
            return true;
        }
        return containsNone(cs, invalidChars.toCharArray());
    }",Checks if the CharSequence contains none of the invalid characters.
"public static void runExample(
      AdWordsServicesInterface adWordsServices,
      AdWordsSession session,
      Long adGroupId,
      Long keywordId)
      throws RemoteException {
    // Get the AdGroupCriterionService.
    AdGroupCriterionServiceInterface adGroupCriterionService =
        adWordsServices.get(session, AdGroupCriterionServiceInterface.class);

    // Create ad group criterion with updated bid.
    Criterion criterion = new Criterion();
    criterion.setId(keywordId);

    BiddableAdGroupCriterion biddableAdGroupCriterion = new BiddableAdGroupCriterion();
    biddableAdGroupCriterion.setAdGroupId(adGroupId);
    biddableAdGroupCriterion.setCriterion(criterion);

    // Create bids.
    BiddingStrategyConfiguration biddingStrategyConfiguration = new BiddingStrategyConfiguration();
    CpcBid bid = new CpcBid();
    bid.setBid(new Money(null, 10000000L));
    biddingStrategyConfiguration.setBids(new Bids[] {bid});
    biddableAdGroupCriterion.setBiddingStrategyConfiguration(biddingStrategyConfiguration);

    // Create operations.
    AdGroupCriterionOperation operation = new AdGroupCriterionOperation();
    operation.setOperand(biddableAdGroupCriterion);
    operation.setOperator(Operator.SET);

    AdGroupCriterionOperation[] operations = new AdGroupCriterionOperation[] {operation};

    // Update ad group criteria.
    AdGroupCriterionReturnValue result = adGroupCriterionService.mutate(operations);

    // Display ad group criteria.
    for (AdGroupCriterion adGroupCriterionResult : result.getValue()) {
      if (adGroupCriterionResult instanceof BiddableAdGroupCriterion) {
        biddableAdGroupCriterion = (BiddableAdGroupCriterion) adGroupCriterionResult;
        CpcBid criterionCpcBid = null;
        // Find the criterion-level CpcBid among the keyword's bids.
        for (Bids bids : biddableAdGroupCriterion.getBiddingStrategyConfiguration().getBids()) {
          if (bids instanceof CpcBid) {
            CpcBid cpcBid = (CpcBid) bids;
            if (BidSource.CRITERION.equals(cpcBid.getCpcBidSource())) {
              criterionCpcBid = cpcBid;
            }
          }
        }

        System.out.printf(
            ""Ad group criterion with ad group ID %d, criterion ID %d, type ""
                + ""'%s', and bid %d was updated.%n"",
            biddableAdGroupCriterion.getAdGroupId(),
            biddableAdGroupCriterion.getCriterion().getId(),
            biddableAdGroupCriterion.getCriterion().getCriterionType(),
            criterionCpcBid.getBid().getMicroAmount());
      }
    }
  }",Run the example.
"public void deleteCrowdIndiv_same(int crowdIdx, int nicheCount, double indivFitness, S indiv) {

    // find the solution indices within this crowdIdx subregion
    ArrayList<Integer> indList = new ArrayList<>();
    for (int i = 0; i < populationSize; i++) {
      if (subregionIdx[crowdIdx][i] == 1) {
        indList.add(i);
      }
    }

    // find the solution with the worst fitness value
    int listSize = indList.size();
    int worstIdx = indList.get(0);
    double maxFitness = fitnessFunction(population.get(worstIdx), lambda[crowdIdx]);
    for (int i = 1; i < listSize; i++) {
      int curIdx = indList.get(i);
      double curFitness = fitnessFunction(population.get(curIdx), lambda[crowdIdx]);
      if (curFitness > maxFitness) {
        worstIdx = curIdx;
        maxFitness = curFitness;
      }
    }

    // if indiv has a better fitness, use indiv to replace the worst one
    if (indivFitness < maxFitness) {
      replace(worstIdx, indiv);
    }
  }",Delete the crowd subregion with the best fitness value
"public int addDocument(String document) {
    if (root().getNumberOfChildren() >= 0) {
      throw new IllegalStateException(""Tree sorting has begun"");
    }
    final int index;
    synchronized (this) {
      index = documents.size();
      documents.add(document);
    }
    cursors.addAll(
      IntStream.range(0, document.length() + 1).mapToObj(i -> new CursorData(index, i)).collect(Collectors.toList()));
    nodes.update(0, node -> node.setCursorCount(cursors.length()));
    return index;
  }",Add a document to the document tree.
"@UiHandler(""m_button"")
    protected void onClick(ClickEvent event) {

        m_tab.removeParam(m_paramKey);
        m_tab = null;
        removeFromParent();
    }",Remove the resource table from the tab.
"public MBeanInfo getMBeanInfo(ObjectName name) throws InstanceNotFoundException, IntrospectionException, ReflectionException {
        return delegate.getMBeanInfo(name);
    }",Get MBeanInfo for a given MBean name.
"static void parseCoreEnvironmentElement(final XMLExtendedStreamReader reader, final ModelNode operation) throws XMLStreamException {

        final int count = reader.getAttributeCount();
        for (int i = 0; i < count; i++) {
            requireNoNamespaceAttribute(reader, i);
            final String value = reader.getAttributeValue(i);
            final Attribute attribute = Attribute.forName(reader.getAttributeLocalName(i));
            switch (attribute) {
                case NODE_IDENTIFIER:
                    TransactionSubsystemRootResourceDefinition.NODE_IDENTIFIER.parseAndSetParameter(value, operation, reader);
                    break;
                case PATH:
                case RELATIVE_TO:
                    throw TransactionLogger.ROOT_LOGGER.unsupportedAttribute(attribute.getLocalName(), reader.getLocation());
                default:
                    throw unexpectedAttribute(reader, i);
            }
        }
        // elements
        final EnumSet<Element> required = EnumSet.of(Element.PROCESS_ID);
        final EnumSet<Element> encountered = EnumSet.noneOf(Element.class);
        while (reader.hasNext() && reader.nextTag() != END_ELEMENT) {
            final Element element = Element.forName(reader.getLocalName());
            required.remove(element);
            switch (element) {
                case PROCESS_ID: {
                    if (!encountered.add(element)) {
                        throw duplicateNamedElement(reader, reader.getLocalName());
                    }
                    parseProcessIdEnvironmentElement(reader, operation);
                    break;
                }
                default:
                    throw unexpectedElement(reader);
            }
        }
        if (!required.isEmpty()) {
            throw missingRequiredElement(reader, required);
        }
    }",Parses the Core Environment Element.
"public Observable<Void> publishAsync(String resourceGroupName, String labAccountName, String labName, String environmentSettingName) {
        return publishWithServiceResponseAsync(resourceGroupName, labAccountName, labName, environmentSettingName).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }",Publish an App Service Environment. Publish an App Service Environment.
"public void finest(String message) throws NullPointerException,
			FacilityException {
		sendNotification(TraceLevel.FINEST, message, null);
		logger.trace(message);
		
	}",Logs a message with a level of Trace. FINEST.
"protected void configureObjectMapper(final ObjectMapper mapper) {
        mapper.configure(SerializationFeature.FAIL_ON_EMPTY_BEANS, false)
            .configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);

        mapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
        mapper.setVisibility(PropertyAccessor.SETTER, JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC);
        mapper.setVisibility(PropertyAccessor.GETTER, JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC);
        mapper.setVisibility(PropertyAccessor.IS_GETTER, JsonAutoDetect.Visibility.PROTECTED_AND_PUBLIC);

        if (isDefaultTypingEnabled()) {
            mapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL, JsonTypeInfo.As.PROPERTY);
        }
        mapper.findAndRegisterModules();
    }",Configure object mapper.
"@Override
    public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
        if (validating) {
            try {
                InputSource source = null;
                if (publicId != null) {
                    String path = doctypeMap.get(publicId.toUpperCase());
                    source = getInputSource(path);
                }
                if (source == null && systemId != null) {
                    String path = doctypeMap.get(systemId.toUpperCase());
                    source = getInputSource(path);
                }
                return source;
            } catch (Exception e) {
                throw new SAXException(e.toString());
            }
        } else {
            return new InputSource(new StringReader(""""));
        }
    }",Resolves an entity.
"public static void calcPoints(final double lat1, final double lon1,
                                  final double lat2, final double lon2,
                                  final PointEmitter emitter,
                                  final double offsetLat, final double offsetLon,
                                  final double deltaLat, final double deltaLon) {
        // round to make results of bresenham closer to correct solution
        int y1 = (int) ((lat1 - offsetLat) / deltaLat);
        int x1 = (int) ((lon1 - offsetLon) / deltaLon);
        int y2 = (int) ((lat2 - offsetLat) / deltaLat);
        int x2 = (int) ((lon2 - offsetLon) / deltaLon);
        bresenham(y1, x1, y2, x2, new PointEmitter() {
            @Override
            public void set(double lat, double lon) {
                // +.1 to move more near the center of the tile
                emitter.set((lat + .1) * deltaLat + offsetLat, (lon + .1) * deltaLon + offsetLon);
            }
        });
    }",Calculate the points of the 2D tile.
"public Alignment<S> move(int offset) {
        return new Alignment<>(sequence1, mutations, sequence1Range, sequence2Range.move(offset), score);
    }",Move the alignment to the given offset.
"public void enableForegroundServiceScanning(Notification notification, int notificationId)
            throws IllegalStateException {
        if (isAnyConsumerBound()) {
            throw new IllegalStateException(""May not be called after consumers are already bound."");
        }
        if (notification == null) {
            throw new NullPointerException(""Notification cannot be null"");
        }
        setEnableScheduledScanJobs(false);
        mForegroundServiceNotification = notification;
        mForegroundServiceNotificationId = notificationId;
    }",Enable the foreground service scanning for a specific notification.
"private void openButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_openButtonActionPerformed
		final File dir = lastOpenDirectory();
		final JFileChooser chooser = dir != null
			? new JFileChooser(dir)
			: new JFileChooser();
		chooser.setDialogTitle(""Choose Image"");
		chooser.setDialogType(JFileChooser.OPEN_DIALOG);
		chooser.setFileSelectionMode(JFileChooser.FILES_ONLY);
		chooser.setMultiSelectionEnabled(false);
		chooser.addChoosableFileFilter(new FileNameExtensionFilter(
			format(
				""Images (%s)"",
				Stream.of(ImageIO.getReaderFileSuffixes())
					.map(s -> format("" *.%s"", s))
					.collect(Collectors.joining("",""))
			),
			ImageIO.getReaderFileSuffixes()
		));

		final int returnVal = chooser.showOpenDialog(this);
		if (returnVal == JFileChooser.APPROVE_OPTION) {
			final File imageFile = chooser.getSelectedFile();
			try {
				update(ImageIO.read(imageFile));
				if (imageFile.getParentFile() != null) {
					lastOpenDirectory(imageFile.getParentFile());
				}
			} catch (IOException e) {
				JOptionPane.showMessageDialog(
					rootPane,
					format(""Error while loading image '%s'."", imageFile),
					e.toString(),
					JOptionPane.ERROR_MESSAGE
				);
			}
		}
	}",The open buttonActionPerformed method.
"@Override
  public Object processTask(String taskName, Map<String, String[]> parameterMap) {

    if (""createAdmin"".equalsIgnoreCase(taskName)) {
      return userService.createDefaultAdmin();
    }

    return null;

  }",Override the processTask method to create a CRAs a SECTYPE.
"public SipTransaction sendReply(SipTransaction transaction, Response response) {
    initErrorInfo();

    if ((transaction == null) || (transaction.getServerTransaction() == null)) {
      setErrorMessage(""Cannot send reply, transaction information is null"");
      setReturnCode(INVALID_ARGUMENT);
      return null;
    }

    // send the message
    try {
      SipStack.dumpMessage(""Response before sending out through stack"", response);
      transaction.getServerTransaction().sendResponse(response);
    } catch (Exception ex) {
      setException(ex);
      setErrorMessage(""Exception: "" + ex.getClass().getName() + "": "" + ex.getMessage());
      setReturnCode(EXCEPTION_ENCOUNTERED);
      return null;
    }

    return transaction;
  }",Send a reply to a transaction
"public static 
  TaskAttemptID downgrade(org.apache.hadoop.mapreduce.TaskAttemptID old) {
    if (old instanceof TaskAttemptID) {
      return (TaskAttemptID) old;
    } else {
      return new TaskAttemptID(TaskID.downgrade(old.getTaskID()), old.getId());
    }
  }",Downgrade a TaskAttemptID to a new TaskAttemptID.
"public void decodeBulk(byte[][] readBufs, byte[][] writeBufs,
      int[] erasedLocations) throws IOException {
    int[] tmpInput = new int[readBufs.length];
    int[] tmpOutput = new int[erasedLocations.length];

    int numBytes = readBufs[0].length;
    for (int idx = 0; idx < numBytes; idx++) {
      for (int i = 0; i < tmpOutput.length; i++) {
        tmpOutput[i] = 0;
      }
      for (int i = 0; i < tmpInput.length; i++) {
        tmpInput[i] = readBufs[i][idx] & 0x000000FF;
      }
      decode(tmpInput, erasedLocations, tmpOutput);
      for (int i = 0; i < tmpOutput.length; i++) {
        writeBufs[i][idx] = (byte) tmpOutput[i];
      }
    }
  }",Decode bulk.
"@Override
    public AtomicValue evaluate() {

        boolean satisfiesCond = false;

        for (AbsAxis axis : mVars) {
            while (axis.hasNext()) {
                if (mSatisfy.hasNext()) {
                    // condition is satisfied for this item -> expression is
                    // true
                    satisfiesCond = true;
                    break;
                }
            }
        }

        AtomicValue val =
            new AtomicValue(TypedValue.getBytes(Boolean.toString(satisfiesCond)), NamePageHash
                .generateHashForString(""xs:boolean""));
        final int mItemKey = getItemList().addItem(val);
        moveTo(mItemKey);
        return val;

    }",Evaluate the result of a CRASS ACS A ACS A CCS A CCS A CCS ACS A CCS A CCS ACS A
"public static boolean isExtension(GeometryType geometryType) {
		return GeometryCodes.getCode(geometryType) > GeometryCodes
				.getCode(GeometryType.GEOMETRYCOLLECTION);
	}",Checks if the geometry type is an extension geometry type.
"private void orderResults(ResultSet cqlRows) throws InvalidRequestException
    {
        if (cqlRows.size() == 0 || !needsPostQueryOrdering())
            return;

        assert orderingIndexes != null;

        List<Integer> idToSort = new ArrayList<Integer>();
        List<Comparator<ByteBuffer>> sorters = new ArrayList<Comparator<ByteBuffer>>();

        for (ColumnIdentifier.Raw identifier : parameters.orderings.keySet())
        {
            ColumnDefinition orderingColumn = cfm.getColumnDefinition(identifier.prepare(cfm));
            idToSort.add(orderingIndexes.get(orderingColumn.name));
            sorters.add(orderingColumn.type);
        }

        Comparator<List<ByteBuffer>> comparator = idToSort.size() == 1
                                                ? new SingleColumnComparator(idToSort.get(0), sorters.get(0))
                                                : new CompositeComparator(sorters, idToSort);
        Collections.sort(cqlRows.rows, comparator);
    }",Order results.
"private void makeIncoming() {
        if (stays == null && move == null) {
            for (BitSet in : ins) {
                in.clear();
            }
            stays = new BitSet();
            move = new BitSet();
            for (int i = 0; i < hosts.length; i++) {
                if (hosts[i] != null && hosts[i].isInstantiated()) {
                    int newPos = hosts[i].getValue();
                    if (oldPos[i] != -1 && newPos != oldPos[i]) {
                        //The VM has move
                        ins[newPos].set(i);
                        move.set(i);
                    } else if (newPos == oldPos[i]) {
                        stays.set(i);
                    }
                }
            }
        }
    }",Make incoming.
"@Override
    public R visitValue(ValueTree node, P p) {
        return defaultAction(node, p);
    }",Visit a ValueTree.
"public void addParameter(String name, String[] values) {
        if (WCCustomProperties.CHECK_REQUEST_OBJECT_IN_USE){
            checkRequestObjectInUse();
        }
        Hashtable aParam = new Hashtable(3);
        aParam.put(name, values);
        mergeQueryParams(aParam);
    }",Add a parameter to the request.
"@Override
  public IRoSessionData getAppSessionData(Class<? extends AppSession> clazz, String sessionId) {
    if (clazz.equals(ClientRoSession.class)) {
      ClientRoSessionDataLocalImpl data = new ClientRoSessionDataLocalImpl();
      data.setSessionId(sessionId);
      return data;
    }
    else if (clazz.equals(ServerRoSession.class)) {
      ServerRoSessionDataLocalImpl data = new ServerRoSessionDataLocalImpl();
      data.setSessionId(sessionId);
      return data;
    }
    throw new IllegalArgumentException(clazz.toString());
  }",Override the method to create and return the appropriate IRoSessionData object for the specified AppSession class and session id.
"public byte[] bind(int commandId, int sequenceNumber, String systemId,
            String password, String systemType, byte interfaceVersion,
            byte addrTon, byte addrNpi, String addressRange)
            throws PDUStringException {
        StringValidator.validateString(systemId, StringParameter.SYSTEM_ID);
        StringValidator.validateString(password, StringParameter.PASSWORD);
        StringValidator.validateString(systemType, StringParameter.SYSTEM_TYPE);
        StringValidator.validateString(addressRange,
                StringParameter.ADDRESS_RANGE);

        PDUByteBuffer buf = new PDUByteBuffer(commandId, 0, sequenceNumber);

        buf.append(systemId);
        buf.append(password);
        buf.append(systemType);
        buf.append(interfaceVersion);
        buf.append(addrTon);
        buf.append(addrNpi);
        buf.append(addressRange);
        return buf.toBytes();
    }",Binds a single ADI message to a single ADI message.
"private void copyDetails(Authentication source, Authentication dest) {
		if ((dest instanceof AbstractAuthenticationToken) && (dest.getDetails() == null)) {
			AbstractAuthenticationToken token = (AbstractAuthenticationToken) dest;

			token.setDetails(source.getDetails());
		}
	}",Copy details from source to dest.
"@SuppressWarnings(""unchecked"")
    public Object[] getInUse() {
        return inUseTable != null ? (((Hashtable<PooledWsByteBufferImpl, PooledWsByteBufferImpl>) inUseTable.clone()).keySet().toArray()) : new Object[0];
    }",Returns an array of all the inUse objects.
"public static String getPathName(String path) {

		String pathName = null;
		if (StringUtils.isEmpty(path)) {
			pathName = """";
		} else {
			pathName = path;
			if (pathName.length() > 1 && pathName.endsWith(JawrConstant.URL_SEPARATOR)) {
				pathName = pathName.substring(0, pathName.length() - 1);
			}
			int index = pathName.lastIndexOf(JawrConstant.URL_SEPARATOR);
			if (index > 0) {
				pathName = pathName.substring(index + 1);
			} else {
				pathName = JawrConstant.URL_SEPARATOR;
			}
		}

		return pathName;
	}",Returns the path name
"protected void setError(int newPosition, String error,
      boolean currentExisting) {
    if (!currentExisting) {
      newBasicValueSumList[newPosition] = operations.getZero1();
      newBasicValueNList[newPosition] = 0;
    }
    newErrorNumber[newPosition]++;
    if (newErrorList[newPosition].containsKey(error)) {
      newErrorList[newPosition].put(error,
          newErrorList[newPosition].get(error) + 1);
    } else {
      newErrorList[newPosition].put(error, 1);
    }
  }",Set an error in the list.
"public EClass getIfcCurtainWall() {
		if (ifcCurtainWallEClass == null) {
			ifcCurtainWallEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc2x3tc1Package.eNS_URI)
					.getEClassifiers().get(133);
		}
		return ifcCurtainWallEClass;
	}",Get the IfcCurtainWallEClass from the IFCCurtainWallPackage.
"void saveNamespace(boolean force, boolean uncompressed)
  throws AccessControlException, IOException {
    try {
      if (namenodeProtocolProxy == null) {
        versionBasedSaveNamespace(force, uncompressed);
      } else {
        methodBasedSaveNamespace(force, uncompressed);
      }
    } catch(RemoteException re) {
      throw re.unwrapRemoteException(AccessControlException.class);
    }
  }",Save the namespace of the current namenode.
"public void setLat(final int LAT_DEG, final double LAT_MIN) {
        this.lat = convert(LAT_DEG, LAT_MIN);
        this.LOCATION.setLocation(this.lat, this.lon);
        adjustDirection();
    }",Sets the Lat value.
"public static ITemplateBoundariesProcessor unwrap(final ITemplateBoundariesProcessor processor) {
        if (processor == null) {
            return null;
        }
        if (processor instanceof AbstractProcessorWrapper) {
            return (ITemplateBoundariesProcessor)((AbstractProcessorWrapper) processor).unwrap();
        }
        return processor;
    }",Unwrap a ITemplateBoundariesProcessor.
"public static void move(String srcPath, String dstPath) throws IOException {
    Files.move(Paths.get(srcPath), Paths.get(dstPath), StandardCopyOption.REPLACE_EXISTING);
  }",Move the src file to the dst file.
"public static synchronized <T> T activateDI(T instance) {
    if (bootstrapedNeeded) bootstrap();

    injectAttributes(instance);
    initialize(instance);
    return instance;
  }",Activates the specified instance.
"@SuppressWarnings(""unchecked"")
    private UNode optionValueToUNode(String optName, Object optValue) {
        if (!(optValue instanceof Map)) {
            if (optValue == null) {
                optValue = """";
            }
            return UNode.createValueNode(optName, optValue.toString(), ""option"");
        }
        UNode optNode = UNode.createMapNode(optName, ""option"");
        Map<String, Object> suboptMap = (Map<String,Object>)optValue;
        for (String suboptName : suboptMap.keySet()) {
            optNode.addChildNode(optionValueToUNode(suboptName, suboptMap.get(suboptName)));
        }
        return optNode;
    }",A method to convert a value to a UNode.
"private List<IAtomContainer> toList(IAtomContainerSet frags) {
        return new ArrayList<>(FluentIterable.from(frags.atomContainers()).toList());
    }",Convert a set of IAtomContainerSet to a List of IAtomContainer objects.
"public void start() {
    proxy.setTrustAllServers(true);
    if (outsideProxy != null) {
      proxy.setChainedProxy(getProxyAddress(outsideProxy));
    }

    addRequestFilter(""authentication"", new AuthenticationFilter());
    addRequestFilter(""requestSizeWatchdog"", new RequestSizeWatchdog());
    addResponseFilter(""responseSizeWatchdog"", new ResponseSizeWatchdog());
    addResponseFilter(""download"", new FileDownloadFilter(config));

    proxy.start(config.proxyPort());
    port = proxy.getPort();
  }",Start the server.
"public int getItemPosition(int id) {
        for(int index = getCount()-1; index >= 0; index--) {
            TwinTextItem item = getItem(index);
            if(item.getId() == id)
                return index;
        }
        return -1;
    }",Gets the position of the item with the specified id.
"@Nonnull
  public static BootstrapButtonGroup createButtonAsDropDownMenuWithSeparateCaret (@Nonnull final BootstrapButton aButton,
                                                                                  @Nonnull final Consumer <? super BootstrapDropdownMenu> aMenuItemProvider)
  {
    final BootstrapButtonGroup aBG = new BootstrapButtonGroup ();
    aBG.addChild (aButton);

    final BootstrapButton aCaret = new BootstrapButton (aButton.getButtonType (), aButton.getButtonSize ());
    BootstrapDropdown.makeDropdownToggle (aCaret);
    aBG.addChild (aCaret);

    final BootstrapDropdownMenu aMenu = aBG.addDropDownMenu ();
    aMenuItemProvider.accept (aMenu);
    return aBG;
  }",Create a button as a drop down menu with separate caret.
"private Page<CollectorItem> removeJobUrlAndInstanceUrl(Page<CollectorItem> collectorItems) {
        for (CollectorItem cItem : collectorItems) {
            if(cItem.getOptions().containsKey(""jobUrl"")) cItem.getOptions().remove(""jobUrl"");
            if(cItem.getOptions().containsKey(""instanceUrl"")) cItem.getOptions().remove(""instanceUrl"");
        }
        return collectorItems;
    }",remove jobUrl and instanceUrl from collectorItems
"public void loadForward(String query, Long afterSortKey, int limit, ListEngineDisplayLoadCallback<T> callback) {
        storageActor.send(new AsyncStorageActor.LoadForward<T>(query, afterSortKey, limit, callback));
    }",Load forward list engine.
"@Override
    public void validate(final FacesContext context) {
        // iterate over submitted values and attempt to convert to the proper
        // data type. For successful values, remove from submitted and add to
        // local values map. for failures, add a conversion message and leave in
        // the submitted state
        final Iterator<Entry<SheetRowColIndex, String>> entries = submittedValues.entrySet().iterator();
        final boolean hadBadUpdates = !getInvalidUpdates().isEmpty();
        getInvalidUpdates().clear();
        while (entries.hasNext()) {
            final Entry<SheetRowColIndex, String> entry = entries.next();
            final SheetColumn column = getColumns().get(entry.getKey().getColIndex());
            final String newValue = entry.getValue();
            final String rowKey = entry.getKey().getRowKey();
            final int col = entry.getKey().getColIndex();
            setRowVar(context, rowKey);

            // attempt to convert new value from string to correct object type
            // based on column converter. Use PF util as helper
            final Converter converter = ComponentUtils.getConverter(context, column);

            // assume string value if converter not found
            Object newValueObj = newValue;
            if (converter != null) {
                try {
                    newValueObj = converter.getAsObject(context, this, newValue);
                }
                catch (final ConverterException e) {
                    // add offending cell to list of bad updates
                    // and to a StringBuilder for error messages (so we have one
                    // message for the component)
                    setValid(false);
                    FacesMessage message = e.getFacesMessage();
                    if (message == null) {
                        message = new FacesMessage(FacesMessage.SEVERITY_ERROR, e.getMessage(), e.getMessage());
                    }
                    context.addMessage(this.getClientId(context), message);

                    final String messageText = message.getDetail();
                    getInvalidUpdates()
                                .add(new SheetInvalidUpdate(getRowKeyValue(context), col, column, newValue, messageText));
                    continue;
                }
            }
            // value is fine, no further validations (again, not to be confused
            // with validators. until we have a ""required"" or something like
            // that, nothing else to do).
            setLocalValue(rowKey, col, newValueObj);

            // process validators on column
            column.setValue(newValueObj);
            try {
                column.validate(context);
            }
            finally {
                column.resetValue();
            }

            entries.remove();
        }
        setRowVar(context, null);

        final boolean newBadUpdates = !getInvalidUpdates().isEmpty();
        final String errorMessage = getErrorMessage();

        if (hadBadUpdates || newBadUpdates) {
            // update the bad data var if partial request
            if (context.getPartialViewContext().isPartialRequest()) {
                renderBadUpdateScript(context);
            }
        }

        if (newBadUpdates && errorMessage != null) {
            final FacesMessage message = new FacesMessage(FacesMessage.SEVERITY_ERROR, errorMessage, errorMessage);
            context.addMessage(null, message);
        }
    }",Validate the input.
"public static Buffer nextHeaderNameDontCheckHColon(final Buffer buffer) {
        try {
            final int startIndex = buffer.getReaderIndex();
            int nameIndex = 0;
            while (buffer.hasReadableBytes() && nameIndex == 0) {
                if (isNext(buffer, SP) || isNext(buffer, HTAB) || isNext(buffer, COLON)) {
                    nameIndex = buffer.getReaderIndex();
                } else {
                    buffer.readByte();
                }
            }

            // Bad header! No HCOLON found! (or beginning thereof anyway)
            if (nameIndex == 0) {
                // probably ran out of bytes to read so lets just return null
                buffer.setReaderIndex(startIndex);
                return null;
            }

            return buffer.slice(startIndex, nameIndex);
        } catch (final IOException e) {
            throw new SipParseException(buffer.getReaderIndex(), UNABLE_TO_READ_FROM_STREAM, e);
        }

    }",Get the next header name without checking for HCOLON.
"@Provides
	@Singleton
	@Named(GuiceProperties.REST_SERVICES_PREFIX)
	public String getRestServicesPrefix(ServletContext context)
	{
		String restPath = context.getInitParameter(RESTEASY_MAPPING_PREFIX);

		if (restPath == null || restPath.isEmpty() || restPath.equals(""/""))
		{
			return """";
		}
		else
		{
			return restPath;
		}
	}",Provides the prefix of the REST services to use.
"private final void fixReportTeamList(final Element root) {
        for (final Element head : root.getElementsByTag(""h2"")) {
            head.tagName(""h1"");
        }

        for (final Element head : root.getElementsByTag(""h3"")) {
            head.tagName(""h2"");
        }
    }",Fix report team list.
"public SDVariable assign(String name, SDVariable x, SDVariable y) {
        SDVariable ret = f().assign(x, y);
        return updateVariableNameAndReference(ret, name);
    }",Assign a single record set operation to a single record set operation.
"public DatanodeInfo[] bestNode(LocatedBlocks blks) throws IOException {
    // insert all known replica locations into a tree map where the
    // key is the DatanodeInfo
    TreeMap<DatanodeInfo, NodeRecord> map = 
      new TreeMap<DatanodeInfo, NodeRecord>();
    for (int i = 0; i < blks.getLocatedBlocks().size(); i++) {
      DatanodeInfo [] nodes = blks.get(i).getLocations();
      for (int j = 0; j < nodes.length; j++) {
        NodeRecord obj = map.get(nodes[j]);
        if (obj != null) {
          obj.frequency++;
        } else {
          map.put(nodes[j], new NodeRecord(nodes[j], 1));
        }
      }
    }
    // sort all locations by their frequency of occurance
    Collection<NodeRecord> values = map.values();
    NodeRecord[] nodes = (NodeRecord[]) 
                         values.toArray(new NodeRecord[values.size()]);
    Arrays.sort(nodes, new NodeRecordComparator());
    try {
      List<NodeRecord> candidates = bestNode(nodes, false);
      return candidates.toArray(new DatanodeInfo[candidates.size()]);
    } catch (IOException e) {
      return new DatanodeInfo[] {randomNode()};
    }
  }",Get the best node for a list of blocks
"private void visit(XmlSchema xmlSchema, final XmlSchemaElement xsdElement,
            final int level, final ArrayNode avroFields)
            throws Xsd2AvroTranslatorException {

        /*
         * If this element is referencing another, it might not be useful to
         * process it.
         */
        if (xsdElement.getRef().getTarget() != null) {
            return;
        }
        log.debug(""process started for element = "" + xsdElement.getName());

        if (xsdElement.getSchemaType() instanceof XmlSchemaComplexType) {
            XmlSchemaComplexType xsdType = (XmlSchemaComplexType) xsdElement
                    .getSchemaType();

            int nextLevel = level + 1;
            final ArrayNode avroChildrenFields = MAPPER.createArrayNode();
            visit(xmlSchema, xsdType, nextLevel, avroChildrenFields);
            ContainerNode avroRecordType = buildAvroCompositeType(
                    getAvroTypeName(xsdType), avroChildrenFields,
                    xsdElement.getMaxOccurs() > 1,
                    xsdElement.getMinOccurs() == 0
                            && xsdElement.getMaxOccurs() == 1);
            ObjectNode avroRecordElement = MAPPER.createObjectNode();
            avroRecordElement.put(""type"", avroRecordType);
            avroRecordElement.put(""name"", getAvroFieldName(xsdElement));
            avroFields.add(avroRecordElement);

        } else if (xsdElement.getSchemaType() instanceof XmlSchemaSimpleType) {
            visit((XmlSchemaSimpleType) xsdElement.getSchemaType(), level,
                    getAvroFieldName(xsdElement), xsdElement.getMinOccurs(),
                    xsdElement.getMaxOccurs(), avroFields);
        }

        log.debug(""process ended for element = "" + xsdElement.getName());
    }",Visit an XML element.
"public static Version from(int major, int minor, int patch, String preRelease) {
        return new Version(buildSemVer(major, minor, patch, preRelease, null));
    }",Creates a new version from the given major minor patch and pre - release numbers.
"protected String columnToPropertyName(ResultSetMetaData rsmd, int col) throws SQLException{
		String columnName = rsmd.getColumnLabel(col);
		if (null == columnName || 0 == columnName.length()) {
			columnName = rsmd.getColumnName(col);
		}
		return columnNameToPropertyName(columnName);
	}",Returns the name of the property in the specified column.
"public CorsConfig build() {
        if (preflightHeaders.isEmpty() && !noPreflightHeaders) {
            preflightHeaders.put(HttpHeaderNames.DATE, DateValueGenerator.INSTANCE);
            preflightHeaders.put(HttpHeaderNames.CONTENT_LENGTH, new ConstantValueGenerator(""0""));
        }
        return new CorsConfig(this);
    }",Build the CorsConfig object.
"public ProductPartitionNode removeCustomParameter(String key) {
    if (!nodeState.supportsCustomParameters()) {
      throw new IllegalStateException(
          String.format(""Cannot remove custom parameters on a %s node"", nodeState.getNodeType()));
    }
    Preconditions.checkNotNull(key, ""Null key"");
    if (!nodeState.getCustomParams().containsKey(key)) {
      throw new IllegalArgumentException(""No custom parameter exists for key: "" + key);
    }
    this.nodeState.getCustomParams().remove(key);
    return this;
  }",Removes a custom parameter from the partition.
"@Override
	public void execute() throws BuildException {
		if (null != this.echo) {
			out.emitText(echo);
		}
		validateAttributes();

		StatisticProvidingMixinGenerator generator = makeInterfaceItGenerator();

		try {
			if (debug) {
				out.emitText(this.toString());
			}

			if (null == this.targetInterfaceParentName || targetInterfaceParentName.trim().length() < 1) {
				File wroteFile = generator.generateMixinJavaFile(getOutputDirectory(), getTargetInterfaceName(),
						getDelegateClassObject(), getTargetPackageName(), makeArgumentNameSource());

				GenerationStatistics stats = generator.getStatistics();
				emitGenerationResult(wroteFile, stats);
			} else {
				final Class<?> delegateClassObject = this.getDelegateClassObject();
				final Class<?> superclass = delegateClassObject.getSuperclass();
				if(null == superclass || java.lang.Object.class.equals(superclass)) {
					out.emitText(""Execution halted without generation. The attribute 'targetInterfaceParentName' should be empty if the delegate class has no superclass other than Object."");
					return;
				}
				MultiFileOutputOptions options = new OptionsForSplittingChildAndParent(this.targetPackageName,
						getOutputDirectory(), this.targetInterfaceName, this.targetInterfaceParentName,
						delegateClassObject);
				List<File> results = generator.generateMixinJavaFiles(options, makeArgumentNameSource(),
						delegateClassObject, superclass);
				for (File result : results) {
					emitGenerationResult(result,
							generator.getStatisticsFor(result.getName()).orElse(generator.getStatistics()));
				}
			}
		} catch (IOException e) {
			handleIOException(e);
		} catch (ClassNotFoundException e) {
			handleClassNotFound(e);
		} catch (Throwable t) {
			handleUnexpectedError(t);
		}
	}",Execute the IGNORING generation.
"public static String getBufferTraceInfo(WsByteBuffer buffers[]) {
        if (null == buffers) {
            return ""Null buffer array"";
        }
        StringBuilder sb = new StringBuilder(32 + (64 * buffers.length));
        for (int i = 0; i < buffers.length; i++) {
            sb.append(""\r\n\t  Buffer ["");
            sb.append(i);
            sb.append(""]: "");
            getBufferTraceInfo(sb, buffers[i]);
        }
        return sb.toString();
    }",Get the trace info for the given buffers.
"public void setName(String name) {
        Validate.notNull(name);
        Validate.notEmpty(name);
        setProperty(ACModelProperty.NAME, name);
    }",Sets the name of the class.
"public Query select(final Expression... selectColumns) {
        if (selectColumns == null) {
            return this;
        }

        return select(Arrays.asList(selectColumns));
    }",Get a new Query that will return a result set of the specified columns.
"public ServiceFuture<VirtualMachineInner> getByResourceGroupAsync(String resourceGroupName, String vmName, final ServiceCallback<VirtualMachineInner> serviceCallback) {
        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, vmName), serviceCallback);
    }",Gets a virtual machine. Gets a virtual machine.
"public static void forceAccess(final AccessibleObject accObject) {
		try {
			if (System.getSecurityManager() == null)
				accObject.setAccessible(true);
			else {
				AccessController.doPrivileged((PrivilegedAction) () -> {
					accObject.setAccessible(true);
					return null;
				});
			}
		} catch (SecurityException sex) {
			// ignore
		}
	}",Force access to an AccessibleObject.
"public void setGridScreen(JComponent gridScreen, boolean bSetupJTable)
    {
        if (gridScreen instanceof JTable)
        {
            JTable control = (JTable)gridScreen;
            ThinTableModelListener thinTableModelListener = new ThinTableModelListener(control, this);
            if (m_modelListeners == null)
                m_modelListeners = new HashSet<ThinTableModelListener>();
            m_modelListeners.add(thinTableModelListener);
            control.getSelectionModel().addListSelectionListener(thinTableModelListener);   // Listen for selection change to update
            if (bSetupJTable)
            {
                FontMetrics fm = control.getFontMetrics(control.getFont());
                int rowHeight = (int)(Math.max(control.getRowHeight(), fm.getHeight()) * 1.5);
                int iCharWidth = (int)(fm.charWidth('X') * 1.5);
                control.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
//              control.setAutoCreateColumnsFromModel(false);
                control.setColumnSelectionAllowed(false); // Don't allow column selections
                control.setModel(this);
                JTableHeader tableHeader = control.getTableHeader();
                TableColumnModel columnModel = tableHeader.getColumnModel();
                for (int iIndex = 0; iIndex < this.getColumnCount(); iIndex++)
                {
                    Convert field = this.getFieldInfo(iIndex);
                    int iWidth = JScreenConstants.ICON_SIZE.width;
                    if (field != null)
                        iWidth = field.getMaxLength() * iCharWidth;
                    TableColumn tableColumn = columnModel.getColumn(iIndex);
                    TableCellRenderer cellRenderer = this.createColumnCellRenderer(iIndex);
                    if (cellRenderer == null)
                        if (field instanceof FieldInfo)
                    {
                        if (Number.class.isAssignableFrom(((FieldInfo)field).getDataClass()))
                        {
                            tableColumn.setCellRenderer(new JCellTextField(field.getMaxLength(), true));    // Align right, use calc length.
                            tableColumn.setCellEditor(new JCellTextField(field.getMaxLength(), true));  // Align right, use calc length.
                        }
                        if (Boolean.class.isAssignableFrom(((FieldInfo)field).getDataClass()))
                        {
                            cellRenderer = new JCellCheckBox(null);
                            tableColumn.setCellEditor(new JCellCheckBox(null));
                        }
                    }
                    if (cellRenderer != null)
                    {
                        tableColumn.setCellRenderer(cellRenderer);
                        if (cellRenderer instanceof JComponent)
                            iWidth = ((JComponent)cellRenderer).getPreferredSize().width;
                        if (field != null)
                            field.addComponent(cellRenderer);
                    }
                    TableCellEditor cellEditor = this.createColumnCellEditor(iIndex);
                    if (cellEditor != null)
                    {
                        tableColumn.setCellEditor(cellEditor);
                        if (field != null)
                            field.addComponent(cellEditor);
                    }
                    tableColumn.setPreferredWidth(iWidth);  // Fixed column width

                    String strFieldName = this.getColumnName(iIndex);
                    tableColumn.setHeaderValue(strFieldName);
                }
        //      this.addMouseListenerToHeaderInTable(control);      // Notify model of row order changed (clicks in the header bar)
                if (rowHeight > 10)
                    control.setRowHeight(rowHeight);
            }
            if (control.getModel() == null)
                control.setModel(this);
            
            control.getModel().addTableModelListener(new FixScrollersOnNewTable(control));
        }
    }",Set the grid screen.
"public Color getFromString(final String hexValue) {
        final String hv = hexValue.toLowerCase(Locale.US);
        Color color = this.colorByHexValue.get(hv);
        if (color == null) {
            color = new Color() {
                @Override
                public String hexValue() {
                    return hv;
                }
            };
            this.colorByHexValue.put(hv, color);
        }
        return color;
    }",Gets the color from a hex value.
"void setObject(final int index, final Object object, final int targetSqlType, final int scale) {
		initPrepared();
	    try {
		    preparedStatement.setObject(index, object, targetSqlType, scale);
	    } catch (SQLException sex) {
			throwSetParamError(index, sex);
	    }
    }",Sets the value of the designated column in the current row of the current row of the current row.
"public void init(Record recLayout, PrintWriter out)
    {
        boolean bFirstTime = false;
        boolean bNewRecord = false;
        if (out == null)
        { // First time
            bFirstTime = true;
            if (recLayout == null)
            {
                recLayout = new Layout((Record.findRecordOwner(null)));
                bNewRecord = true;
            }
            recLayout.getField(Layout.ID).setValue(1);
            try   {
                if (!recLayout.seek(""=""))
                { // Error - top level not found?
                }
            } catch   (DBException ex)  {
                ex.printStackTrace();
                return;
            }
            String strFileName = recLayout.getField(Layout.NAME).toString() + "".idl"";
            try   {
                FileOutputStream outStream = new FileOutputStream(strFileName);
                BufferedOutputStream buffOut = new BufferedOutputStream(outStream);
                out = new PrintWriter(buffOut);
            } catch (IOException ex)    {
                ex.printStackTrace();
                return;
            }
        }
            
        this.printIt(recLayout, out, 0, "";"");
        
        if (bFirstTime)
            out.close();
        if (bNewRecord)
            recLayout.free();
    }",Initialization Method.
"public EClass getGCCBEZRG() {
		if (gccbezrgEClass == null) {
			gccbezrgEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(493);
		}
		return gccbezrgEClass;
	}",Get the gccbezrgEClass
"public void paint (Graphics g, int x, int y, int width, int height)
    {
        // bail out now if we were passed a bogus source image at construct time
        if (_tiles == null) {
            return;
        }

        int rwid = width-2*_w3, rhei = height-2*_h3;

        g.drawImage(_tiles[0], x, y, _w3, _h3, null);
        g.drawImage(_tiles[1], x + _w3, y, rwid, _h3, null);
        g.drawImage(_tiles[2], x + _w3 + rwid, y, _w3, _h3, null);

        y += _h3;
        g.drawImage(_tiles[3], x, y, _w3, rhei, null);
        g.drawImage(_tiles[4], x + _w3, y, rwid, rhei, null);
        g.drawImage(_tiles[5], x + _w3 + rwid, y, _w3, rhei, null);

        y += rhei;
        g.drawImage(_tiles[6], x, y, _w3, _h3, null);
        g.drawImage(_tiles[7], x + _w3, y, rwid, _h3, null);
        g.drawImage(_tiles[8], x + _w3 + rwid, y, _w3, _h3, null);
    }",Paint the image at the specified coordinates.
"public static List<Object> getDecoratorLineage(Object obj) {
    List<Object> lineage = Lists.newArrayList(obj);
    Object currentObject = obj;
    while(currentObject instanceof Decorator) {
      currentObject = ((Decorator)currentObject).getDecoratedObject();
      lineage.add(currentObject);
    }

    return Lists.reverse(lineage);
  }",Get the decorator lineage of the given object
"@Override
    protected void onStop()
    {
        m_context.removeBundleListener( m_bundleListener );
        final Bundle[] toBeRemoved =
            m_mappings.keySet().toArray( new Bundle[m_mappings.keySet().size()] );
        for( Bundle bundle : toBeRemoved )
        {
            unregister( bundle );
        }

        m_bundleListener = null;
        m_mappings = null;
    }",Called by the OSGi framework when the application stops the application.
"Symbol addConstantFieldref(final String owner, final String name, final String descriptor) {
    return addConstantMemberReference(Symbol.CONSTANT_FIELDREF_TAG, owner, name, descriptor);
  }",Add a field reference to a constant.
"public static boolean intersectLineSegmentTriangle(double p0X, double p0Y, double p0Z, double p1X, double p1Y, double p1Z,
            double v0X, double v0Y, double v0Z, double v1X, double v1Y, double v1Z, double v2X, double v2Y, double v2Z,
            double epsilon, Vector3d intersectionPoint) {
        double dirX = p1X - p0X;
        double dirY = p1Y - p0Y;
        double dirZ = p1Z - p0Z;
        double t = intersectRayTriangle(p0X, p0Y, p0Z, dirX, dirY, dirZ, v0X, v0Y, v0Z, v1X, v1Y, v1Z, v2X, v2Y, v2Z, epsilon);
        if (t >= 0.0 && t <= 1.0) {
            intersectionPoint.x = p0X + dirX * t;
            intersectionPoint.y = p0Y + dirY * t;
            intersectionPoint.z = p0Z + dirZ * t;
            return true;
        }
        return false;
    }",Intersects the line segment triangle with the given intersection point.
"protected static Log getLogger() {
        Log l = logger;
        if (l == null) {
            l = LogFactory.getLog(LOGGER_NAME);
            logger = l;
        }
        return l;
    }",Get the Log instance.
"@Override
    protected AuthenticationHandlerExecutionResult doAuthentication(final Credential credential) throws GeneralSecurityException {

        val x509Credential = (X509CertificateCredential) credential;
        val certificates = x509Credential.getCertificates();

        var clientCert = (X509Certificate) null;
        var hasTrustedIssuer = false;
        for (var i = certificates.length - 1; i >= 0; i--) {
            val certificate = certificates[i];
            LOGGER.debug(""Evaluating [{}]"", CertUtils.toString(certificate));

            validate(certificate);

            if (!hasTrustedIssuer) {
                hasTrustedIssuer = isCertificateFromTrustedIssuer(certificate);
            }

            val pathLength = certificate.getBasicConstraints();
            if (pathLength < 0) {
                LOGGER.debug(""Found valid client certificate"");
                clientCert = certificate;
            } else {
                LOGGER.debug(""Found valid CA certificate"");
            }
        }
        if (hasTrustedIssuer && clientCert != null) {
            x509Credential.setCertificate(clientCert);
            return new DefaultAuthenticationHandlerExecutionResult(this, x509Credential,
                this.principalFactory.createPrincipal(x509Credential.getId()));
        }
        LOGGER.warn(""Either client certificate could not be determined, or a trusted issuer could not be located"");
        throw new FailedLoginException();
    }",Do authentication.
"@Override
	public void registerOsgiProviders (Collection<Object> providers) throws FhirConfigurationException {
		if (null == providers) {
			throw new NullPointerException(""FHIR Provider list cannot be null"");
		}
		try {
			super.registerProviders(providers);
			for (Object provider : providers) {
				log.trace(""registered provider. class [""+provider.getClass().getName()+""]"");
				this.serverProviders.add(provider);
			}
		} catch (Exception e) {
			log.error(""Error registering FHIR Providers"", e);
			throw new FhirConfigurationException(""Error registering FHIR Providers"", e);
		}
	}",Register the given list of providers with the server.
"public static Field[] getFieldArrayIncludeSupClassExcludeUID(Class<?> clazz) {
        Field[] currField = clazz.getDeclaredFields();
        clazz = clazz.getSuperclass();
        Field[] supField = clazz.getDeclaredFields();
        Field[] temp = new Field[currField.length + supField.length];
        int length = 0;
        for (Field curr : currField) {
            if (""serialVersionUID"".equals(curr.getName())) {
                continue;
            }
            temp[length] = curr;
            length++;
        }
        for (Field sup : supField) {
            if (""serialVersionUID"".equals(sup.getName())) {
                continue;
            }
            temp[length] = sup;
            length++;
        }
        Field[] all = new Field[length];
        for (int i = 0; i < all.length; i++) {
            all[i] = temp[i];
        }
        return all;
    }",Get Field array include supClassExcludeUID.
"@NonNull
  public static Point nearestPoint(@NonNull Point targetPoint, @NonNull List<Point> points) {
    if (points.isEmpty()) {
      return targetPoint;
    }
    Point nearestPoint = points.get(0);
    double minDist = Double.POSITIVE_INFINITY;
    for (Point point : points) {
      double distanceToPoint = TurfMeasurement.distance(targetPoint, point);
      if (distanceToPoint < minDist) {
        nearestPoint = point;
        minDist = distanceToPoint;
      }
    }
    return nearestPoint;
  }",Get nearest point from targetPoint
"@Override
    public int enqueue(JobRequest jd)
    {
        try
        {
            return target.path(""ji"").request().post(Entity.entity(jd, MediaType.APPLICATION_XML), JobInstance.class).getId();
        }
        catch (BadRequestException e)
        {
            throw new JqmInvalidRequestException(e.getResponse().readEntity(String.class), e);
        }
        catch (Exception e)
        {
            throw new JqmClientException(e);
        }
    }",Enqueue a job instance.
"private TypeSpec getBinderWrapper() {
        TypeSpec.Builder staticBinderWrapperClassBuilder = TypeSpec
                .classBuilder(""BinderWrapper"")
                .addModifiers(Modifier.PRIVATE)
                .addModifiers(Modifier.STATIC)
                .addField(ClassName.get(""android.os"", ""IBinder""), ""binder"", Modifier.PRIVATE)
                .addMethod(MethodSpec.constructorBuilder()
                        .addParameter(ClassName.get(""android.os"", ""IBinder""), ""binder"")
                        .addStatement(""this.binder = binder"")
                        .build())
                .addMethod(MethodSpec.methodBuilder(""asBinder"")
                        .addModifiers(Modifier.PUBLIC)
                        .addAnnotation(Override.class)
                        .returns(ClassName.get(""android.os"", ""IBinder""))
                        .addStatement(""return binder"")
                        .build())
                .addSuperinterface(ClassName.get(""android.os"", ""IInterface""));

        return staticBinderWrapperClassBuilder.build();
    }",get the binder wrapper
"@Override
    public void initializeParsers(ExtensionParsingContext context) {
        for (InfinispanSchema namespace: InfinispanSchema.SCHEMAS) {
            context.setSubsystemXmlMapping(SUBSYSTEM_NAME, namespace.getNamespaceUri(), () -> new InfinispanSubsystemXMLReader(namespace));
        }
    }",Initialize the subsystem xml mappings.
"public static String createCookieToken(String clientUserName) {
    StringBuffer sb = new StringBuffer();
    sb.append(COOKIE_CLIENT_USER_NAME).append(COOKIE_KEY_VALUE_SEPARATOR).append(clientUserName)
      .append(COOKIE_ATTR_SEPARATOR);
    sb.append(COOKIE_CLIENT_RAND_NUMBER).append(COOKIE_KEY_VALUE_SEPARATOR)
      .append((new Random(System.currentTimeMillis())).nextLong());
    return sb.toString();
  }",Create a cookie token from the client user name and random number
"@Override
    protected void paintComponent(Graphics g) {
        if (!isInitialized()) {
            return;
        }

        final Graphics2D G2 = (Graphics2D) g.create();

        G2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        G2.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
        G2.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_NORMALIZE);
        G2.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);

        G2.translate(getFramelessOffset().getX(), getFramelessOffset().getY());
        final AffineTransform OLD_TRANSFORM = G2.getTransform();

        // Draw combined background image
        G2.drawImage(bImage, 0, 0, null);

        // Draw an Arc2d object that will visualize the range of measured values
        if (isRangeOfMeasuredValuesVisible()) {
            G2.setPaint(getModel().getRangeOfMeasuredValuesPaint());
            if ((getGaugeType() == GaugeType.TYPE3 || getGaugeType() == GaugeType.TYPE4) && isLcdVisible()) {
                final Area area = getModel().getRadialAreaOfMeasuredValues();
                area.subtract(lcdArea);
                G2.fill(area);
            } else {
                G2.fill(getModel().getRadialShapeOfMeasuredValues());
            }
        }

        // Highlight active area
        if (isHighlightArea()) {
            for(Section area : getAreas()) {
                if (area.contains(getValue())) {
                    G2.setColor(area.getHighlightColor());
                    if ((getGaugeType() == GaugeType.TYPE3 || getGaugeType() == GaugeType.TYPE4) && isLcdVisible()) {
                        final Area currentArea = new Area(area.getFilledArea());
                        currentArea.subtract(lcdArea);
                        G2.fill(currentArea);
                    } else {
                        G2.fill(area.getFilledArea());
                    }
                    break;
                }
            }
        }

        // Highlight active section
        if (isHighlightSection()) {
            for(Section section : getSections()) {
                if (section.contains(getValue())) {
                    G2.setColor(section.getHighlightColor());
                    G2.fill(section.getSectionArea());
                    break;
                }
            }
        }

        // Draw threshold indicator
        if (isThresholdVisible()) {
            if (!isLogScale()) {
                G2.rotate(getRotationOffset() + (getThreshold() - getMinValue()) * getAngleStep(), CENTER.getX(), CENTER.getY());
            } else {
                G2.rotate(getRotationOffset() + UTIL.logOfBase(BASE, getThreshold() - getMinValue()) * getLogAngleStep(), CENTER.getX(), CENTER.getY());
            }
            G2.drawImage(thresholdImage, (int) (getGaugeBounds().width * 0.4813084112), (int) (getGaugeBounds().height * 0.0841121495), null);
            G2.setTransform(OLD_TRANSFORM);
        }

        // Draw min measured value indicator
        if (isMinMeasuredValueVisible()) {
            if (!isLogScale()) {
                G2.rotate(getRotationOffset() + (getMinMeasuredValue() - getMinValue()) * getAngleStep(), CENTER.getX(), CENTER.getY());
            } else {
                G2.rotate(getRotationOffset() + UTIL.logOfBase(BASE, getMinMeasuredValue() - getMinValue()) * getLogAngleStep(), CENTER.getX(), CENTER.getY());
            }
            G2.drawImage(minMeasuredImage, (int) (getGaugeBounds().width * 0.4865), (int) (getGaugeBounds().height * 0.105), null);
            G2.setTransform(OLD_TRANSFORM);
        }

        // Draw max measured value indicator
        if (isMaxMeasuredValueVisible()) {
            if (!isLogScale()) {
                G2.rotate(getRotationOffset() + (getMaxMeasuredValue() - getMinValue()) * getAngleStep(), CENTER.getX(), CENTER.getY());
            } else {
                G2.rotate(getRotationOffset() + UTIL.logOfBase(BASE, getMaxMeasuredValue() - getMinValue()) * getLogAngleStep(), CENTER.getX(), CENTER.getY());
            }
            G2.drawImage(maxMeasuredImage, (int) (getGaugeBounds().width * 0.4865), (int) (getGaugeBounds().height * 0.105), null);
            G2.setTransform(OLD_TRANSFORM);
        }

        // Draw LED if enabled
        if (isLedVisible()) {
            G2.drawImage(getCurrentLedImage(), (int) (getGaugeBounds().width * getLedPosition().getX()), (int) (getGaugeBounds().height * getLedPosition().getY()), null);
        }

        // Draw user LED if enabled
        if (isUserLedVisible()) {
            G2.drawImage(getCurrentUserLedImage(), (int) (getGaugeBounds().width * getUserLedPosition().getX()), (int) (getGaugeBounds().height * getUserLedPosition().getY()), null);
        }

        // Draw LCD display
        if (isLcdVisible()) {
            if (getLcdColor() == LcdColor.CUSTOM) {
                G2.setColor(getCustomLcdForeground());
            } else {
                G2.setColor(getLcdColor().TEXT_COLOR);
            }
            // Draw LCD text only if isVisible() in AbstractGauge (this is needed for lcd blinking)
            if (isLcdTextVisible()) {
            G2.setFont(getLcdUnitFont());
            if (isLcdUnitStringVisible()) {
                unitLayout = new TextLayout(getLcdUnitString(), G2.getFont(), RENDER_CONTEXT);
                UNIT_BOUNDARY.setFrame(unitLayout.getBounds());
                G2.drawString(getLcdUnitString(), (int) (LCD.getX() + (LCD.getWidth() - UNIT_BOUNDARY.getWidth()) - LCD.getWidth() * 0.03), (int) (LCD.getY() + LCD.getHeight() * 0.76));
                unitStringWidth = UNIT_BOUNDARY.getWidth();
            } else {
                unitStringWidth = 0;
            }
            G2.setFont(getLcdValueFont());
            switch (getModel().getNumberSystem()) {
                case HEX:
                    valueLayout = new TextLayout(Integer.toHexString((int) getLcdValue()).toUpperCase(), G2.getFont(), RENDER_CONTEXT);
                    VALUE_BOUNDARY.setFrame(valueLayout.getBounds());
                    G2.drawString(Integer.toHexString((int) getLcdValue()).toUpperCase(), (float) (LCD.getX() + (LCD.getWidth() - unitStringWidth - VALUE_BOUNDARY.getWidth()) - LCD.getHeight() * 0.333333333), (float) (LCD.getY() + LCD.getHeight() * 0.76));
                    break;

                case OCT:
                    valueLayout = new TextLayout(Integer.toOctalString((int) getLcdValue()), G2.getFont(), RENDER_CONTEXT);
                    VALUE_BOUNDARY.setFrame(valueLayout.getBounds());
                    G2.drawString(Integer.toOctalString((int) getLcdValue()), (float) (LCD.getX() + (LCD.getWidth() - unitStringWidth - VALUE_BOUNDARY.getWidth()) - LCD.getHeight() * 0.333333333), (float) (LCD.getY() + LCD.getHeight() * 0.76));
                    break;

                case DEC:

                default:
                    int digitalFontNo_1Offset = 0;
                    if (isDigitalFont() && Double.toString(getLcdValue()).startsWith(""1"")) {
                        digitalFontNo_1Offset = (int) (LCD.getHeight() * 0.2166666667);
                    }
                    valueLayout = new TextLayout(formatLcdValue(getLcdValue()), G2.getFont(), RENDER_CONTEXT);
                    VALUE_BOUNDARY.setFrame(valueLayout.getBounds());
                    G2.drawString(formatLcdValue(getLcdValue()), (float) (LCD.getX() + (LCD.getWidth() - unitStringWidth - VALUE_BOUNDARY.getWidth()) - LCD.getHeight() * 0.333333333) - digitalFontNo_1Offset, (float) (LCD.getY() + LCD.getHeight() * 0.76));
                    break;
            }
            }
            // Draw lcd info string
            if (!getLcdInfoString().isEmpty()) {
                G2.setFont(getLcdInfoFont());
                infoLayout = new TextLayout(getLcdInfoString(), G2.getFont(), RENDER_CONTEXT);
                INFO_BOUNDARY.setFrame(infoLayout.getBounds());
                G2.drawString(getLcdInfoString(), (float) LCD.getBounds().x + 5f, LCD.getBounds().y + (float) INFO_BOUNDARY.getHeight() + 5f);
            }
            // Draw lcd threshold indicator
            if (getLcdNumberSystem() == NumberSystem.DEC && isLcdThresholdVisible() && getLcdValue() >= getLcdThreshold()) {
                G2.drawImage(lcdThresholdImage, (int) (LCD.getX() + LCD.getHeight() * 0.0568181818), (int) (LCD.getY() + LCD.getHeight() - lcdThresholdImage.getHeight() - LCD.getHeight() * 0.0568181818), null);
            }
        }

        // Draw the pointer
        if (!isLogScale()) {
            angle = getRotationOffset() + (getValue() - getMinValue()) * getAngleStep();
            G2.rotate(angle + (Math.cos(Math.toRadians(angle - getRotationOffset() - 91.5))), CENTER.getX(), CENTER.getY());
        } else {
            angle = getRotationOffset() + UTIL.logOfBase(BASE, getValue() - getMinValue()) * getLogAngleStep();
            G2.rotate(angle, CENTER.getX(), CENTER.getY() + 2);
        }
        G2.drawImage(pointerShadowImage, 0, 0, null);
        G2.setTransform(OLD_TRANSFORM);
        G2.rotate(angle, CENTER.getX(), CENTER.getY());
        G2.drawImage(pointerImage, 0, 0, null);
        G2.setTransform(OLD_TRANSFORM);

        // Draw combined foreground image
        G2.drawImage(fImage, 0, 0, null);

        // Draw glow indicator
        if (isGlowVisible()) {
            if (isGlowing()) {
                G2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, getGlowAlpha()));
                G2.drawImage(glowImageOn, 0, 0, null);
                G2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1.0f));
            } else {
                G2.drawImage(glowImageOff, 0, 0, null);
            }
        }

        // Draw disabled image if component isEnabled() == false
        if (!isEnabled()) {
            G2.drawImage(disabledImage, 0, 0, null);
        }

        G2.dispose();
    }",Override paintComponent to draw the image of the calendar.
"public StatementBuilder withQualifier(Snak qualifier) {
		getQualifierList(qualifier.getPropertyId()).add(qualifier);
		return getThis();
	}",Add a qualifier to the statement.
"protected ApacheLog createEntity(Map<String, String> logInfoMap) throws ParseException
    {
        String serverName = logInfoMap.get(""hostname"");
        String sizeStr = logInfoMap.get(""size"");
        String timeStr = logInfoMap.get(""reqtime_microsec"");
        String recordedTimeStr = logInfoMap.get(""time"");

        long size = 0;
        long time = 0;
        Date recordedTime = null;

        if (sizeStr != null && StringUtils.equals(sizeStr, ""-"") == false)
        {
            size = Long.valueOf(sizeStr);
        }

        if (timeStr != null && StringUtils.equals(timeStr, ""-"") == false)
        {
            time = Long.valueOf(timeStr);
        }

        if (recordedTimeStr != null)
        {
            recordedTime = this.javaDateFormat.parse(recordedTimeStr);
        }
        else
        {
            recordedTime = new Date();
        }

        ApacheLog result = new ApacheLog(serverName, 1, size, time, recordedTime, 0d);
        return result;
    }",Create an entity from the log info map.
"public static Logger getLogger(final String aName, final String aBundleName) {
        final ILoggerFactory factory = org.slf4j.LoggerFactory.getILoggerFactory();
        final Logger logger;

        if (aBundleName != null) {
            logger = new Logger(factory.getLogger(aName), aBundleName);
        } else {
            logger = new Logger(factory.getLogger(aName));
        }

        return logger;
    }",Get a Logger object from the logger factory.
"public boolean replace( Long key, TypeV oldValue, TypeV newValue ) {
    return replace(key.longValue(), oldValue, newValue);
  }",Replaces the value of the specified key with the specified value.
"public HBaseDataHandler getHandle()
    {
        HBaseDataHandler handler = new HBaseDataHandler(this.kunderaMetadata, this.connection);
        handler.filter = this.filter;
        handler.filters = this.filters;
        return handler;
    }",Gets the HBaseDataHandler.
"public static boolean isMethodDirectlyExists(Object object, String methodName, Class<?>... params) {
		try {
			Method method = object.getClass().getDeclaredMethod(methodName, params);
			return true;
		} catch (NoSuchMethodException e) {
			return false;
		} catch (SecurityException e) {
			throw new RuntimeException(e);
		}
	}",Checks if the specified object has a method with the specified name and parameters.
"@BetaApi
  public final Operation setLabelsInstance(
      ProjectZoneInstanceName instance,
      InstancesSetLabelsRequest instancesSetLabelsRequestResource) {

    SetLabelsInstanceHttpRequest request =
        SetLabelsInstanceHttpRequest.newBuilder()
            .setInstance(instance == null ? null : instance.toString())
            .setInstancesSetLabelsRequestResource(instancesSetLabelsRequestResource)
            .build();
    return setLabelsInstance(request);
  }",Sets the labels for an instance.
"public void setItems(java.util.Collection<Route> items) {
        if (items == null) {
            this.items = null;
            return;
        }

        this.items = new java.util.ArrayList<Route>(items);
    }",Sets the value of the items property.
"public static Map<String, Object> verify(String token, final RSAPublicKey pk) throws InvalidTokenException {
        // RS256签名验证器
        Verifier verifier = new Verifier() {
            @Override
            public boolean verifySignature(String content, String payload, String signature) {
                return JWT.verifySignature(content,signature,pk);
            }
        };
        return verify(token, verifier);
    }",Verify a JWT token.
"public static AsyncSemaphoreBuilder newBuilder(Supplier<Integer> concurrentRequestLimit, ScheduledExecutorService flushingExecutor) {
    return new AsyncSemaphoreBuilder(new PermitSource(concurrentRequestLimit), flushingExecutor);
  }",Creates an AsyncSemaphoreBuilder.
"public static String encodeQueryParamSaveEncodings(String segment) {
        String result = encodeFromArray(segment, queryNameValueEncoding, false);
        result = encodeNonCodes(result);
        return result;
    }",Encode a segment in the format used by the URL to save the query parameters.
"public CellField<T> add(final FieldValidator<T> validator) {
        ArgUtils.notNull(validator, ""validator"");
        this.validators.add(validator);

        return this;
    }",Add a new validator to the cell field.
"@Override
	protected String getRewrittenImagePath(String originalCssPath, String newCssPath, String url) throws IOException {

		String imgUrl = null;

		// Retrieve the current CSS file from which the CSS image is referenced
		String currentCss = originalCssPath;
		boolean generatedImg = false;
		if (binaryRsHandler != null) {
			GeneratorRegistry imgRsGeneratorRegistry = binaryRsHandler.getConfig().getGeneratorRegistry();
			generatedImg = imgRsGeneratorRegistry.isGeneratedBinaryResource(url);
		}

		boolean cssGeneratorIsHandleCssImage = isCssGeneratorHandlingCssImage(currentCss);

		String rootPath = currentCss;

		// If the CSS image is taken from the classpath, add the classpath cache
		// prefix
		if (generatedImg || cssGeneratorIsHandleCssImage) {

			String tempUrl = url;

			// If it's a classpath CSS, the url of the CSS image is defined
			// relatively to it.
			if (cssGeneratorIsHandleCssImage && !generatedImg) {
				tempUrl = PathNormalizer.concatWebPath(rootPath, url);
			}

			// generate image cache URL
			imgUrl = rewriteURL(tempUrl, binaryServletPath, newCssPath, binaryRsHandler);
		} else {

			if (config.getGeneratorRegistry().isPathGenerated(rootPath)) {
				rootPath = rootPath.substring(rootPath.indexOf(GeneratorRegistry.PREFIX_SEPARATOR) + 1);
			}

			// Generate the image URL from the current CSS path
			imgUrl = PathNormalizer.concatWebPath(rootPath, url);
			imgUrl = rewriteURL(imgUrl, binaryServletPath, newCssPath, binaryRsHandler);
		}

		// This following condition should never be true.
		// If it does, it means that the image path is wrongly defined.
		if (imgUrl == null) {
			LOGGER.error(""The CSS image path for '"" + url + ""' defined in '"" + currentCss
					+ ""' is out of the application context. Please check your CSS file."");
		}

		return imgUrl;
	}",Get the path of the image to be rewritten.
"public static String getHost(final URI uri) throws NormalizationException {
        final String host = Strings.emptyToNull(uri.getHost());
        if (host == null) {
            throw new NormalizationException(uri.toString(), ""No host in URI"");
        }
        return host;
    }",Get the host of the URI.
"boolean tryAdd(TaskMessage taskMsg) {
        if ((encodedLength + msgEncodeLength(taskMsg)) > buffer_size)
            return false;
        add(taskMsg);
        return true;
    }",Try to add a single message to the cache.
"@SuppressWarnings({""ConstantConditions"",""deprecation""})
    @SuppressFBWarnings(""RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE"")
    public void addAction(@Nonnull Action a) {
        if(a==null) {
            throw new IllegalArgumentException(""Action must be non-null"");
        }
        getActions().add(a);
    }",Add an action to the application.
"@Deprecated
	@Override
	public void setTag(final String tag) {
		ComponentModel model = getOrCreateComponentModel();
		model.setTag(tag);
	}",Sets the tag of the entity.
"private void buildPolicyErrorMessage(String msgKey, String defaultMessage, Object... arg1) {
        /* The message need to be logged only for level below 'Warning' */
        if (TraceComponent.isAnyTracingEnabled() && tc.isWarningEnabled()) {
            String messageFromBundle = Tr.formatMessage(tc, msgKey, arg1);
            Tr.error(tc, messageFromBundle);
        }
    }",Build the error message from the bundle.
"public static void multAddTransA(double realAlpha , double imagAlpha , ZMatrixRMaj a , ZMatrixRMaj b , ZMatrixRMaj c )
    {
        // TODO add a matrix vectory multiply here
        if( a.numCols >= EjmlParameters.CMULT_COLUMN_SWITCH ||
                b.numCols >= EjmlParameters.CMULT_COLUMN_SWITCH ) {
            MatrixMatrixMult_ZDRM.multAddTransA_reorder(realAlpha, imagAlpha, a, b, c);
        } else {
            MatrixMatrixMult_ZDRM.multAddTransA_small(realAlpha, imagAlpha, a, b, c);
        }
    }",multAddTransA.
"@Nonnull
    public List<String> getRemainingLines(boolean trimAndSkipEmpty) throws IOException {
        List<String> out = new ArrayList<>();

        StringBuilder builder = new StringBuilder();
        while (bufferOffset <= bufferLimit || !bufferLineEnd) {
            if (!readNextChar()) {
                break;
            }
            if (lastChar == '\n') {
                String line = builder.toString();
                if (!trimAndSkipEmpty || !line.trim().isEmpty()) {
                    out.add(trimAndSkipEmpty ? line.trim() : line);
                }
                builder = new StringBuilder();
            } else {
                builder.append((char) lastChar);
            }
        }
        if (builder.length() > 0) {
            String line = builder.toString();
            if (!trimAndSkipEmpty || !line.trim().isEmpty()) {
                out.add(builder.toString());
            }
        }
        return out;
    }",Get the remaining lines of the file.
"public boolean verify() {
    boolean success = false;
    try {
      TransactionAwareHTable table = new TransactionAwareHTable(conn.getTable(TABLE));
      TransactionContext context = new TransactionContext(txClient, table);

      LOG.info(""VERIFYING BALANCES"");
      context.start();
      long totalBalance = 0;
      ResultScanner scanner = table.getScanner(new Scan());
      try {
        for (Result r : scanner) {
          if (!r.isEmpty()) {
            int rowId = Bytes.toInt(r.getRow());
            long balance = Bytes.toLong(r.getValue(FAMILY, COL));
            totalBalance += balance;
            LOG.info(""Client #{}: balance = ${}"", rowId, balance);
          }
        }
      } finally {
        if (scanner != null) {
          Closeables.closeQuietly(scanner);
        }
      }
      if (totalBalance == 0) {
        LOG.info(""PASSED!"");
        success = true;
      } else {
        LOG.info(""FAILED! Total balance should be 0 but was {}"", totalBalance);
      }
      context.finish();
    } catch (Exception e) {
      LOG.error(""Failed verification check"", e);
    }
    return success;
  }",Verify the table.
"public static SecurityException newSecurityException(String message, Object... args) {
    return newSecurityException(null, message, args);
  }",Creates a new SecurityException with the specified message and arguments.
"private void startDisseminators(String localName, Attributes a)
            throws SAXException {
        if (localName.equals(""structMap"")) {
            // this is a component of a disseminator.  here we assume the rest
            // of the disseminator's information will be seen later, so we
            // construct a new Disseminator object to hold the structMap...
            // and later, the other info
            //
            // Building up a global map of Disseminators, m_dissems,
            // keyed by bindingmap ID.
            //
            if (grab(a, METS.uri, ""TYPE"").equals(""fedora:dsBindingMap"")) {
                String bmId = grab(a, METS.uri, ""ID"");
                if (bmId == null || bmId.isEmpty()) {
                    throw new SAXException(""structMap with TYPE ""
                            + ""fedora:dsBindingMap must specify a non-empty ""
                            + ""ID attribute."");
                } else {
                    Disseminator diss = new Disseminator();
                    diss.dsBindMapID = bmId;
                    m_dissems.put(bmId, diss);
                    m_diss = diss;
                    m_diss.dsBindMap = new DSBindingMap();
                    m_diss.dsBindMap.dsBindMapID = bmId;
                    m_indiv = false; // flag we're not looking at inner part yet
                }
            } else {
                throw new SAXException(""StructMap must have TYPE fedora:dsBindingMap"");
            }
        } else if (localName.equals(""div"")) {
            if (m_indiv) {
                // inner part of structmap
                DSBinding binding = new DSBinding();
                if (m_diss.dsBindMap.dsBindings == null) {
                    // none yet.. create array of size one
                    DSBinding[] bindings = new DSBinding[1];
                    m_diss.dsBindMap.dsBindings = bindings;
                    m_diss.dsBindMap.dsBindings[0] = binding;
                } else {
                    // need to expand the array size by one,
                    // and do an array copy.
                    int curSize = m_diss.dsBindMap.dsBindings.length;
                    DSBinding[] oldArray = m_diss.dsBindMap.dsBindings;
                    DSBinding[] newArray = new DSBinding[curSize + 1];
                    for (int i = 0; i < curSize; i++) {
                        newArray[i] = oldArray[i];
                    }
                    newArray[curSize] = binding;
                    m_diss.dsBindMap.dsBindings = newArray;
                }
                // now populate 'binding' values...we'll have
                // everything at this point except datastreamID...
                // that comes as a child: <fptr FILEID=""DS2""/>
                binding.bindKeyName = grab(a, METS.uri, ""TYPE"");
                binding.bindLabel = grab(a, METS.uri, ""LABEL"");
                binding.seqNo = grab(a, METS.uri, ""ORDER"");
            } else {
                m_indiv = true;
                // first (outer div) part of structmap
                m_diss.dsBindMap.dsBindMechanismPID = grab(a, METS.uri, ""TYPE"");
                m_diss.dsBindMap.dsBindMapLabel = grab(a, METS.uri, ""LABEL"");
            }
        } else if (localName.equals(""fptr"")) {
            // assume we're inside the inner div... that's the
            // only place the fptr element is valid.
            DSBinding binding =
                    m_diss.dsBindMap.dsBindings[m_diss.dsBindMap.dsBindings.length - 1];
            binding.datastreamID = grab(a, METS.uri, ""FILEID"");
        } else if (localName.equals(""behaviorSec"")) {
            // looks like we're in a disseminator... it should be in the
            // hash by now because we've already gone through structmaps
            // ...keyed by structmap id... remember the id (group id)
            // so we can put it in when parsing serviceBinding
            m_dissemId = grab(a, METS.uri, ""ID"");
            m_dissemState = grab(a, METS.uri, ""STATUS"");
        } else if (localName.equals(""serviceBinding"")) {
            // remember the structId so we can grab the right dissem
            // when parsing children
            m_structId = grab(a, METS.uri, ""STRUCTID"");
            // grab the disseminator associated with the provided structId
            Disseminator dissem = m_dissems.get(m_structId);
            // plug known items in..
            dissem.dissID = m_dissemId;
            dissem.dissState = m_dissemState;
            // then grab the new stuff for the dissem for this element, and
            // put it in.
            dissem.dissVersionID = grab(a, METS.uri, ""ID"");
            dissem.bDefID = grab(a, METS.uri, ""BTYPE"");
            dissem.dissCreateDT =
                    DateUtility
                            .convertStringToDate(grab(a, METS.uri, ""CREATED""));
            dissem.dissLabel = grab(a, METS.uri, ""LABEL"");
        } else if (localName.equals(""interfaceMD"")) {
            // no-op?
            // Disseminator dissem = m_dissems.get(m_structId);
        } else if (localName.equals(""serviceBindMD"")) {
            Disseminator dissem = m_dissems.get(m_structId);
            dissem.sDepID = grab(a, m_xlink.uri, ""href"");
        }
    }",Start Disseminators.
"public void marshall(DeleteTrailRequest deleteTrailRequest, ProtocolMarshaller protocolMarshaller) {

        if (deleteTrailRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(deleteTrailRequest.getName(), NAME_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",Creates the given parameter object.
"@CheckResult
    @NonNull
    public static PowerAdapter asAdapter(@NonNull ViewFactory... views) {
        checkNotNull(views, ""views"");
        if (views.length == 0) {
            return EMPTY;
        }
        return new ItemAdapter(ItemAdapter.toItems(asList(views)));
    }",Create a new adapter for a single entity type.
"private List<String> getSchemaStringsFromDir(File dir) {
    List<String> schemaStrings = new ArrayList<String>();
    Collection<File> schemaFiles = FileUtils.listFiles(dir,
        new SuffixFileFilter("".avsc""), TrueFileFilter.INSTANCE);
    for (File schemaFile : schemaFiles) {
      schemaStrings.add(getSchemaStringFromFile(schemaFile));
    }
    return schemaStrings;
  }",Get the list of schema strings from a directory
"public void setAllowedPrefixesToDirectConnectGateway(java.util.Collection<RouteFilterPrefix> allowedPrefixesToDirectConnectGateway) {
        if (allowedPrefixesToDirectConnectGateway == null) {
            this.allowedPrefixesToDirectConnectGateway = null;
            return;
        }

        this.allowedPrefixesToDirectConnectGateway = new com.amazonaws.internal.SdkInternalList<RouteFilterPrefix>(allowedPrefixesToDirectConnectGateway);
    }",Sets the value allowedPrefixesToDirectConnectGateway ;
"public PassiveScanner getScanner(int pluginId) {
        for (PassiveScanner scanner : passiveScanners) {
            if (scanner instanceof PluginPassiveScanner) {
                if (((PluginPassiveScanner)scanner).getPluginId() == pluginId) {
                    return scanner;
                }
            }
        }
        return null;
    }",Get a PassiveScanner for the given pluginId.
"public User login(final String username,
            final String password) throws IOException, GroovesharkException {
        JsonNode node = sendRequest(new RequestBuilder(""authenticateUser"", true) {

            @Override
            void populateParameters(Session session, ObjectNode parameters) {
                parameters.put(""username"", username);
                parameters.put(""password"", password);
            }
        });
        // Success: the session that created this request is now authenticated,
        // so we can mark is as such.
        User user = new User(this, username, password, node);
        session.setAuthenticated(user);
        return user;
    }",Login to the server.
"@Implementation
  protected int load(String path, int priority) {
    int soundId = soundIds.getAndIncrement();
    idToPaths.put(soundId, path);
    return soundId;
  }",Load a single sound from the file system.
"public static boolean isNullOrEmpty(@Nullable String string)
  {
    if (string == null || string.isEmpty())
    {
      return true;
    }
    return false;
  }",Checks if the given string is null or empty.
"public void copyFromMaster(Storable reference, S master) throws FetchException {
        try {
            mCopyFromMasterMethod.invoke(reference, master);
        } catch (Exception e) {
            ThrowUnchecked.fireFirstDeclaredCause(e, FetchException.class);
        }
    }",Copies the content of the given Storable object from the given master object.
"public Observable<ServiceResponse<List<AzureSkuInner>>> listSkusWithServiceResponseAsync() {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");
        }
        return service.listSkus(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<AzureSkuInner>>>>() {
                @Override
                public Observable<ServiceResponse<List<AzureSkuInner>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<PageImpl<AzureSkuInner>> result = listSkusDelegate(response);
                        List<AzureSkuInner> items = null;
                        if (result.body() != null) {
                            items = result.body().items();
                        }
                        ServiceResponse<List<AzureSkuInner>> clientResponse = new ServiceResponse<List<AzureSkuInner>>(items, result.response());
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }",List the SKUs of the specified resource.
"@Override
   protected ResultSet findItemQPathByIdentifierCQ(String identifier) throws SQLException
   {
      if (findItemQPathByIdentifierCQ == null)
      {
         findItemQPathByIdentifierCQ = dbConnection.prepareStatement(FIND_ITEM_QPATH_BY_ID_CQ);
      }
      else
      {
         findItemQPathByIdentifierCQ.clearParameters();
      }

      findItemQPathByIdentifierCQ.setString(1, identifier);
      return findItemQPathByIdentifierCQ.executeQuery();
   }",Override the method findItemQPathByIdentifierCQ.
"@Override
    public Object convertRequest(ServiceRequestContext ctx, AggregatedHttpMessage request,
                                 Class<?> expectedResultType) throws Exception {
        final String ifNoneMatch = request.headers().get(HttpHeaderNames.IF_NONE_MATCH);
        if (!isNullOrEmpty(ifNoneMatch)) {
            final Revision lastKnownRevision = new Revision(ifNoneMatch);
            final String prefer = request.headers().get(HttpHeaderNames.PREFER);
            final long timeoutMillis;
            if (!isNullOrEmpty(prefer)) {
                timeoutMillis = getTimeoutMillis(prefer);
            } else {
                timeoutMillis = DEFAULT_TIMEOUT_MILLIS;
            }
            // Update timeout according to the watch API specifications.
            ctx.setRequestTimeoutMillis(
                    WatchTimeout.makeReasonable(timeoutMillis, ctx.requestTimeoutMillis()));
            return Optional.of(new WatchRequest(lastKnownRevision, timeoutMillis));
        }
        return Optional.empty();
    }",Convert a request to a watch request.
"public void setOrdererProperties(String name, Properties properties) throws InvalidArgumentException {
        setNodeProperties(""Orderer"", name, orderers, properties);
    }",Sets the properties for an orderer.
"@Override
  public String getReturnAuthnContextClassRef(ProfileRequestContext<?, ?> context, String authnContextUri, boolean displayedSignMessage)
      throws ExternalAutenticationErrorCodeException {

    final String logId = this.getLogString(context);

    AuthnContextClassContext authnContextClassContext = this.getAuthnContextClassContext(context);

    // Make sure we received one of the requested AuthnContextClassRef URI:s.
    //
    if (!this.isIssuedAuthnContextClassRefAccepted(context, authnContextUri)) {
      final String msg = String.format(
        ""AuthnContextClassRef URI received in assertion from IdP (%s) does not match any of the URI:s sent in the AuthnRequest (%s)"",
        authnContextUri, authnContextClassContext.getProxiedAuthnContextClassRefs());
      log.info(""{} [{}]"", msg, logId);
      throw new ExternalAutenticationErrorCodeException(AuthnEventIds.AUTHN_EXCEPTION, msg);
    }

    // OK, that seems OK. Next, we will have to cover up for signing and for transformation.
    //
    String authnContextUriForSp = this.transformForSp(context, authnContextUri);
    if (authnContextUriForSp == null) {
      // Should never happen since we matched everything before sending the request.
      final String msg = String.format(""AuthnContextClassRef received from IdP '{}' cannot be transformed"", authnContextUri);
      log.info(""{} [{}]"", msg, logId);
      throw new ExternalAutenticationErrorCodeException(AuthnEventIds.AUTHN_EXCEPTION, msg);
    }

    // OK, now we have the URI in a format that the SP understands. Let's check if we need to add
    // a sigmessage extension to it.
    //
    if (!authnContextClassContext.isProxiedIdPSupportsSignMessage() && displayedSignMessage) {

      // The remote IdP does not support sign messages, but the Proxy IdP has displayed the
      // sign message. See if a sigmessage URI corresponding to the one we got back from the
      // remote IdP was requested by the SP. If so, use that.
      //
      String sigmessageUri = this.toSignMessageURI(authnContextUriForSp);
      if (sigmessageUri != null) {
        if (authnContextClassContext.getAuthnContextClassRefs().contains(sigmessageUri)) {
          authnContextUriForSp = sigmessageUri;
        }
      }
    }

    return authnContextUriForSp;
  }",Override the method to return the AuthnContextClassRef from the request.
"@Override
    public void visitFormalTypeParameter(final String name) {
        if (!hasFormals) {
            hasFormals = true;
            buf.append('<');
        }
        buf.append(name);
        buf.append(':');
    }",Visit a formal type parameter.
"public TomcatServiceBuilder baseDir(Path baseDir) {
        baseDir = requireNonNull(baseDir, ""baseDir"").toAbsolutePath();
        if (!Files.isDirectory(baseDir)) {
            throw new IllegalArgumentException(""baseDir: "" + baseDir + "" (expected: a directory)"");
        }

        this.baseDir = baseDir;
        return this;
    }",Sets the base directory.
"private HamtPMap<K, V> minus(K key, int hash, V[] value) {
    if (hash == this.hash && key.equals(this.key)) {
      HamtPMap<K, V> result = deleteRoot(mask, children);
      if (value != null) {
        value[0] = this.value;
      }
      return result != null ? result : empty();
    }
    int bucket = bucket(hash);
    int bucketMask = 1 << bucket;
    if ((mask & bucketMask) == 0) {
      // not present, stop looking
      return this;
    }
    hash = shift(hash);
    int index = index(bucketMask);
    HamtPMap<K, V> child = children[index];
    HamtPMap<K, V> newChild = child.minus(key, hash, value);
    if (newChild == child) {
      return this;
    } else if (newChild == EMPTY) {
      return withChildren(mask & ~bucketMask, deleteChild(children, index));
    } else {
      return withChildren(mask, replaceChild(children, index, newChild));
    }
  }",Subtracts the value from this map.
"protected void handleResponse(int responseCode, InputStream inputStream) {
        BufferedReader rd = null;
        try {
            // Buffer the result into a string
            rd = new BufferedReader(new InputStreamReader(inputStream));
            StringBuilder sb = new StringBuilder();
            String line;
            while((line = rd.readLine()) != null) {
                sb.append(line);
            }
            log.info(""HttpHook ["" + hookName + ""] received "" + responseCode + "" response: "" + sb);
        } catch (IOException e) {
            log.error(""Error while reading response for HttpHook ["" + hookName + ""]"", e);
        } finally {
            if (rd != null) {
                try {
                    rd.close();
                } catch (IOException e) {
                    // no-op
                }
            }
        }
    }",Handle response from a HTTP response.
"public static CreateObjectOptions objectOptionsFromFileOptions(CreateFileOptions options) {
    return new CreateObjectOptions(
        options.overwriteExisting(), options.getContentType(), options.getAttributes());
  }",Create object options from file options.
"@GwtIncompatible(""incompatible method"")
    private void reflectionAppend(
        final Object lhs,
        final Object rhs,
        final Class<?> clazz) {

        if (isRegistered(lhs, rhs)) {
            return;
        }

        try {
            register(lhs, rhs);
            final Field[] fields = clazz.getDeclaredFields();
            AccessibleObject.setAccessible(fields, true);
            for (int i = 0; i < fields.length && isEquals; i++) {
                final Field f = fields[i];
                if (!ArrayUtils.contains(excludeFields, f.getName())
                    && !f.getName().contains(""$"")
                    && (testTransients || !Modifier.isTransient(f.getModifiers()))
                    && !Modifier.isStatic(f.getModifiers())
                    && !f.isAnnotationPresent(EqualsExclude.class)) {
                    try {
                        append(f.get(lhs), f.get(rhs));
                    } catch (final IllegalAccessException e) {
                        //this can't happen. Would get a Security exception instead
                        //throw a runtime exception in case the impossible happens.
                        throw new InternalError(""Unexpected IllegalAccessException"");
                    }
                }
            }
        } finally {
            unregister(lhs, rhs);
        }
    }",Append a pair of objects to the class.
"public void marshall(DeleteJobRequest deleteJobRequest, ProtocolMarshaller protocolMarshaller) {

        if (deleteJobRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(deleteJobRequest.getJobName(), JOBNAME_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given parameter object.
"public ComponentView createComponentView(Container container, String key, String description) {
        assertThatTheContainerIsNotNull(container);
        assertThatTheViewKeyIsSpecifiedAndUnique(key);

        ComponentView view = new ComponentView(container, key, description);
        view.setViewSet(this);
        componentViews.add(view);
        return view;
    }",Creates a ComponentView object.
"public static FDBigInteger valueOfMulPow52(long value, int p5, int p2) {
        assert p5 >= 0 : p5;
        assert p2 >= 0 : p2;
        int v0 = (int) value;
        int v1 = (int) (value >>> 32);
        int wordcount = p2 >> 5;
        int bitcount = p2 & 0x1f;
        if (p5 != 0) {
            if (p5 < SMALL_5_POW.length) {
                long pow5 = SMALL_5_POW[p5] & LONG_MASK;
                long carry = (v0 & LONG_MASK) * pow5;
                v0 = (int) carry;
                carry >>>= 32;
                carry = (v1 & LONG_MASK) * pow5 + carry;
                v1 = (int) carry;
                int v2 = (int) (carry >>> 32);
                if (bitcount == 0) {
                    return new FDBigInteger(new int[]{v0, v1, v2}, wordcount);
                } else {
                    return new FDBigInteger(new int[]{
                            v0 << bitcount,
                            (v1 << bitcount) | (v0 >>> (32 - bitcount)),
                            (v2 << bitcount) | (v1 >>> (32 - bitcount)),
                            v2 >>> (32 - bitcount)
                    }, wordcount);
                }
            } else {
                FDBigInteger pow5 = big5pow(p5);
                int[] r;
                if (v1 == 0) {
                    r = new int[pow5.nWords + 1 + ((p2 != 0) ? 1 : 0)];
                    mult(pow5.data, pow5.nWords, v0, r);
                } else {
                    r = new int[pow5.nWords + 2 + ((p2 != 0) ? 1 : 0)];
                    mult(pow5.data, pow5.nWords, v0, v1, r);
                }
                return (new FDBigInteger(r, pow5.offset)).leftShift(p2);
            }
        } else if (p2 != 0) {
            if (bitcount == 0) {
                return new FDBigInteger(new int[]{v0, v1}, wordcount);
            } else {
                return new FDBigInteger(new int[]{
                         v0 << bitcount,
                        (v1 << bitcount) | (v0 >>> (32 - bitcount)),
                        v1 >>> (32 - bitcount)
                }, wordcount);
            }
        }
        return new FDBigInteger(new int[]{v0, v1}, 0);
    }",Returns the result of a multiplication of the specified value with the specified power of two bits.
"public static STSClient createSTSX509Client(Bus bus, Map<String, String> stsProps) {
        final STSClient stsClient = createClient(bus, stsProps);

        stsClient.setWsdlLocation(stsProps.get(STS_X509_WSDL_LOCATION));
        stsClient.setEndpointQName(new QName(stsProps.get(STS_NAMESPACE), stsProps.get(STS_X509_ENDPOINT_NAME)));

        return stsClient;
    }","Create a new instance of a
        client."
"public int compareTo (Name other)
    {
        Integer override = overrideCompareTo(other);
        if (override != null) {
            return override;
        } else if ((override = other.overrideCompareTo(this)) != null) {
            return -override;
        }
        Class<?> c = getClass();
        Class<?> oc = other.getClass();
        if (c == oc || c.getName().equals(oc.getName())) {
            return getNormal().compareTo(other.getNormal());
        } else {
            return c.getName().compareTo(oc.getName());
        }
    }",Compare two Name objects.
"public static String daoName(SQLiteDaoDefinition value) {
		String classTableName = value.getName();
		classTableName = classTableName + SUFFIX;
		return classTableName;
	}",Get the name of the database table for a given DAO definition
"@CheckReturnValue(when = When.NEVER)
  public boolean isLoggedInInterruptibly() throws InterruptedException {
    authLock.readLock().lockInterruptibly();
    try {
      return activeUser != null && activeUser.isLoggedIn();
    } finally {
      authLock.readLock().unlock();
    }
  }",Check if the user is logged in interruptibly.
"public DateTimeFormatterBuilder appendText(DateTimeFieldType fieldType) {
        if (fieldType == null) {
            throw new IllegalArgumentException(""Field type must not be null"");
        }
        return append0(new TextField(fieldType, false));
    }",Append a text field to the calendar.
"@Override
    public void readFragmentFrom(MwsReader r) {
        invoiceRequirement = r.read(""InvoiceRequirement"", String.class);
        buyerSelectedInvoiceCategory = r.read(""BuyerSelectedInvoiceCategory"", String.class);
        invoiceTitle = r.read(""InvoiceTitle"", String.class);
        invoiceInformation = r.read(""InvoiceInformation"", String.class);
    }",read the content of the SECTYPE from the MWSReader
"public static JobDescFactoryBase getFrameworkSpecificJobDescFactory(Configuration jobConf) {
    Framework framework = getFramework(jobConf);

    switch (framework) {
    case PIG:
      return PIG_JOB_DESC_FACTORY;
    case SCALDING:
      return SCALDING_JOB_DESC_FACTORY;
    default:
      return MR_JOB_DESC_FACTORY;
    }
  }",Get the JobDescFactoryBase for a specific framework
"@SuppressWarnings({""unused"", ""WeakerAccess""})
    public ArrayList<CTInboxMessage> getAllInboxMessages(){
        ArrayList<CTInboxMessage> inboxMessageArrayList = new ArrayList<>();
        synchronized (inboxControllerLock) {
            if(ctInboxController != null){
                ArrayList<CTMessageDAO> messageDAOArrayList = ctInboxController.getMessages();
                for (CTMessageDAO messageDAO : messageDAOArrayList) {
                    Logger.v(""CTMessage Dao - ""+messageDAO.toJSON().toString());
                    inboxMessageArrayList.add(new CTInboxMessage(messageDAO.toJSON()));
                }
                return inboxMessageArrayList;
            }else{
                getConfigLogger().debug(getAccountId(),""Notification Inbox not initialized"");
                return null;
            }
        }
    }",Gets all inbox messages.
"@Override
	public CommerceVirtualOrderItem findByUUID_G(String uuid, long groupId)
		throws NoSuchVirtualOrderItemException {
		CommerceVirtualOrderItem commerceVirtualOrderItem = fetchByUUID_G(uuid,
				groupId);

		if (commerceVirtualOrderItem == null) {
			StringBundler msg = new StringBundler(6);

			msg.append(_NO_SUCH_ENTITY_WITH_KEY);

			msg.append(""uuid="");
			msg.append(uuid);

			msg.append("", groupId="");
			msg.append(groupId);

			msg.append(""}"");

			if (_log.isDebugEnabled()) {
				_log.debug(msg.toString());
			}

			throw new NoSuchVirtualOrderItemException(msg.toString());
		}

		return commerceVirtualOrderItem;
	}",Returns the commerce virtual order item with the matching UUID and group.
"public EClass getIfcLoop() {
		if (ifcLoopEClass == null) {
			ifcLoopEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc2x3tc1Package.eNS_URI).getEClassifiers()
					.get(303);
		}
		return ifcLoopEClass;
	}",Get the IfcLoop feature from the EPackage.
"public Object invokeMethod(Object object, String methodName, Object[] originalArguments) {
        return invokeMethod(theClass, object, methodName, originalArguments, false, false);
    }",This method is used to invoke a method on a class.
"public static IAtom[] findClosestByBond(IAtomContainer atomContainer, IAtom atom, int max) {
        IAtomContainer mol = atomContainer.getBuilder().newInstance(IAtomContainer.class);
        List<IAtom> v = new ArrayList<IAtom>();
        v.add(atom);
        breadthFirstSearch(atomContainer, v, mol, max);
        IAtom[] returnValue = new IAtom[mol.getAtomCount() - 1];
        int k = 0;
        for (int i = 0; i < mol.getAtomCount(); i++) {
            if (!mol.getAtom(i).equals(atom)) {
                returnValue[k] = mol.getAtom(i);
                k++;
            }
        }
        return (returnValue);
    }",Find the closest atom in an AtomContainer by bond.
"public void errorv(Throwable t, String format, Object... params) {
        doLog(Level.ERROR, FQCN, format, params, t);
    }",Log a message at the ERROR level.
"public final <K> Mono<Map<K, T>> collectMap(Function<? super T, ? extends K> keyExtractor) {
		return collectMap(keyExtractor, identityFunction());
	}",Returns a Mono that contains all of the elements of this stream as a Map where the key is extracted from the elements of this stream.
"public static void fe_add(int[] h,int[] f,int[] g)
{
  int f0 = f[0];
  int f1 = f[1];
  int f2 = f[2];
  int f3 = f[3];
  int f4 = f[4];
  int f5 = f[5];
  int f6 = f[6];
  int f7 = f[7];
  int f8 = f[8];
  int f9 = f[9];
  int g0 = g[0];
  int g1 = g[1];
  int g2 = g[2];
  int g3 = g[3];
  int g4 = g[4];
  int g5 = g[5];
  int g6 = g[6];
  int g7 = g[7];
  int g8 = g[8];
  int g9 = g[9];
  int h0 = f0 + g0;
  int h1 = f1 + g1;
  int h2 = f2 + g2;
  int h3 = f3 + g3;
  int h4 = f4 + g4;
  int h5 = f5 + g5;
  int h6 = f6 + g6;
  int h7 = f7 + g7;
  int h8 = f8 + g8;
  int h9 = f9 + g9;
  h[0] = (int)h0;
  h[1] = (int)h1;
  h[2] = (int)h2;
  h[3] = (int)h3;
  h[4] = (int)h4;
  h[5] = (int)h5;
  h[6] = (int)h6;
  h[7] = (int)h7;
  h[8] = (int)h8;
  h[9] = (int)h9;
}",Add two non - zero elements in the F - tree.
"public void print(char c) throws IOException {
	    if (writer != null) {
	        writer.write(String.valueOf(c));
	    } else {
	        write(String.valueOf(c));
	    }
    }",Print a char to the underlying stream.
"@Override
    public boolean accept(final Packet packet) throws FilterException {
        try {
            if (super.accept(packet)) {
                final SipPacket msg = (SipPacket) packet.getPacket(Protocol.SIP);
                return msg.getCallIDHeader().getValue().equals(this.callId);
            }
        } catch (final SipPacketParseException e) {
            throw new FilterException(""Unable to process the frame due to SipParseException"", e);
        } catch (final IOException e) {
            throw new FilterException(""Unable to process the frame due to IOException"", e);
        } catch (final PacketParseException e) {
            throw new FilterException(""Unable to process the frame due to parse issue of the SIP Message"", e);
        }
        return false;
    }",Override accept to check if the call id matches the call id.
"public static BorderStyle getBorderBottom(final Cell cell) {

        ArgUtils.notNull(cell, ""cell"");

        final Sheet sheet = cell.getSheet();
        CellRangeAddress mergedRegion = getMergedRegion(sheet, cell.getRowIndex(), cell.getColumnIndex());

        final Cell target;
        if(mergedRegion == null) {
            // 結合されていない場合
            target = cell;

        } else {
            if(mergedRegion.getLastRow() == cell.getRowIndex()) {
                // 引数のCellが下部のセルの場合
                target = cell;
            } else {
                target = getCell(sheet, cell.getColumnIndex(), mergedRegion.getLastRow());
            }

        }

        final CellStyle style = target.getCellStyle();
        if(style == null) {
            return BorderStyle.NONE;
        } else {
            return style.getBorderBottomEnum();
        }

    }",Gets the border bottom style from the specified cell.
"protected void zSetData(MithraDataObject data)
    {
        this.currentData = data;
        this.persistenceState = PersistenceState.PERSISTED;

        MithraTransaction currentTransaction = MithraManagerProvider.getMithraManager().getCurrentTransaction();
        if (currentTransaction != null && zGetPortal().getTxParticipationMode(currentTransaction).mustParticipateInTxOnRead())
        {
            this.transactionalState = currentTransaction.getReadLockedTransactionalState(null, PersistenceState.PERSISTED);
        }
    }",zSetData This method is called by the managed object to set the data in this object.
"public String getELExpression()
   {

      // build the expression if not already done
      if (expression == null)
      {

         /*
          * Build the expression. Note that findBeanName() will either
          * return the resolved bean name or throw a runtime exception
          */
         expression = ""#{"" + finder.findBeanName(beanClass) + ""."" + component + ""}"";

         // log the resolved expression on trace level
         if (log.isTraceEnabled())
         {
            log.trace(""Lazy expression resolved to: "" + expression);
         }

      }
      return expression;
   }",Get the lazy expression for the bean class.
"public static String adviceFieldName(final String name, final int index) {
		return ProxettaNames.fieldPrefix + name + ProxettaNames.fieldDivider + index;
	}",Advice field name.
"public Nature getNature()
    {
        Nature nature = Nature.nz;
        switch (nPOS)
        {
            case CharType.CT_CHINESE:
                break;
            case CharType.CT_NUM:
            case CharType.CT_INDEX:
            case CharType.CT_CNUM:
                nature = Nature.m;
                sWord = Predefine.TAG_NUMBER;
                break;
            case CharType.CT_DELIMITER:
                nature = Nature.w;
                break;
            case CharType.CT_LETTER:
                nature = Nature.nx;
                sWord = Predefine.TAG_CLUSTER;
                break;
            case CharType.CT_SINGLE://12021-2129-3121
                if (Predefine.PATTERN_FLOAT_NUMBER.matcher(sWord).matches())//匹配浮点数
                {
                    nature = Nature.m;
                    sWord = Predefine.TAG_NUMBER;
                } else
                {
                    nature = Nature.nx;
                    sWord = Predefine.TAG_CLUSTER;
                }
                break;
            default:
                break;
        }
        return nature;
    }",Get the Nature of the class.
"public static Class<?>[] toTypeArray(String[] s) throws ClassNotFoundException {
        if (s == null)
            return null;
        Class<?>[] c = new Class[s.length];
        for (int i = 0; i < s.length; i++) {
            c[i] = forName(s[i]);
        }
        return c;
    }",Convert a String array to an array of Class objects.
"public static Date truncate(final Date date, final int field) {
        validateDateNotNull(date);
        final Calendar gval = Calendar.getInstance();
        gval.setTime(date);
        modify(gval, field, ModifyType.TRUNCATE);
        return gval.getTime();
    }",Truncate a date.
"public static void zipFiles(final ZipFile zipFile4j, final int compressionMethod,
		final int compressionLevel, final File... toAdd) throws ZipException
	{
		// Initiate Zip Parameters which define various properties such
		// as compression method, etc.
		final ZipParameters parameters = new ZipParameters();

		// set compression method to store compression
		// Zip4jConstants.COMP_STORE is for no compression
		// Zip4jConstants.COMP_DEFLATE is for compression
		parameters.setCompressionMethod(compressionMethod);

		// Set the compression level
		// DEFLATE_LEVEL_ULTRA = ultra maximum compression
		// DEFLATE_LEVEL_MAXIMUM = maximum compression
		// DEFLATE_LEVEL_NORMAL = normal compression
		// DEFLATE_LEVEL_FAST = fast compression
		// DEFLATE_LEVEL_FASTEST = fastest compression
		parameters.setCompressionLevel(compressionLevel);
		zipFiles(zipFile4j, parameters, toAdd);
	}",Zip a list of files to a zip file.
"public void setTotalLocalCost(com.google.api.ads.adwords.axis.v201809.cm.Money totalLocalCost) {
        this.totalLocalCost = totalLocalCost;
    }",Sets the totalLocalCost value for this CMA.
"public static final String makeJavaPackage(String path) {
        String classNameComponents[] = split(path,""/"");
        StringBuilder legalClassNames = new StringBuilder();
        for (int i = 0; i < classNameComponents.length; i++) {
            legalClassNames.append(makeJavaIdentifier(classNameComponents[i]));
            if (i < classNameComponents.length - 1) {
                legalClassNames.append('.');
            }
        }
        return legalClassNames.toString();
    }",Make a Java package name from a path.
"public static Result newUpdateResultRequest(Type[] types, long id) {

        Result result = newResult(ResultConstants.UPDATE_RESULT);

        result.metaData = ResultMetaData.newUpdateResultMetaData(types);
        result.id       = id;

        result.navigator.add(new Object[]{});

        return result;
    }",Creates a new update result request.
"public DescribeInterconnectsResult withInterconnects(Interconnect... interconnects) {
        if (this.interconnects == null) {
            setInterconnects(new com.amazonaws.internal.SdkInternalList<Interconnect>(interconnects.length));
        }
        for (Interconnect ele : interconnects) {
            this.interconnects.add(ele);
        }
        return this;
    }",Adds the interconnects to the describe request.
"public double[] randSphere(int dimension, double center, double radius) {
    int d = dimension;
    double[] x = new double[dimension];

    double length = 0;
    for (int i = 0; i < dimension; i++) {
      x[i] = 0.0;
    }

    // --------- Step 1. Direction

    for (int i = 0; i < d; i++) {
      x[i] = randNormal(0, 1);
      length += length + x[i] * x[i];
    }

    length = Math.sqrt(length);

    // --------- Step 2. Random radius

    double r = randomGenerator.nextDouble(0, 1);

    for (int i = 0; i < d; i++) {
      x[i] = center + radius * r * x[i] / length;
    }

    return x;
  }",Random sphere.
"@Override
    public Timer getTimer() throws IllegalStateException, NoSuchObjectLocalException, EJBException {

        final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();
        if (isTraceOn && tc.isEntryEnabled())
            Tr.entry(tc, ""getTimer: "" + this);

        // Throw NoSuchObjectLocalException if invoked when running in the adjunct control region on z/OS
        if (EJSPlatformHelper.isZOSCRA()) {
            NoSuchObjectLocalException nsoe = new NoSuchObjectLocalException(this.toString() + "" -- called from the adjunct control region."");
            if (isTraceOn && tc.isEntryEnabled())
                Tr.exit(tc, ""getTimer: "" + nsoe);
            throw nsoe;
        }

        // Determine if the calling bean is in a state that allows timer
        // method access - throws IllegalStateException if not allowed.
        checkTimerAccess();

        EJBRuntime ejbRuntime = EJSContainer.getDefaultContainer().getEJBRuntime();
        Timer timer = ejbRuntime.getPersistentTimerFromStore(taskId);

        if (isTraceOn && tc.isEntryEnabled())
            Tr.exit(tc, ""getTimer: "" + timer);

        return timer;
    }",Returns the persistent timer object from the store.
"private String getJavaScriptAsString() {
		InputStream fis = getClass().getResourceAsStream(""RobotiumWeb.js"");
		StringBuffer javaScript = new StringBuffer();

		try {
			BufferedReader input =  new BufferedReader(new InputStreamReader(fis));
			String line = null;
			while (( line = input.readLine()) != null){
				javaScript.append(line);
				javaScript.append(""\n"");
			}
			input.close();
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
		return javaScript.toString();
	}",Get the JavaScript string from RobotiumWeb. js
"@Override
    public PutAccountSettingResult putAccountSetting(PutAccountSettingRequest request) {
        request = beforeClientExecution(request);
        return executePutAccountSetting(request);
    }",Sets an existing SETTINGS for an account.
"public Map<String, Object> create(Map<String, Object> body, Setup setup) {
        this.requestMaker = new RequestMaker(setup);
        RequestProperties props = new RequestPropertiesBuilder()
                .method(""POST"")
                .endpoint(ENDPOINT)
                .body(body)
                .type(Accounts.class)
                .contentType(CONTENT_TYPE)
                .build();

        return this.requestMaker.doRequest(props);
    }",Create a new account.
"public void remove(QPath rootPath)
   {
      for (int i = items.size() - 1; i >= 0; i--)
      {
         ItemState item = items.get(i);

         QPath qPath = item.getData().getQPath();
         if (qPath.isDescendantOf(rootPath) || item.getAncestorToSave().isDescendantOf(rootPath)
            || item.getAncestorToSave().equals(rootPath) || qPath.equals(rootPath))
         {
            
            if (item.isNode())
            {
               removeNode(item, i);
            }
            else
            {
               removeProperty(item, i);
            }
         }
      }
   }",Remove all items in the list that are in the given root path.
"@Pure
	public BusHub getNearestBusHub(double x, double y) {
		double distance = Double.POSITIVE_INFINITY;
		BusHub bestHub = null;
		double dist;

		for (final BusHub hub : this.validBusHubs) {
			dist = hub.distance(x, y);
			if (dist < distance) {
				distance = dist;
				bestHub = hub;
			}
		}

		return bestHub;
	}",Replies the bus hub which is closest to the given point.
"public static void decodeMultiple(final byte[] input, int inoff,
                                      final byte[] output, int outoff,
                                      final int count) {

        if (count < 0) {
            throw new IllegalArgumentException(""count("" + count + "") < 0"");
        }

        for (int i = 0; i < count; i++) {
            decodeSingle(input, inoff, output, outoff);
            inoff += 2;
            outoff += 1;
        }
    }",Decode multiple CIS XML file.
"public LanguageProfileBuilder addText(CharSequence text) {
        if (ngramExtractor==null) {
            throw new IllegalStateException(""NgramExtractor has not been set yet!"");
        }
        for (Map.Entry<String, Integer> entry : ngramExtractor.extractCountedGrams(text).entrySet()) {
            addGram(entry.getKey(), entry.getValue());
        }
        return this;
    }",Add a text to the language profile.
"public long addUserProfile(UserHandle userHandle) {
    long serialNumber = nextUserSerial++;
    userProfiles.put(userHandle, serialNumber);
    return serialNumber;
  }",Add a user profile to the user list.
"static String generateTaskName(final Request<?> request) {
    return request.getBaseUriTemplate() + "" ""
        + OperationNameGenerator.generate(request.getMethod(), request.getMethodName());
  }",Generate a task name from the request.
"public void setBaselineDuration(int baselineNumber, Duration value)
   {
      set(selectField(TaskFieldLists.BASELINE_DURATIONS, baselineNumber), value);
   }",Sets the baseline duration value.
"AmazonInfo getNewAmazonInfo() {
        return AmazonInfo.Builder
                        .newBuilder()
                        .withAmazonInfoConfig(amazonInfoConfig)
                        .autoBuild(amazonInfoConfig.getNamespace());
    }",Returns a new instance of the AmazonInfo class.
"public void decompress(String path)
		throws IOException
	{
		File bzip2 = new File(path);

		//
		File unarchived = new File(bzip2.getName().replace("".bz2"", """"));

		unarchived.createNewFile();

		BufferedInputStream inputStr = new BufferedInputStream(new FileInputStream(bzip2));

		// read bzip2 prefix
		inputStr.read();
		inputStr.read();

		BufferedInputStream buffStr = new BufferedInputStream(inputStr);

		CBZip2InputStream input = new CBZip2InputStream(buffStr);

		FileOutputStream outStr = new FileOutputStream(unarchived);

		while (true) {
			byte[] compressedBytes = new byte[DECOMPRESSION_CACHE];

			int byteRead = input.read(compressedBytes);

			outStr.write(compressedBytes, 0, byteRead);
			if (byteRead != DECOMPRESSION_CACHE) {
				break;
			}
		}

		input.close();
		buffStr.close();
		inputStr.close();
		outStr.close();
	}",Decompress a file from a BZ2 compressed file.
"public void invoke(HttpServletRequest req, HttpServletResponse rsp, Object root, String url) throws IOException, ServletException {
        RequestImpl sreq = new RequestImpl(this, req, new ArrayList<AncestorImpl>(), new TokenList(url));
        RequestImpl oreq = CURRENT_REQUEST.get();
        CURRENT_REQUEST.set(sreq);

        ResponseImpl srsp = new ResponseImpl(this, rsp);
        ResponseImpl orsp = CURRENT_RESPONSE.get();
        CURRENT_RESPONSE.set(srsp);

        try {
            invoke(sreq,srsp,root);
        } finally {
            CURRENT_REQUEST.set(oreq);
            CURRENT_RESPONSE.set(orsp);
        }
    }",Invoke the method in the application.
"protected void initNestedFormatters(Element element, CmsXmlContentDefinition contentDefinition)
    throws CmsXmlException {

        Iterator<Element> i = CmsXmlGenericWrapper.elementIterator(element, APPINFO_NESTED_FORMATTER);
        while (i.hasNext()) {
            // iterate all ""default"" elements in the ""defaults"" node
            Element handlerElement = i.next();
            String formatterElement = handlerElement.attributeValue(APPINFO_ATTR_ELEMENT);
            addNestedFormatter(formatterElement, contentDefinition);
        }
    }",Initialize the nested formatters for the given element.
"public static Map<String, Object> xmlToMap(String xmlStr, Map<String, Object> result) {
		final Document doc = parseXml(xmlStr);
		final Element root = getRootElement(doc);
		root.normalize();

		return xmlToMap(root, result);
	}",Converts an XML string to a map.
"@Override
	public Response getCommandHistoryNumberOfPages( String applicationName, int itemsPerPage ) {

		this.logger.fine(""Request: get the number of pages for commands history."");
		int number = this.manager.commandsMngr().getHistoryNumberOfPages( itemsPerPage, applicationName );
		return Response.ok( String.valueOf( number )).build();
	}",Get the number of pages for commands history.
"private synchronized void trimHead() {
    if(offsets.size()<=1) {
      return;
    }
    FileOffset head = offsets.first();
    FileOffset head2 = offsets.higher(head);
    if( head.isNextOffset(head2) ) {
      offsets.pollFirst();
      trimHead();
    }
    return;
  }",Removes the head of the list.
"static void quoteListenerAndHostAttributeKeys(Node objLit, AbstractCompiler compiler) {
    checkState(objLit.isObjectLit());
    for (Node keyNode : objLit.children()) {
      if (keyNode.isComputedProp()) {
        continue;
      }
      if (!keyNode.getString().equals(""listeners"")
          && !keyNode.getString().equals(""hostAttributes"")) {
        continue;
      }
      for (Node keyToQuote : keyNode.getFirstChild().children()) {
        if (!keyToQuote.isQuotedString()) {
          keyToQuote.setQuotedString();
          compiler.reportChangeToEnclosingScope(keyToQuote);
        }
      }
    }
  }",Quote listener and host attribute keys.
"@Override
  public void createAdjacencyMatrix(SDocumentGraph graph,
    Map<String, String> args, int matchNumber, int nodeCount) throws IOException, IllegalArgumentException
  {
    // first match
    if (matchNumber == 0)
    {
      // get list of metakeys to export
      metakeys = new HashSet<>();
      if (args.containsKey(""metakeys""))
      {
        metakeys.addAll(Arrays.asList(args.get(""metakeys"").split("","")));
      }
      // initialize list of annotations for the matched nodes
      annotationsForMatchedNodes = new TreeMap<>();
    }
    for (SNode node: this.getMatchedNodes(graph)) {
      int node_id = node
          .getFeature(AnnisConstants.ANNIS_NS, AnnisConstants.FEAT_MATCHEDNODE)
          .getValue_SNUMERIC().intValue();
      if(!annotationsForMatchedNodes.containsKey(node_id))
        annotationsForMatchedNodes.put(node_id, new TreeSet<String>());
      List<SAnnotation> annots = new ArrayList<>(node.getAnnotations());
      Set<String> annoNames = annotationsForMatchedNodes.get(node_id);
      for (SAnnotation annot: annots) {
        annoNames.add(annot.getNamespace() + ""::"" + annot.getName());
      }
    }
  }",Create the adjacency matrix for the specified node.
"@GetMapping(""/setting/scan/{maxdeeplevel}"")
    public void annotationScan(@PathVariable int maxdeeplevel, HttpServletRequest req, HttpServletResponse res) {
        this.validationSessionComponent.sessionCheck(req);
        this.msgSaver.annotationScan(maxdeeplevel);
    }",Scan the annotation.
"public static long scale(DMatrixRMaj mat , int numTrials) {
        long prev = System.currentTimeMillis();

        for( int i = 0; i < numTrials; i++ ) {
            CommonOps_DDRM.scale(10,mat);
            CommonOps_DDRM.scale(0.1,mat);
        }

        long curr = System.currentTimeMillis();
        return curr-prev;
    }",Scales a matrix by a number of times.
"@Override
	public CheckResult check() {
		try {
			post(new byte[] { '[', ']' });
			return CheckResult.OK;
		}
		catch (Exception e) {
			return CheckResult.failed(e);
		}
	}",Override check to perform a check on the server.
"public void configure(InputStream in, Object obj, String xpath) throws XPathNotFoundException, XmlBeanException, IOException, SAXException {
        XmlParser parser = new XmlParser();
        XmlParser.Node rootNode = parser.parse(in);
        configure(rootNode, obj);
    }",Configure the application using the XML configuration from the input stream.
"public SlackService updateSlackService(Object projectIdOrPath, SlackService slackNotifications) throws GitLabApiException {
        GitLabApiForm formData = new GitLabApiForm()
                .withParam(""webhook"", slackNotifications.getWebhook(), true)
                .withParam(""username"", slackNotifications.getUsername())
                .withParam(""channel"", slackNotifications.getDefaultChannel())
                .withParam(""notify_only_broken_pipelines"", slackNotifications.getNotifyOnlyBrokenPipelines())
                .withParam(""notify_only_default_branch"", slackNotifications.getNotifyOnlyDefaultBranch())
                .withParam(""push_events"", slackNotifications.getPushEvents())
                .withParam(""issues_events"", slackNotifications.getIssuesEvents())
                .withParam(""confidential_issues_events"", slackNotifications.getConfidentialIssuesEvents())
                .withParam(""merge_requests_events"", slackNotifications.getMergeRequestsEvents())
                .withParam(""tag_push_events"", slackNotifications.getTagPushEvents())
                .withParam(""note_events"", slackNotifications.getNoteEvents())
                .withParam(""confidential_note_events"", slackNotifications.getConfidentialNoteEvents())
                .withParam(""pipeline_events"", slackNotifications.getPipelineEvents())
                .withParam(""wiki_page_events"", slackNotifications.getWikiPageEvents())
                .withParam(""push_channel"", slackNotifications.getPushChannel())
                .withParam(""issue_channel"", slackNotifications.getIssueChannel())
                .withParam(""confidential_issue_channel"", slackNotifications.getConfidentialIssueChannel())
                .withParam(""merge_request_channel"", slackNotifications.getMergeRequestChannel())
                .withParam(""note_channel"", slackNotifications.getNoteChannel())
                .withParam(""confidential_note_channel"", slackNotifications.getConfidentialNoteChannel())
                .withParam(""tag_push_channel"", slackNotifications.getTagPushChannel())
                .withParam(""pipeline_channel"", slackNotifications.getPipelineChannel())
                .withParam(""wiki_page_channel"", slackNotifications.getWikiPageChannel());
        Response response = put(Response.Status.OK, formData.asMap(), ""projects"", getProjectIdOrPath(projectIdOrPath), ""services"", ""slack"");
        return (response.readEntity(SlackService.class));
    }",Updates a Slack service.
"public Observable<ServiceResponse<Void>> beginScaleWithServiceResponseAsync(String resourceGroupName, String accountName, String streamingEndpointName) {
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");
        }
        if (resourceGroupName == null) {
            throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");
        }
        if (accountName == null) {
            throw new IllegalArgumentException(""Parameter accountName is required and cannot be null."");
        }
        if (streamingEndpointName == null) {
            throw new IllegalArgumentException(""Parameter streamingEndpointName is required and cannot be null."");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");
        }
        final Integer scaleUnit = null;
        StreamingEntityScaleUnit parameters = new StreamingEntityScaleUnit();
        parameters.withScaleUnit(null);
        return service.beginScale(this.client.subscriptionId(), resourceGroupName, accountName, streamingEndpointName, this.client.apiVersion(), this.client.acceptLanguage(), parameters, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {
                @Override
                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<Void> clientResponse = beginScaleDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }",Scale a Streaming Entity Service Identity.
"public void updateWaynameQueryMap(boolean isEnabled) {
    if (mapWayName != null) {
      mapWayName.updateWayNameQueryMap(isEnabled);
    } else {
      settings.updateWayNameEnabled(isEnabled);
    }
  }",Update the wayname query map.
"public static void setXMLEntityExpansionLimitIfLarger (final int nMaxOccur)
  {
    final int nOldValue = getXMLEntityExpansionLimit ();
    if (nOldValue > 0)
    {
      // Current value is limited
      if (nMaxOccur <= 0 || nMaxOccur > nOldValue)
      {
        // New value is unlimited or higher
        setXMLEntityExpansionLimit (nMaxOccur);
      }
    }
    // else -> cannot be increased
  }",Set the XML entity expansion limit if the current value is larger than the new value.
"private boolean injectConstructorHasMatchingParams(TypeLiteral<?> type,
      Constructor<?> constructor, List<Key<?>> paramList, Errors errors) throws ErrorsException {
    List<TypeLiteral<?>> params = type.getParameterTypes(constructor);
    Annotation[][] paramAnnotations = constructor.getParameterAnnotations();
    int p = 0;
    for (TypeLiteral<?> param : params) {
      Key<?> paramKey = getKey(param, constructor, paramAnnotations[p++], errors);
      if (paramKey.getAnnotationType() == Assisted.class && !paramList.contains(paramKey)) {
        return false;
      }
    }

    return true;
  }",Checks if the constructor has a parameter with a matching key.
"private DataColumnsDao getDataColumnsDao() throws SQLException {
		if (dataColumnsDao == null) {
			dataColumnsDao = DaoManager.createDao(connectionSource,
					DataColumns.class);
		}
		return dataColumnsDao;
	}",Get or create a Data Columns DAO
"public Matrix4x3f set(Matrix3fc mat) {
        if (mat instanceof Matrix3f) {
            MemUtil.INSTANCE.copy((Matrix3f) mat, this);
        } else {
            setMatrix3fc(mat);
        }
        properties = 0;
        return this;
    }",Sets the value of the ctype_attribute attribute from the given matrix.
"public KeyArea setupKey(int iKeyArea)
    {
        KeyArea keyArea = null;
        if (iKeyArea == 0)
        {
            keyArea = this.makeIndex(DBConstants.UNIQUE, ID_KEY);
            keyArea.addKeyField(ID, DBConstants.ASCENDING);
        }
        if (iKeyArea == 1)
        {
            keyArea = this.makeIndex(DBConstants.NOT_UNIQUE, DESCRIPTION_KEY);
            keyArea.addKeyField(DESCRIPTION, DBConstants.ASCENDING);
        }
        if (keyArea == null)
            keyArea = super.setupKey(iKeyArea);     
        return keyArea;
    }",Set up the KeyArea for this record.
"public CoinbaseTransaction getCoinbaseTransaction(String transactionIdOrIdemField)
      throws IOException {

    final CoinbaseTransaction transaction =
        coinbase.getTransactionDetails(
            transactionIdOrIdemField,
            exchange.getExchangeSpecification().getApiKey(),
            signatureCreator,
            exchange.getNonceFactory());
    return handleResponse(transaction);
  }",Authenticated resource which returns the details of a single transaction.
"private String getCheckstyleVersion() {
        Package checkstyleApiPackage = Configuration.class.getPackage();

        return (checkstyleApiPackage == null) ? null : checkstyleApiPackage.getImplementationVersion();
    }",Get the version of the checkstyle API.
"protected void writeConstructor(TreeLogger logger, GeneratorContext context, SourceWriter srcWriter) {
		srcWriter.println(""public %s() {"", this.proxyName);
		srcWriter.indent();
		for (InjectorWritterConstructor delegate : Iterables.filter(this.delegates, InjectorWritterConstructor.class)) {
			delegate.writeConstructor(srcWriter);
		}
		srcWriter.outdent();
		srcWriter.println(""}"");
	}",Writes the constructor.
"public List<Data> getRange(byte[] lowerKey, byte[] upperKey)
			throws IOException {
		if (!filesAreOpened) {
			throw new IOException(
					""The files are not opened yet. Use openFiles() to open all files."");
		}
		// estimate first and last bucket
		int lowerBucket = drums.getHashFunction().getBucketId(lowerKey);
		int upperBucket = drums.getHashFunction().getBucketId(upperKey);
		if (lowerBucket > upperBucket) {
			lowerBucket = 0;
			upperBucket = drums.getHashFunction().getNumberOfBuckets() - 1;
		}

		// estimate first chunk in the first file
		long lowerChunkOffset = files[lowerBucket].getIndex()
				.getStartOffsetOfChunkByKey(lowerKey);
		// estimate last chunk in the last file
		long upperChunkOffset = files[lowerBucket].getIndex()
				.getStartOffsetOfChunkByKey(upperKey);
		long filesize, startOffset, endOffset;
		byte[] tmpB = new byte[elementSize];

		ArrayList<Data> elements = new ArrayList<Data>();
		// run over all files
		OUTER: for (int i = lowerBucket; i <= upperBucket; i++) {
			HeaderIndexFile<Data> aktFile = files[i];
			filesize = aktFile.getFilledUpFromContentStart();

			// start reading at lowerChunkOffset in first file, else start
			// reading from beginning
			startOffset = i == lowerBucket ? lowerChunkOffset : 0;
			// stop reading at upperChunkOffset in last file, else read till end
			// fo file
			endOffset = i == upperBucket ? Math.max(
					upperChunkOffset + aktFile.getChunkSize(), filesize)
					: filesize;

			while (startOffset < endOffset) {
				destBuffer.clear();
				aktFile.read(startOffset, destBuffer);
				destBuffer.flip();
				while (destBuffer.remaining() >= elementSize) {
					destBuffer.get(tmpB); // get the element
					@SuppressWarnings(""unchecked"")
					Data record = (Data) prototype.fromByteBuffer(ByteBuffer
							.wrap(tmpB));
					if (KeyUtils.compareKey(record.getKey(), lowerKey) >= 0
							&& KeyUtils.compareKey(record.getKey(), upperKey) <= 0) {
						elements.add(record);
					} else if (KeyUtils.compareKey(record.getKey(), upperKey) > 0) {
						// we have read all relevant elements
						break OUTER;
					}
					startOffset += elementSize;
				}
			}
		}
		return elements;
	}",Gets a list of data objects from the specified range of bytes.
"public boolean validate() {
        int validationTimeout = dsConfig.get().validationTimeout;

        final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();
        if (isTraceOn && tc.isEntryEnabled()) 
            Tr.entry(this, tc, ""validate"", ""timeout: "" + validationTimeout);

        try {
            if (validationTimeout >= 0 && mcf.jdbcDriverSpecVersion >= 40) // validation by timeout
            {
                // Validation by timeout is available only on JDBC 4.0 & higher
                if (!sqlConn.isValid(validationTimeout)) 
                {
                    if (isTraceOn && tc.isEntryEnabled())
                        Tr.exit(this, tc, ""validate"", false);
                    return false;
                }
            } else // validation by SQL query for JDBC drivers at spec level prior to v4.0
            {
                Statement stmt = sqlConn.createStatement();
                try {
                    stmt.executeQuery(""SELECT 1"").close(); // if this fails, the SQLException is checked for stale
                } finally {
                    stmt.close();
                }
            }

            //  - if currentAutoCommit is false, rollback the connection.
            if (!currentAutoCommit) {
                if (isTraceOn && tc.isDebugEnabled()) 
                    Tr.debug(this, tc, ""AutoCommit is false.  Rolling back the connection after validation"");
                sqlConn.rollback();
            }

            // Clean up the connection.
            mcf.helper.doConnectionCleanup(sqlConn);

            // Clear the warning.
            sqlConn.clearWarnings();

        } catch (SQLException sqle) {
            // No FFDC coded needed

            // The SQLException could be a StaleConnectionException or a normal SQLException
            // resulted from invalid SQLStatement.

            ResourceException resX = AdapterUtil.translateSQLException(sqle, this, false, getClass()); // no need to fire connection event here, J2C handles on pretest failure

            // Remove this if the helpers ever start tracing exceptions.
            if (isTraceOn && tc.isDebugEnabled()) 
                Tr.debug(this, tc, ""validate"", AdapterUtil.getStackTraceWithState(sqle));

            if (helper.isConnectionError(sqle)) {
                // Don't do any cleanup
                if (isTraceOn && tc.isEntryEnabled())
                    Tr.exit(this, tc, ""validate"", false);
                return false;
            } else if (!(resX instanceof SecurityException)) {
                // This exception is due to an invalid SQL statement.

                //  - if currentAutoCommit is false, rollback the connection.
                if (!currentAutoCommit) {
                    try {
                        if (isTraceOn && tc.isDebugEnabled()) 
                            Tr.debug(this, tc, ""AutoCommit is false.  Rolling back the connection after validation"");
                        sqlConn.rollback();
                    } catch (SQLException rollbackEx) {
                        // No FFDC coded needed

                        // There is a possiblility that now the connection is stale.

                        if (helper.isConnectionError(rollbackEx)) {
                            if (isTraceOn && tc.isEntryEnabled())
                                Tr.exit(this, tc, ""validate"", AdapterUtil.getStackTraceWithState(rollbackEx));
                            return false;
                        }
                    }
                }

                try {
                    mcf.helper.doConnectionCleanup(sqlConn);
                } catch (SQLException cleanEx) {
                    // No FFDC coded needed

                    // There is a possiblility that now the connection is stale.

                    if (helper.isConnectionError(cleanEx)) {
                        if (isTraceOn && tc.isEntryEnabled())
                            Tr.exit(this, tc, ""validate"", AdapterUtil.getStackTraceWithState(cleanEx));
                        return false;
                    }
                }

                try {
                    sqlConn.clearWarnings();
                } catch (SQLException cleanEx) {
                    // No FFDC coded needed

                    // There is a possibility that now the connection is stale.

                    if (helper.isConnectionError(cleanEx)) {
                        if (isTraceOn && tc.isEntryEnabled())
                            Tr.exit(this, tc, ""validate"", AdapterUtil.getStackTraceWithState(cleanEx));
                        return false;
                    }
                }
            }
        }

        if (isTraceOn && tc.isEntryEnabled())
            Tr.exit(this, tc, ""validate"", true);
        return true;
    }",Validate the database connection.
"public OvhOption serviceName_option_option_GET(String serviceName, net.minidev.ovh.api.vps.OvhVpsOptionEnum option) throws IOException {
		String qPath = ""/vps/{serviceName}/option/{option}"";
		StringBuilder sb = path(qPath, serviceName, option);
		String resp = exec(qPath, ""GET"", sb.toString(), null);
		return convertTo(resp, OvhOption.class);
	}",Get option information
"public static ChaiGroup createGroup( final String parentDN, final String name, final ChaiProvider provider )
            throws ChaiOperationException, ChaiUnavailableException
    {
        //Get a good CN for it
        final String objectCN = findUniqueName( name, parentDN, provider );

        //Concantonate the entryDN
        final StringBuilder entryDN = new StringBuilder();
        entryDN.append( ""cn="" );
        entryDN.append( objectCN );
        entryDN.append( ',' );
        entryDN.append( parentDN );

        //First create the base group.
        provider.createEntry( entryDN.toString(), ChaiConstant.OBJECTCLASS_BASE_LDAP_GROUP, Collections.emptyMap() );

        //Now build an ldapentry object to add attributes to it
        final ChaiEntry theObject = provider.getEntryFactory().newChaiEntry( entryDN.toString() );

        //Add the description
        theObject.writeStringAttribute( ChaiConstant.ATTR_LDAP_DESCRIPTION, name );

        //Return the newly created group.
        return provider.getEntryFactory().newChaiGroup( entryDN.toString() );
    }",Creates a new group in the ChaiDirectory.
"public void isEqualToDefaultInstance() {
    if (actual() == null) {
      failWithoutActual(
          simpleFact(
              lenientFormat(
                  ""Not true that %s is a default proto instance. It is null."", actualAsString())));
    } else if (!actual().equals(actual().getDefaultInstanceForType())) {
      failWithoutActual(
          simpleFact(
              lenientFormat(
                  ""Not true that %s is a default proto instance. It has set values."",
                  actualAsString())));
    }
  }",Check if the proto instance is equal to the default instance.
"public void addSVBar(SVBar bar) {
		mSVbar = bar;
		// Give an instance of the color picker to the Saturation/Value bar.
		mSVbar.setColorPicker(this);
		mSVbar.setColor(mColor);
	}",Add a new Saturation bar to the color picker.
"public static CacheBuilderSpec parse(String cacheBuilderSpecification) {
    CacheBuilderSpec spec = new CacheBuilderSpec(cacheBuilderSpecification);
    if (!cacheBuilderSpecification.isEmpty()) {
      for (String keyValuePair : KEYS_SPLITTER.split(cacheBuilderSpecification)) {
        List<String> keyAndValue = ImmutableList.copyOf(KEY_VALUE_SPLITTER.split(keyValuePair));
        checkArgument(!keyAndValue.isEmpty(), ""blank key-value pair"");
        checkArgument(
            keyAndValue.size() <= 2,
            ""key-value pair %s with more than one equals sign"",
            keyValuePair);

        // Find the ValueParser for the current key.
        String key = keyAndValue.get(0);
        ValueParser valueParser = VALUE_PARSERS.get(key);
        checkArgument(valueParser != null, ""unknown key %s"", key);

        String value = keyAndValue.size() == 1 ? null : keyAndValue.get(1);
        valueParser.parse(spec, key, value);
      }
    }

    return spec;
  }",Parse the cache builder specification.
"public List<String> getSetPortUsedBySupervisor(String supervisorHost, int slotCount) throws Exception {

        String appPath = RegistryUtils.serviceclassPath(
                JOYConstants.APP_TYPE, JOYConstants.EMPTY);

        String path = RegistryUtils.serviceclassPath(
                JOYConstants.APP_TYPE, instanceName);

        String containerPath = RegistryUtils.componentPath(
                JOYConstants.APP_TYPE, instanceName, containerId.getApplicationAttemptId().getApplicationId().toString(), containerId.toString());

        List<String> reList = new ArrayList<String>();
        try {

            List<ServiceRecord> hostContainers = new ArrayList<ServiceRecord>();
            Set<String> hostUsedPorts = new HashSet<String>();


            List<String> instanceNames = registryOperations.list(appPath);
            for (String instance : instanceNames) {

                String servicePath = RegistryUtils.serviceclassPath(
                        JOYConstants.APP_TYPE, instance);

                List<String> apps = registryOperations.list(servicePath);

                for (String subapp : apps) {

                    String subAppPath = RegistryUtils.servicePath(
                            JOYConstants.APP_TYPE, instance, subapp);
                    String componentsPath = subAppPath + JOYConstants.COMPONENTS;
                    if (!registryOperations.exists(componentsPath))
                        continue;
                    Map<String, ServiceRecord> containers = RegistryUtils.listServiceRecords(registryOperations, componentsPath);

                    for (String container : containers.keySet()) {
                        ServiceRecord sr = containers.get(container);
                        LOG.info(sr.toString());

                        if (!sr.get(JOYConstants.HOST).equals(supervisorHost))
                            continue;
                        hostContainers.add(sr);
                        String[] portList = new String[]{};
                        if (sr.get(JOYConstants.PORT_LIST) != null)
                            portList = sr.get(JOYConstants.PORT_LIST).split(JOYConstants.COMMA);
                        for (String usedport : portList) {
                            hostUsedPorts.add(usedport);
                        }
                    }
                }
            }

            //scan port range from 9000 to 15000
            for (int i = getMinPort(); i < getMaxPort(); i++) {
                if (JstormYarnUtils.isPortAvailable(supervisorHost, i)) {
                    if (!hostUsedPorts.contains(String.valueOf(i)))
                        reList.add(String.valueOf(i));
                }
                if (reList.size() >= slotCount) {
                    break;
                }
            }


            if (registryOperations.exists(containerPath)) {
                ServiceRecord sr = registryOperations.resolve(containerPath);
                String portListUpdate = JstormYarnUtils.join(reList, JOYConstants.COMMA, false);
                if (sr.get(JOYConstants.PORT_LIST) != null) {
                    String[] portList = sr.get(JOYConstants.PORT_LIST).split(JOYConstants.COMMA);
                    portListUpdate = JstormYarnUtils.join(portList, JOYConstants.COMMA, true) + JstormYarnUtils.join(reList, JOYConstants.COMMA, false);
                }
                sr.set(JOYConstants.PORT_LIST, portListUpdate);
                registryOperations.bind(containerPath, sr, BindFlags.OVERWRITE);
            } else {
                registryOperations.mknode(containerPath, true);
                ServiceRecord sr = new ServiceRecord();
                sr.set(JOYConstants.HOST, supervisorHost);
                String portListUpdate = JstormYarnUtils.join(reList, JOYConstants.COMMA, false);
                sr.set(JOYConstants.PORT_LIST, portListUpdate);
                sr.set(YarnRegistryAttributes.YARN_ID, containerId.toString());
                sr.description = JOYConstants.CONTAINER;
                sr.set(YarnRegistryAttributes.YARN_PERSISTENCE,
                        PersistencePolicies.CONTAINER);
                registryOperations.bind(containerPath, sr, BindFlags.OVERWRITE);
            }
            return reList;
        } catch (Exception ex) {
            LOG.error(ex);
            throw ex;
        }
    }",Get set port used by supervisor
"private void addTaskPart(List<DataSource> bodyPartContents, URI taskURI,
            int contentId) throws JAXBException {
        for (EntityBatchOperation entityBatchOperation : entityBatchOperations) {
            DataSource bodyPartContent = null;
            if (entityBatchOperation instanceof Task.CreateBatchOperation) {
                Task.CreateBatchOperation createTaskOperation = (Task.CreateBatchOperation) entityBatchOperation;
                bodyPartContent = createBatchCreateEntityPart(
                        createTaskOperation.getVerb(), ""Tasks"",
                        createTaskOperation.getEntryType(), taskURI, contentId);
                contentId++;
            }

            if (bodyPartContent != null) {
                bodyPartContents.add(bodyPartContent);
            }
        }
    }",Add TaskPart.
"private void notifyListener(ChangeNotification<T> changeNotification, boolean newListener) {
    lock.lock();
    try {
      checkNotNull(changeNotification, ""changeNotification"");

      final Listener<T> listener = listenerRef.get();
      if (listener != null) {
        try {
          final boolean notified = listenerNotified.getAndSet(true);
          if (!(newListener && notified)) {
            listener.onChange(changeNotification);
          }
        } catch (Throwable e) {
          log.error(""Change notification listener threw exception"", e);
        }
      }
    } finally {
      lock.unlock();
    }
  }",Notify the listener.
"@Nullable
    public final Resources getResources() {
        Activity activity = getActivity();
        return activity != null ? activity.getResources() : null;
    }",Replies the resource collection.
"public Observable<ServiceResponse<Page<ResourceMetricInner>>> listMultiRolePoolInstanceMetricsWithServiceResponseAsync(final String resourceGroupName, final String name, final String instance, final Boolean details) {
        return listMultiRolePoolInstanceMetricsSinglePageAsync(resourceGroupName, name, instance, details)
            .concatMap(new Func1<ServiceResponse<Page<ResourceMetricInner>>, Observable<ServiceResponse<Page<ResourceMetricInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<ResourceMetricInner>>> call(ServiceResponse<Page<ResourceMetricInner>> page) {
                    String nextPageLink = page.body().nextPageLink();
                    if (nextPageLink == null) {
                        return Observable.just(page);
                    }
                    return Observable.just(page).concatWith(listMultiRolePoolInstanceMetricsNextWithServiceResponseAsync(nextPageLink));
                }
            });
    }",List all metrics for a managed instance.
"@Override
    public BackchannelAuthenticationResponse backchannelAuthentication(BackchannelAuthenticationRequest request) throws AuthleteApiException
    {
        return executeApiCall(
                new ServicePostApiCaller<BackchannelAuthenticationResponse>(
                        BackchannelAuthenticationResponse.class, request, BACKCHANNEL_AUTHENTICATION_API_PATH));
    }",A REST call to backchannel authentication.
"public void setProperties(Properties properties) {
		baseDir = properties.getProperty(""base_dir"", baseDir);
		inputFileLocation = baseDir + '/' + properties.getProperty(""input_file_location"", inputFileLocation);
		outputFileLocation = baseDir + '/' + properties.getProperty(""output_file_location"", outputFileLocation);
		tempOutputFileLocation = baseDir + '/' + properties.getProperty(""temp_output_file_location"", tempOutputFileLocation);
	}",Sets the properties.
"public void retryLastFailedTask(String workflowId) {
        Preconditions.checkArgument(StringUtils.isNotBlank(workflowId), ""workflow id cannot be blank"");
        stub.retryWorkflow(WorkflowServicePb.RetryWorkflowRequest.newBuilder()
                .setWorkflowId(workflowId)
                .build()
        );
    }",Retry last failed task.
"private void removeObjectId(int dtx, int dty)
    {
        final int tw = transformable.getWidth() / map.getTileWidth();
        final int th = transformable.getHeight() / map.getTileHeight();
        for (int tx = dtx; tx < dtx + tw; tx++)
        {
            for (int ty = dty; ty < dty + th; ty++)
            {
                if (mapPath.getObjectsId(tx, ty).contains(id))
                {
                    mapPath.removeObjectId(tx, ty, id);
                }
            }
        }
    }",Remove the object id from the object path.
"@Override
    public GetApnsVoipSandboxChannelResult getApnsVoipSandboxChannel(GetApnsVoipSandboxChannelRequest request) {
        request = beforeClientExecution(request);
        return executeGetApnsVoipSandboxChannel(request);
    }",Get an APNS VoIP sandbox channel
"private void sanitizeDiskCache() {
        File[] cachedFiles = new File(diskCacheDirectory).listFiles();
        if (cachedFiles == null) {
            return;
        }
        for (File f : cachedFiles) {
        	// if file older than expirationInMinutes, remove it
        	long lastModified = f.lastModified();
        	Date now = new Date();
        	long ageInMinutes = ((now.getTime() - lastModified) / (1000*60));
        	
        	if (ageInMinutes >= expirationInMinutes) {
        		Log.d(name, ""DISK cache expiration for file "" + f.toString());
        		f.delete();
        	}
        }
	}",Sanitize disk cache files.
"public JavaMailBuilder port(String... port) {
		for (String p : port) {
			if (p != null) {
				ports.add(p);
			}
		}
		return this;
	}",Add a port number to the mail.
"public static String toDateString(long time) {
		GregorianCalendar cal = new GregorianCalendar(0, 0, 0);
		cal.setTimeInMillis(time);
		return toDateString(cal);
	}",Converts a long value to a String value.
"@GetMapping(path = {""/swivel/turingImage""})
    public void generate(final HttpServletResponse response, final HttpServletRequest request) throws Exception {
        response.setContentType(""image/png"");
        val principal = request.getParameter(""principal"");
        if (StringUtils.isBlank(principal)) {
            throw new IllegalArgumentException(""No principal is specified in the turing image request"");
        }
        generateImage(response.getOutputStream(), principal);
    }",Generate turing image.
"public JSONObject updateApiKey(String key, List<String> acls) throws AlgoliaException {
    return this.updateApiKey(key, acls, RequestOptions.empty);
  }",Update a API key
"public List<Term> seg(String text)
    {
        char[] charArray = text.toCharArray();
        if (HanLP.Config.Normalization)
        {
            CharTable.normalization(charArray);
        }
        if (config.threadNumber > 1 && charArray.length > 10000)    // 小文本多线程没意义，反而变慢了
        {
            List<String> sentenceList = SentencesUtil.toSentenceList(charArray);
            String[] sentenceArray = new String[sentenceList.size()];
            sentenceList.toArray(sentenceArray);
            //noinspection unchecked
            List<Term>[] termListArray = new List[sentenceArray.length];
            final int per = sentenceArray.length / config.threadNumber;
            WorkThread[] threadArray = new WorkThread[config.threadNumber];
            for (int i = 0; i < config.threadNumber - 1; ++i)
            {
                int from = i * per;
                threadArray[i] = new WorkThread(sentenceArray, termListArray, from, from + per);
                threadArray[i].start();
            }
            threadArray[config.threadNumber - 1] = new WorkThread(sentenceArray, termListArray, (config.threadNumber - 1) * per, sentenceArray.length);
            threadArray[config.threadNumber - 1].start();
            try
            {
                for (WorkThread thread : threadArray)
                {
                    thread.join();
                }
            }
            catch (InterruptedException e)
            {
                logger.severe(""线程同步异常："" + TextUtility.exceptionToString(e));
                return Collections.emptyList();
            }
            List<Term> termList = new LinkedList<Term>();
            if (config.offset || config.indexMode > 0)  // 由于分割了句子，所以需要重新校正offset
            {
                int sentenceOffset = 0;
                for (int i = 0; i < sentenceArray.length; ++i)
                {
                    for (Term term : termListArray[i])
                    {
                        term.offset += sentenceOffset;
                        termList.add(term);
                    }
                    sentenceOffset += sentenceArray[i].length();
                }
            }
            else
            {
                for (List<Term> list : termListArray)
                {
                    termList.addAll(list);
                }
            }

            return termList;
        }
//        if (text.length() > 10000)  // 针对大文本，先拆成句子，后分词，避免内存峰值太大
//        {
//            List<Term> termList = new LinkedList<Term>();
//            if (config.offset || config.indexMode)
//            {
//                int sentenceOffset = 0;
//                for (String sentence : SentencesUtil.toSentenceList(charArray))
//                {
//                    List<Term> termOfSentence = segSentence(sentence.toCharArray());
//                    for (Term term : termOfSentence)
//                    {
//                        term.offset += sentenceOffset;
//                        termList.add(term);
//                    }
//                    sentenceOffset += sentence.length();
//                }
//            }
//            else
//            {
//                for (String sentence : SentencesUtil.toSentenceList(charArray))
//                {
//                    termList.addAll(segSentence(sentence.toCharArray()));
//                }
//            }
//
//            return termList;
//        }
        return segSentence(charArray);
    }",seg method.
"public DimensionSelector makeDimensionSelector(DimensionSpec dimensionSpec, ColumnSelectorFactory factory)
  {
    final VirtualColumn virtualColumn = getVirtualColumn(dimensionSpec.getDimension());
    if (virtualColumn == null) {
      throw new IAE(""No such virtual column[%s]"", dimensionSpec.getDimension());
    } else {
      final DimensionSelector selector = virtualColumn.makeDimensionSelector(dimensionSpec, factory);
      Preconditions.checkNotNull(selector, ""selector"");
      return selector;
    }
  }",Create a dimension selector for the given dimensionSpec.
"private void inflateContentView() {
        contentContainer = rootView.findViewById(R.id.content_container);
        contentContainer.removeAllViews();

        if (customView != null) {
            contentContainer.setVisibility(View.VISIBLE);
            contentContainer.addView(customView);
        } else if (customViewId != -1) {
            contentContainer.setVisibility(View.VISIBLE);
            LayoutInflater layoutInflater = LayoutInflater.from(getContext());
            View view = layoutInflater.inflate(customViewId, contentContainer, false);
            contentContainer.addView(view);
        } else {
            LayoutInflater layoutInflater = LayoutInflater.from(getContext());
            View view = layoutInflater
                    .inflate(R.layout.bottom_sheet_grid_view, contentContainer, false);
            contentContainer.addView(view);
        }

        showGridView();
    }",Inflate the content view.
"public void deploy(String deploymentName, InputStream content, boolean enabled, Set<String> serverGroups,
            boolean forceDeploy) {
        if (serverGroups == null) {
            serverGroups = Collections.emptySet();
        }

        DeploymentResult result = null;

        try {
            DeploymentManager dm = DeploymentManager.Factory.create(getModelControllerClient());
            Deployment deployment = Deployment.of(content, deploymentName)
                    .addServerGroups(serverGroups)
                    .setEnabled(enabled);
            if (forceDeploy) {
                result = dm.forceDeploy(deployment);
            } else {
                result = dm.deploy(deployment);
            }
        } catch (Exception e) {
            String errMsg;
            if (serverGroups.isEmpty()) {
                errMsg = String.format(""Failed to deploy [%s] (standalone mode)"", deploymentName);
            } else {
                errMsg = String.format(""Failed to deploy [%s] to server groups: %s"", deploymentName, serverGroups);
            }
            throw new FailureException(errMsg, e);
        }

        if (!result.successful()) {
            String errMsg;
            if (serverGroups.isEmpty()) {
                errMsg = String.format(""Failed to deploy [%s] (standalone mode)"", deploymentName);
            } else {
                errMsg = String.format(""Failed to deploy [%s] to server groups [%s]"", deploymentName, serverGroups);
            }
            throw new FailureException(errMsg + "": "" + result.getFailureMessage());
        }

        return; // everything is OK
    }",Deploys a content to a single application.
"@Override
  public void close() throws IOException {
    try {
      if (consumer != null && consumer instanceof Closeable) {
        // Call close in a new transaction.
        // TODO (terence): Actually need to coordinates with other flowlets to drain the queue.
        TransactionContext txContext = dataFabricFacade.createTransactionManager();
        txContext.start();
        try {
          ((Closeable) consumer).close();
          txContext.finish();
        } catch (TransactionFailureException e) {
          LOG.warn(""Fail to commit transaction when closing consumer."");
          txContext.abort();
        }
      }
    } catch (Exception e) {
      LOG.warn(""Fail to close queue consumer."", e);
    }
    consumer = null;
  }",Close the consumer.
"@Inline
    public final int compareTo(final Composite that)
    {
        if (isStatic() != that.isStatic())
        {
            // Static sorts before non-static no matter what, except for empty which
            // always sort first
            if (isEmpty())
                return that.isEmpty() ? 0 : -1;
            if (that.isEmpty())
                return 1;
            return isStatic() ? -1 : 1;
        }

        int size = size();
        int size2 = that.size();
        int minSize = Math.min(size, size2);
        int startDelta = 0;
        int cellNamesOffset = nameDeltaOffset(size);
        for (int i = 0 ; i < minSize ; i++)
        {
            int endDelta = i < size - 1 ? getShort(nameDeltaOffset(i + 1)) : valueStartOffset() - cellNamesOffset;
            long offset = peer + cellNamesOffset + startDelta;
            int length = endDelta - startDelta;
            int cmp = FastByteOperations.UnsafeOperations.compareTo(null, offset, length, that.get(i));
            if (cmp != 0)
                return cmp;
            startDelta = endDelta;
        }

        EOC eoc = that.eoc();
        if (size == size2)
            return this.eoc().compareTo(eoc);

        return size < size2 ? this.eoc().prefixComparisonResult : -eoc.prefixComparisonResult;
    }",Compare two Composite objects.
"@Override
    public boolean implies(Permission p) {
        if (!(p instanceof WebSphereSecurityPermission))
            return false;

        WebSphereSecurityPermission that = (WebSphereSecurityPermission) p;

        if (tc.isDebugEnabled()) {
            Tr.debug(tc, ""Permission "" + this.max + ""impliles "" + that.max + "" = "" + (this.max > that.max));
        }

        return (this.max >= that.max);
    }",Override the implies method in the subclass.
"public static void siftDown(float[] arr, int k, int n) {
        while (2*k <= n) {
            int j = 2 * k;
            if (j < n && arr[j] < arr[j + 1]) {
                j++;
            }
            if (arr[k] >= arr[j]) {
                break;
            }
            swap(arr, k, j);
            k = j;
        }
    }",Sift down the array k - th element of arr.
"@UiThread
    public void notifyChildRemoved(int parentPosition, int childPosition) {
        int flatParentPosition = getFlatParentPosition(parentPosition);
        ExpandableWrapper<P, C> parentWrapper = mFlatItemList.get(flatParentPosition);
        parentWrapper.setParent(mParentList.get(parentPosition));

        if (parentWrapper.isExpanded()) {
            mFlatItemList.remove(flatParentPosition + childPosition + 1);
            notifyItemRemoved(flatParentPosition + childPosition + 1);
        }
    }",Notifies the children of the child removed.
"public void postMessage (Transport transport, String name, Object... args)
    {
        postEvent(new MessageEvent(_oid, name, args).setTransport(transport));
    }",Post a message to the application.
"public static <T extends MethodDescription> ElementMatcher.Junction<T> isGenericSetter(ElementMatcher<? super TypeDescription.Generic> matcher) {
        return isSetter().and(takesGenericArguments(new CollectionOneToOneMatcher<TypeDescription.Generic>(Collections.singletonList(matcher))));
    }",Matches a method s generic parameters.
"private List<Boolean> asBooleanList(Object value) {
        boolean[] values = (boolean[]) value;
        List<Boolean> list = new ArrayList<Boolean>(values.length);
        for (boolean booleanValue : values) {
            list.add(booleanValue);
        }
        return list;
    }",As boolean list.
"@Nonnull
	public static LLongToSrtFunction longToSrtFunctionFrom(Consumer<LLongToSrtFunctionBuilder> buildingFunction) {
		LLongToSrtFunctionBuilder builder = new LLongToSrtFunctionBuilder();
		buildingFunction.accept(builder);
		return builder.build();
	}",Create a LLongToSrtFunction from the given consumer.
"public AbstractBuilder getPropertyBuilder(ClassWriter classWriter) {
        final PropertyWriter propertyWriter =
                writerFactory.getPropertyWriter(classWriter);
        return PropertyBuilder.getInstance(context,
                                           classWriter.getTypeElement(),
                                           propertyWriter);
    }",Get a property builder.
"public static crvserver_crpolicy_binding[] get(nitro_service service, String name) throws Exception{
		crvserver_crpolicy_binding obj = new crvserver_crpolicy_binding();
		obj.set_name(name);
		crvserver_crpolicy_binding response[] = (crvserver_crpolicy_binding[]) obj.get_resources(service);
		return response;
	}",Use this API to fetch crvserver_crpolicy_binding resources of given name.
"public boolean hasDirectory(final String name) throws IOException
   {
      return SecurityHelper.doPrivilegedIOExceptionAction(new PrivilegedExceptionAction<Boolean>()
      {
         public Boolean run() throws Exception
         {
            return new File(baseDir, name).exists();

         }
      });
   }",Checks if a directory with the specified name exists.
"public static String md5Encode(String strIn) {
        try {
            MessageDigest md5 = MessageDigest.getInstance(""md5"");
            byte[] bin = toBytes(strIn);
            byte[] bout = md5.digest(bin);
            String strOut = javax.xml.bind.DatatypeConverter.printBase64Binary(bout);
            return strOut;
        }catch (Exception e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }",This method encodes a string in Base64 format.
"public Observable<Page<VirtualNetworkTapInner>> listByResourceGroupNextAsync(final String nextPageLink) {
        return listByResourceGroupNextWithServiceResponseAsync(nextPageLink)
            .map(new Func1<ServiceResponse<Page<VirtualNetworkTapInner>>, Page<VirtualNetworkTapInner>>() {
                @Override
                public Page<VirtualNetworkTapInner> call(ServiceResponse<Page<VirtualNetworkTapInner>> response) {
                    return response.body();
                }
            });
    }",Gets a list of a VirtualNetworkTap.
"public CountDownLatch requestJoin(final long joiningSite) throws Exception {
        final CountDownLatch cdl = new CountDownLatch(1);
        final Runnable r = new Runnable() {
            @Override
            public void run() {
                try {
                    final long txnId = m_idManager.getNextUniqueTransactionId();

                    for (long initiatorHSId : m_hsIds) {
                        if (initiatorHSId == m_hsId) continue;
                        JSONObject jsObj = new JSONObject();
                        jsObj.put(""txnId"", txnId);
                        jsObj.put(""initiatorHSId"", m_hsId);
                        jsObj.put(""joiningHSId"", joiningSite);
                        jsObj.put(""lastSafeTxnId"", m_safetyState.getNewestSafeTxnIdForExecutorBySiteId(initiatorHSId));
                        byte payload[] = jsObj.toString(4).getBytes(""UTF-8"");
                        ByteBuffer metadata = ByteBuffer.allocate(1);
                        metadata.put(BINARY_PAYLOAD_JOIN_REQUEST);
                        BinaryPayloadMessage bpm = new BinaryPayloadMessage(metadata.array(), payload);
                        m_mailbox.send( initiatorHSId, bpm);
                    }

                    m_txnQueue.noteTransactionRecievedAndReturnLastSeen(m_hsId,
                            txnId,
                            m_safetyState.getNewestGloballySafeTxnId());

                    AgreementRejoinTransactionState arts =
                        new AgreementRejoinTransactionState( txnId, m_hsId, joiningSite, cdl );

                    if (!m_txnQueue.add(arts)) {
                        org.voltdb.VoltDB.crashLocalVoltDB(""Shouldn't have failed to add txn"", true, null);
                    }
                    m_transactionsById.put(arts.txnId, arts);
                } catch (Throwable e) {
                    org.voltdb.VoltDB.crashLocalVoltDB(""Error constructing JSON"", false, e);
                }
            }
        };
        LocalObjectMessage lom = new LocalObjectMessage(r);
        lom.m_sourceHSId = m_hsId;
        m_mailbox.deliver(lom);
        return cdl;
    }",Request a join request.
"@XmlElementDecl(namespace = ""http://www.opengis.net/citygml/tunnel/2.0"", name = ""IntTunnelInstallation"", substitutionHeadNamespace = ""http://www.opengis.net/citygml/2.0"", substitutionHeadName = ""_CityObject"")
    public JAXBElement<IntTunnelInstallationType> createIntTunnelInstallation(IntTunnelInstallationType value) {
        return new JAXBElement<IntTunnelInstallationType>(_IntTunnelInstallation_QNAME, IntTunnelInstallationType.class, null, value);
    }",Create an instance of the IntTunnelInstallation property.
"public static void removeEntry(File zip, String path, File destZip) {
    removeEntries(zip, new String[] { path }, destZip);
  }",Remove entry from a zip file.
"public final void ruleArrayBrackets() throws RecognitionException {

        		int stackSize = keepStackSize();
        	
        try {
            // InternalXbase.g:1629:2: ( ( ( rule__ArrayBrackets__Group__0 ) ) )
            // InternalXbase.g:1630:2: ( ( rule__ArrayBrackets__Group__0 ) )
            {
            // InternalXbase.g:1630:2: ( ( rule__ArrayBrackets__Group__0 ) )
            // InternalXbase.g:1631:3: ( rule__ArrayBrackets__Group__0 )
            {
            if ( state.backtracking==0 ) {
               before(grammarAccess.getArrayBracketsAccess().getGroup()); 
            }
            // InternalXbase.g:1632:3: ( rule__ArrayBrackets__Group__0 )
            // InternalXbase.g:1632:4: rule__ArrayBrackets__Group__0
            {
            pushFollow(FOLLOW_2);
            rule__ArrayBrackets__Group__0();

            state._fsp--;
            if (state.failed) return ;

            }

            if ( state.backtracking==0 ) {
               after(grammarAccess.getArrayBracketsAccess().getGroup()); 
            }

            }


            }

        }
        catch (RecognitionException re) {
            reportError(re);
            recover(input,re);
        }
        finally {

            	restoreStackSize(stackSize);

        }
        return ;
    }",start of ruleArrayBrackets
"public double distance(Vector2D vector2d) {
		double a = vector2d.x - x;
		double b = vector2d.y - y;
		return Math.sqrt(a * a + b * b);
	}",Returns the Euclidean distance between this vector and another.
"public static HashValue murmurhash3_x64_128(final byte[] key, final int offset, final int len, final int seed) {
		// The original algorithm does have a 32 bit unsigned seed.
		// We have to mask to match the behavior of the unsigned types and prevent sign extension.
		long h1 = seed & 0x00000000FFFFFFFFL;
		long h2 = seed & 0x00000000FFFFFFFFL;

		final long c1 = 0x87c37b91114253d5L;
		final long c2 = 0x4cf5ad432745937fL;

		int roundedEnd = offset + (len & 0xFFFFFFF0);  // round down to 16 byte block
		for (int i = offset; i < roundedEnd; i += 16) {
			long k1 = getLongLittleEndian(key, i);
			long k2 = getLongLittleEndian(key, i + 8);
			k1 *= c1;
			k1 = Long.rotateLeft(k1, 31);
			k1 *= c2;
			h1 ^= k1;
			h1 = Long.rotateLeft(h1, 27);
			h1 += h2;
			h1 = h1 * 5 + 0x52dce729;
			k2 *= c2;
			k2 = Long.rotateLeft(k2, 33);
			k2 *= c1;
			h2 ^= k2;
			h2 = Long.rotateLeft(h2, 31);
			h2 += h1;
			h2 = h2 * 5 + 0x38495ab5;
		}

		long k1 = 0;
		long k2 = 0;

		switch (len & 15) {
			case 15:
				k2 = (key[roundedEnd + 14] & 0xffL) << 48;
			case 14:
				k2 |= (key[roundedEnd + 13] & 0xffL) << 40;
			case 13:
				k2 |= (key[roundedEnd + 12] & 0xffL) << 32;
			case 12:
				k2 |= (key[roundedEnd + 11] & 0xffL) << 24;
			case 11:
				k2 |= (key[roundedEnd + 10] & 0xffL) << 16;
			case 10:
				k2 |= (key[roundedEnd + 9] & 0xffL) << 8;
			case 9:
				k2 |= (key[roundedEnd + 8] & 0xffL);
				k2 *= c2;
				k2 = Long.rotateLeft(k2, 33);
				k2 *= c1;
				h2 ^= k2;
			case 8:
				k1 = ((long) key[roundedEnd + 7]) << 56;
			case 7:
				k1 |= (key[roundedEnd + 6] & 0xffL) << 48;
			case 6:
				k1 |= (key[roundedEnd + 5] & 0xffL) << 40;
			case 5:
				k1 |= (key[roundedEnd + 4] & 0xffL) << 32;
			case 4:
				k1 |= (key[roundedEnd + 3] & 0xffL) << 24;
			case 3:
				k1 |= (key[roundedEnd + 2] & 0xffL) << 16;
			case 2:
				k1 |= (key[roundedEnd + 1] & 0xffL) << 8;
			case 1:
				k1 |= (key[roundedEnd] & 0xffL);
				k1 *= c1;
				k1 = Long.rotateLeft(k1, 31);
				k1 *= c2;
				h1 ^= k1;
		}

		//----------
		// finalization

		h1 ^= len;
		h2 ^= len;

		h1 += h2;
		h2 += h1;

		h1 = fmix64(h1);
		h2 = fmix64(h2);

		h1 += h2;
		h2 += h1;

		return new HashValue(h1, h2);
	}",MurmurHash3 - 64 - 128 - 1a
"public FeatureList selectOverlapping(String seqname, Location location, boolean useBothStrands)
			throws Exception {
		FeatureList list = new FeatureList();

		for (FeatureI feature : this) {
			boolean overlaps = false;
			if (feature.seqname().equals(seqname)) {
				if (location.isSameStrand(feature.location())) {
					overlaps = feature.location().overlaps(location);
				} else if (useBothStrands) {
					overlaps = feature.location().overlaps(location.opposite());
				}
			}
			if (overlaps) {
				list.add(feature);
			}
		}
		return list;
	}",Select the features that overlap the specified location.
"public List<GitFileSystemObject> getChildren() throws IOException, JavaGitException {
    List<GitFileSystemObject> children = new ArrayList<GitFileSystemObject>();

    // get all of the file system objects currently located under this directory
    for (File memberFile : file.listFiles()) {
      // check if this file is hidden also some times the .git and 
      //other unix hidden directories are not hidden in Windows
      if (memberFile.isHidden()||memberFile.getName().startsWith(""."")) {
        // ignore (could be .git directory)
        continue;
      }

      // now, just check for the type of the filesystem object
      if (memberFile.isDirectory()) {
        children.add(new GitDirectory(memberFile, workingTree));
      } else {
        children.add(new GitFile(memberFile, workingTree));
      }
    }

    return children;
  }",Get the list of all the children of this directory.
"static RollupStats getOrNull(Vec vec, final Key rskey ) {
    Value val = DKV.get(rskey);
    if( val == null )           // No rollup stats present?
      return vec.length() > 0 ? /*not computed*/null : /*empty vec*/new RollupStats(0);
    RollupStats rs = val.get(RollupStats.class);
    return rs.isReady() ? rs : null;
  }",Get or null RollupStats from a vector.
"@Override
  protected Iterator<T> search(final IndexSearcher searcher, final Query query) throws IOException {
    // grow the bit set if needed
    docIds.set(searcher.getIndexReader().maxDoc());
    // clear it
    docIds.clear();
    searcher.search(query, new Collector() {
      private int docBase;

      @Override
      public void setScorer(Scorer scorer) {
      }

      @Override
      public boolean acceptsDocsOutOfOrder() {
        return true;
      }

      @Override
      public void collect(int doc) {
        docIds.set(doc + docBase);
      }

      public void setNextReader(AtomicReaderContext context) {
        this.docBase = context.docBase;
      }
    });

    return new AbstractIterator<T>() {
      private int doc = docIds.nextSetBit(0);

      @Override
      protected T computeNext() {
        ((Progressable)context).progress(); // casting to avoid Hadoop 2 incompatibility
        if (doc < 0) {
          return endOfData();
        }
        try {
          T ret = docToValue(searcher.doc(doc));
          doc = docIds.nextSetBit(doc + 1);
          return  ret;
        } catch (IOException e) {
          throw new RuntimeException(e);
        }
      }
    };
  }",Override the search method to search for documents.
"public Recommender buildRecommender(final DataModel dataModel,
            final String recType,
            final String similarityType,
            final int neighborhoodSize,
            final int factors,
            final int iterations,
            final String facType)
            throws RecommenderException {
        String neighborhoodType = ""org.apache.mahout.cf.taste.impl.neighborhood.NearestNUserNeighborhood"";
        Object simObj = null;
        /**
         * Instantiate similarity class
         */
        if (similarityType != null) {
            Class<?> similarityClass = null;
            try {
                similarityClass = Class.forName(similarityType);
                simObj = similarityClass.getConstructor(DataModel.class).newInstance(dataModel);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());
            } catch (IllegalAccessException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());
            } catch (IllegalArgumentException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());
            } catch (InstantiationException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());
            } catch (InvocationTargetException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());
            } catch (NoSuchMethodException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());
            } catch (SecurityException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Similarity class "" + e.getMessage());
            }
        }
        /**
         * Instantiate neighborhood class
         */
        Object neighObj = null;
        if (neighborhoodSize != NO_N) {
            Class<?> neighborhoodClass = null;
            try {
                neighborhoodClass = Class.forName(neighborhoodType);
                neighObj = neighborhoodClass.getConstructor(int.class, UserSimilarity.class, DataModel.class).newInstance(neighborhoodSize, simObj, dataModel);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());
            } catch (IllegalAccessException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());
            } catch (IllegalArgumentException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());
            } catch (InstantiationException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());
            } catch (InvocationTargetException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());
            } catch (NoSuchMethodException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());
            } catch (SecurityException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Neighborhood class "" + e.getMessage());
            }
        }
        /**
         * Instantiate factorizer class
         */
        if (facType != null) {
            Class<?> factorizerClass = null;
            try {
                factorizerClass = Class.forName(facType);
                simObj = factorizerClass.getConstructor(DataModel.class, int.class, int.class).newInstance(dataModel, factors, iterations);
            } catch (ClassNotFoundException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());
            } catch (IllegalAccessException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());
            } catch (IllegalArgumentException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());
            } catch (InstantiationException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());
            } catch (InvocationTargetException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());
            } catch (NoSuchMethodException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());
            } catch (SecurityException e) {
                e.printStackTrace();
                throw new RecommenderException(""Could not create Factorizer "" + e.getMessage());
            }
        }
        /**
         * Instantiate recommender class
         */
        final Class<?> recommenderClass;
        try {
            recommenderClass = Class.forName(recType);
        } catch (ClassNotFoundException e) {
            throw new RecommenderException(""Could not create Recommender class "" + e.getMessage());
        }
        final Object recObj;
        try {
            if (facType != null) {
                recObj = recommenderClass.getConstructor(DataModel.class, Factorizer.class).newInstance(dataModel, (Factorizer) simObj);
            } else if (recType.contains(""UserBased"")) {
                // user-based similarity with neighborhood
                recObj = recommenderClass.getConstructor(DataModel.class, UserNeighborhood.class, UserSimilarity.class).newInstance(dataModel, neighObj, simObj);
            } else if (similarityType != null) {
                // item-based similarity, no neighborhood
                recObj = recommenderClass.getConstructor(DataModel.class, ItemSimilarity.class).newInstance(dataModel, simObj);
            } else {
                recObj = recommenderClass.getConstructor(DataModel.class).newInstance(dataModel);
            }
        } catch (IllegalAccessException e) {
            throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());
        } catch (IllegalArgumentException e) {
            throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());
        } catch (InstantiationException e) {
            throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());
        } catch (InvocationTargetException e) {
            throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());
        } catch (NoSuchMethodException e) {
            throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());
        } catch (SecurityException e) {
            throw new RecommenderException(""Could not create Recommender: "" + e.getMessage());
        }
        return (Recommender) recObj;
    }",Build a Recommender object.
"public static CPDAvailabilityEstimate[] findByUuid_C_PrevAndNext(
		long CPDAvailabilityEstimateId, String uuid, long companyId,
		OrderByComparator<CPDAvailabilityEstimate> orderByComparator)
		throws com.liferay.commerce.exception.NoSuchCPDAvailabilityEstimateException {
		return getPersistence()
				   .findByUuid_C_PrevAndNext(CPDAvailabilityEstimateId, uuid,
			companyId, orderByComparator);
	}",Returns the cpd availability estimates before and after the UUID and company.
"public void destroySubcontext(Name name)
            throws NamingException {
        if (_nc == null)
            throw IIOPLogger.ROOT_LOGGER.notANamingContext(name.toString());
        NamingContext the_nc = _nc;
        NameComponent[] path = org.wildfly.iiop.openjdk.naming.jndi.CNNameParser.nameToCosName(name);
        if (name.size() > 0) {
            try {
                javax.naming.Context ctx =
                        (javax.naming.Context) callResolve(path);
                CNCtx cnc = (CNCtx) ctx;
                the_nc = cnc._nc;
                cnc.close(); //remove the reference to the context
            } catch (ClassCastException e) {
                throw new NotContextException(name.toString());
            } catch (CannotProceedException e) {
                javax.naming.Context cctx = getContinuationContext(e);
                cctx.destroySubcontext(e.getRemainingName());
                return;
            } catch (NameNotFoundException e) {
                // If leaf is the one missing, return success
                // as per JNDI spec

                if (e.getRootCause() instanceof NotFound &&
                        leafNotFound((NotFound) e.getRootCause(),
                                path[path.length - 1])) {
                    return; // leaf missing OK
                }
                throw e;
            } catch (NamingException e) {
                throw e;
            }
        }
        callDestroy(the_nc);
        callUnbind(path);
    }",Destroy a context.
"@Nonnull
  @Nonempty
  public static String getObjectAddress (@Nullable final Object aObject)
  {
    if (aObject == null)
      return ""0x00000000"";
    return ""0x"" + StringHelper.getHexStringLeadingZero (System.identityHashCode (aObject), 8);
  }",Get the object address.
"private synchronized void emitRecords() throws IOException {
    for (String recordName : bufferedData.keySet()) {
      RecordMap recordMap = bufferedData.get(recordName);
      synchronized (recordMap) {
        Set<Entry<TagMap, MetricMap>> entrySet = recordMap.entrySet ();
        for (Entry<TagMap, MetricMap> entry : entrySet) {
          OutputRecord outRec = new OutputRecord(entry.getKey(), entry.getValue());
          emitRecord(contextName, recordName, outRec);
        }
      }
    }
    flush();
  }",Emit all records in the buffered data.
"public static HystrixCommandMetrics getInstance(HystrixCommandKey key, HystrixCommandGroupKey commandGroup, HystrixCommandProperties properties) {
        return getInstance(key, commandGroup, null, properties);
    }",Gets the instance of the command metrics.
"public <C extends Collection<T>> Map<Boolean, C> partitioningTo(Predicate<? super T> predicate,
            Supplier<C> collectionFactory) {
        return collect(Collectors.partitioningBy(predicate, Collectors.toCollection(collectionFactory)));
    }",Partition the result set by the given predicate using the given collection factory.
"static void overwrite(StringBuffer sb, int pos, String s) {
        int len = s.length();
        for (int i = 0; i < len; i++) {
            sb.setCharAt(pos + i, s.charAt(i));
        }
    }",overwrite the contents of a StringBuffer at a given position
"public static OutputAccessor from(ByteBuffer byteBuffer) {

        ByteBufferOutputAccessor accessor = new ByteBufferOutputAccessor();
        accessor.byteBuffer = byteBuffer;

        return accessor;
    }",Creates an output accessor from a byte buffer.
"public static Font createFont(File fontFile) {
		try {
			return Font.createFont(Font.TRUETYPE_FONT, fontFile);
		} catch (FontFormatException e) {
			// True Type字体无效时使用Type1字体
			try {
				return Font.createFont(Font.TYPE1_FONT, fontFile);
			} catch (Exception e1) {
				throw new UtilException(e);
			}
		} catch (IOException e) {
			throw new IORuntimeException(e);
		}
	}",Creates a Font object from the specified font file.
"protected void appendDefType(SolrQuery solrQuery, @Nullable String defType) {
		if (StringUtils.isNotBlank(defType)) {
			solrQuery.set(""defType"", defType);
		}
	}",Append the defType to the solrQuery
"public String htmlPool(String pool) throws Exception {

        StringBuffer html = new StringBuffer(256);

        html.append(""<a href=\""javascript:switchview('"").append(pool).append(""');\"">"");
        html.append(pool).append(""</a><br>\n"");
        html.append(""\t<div id='"").append(pool).append(""' style='display: none;'>\n"");
        html.append(""\t\t<table border='0'>\n"");
        html.append(""\t\t\t<tr><td>JDBC Driver:</td><td>"" + getDbDriver(pool) + ""</td></tr>\n"");
        html.append(""\t\t\t<tr><td>JDBC Connection Url:</td><td>"" + getDbUrl(pool) + ""</td></tr>\n"");
        html.append(""\t\t\t<tr><td>JDBC Connection Url Params:</td><td>"" + getDbParams(pool) + ""</td></tr>\n"");
        html.append(""\t\t\t<tr><td>Database User:</td><td>"" + getDbUser(pool) + ""</td></tr>\n"");
        html.append(""\t\t</table>\n"");
        html.append(""\t</div>\n"");

        return html.toString();
    }",Get the HTML representation of a single pool.
"private String getClassLabel(EntityIdValue entityIdValue) {
		ClassRecord classRecord = this.classRecords.get(entityIdValue);
		String label;
		if (classRecord == null || classRecord.itemDocument == null) {
			label = entityIdValue.getId();
		} else {
			label = getLabel(entityIdValue, classRecord.itemDocument);
		}

		EntityIdValue labelOwner = this.labels.get(label);
		if (labelOwner == null) {
			this.labels.put(label, entityIdValue);
			return label;
		} else if (labelOwner.equals(entityIdValue)) {
			return label;
		} else {
			return label + "" ("" + entityIdValue.getId() + "")"";
		}
	}",Gets the label for the given entity id value.
"public void assignAmounts(XTrace trace, Map<String, Double> amounts) {
		XCostAmount.instance().assignValues(trace, amounts);
	}",Assigns amounts to a trace.
"private void setFilePosition(FileWindow w, int line) {
        boolean activate = true;
        JTextArea ta = w.textArea;
        try {
            if (line == -1) {
                w.setPosition(-1);
                if (currentWindow == w) {
                    currentWindow = null;
                }
            } else {
                int loc = ta.getLineStartOffset(line-1);
                if (currentWindow != null && currentWindow != w) {
                    currentWindow.setPosition(-1);
                }
                w.setPosition(loc);
                currentWindow = w;
            }
        } catch (BadLocationException exc) {
            // fix me
        }
        if (activate) {
            if (w.isIcon()) {
                desk.getDesktopManager().deiconifyFrame(w);
            }
            desk.getDesktopManager().activateFrame(w);
            try {
                w.show();
                w.toFront();  // required for correct frame layering (JDK 1.4.1)
                w.setSelected(true);
            } catch (Exception exc) {
            }
        }
    }",Set the file position of the given file window.
"public static void writeJsonValue(JsonWriter writer, Node node, String name, Object value,
                                      Integer type, MappingRules mapping)
            throws RepositoryException, IOException {
        Value jcrValue = value instanceof Value ? (Value) value : null;
        switch (type) {
            case PropertyType.BINARY:
                if (node != null && jcrValue != null) {
                    if (mapping.propertyFormat.binary == MappingRules.PropertyFormat.Binary.link) {
                        String uri = ""/bin/cpm/nodes/property.bin""
                                + LinkUtil.encodePath(node.getPath())
                                + ""?name="" + LinkUtil.encodePath(name);
                        boolean htmlSafe = writer.isHtmlSafe();
                        writer.setHtmlSafe(false);
                        writer.value(uri);
                        writer.setHtmlSafe(htmlSafe);
                    } else if (mapping.propertyFormat.binary == MappingRules.PropertyFormat.Binary.base64) {
                        Binary binary = jcrValue.getBinary();
                        byte[] buffer = IOUtils.toByteArray(binary.getStream());
                        String encoded = Base64.encodeBase64String(buffer);
                        writer.value(getValueString(encoded, type, mapping));
                    } else {
                        writer.nullValue();
                    }
                } else {
                    writer.nullValue();
                }
                break;
            case PropertyType.BOOLEAN:
                writer.value(jcrValue != null ? jcrValue.getBoolean()
                        : (value instanceof Boolean ? (Boolean) value : Boolean.valueOf(value.toString())));
                break;
            case PropertyType.DATE:
                Calendar cal = jcrValue != null ? jcrValue.getDate()
                        : (value instanceof Calendar ? (Calendar) value : null);
                if (cal != null) {
                    SimpleDateFormat dateFormat = new SimpleDateFormat(MappingRules.MAP_DATE_FORMAT);
                    dateFormat.setTimeZone(cal.getTimeZone());
                    writer.value(getValueString(dateFormat.format(cal.getTime()), type, mapping));
                }
                break;
            case PropertyType.DECIMAL:
                writer.value(getValueString(jcrValue != null
                        ? jcrValue.getDecimal() : (value instanceof BigDecimal ? (BigDecimal) value
                        : new BigDecimal(value.toString())), type, mapping));
                break;
            case PropertyType.DOUBLE:
                writer.value(getValueString(jcrValue != null
                        ? jcrValue.getDouble() : (value instanceof Double ? (Double) value
                        : Double.valueOf(value.toString())), type, mapping));
                break;
            case PropertyType.LONG:
                writer.value(jcrValue != null ? jcrValue.getLong()
                        : (value instanceof Long ? (Long) value : Long.valueOf(value.toString())));
                break;
            case PropertyType.NAME:
            case PropertyType.PATH:
            case PropertyType.REFERENCE:
            case PropertyType.STRING:
            case PropertyType.URI:
            case PropertyType.WEAKREFERENCE:
                writer.value(getValueString(jcrValue != null
                        ? jcrValue.getString() : value.toString(), type, mapping));
                break;
            case PropertyType.UNDEFINED:
                writer.nullValue();
                break;
        }
    }",Write a value to a JsonWriter.
"public final void setTimeRange (final Calendar rangeStartingCalendar, final Calendar rangeEndingCalendar)
  {
    setTimeRange (rangeStartingCalendar.get (Calendar.HOUR_OF_DAY),
                  rangeStartingCalendar.get (Calendar.MINUTE),
                  rangeStartingCalendar.get (Calendar.SECOND),
                  rangeStartingCalendar.get (Calendar.MILLISECOND),
                  rangeEndingCalendar.get (Calendar.HOUR_OF_DAY),
                  rangeEndingCalendar.get (Calendar.MINUTE),
                  rangeEndingCalendar.get (Calendar.SECOND),
                  rangeEndingCalendar.get (Calendar.MILLISECOND));
  }",Sets the time range of the sequence.
"public List<MessageDestinationRefType<WebFragmentDescriptor>> getAllMessageDestinationRef()
   {
      List<MessageDestinationRefType<WebFragmentDescriptor>> list = new ArrayList<MessageDestinationRefType<WebFragmentDescriptor>>();
      List<Node> nodeList = model.get(""message-destination-ref"");
      for(Node node: nodeList)
      {
         MessageDestinationRefType<WebFragmentDescriptor>  type = new MessageDestinationRefTypeImpl<WebFragmentDescriptor>(this, ""message-destination-ref"", model, node);
         list.add(type);
      }
      return list;
   }",Gets all message destination ref.
"@Override
    public Object visitNegation(ExcellentParser.NegationContext ctx) {
        return Conversions.toDecimal(visit(ctx.expression()), m_evalContext).negate();
    }",Visit a Negation.
"public void setType(String type) throws PageException {
	if (type == null) return;
	try {
	    this.type = toType(type);
	}
	catch (SearchException e) {
	    throw Caster.toPageException(e);
	}
    }",set the value type The type of the specification.
"public static String subjectToString(final Subject subject) {

        final String result;

        if (subject == null) {

            result = ""null"";

        } else {

            StringBuffer buffer = new StringBuffer(""["");
            buffer.append(subject.getClass().getName());
            buffer.append(""@"");
            buffer
                            .append(Integer.toHexString(System
                                            .identityHashCode(subject)));
            buffer.append("" <principals="");
            buffer.append(subject.getPrincipals());
            buffer.append("">]"");
            result = buffer.toString();

        }

        return result;

    }",Method to get the string representation of a Subject object.
"public Long addSubscriberLocationReportRequest(LCSEvent lcsEvent, LCSClientID lcsClientID, LCSLocationInfo lcsLocationInfo,
            ISDNAddressString msisdn, IMSI imsi, IMEI imei, ISDNAddressString naEsrd, ISDNAddressString naEsrk,
            ExtGeographicalInformation locationEstimate, Integer ageOfLocationEstimate,
            SLRArgExtensionContainer slrArgExtensionContainer, AddGeographicalInformation addLocationEstimate,
            DeferredmtlrData deferredmtlrData, Integer lcsReferenceNumber, PositioningDataInformation geranPositioningData,
            UtranPositioningDataInfo utranPositioningData, CellGlobalIdOrServiceAreaIdOrLAI cellIdOrSai,
            GSNAddress hgmlcAddress, Integer lcsServiceTypeID, boolean saiPresent, boolean pseudonymIndicator,
            AccuracyFulfilmentIndicator accuracyFulfilmentIndicator, VelocityEstimate velocityEstimate, Integer sequenceNumber,
            PeriodicLDRInfo periodicLDRInfo, boolean moLrShortCircuitIndicator,
            GeranGANSSpositioningData geranGANSSpositioningData, UtranGANSSpositioningData utranGANSSpositioningData,
            ServingNodeAddress targetServingNodeForHandover) throws MAPException {
        return this.addSubscriberLocationReportRequest(_Timer_Default, lcsEvent, lcsClientID, lcsLocationInfo, msisdn, imsi,
                imei, naEsrd, naEsrk, locationEstimate, ageOfLocationEstimate, slrArgExtensionContainer, addLocationEstimate,
                deferredmtlrData, lcsReferenceNumber, geranPositioningData, utranPositioningData, cellIdOrSai, hgmlcAddress,
                lcsServiceTypeID, saiPresent, pseudonymIndicator, accuracyFulfilmentIndicator, velocityEstimate,
                sequenceNumber, periodicLDRInfo, moLrShortCircuitIndicator, geranGANSSpositioningData,
                utranGANSSpositioningData, targetServingNodeForHandover);
    }",This function is called to add a subscriber location report request to the subscriber.
"public static boolean reflectionEquals(Object lhs, Object rhs, boolean testTransients, Class<?> reflectUpToClass) {
        return reflectionEquals(lhs, rhs, testTransients, reflectUpToClass, null);
    }",ReflectionEquals method.
"public static List<JSModule> createJsModules(List<JsModuleSpec> specs, List<SourceFile> inputs)
      throws IOException {
    checkState(specs != null);
    checkState(!specs.isEmpty());
    checkState(inputs != null);

    List<String> moduleNames = new ArrayList<>(specs.size());
    Map<String, JSModule> modulesByName = new LinkedHashMap<>();
    Map<String, Integer> modulesFileCountMap = new LinkedHashMap<>();
    int numJsFilesExpected = 0;
    int minJsFilesRequired = 0;
    for (JsModuleSpec spec : specs) {
      if (modulesByName.containsKey(spec.name)) {
        throw new FlagUsageException(""Duplicate module name: "" + spec.name);
      }
      JSModule module = new JSModule(spec.name);

      for (String dep : spec.deps) {
        JSModule other = modulesByName.get(dep);
        if (other == null) {
          throw new FlagUsageException(
              ""Module '""
                  + spec.name
                  + ""' depends on unknown module '""
                  + dep
                  + ""'. Be sure to list modules in dependency order."");
        }
        module.addDependency(other);
      }

      // We will allow modules of zero input.
      if (spec.numJsFiles < 0) {
        numJsFilesExpected = -1;
      } else {
        minJsFilesRequired += spec.numJsFiles;
      }

      if (numJsFilesExpected >= 0) {
        numJsFilesExpected += spec.numJsFiles;
      }

      // Add modules in reverse order so that source files are allocated to
      // modules in reverse order. This allows the first module
      // (presumably the base module) to have a size of 'auto'
      moduleNames.add(0, spec.name);
      modulesFileCountMap.put(spec.name, spec.numJsFiles);
      modulesByName.put(spec.name, module);
    }

    final int totalNumJsFiles = inputs.size();

    if (numJsFilesExpected >= 0 || minJsFilesRequired > totalNumJsFiles) {
      if (minJsFilesRequired > totalNumJsFiles) {
        numJsFilesExpected = minJsFilesRequired;
      }

      if (numJsFilesExpected > totalNumJsFiles) {
        throw new FlagUsageException(
            ""Not enough JS files specified. Expected ""
                + numJsFilesExpected
                + "" but found ""
                + totalNumJsFiles);
      } else if (numJsFilesExpected < totalNumJsFiles) {
        throw new FlagUsageException(
            ""Too many JS files specified. Expected ""
                + numJsFilesExpected
                + "" but found ""
                + totalNumJsFiles);
      }
    }

    int numJsFilesLeft = totalNumJsFiles;
    int moduleIndex = 0;
    for (String moduleName : moduleNames) {
      // Parse module inputs.
      int numJsFiles = modulesFileCountMap.get(moduleName);
      JSModule module = modulesByName.get(moduleName);

      // Check if the first js module specified 'auto' for the number of files
      if (moduleIndex == moduleNames.size() - 1 && numJsFiles == -1) {
        numJsFiles = numJsFilesLeft;
      }

      List<SourceFile> moduleFiles = inputs.subList(numJsFilesLeft - numJsFiles, numJsFilesLeft);
      for (SourceFile input : moduleFiles) {
        module.add(input);
      }
      numJsFilesLeft -= numJsFiles;
      moduleIndex++;
    }

    return new ArrayList<>(modulesByName.values());
  }",Create JS modules from a list of JS module specs.
"public SftpClientBuilder sessionConfigs(Map<String, String> sessionConfigs) {
        endpoint.getEndpointConfiguration().setSessionConfigs(sessionConfigs);
        return this;
    }",Sets the session configs for the client.
"protected Tree<FeatureStructure> populateTree(JCas jcas) {
		Tree<FeatureStructure> tree = new Tree<FeatureStructure>(jcas.getDocumentAnnotationFs());
		for (TOP a : JCasUtil.select(jcas, annotationTypes.get(0))) {
			tree.add(populateTree(jcas, a, 1));
		}
		return tree;

	}",Populates a tree of feature structures.
"private static Optional<String> getMethodReturnValueName(ConstraintViolation<?> violation) {
        int returnValueNames = -1;

        final StringBuilder result = new StringBuilder(""server response"");
        for (Path.Node node : violation.getPropertyPath()) {
            if (node.getKind().equals(ElementKind.RETURN_VALUE)) {
                returnValueNames = 0;
            } else if (returnValueNames >= 0) {
                result.append(returnValueNames++ == 0 ? "" "" : ""."").append(node);
            }
        }

        return returnValueNames >= 0 ? Optional.of(result.toString()) : Optional.empty();
    }",Get method return value name.
"public void setDeploymentJobs(java.util.Collection<DeploymentJob> deploymentJobs) {
        if (deploymentJobs == null) {
            this.deploymentJobs = null;
            return;
        }

        this.deploymentJobs = new java.util.ArrayList<DeploymentJob>(deploymentJobs);
    }",Sets the value of the deploymentJobs property.
"public ResolvableType getGeneric(int... indexes) {
        try {
            if (indexes == null || indexes.length == 0) {
                return getGenerics()[0];
            }
            ResolvableType generic = this;
            for (int index : indexes) {
                generic = generic.getGenerics()[index];
            }
            return generic;
        } catch (IndexOutOfBoundsException ex) {
            return NONE;
        }
    }",Gets the generic type.
"public static CopticCalendar of(
        int cyear,
        int cmonth,
        int cdom
    ) {

        if (!CALSYS.isValid(CopticEra.ANNO_MARTYRUM, cyear, cmonth, cdom)) {
            throw new IllegalArgumentException(
                ""Invalid Coptic date: year="" + cyear + "", month="" + cmonth + "", day="" + cdom);
        }

        return new CopticCalendar(cyear, cmonth, cdom);

    }",Create a CopticCalendar from the given Coptic calendar year month and day.
"public <T> Consumer<T> wrap(Throwing.Consumer<T> consumer) {
		return val -> {
			try {
				consumer.accept(val);
			} catch (Throwable e) {
				handler.accept(e);
			}
		};
	}",Wrap a Throwing consumer.
"public ImmutableList<EscapingMode> getEscapingModesForNode(SoyNode node) {
    ImmutableList<EscapingMode> modes = nodeToEscapingModes.get(node);
    if (modes == null) {
      modes = ImmutableList.of();
    }
    return modes;
  }",Get the escaping modes for a given node.
"String concatIconTitles(String main, String secondary) {

        if (main == null) {
            main = """";
        }
        if (secondary == null) {
            secondary = """";
        }

        if (secondary.length() == 0) {
            return main;
        }
        return main + "" ["" + secondary + ""]"";

    }",Concatenate the icon titles.
"private Expr parseMultiplicativeExpression(EnclosingScope scope, boolean terminated) {
		int start = index;
		Expr lhs = parseAccessExpression(scope, terminated);

		Token lookahead = tryAndMatch(terminated, Star, RightSlash, Percent);
		if (lookahead != null) {
			Expr rhs = parseAccessExpression(scope, terminated);
			switch (lookahead.kind) {
			case Star:
				lhs = new Expr.IntegerMultiplication(Type.Void, lhs, rhs);
				break;
			case RightSlash:
				lhs = new Expr.IntegerDivision(Type.Void, lhs, rhs);
				break;
			case Percent:
				lhs = new Expr.IntegerRemainder(Type.Void, lhs, rhs);
				break;
			default:
				throw new RuntimeException(""deadcode""); // dead-code
			}
			lhs = annotateSourceLocation(lhs, start);
		}

		return lhs;
	}",Parse a multiplicative expression.
"private void putFrame() {
    final int numLocal = currentFrame[1];
    final int numStack = currentFrame[2];
    if (symbolTable.getMajorVersion() < Opcodes.V1_6) {
      // Generate a StackMap attribute entry, which are always uncompressed.
      stackMapTableEntries.putShort(currentFrame[0]).putShort(numLocal);
      putAbstractTypes(3, 3 + numLocal);
      stackMapTableEntries.putShort(numStack);
      putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);
      return;
    }
    final int offsetDelta =
        stackMapTableNumberOfEntries == 0
            ? currentFrame[0]
            : currentFrame[0] - previousFrame[0] - 1;
    final int previousNumlocal = previousFrame[1];
    final int numLocalDelta = numLocal - previousNumlocal;
    int type = Frame.FULL_FRAME;
    if (numStack == 0) {
      switch (numLocalDelta) {
        case -3:
        case -2:
        case -1:
          type = Frame.CHOP_FRAME;
          break;
        case 0:
          type = offsetDelta < 64 ? Frame.SAME_FRAME : Frame.SAME_FRAME_EXTENDED;
          break;
        case 1:
        case 2:
        case 3:
          type = Frame.APPEND_FRAME;
          break;
        default:
          // Keep the FULL_FRAME type.
          break;
      }
    } else if (numLocalDelta == 0 && numStack == 1) {
      type =
          offsetDelta < 63
              ? Frame.SAME_LOCALS_1_STACK_ITEM_FRAME
              : Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED;
    }
    if (type != Frame.FULL_FRAME) {
      // Verify if locals are the same as in the previous frame.
      int frameIndex = 3;
      for (int i = 0; i < previousNumlocal && i < numLocal; i++) {
        if (currentFrame[frameIndex] != previousFrame[frameIndex]) {
          type = Frame.FULL_FRAME;
          break;
        }
        frameIndex++;
      }
    }
    switch (type) {
      case Frame.SAME_FRAME:
        stackMapTableEntries.putByte(offsetDelta);
        break;
      case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME:
        stackMapTableEntries.putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME + offsetDelta);
        putAbstractTypes(3 + numLocal, 4 + numLocal);
        break;
      case Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED:
        stackMapTableEntries
            .putByte(Frame.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED)
            .putShort(offsetDelta);
        putAbstractTypes(3 + numLocal, 4 + numLocal);
        break;
      case Frame.SAME_FRAME_EXTENDED:
        stackMapTableEntries.putByte(Frame.SAME_FRAME_EXTENDED).putShort(offsetDelta);
        break;
      case Frame.CHOP_FRAME:
        stackMapTableEntries
            .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)
            .putShort(offsetDelta);
        break;
      case Frame.APPEND_FRAME:
        stackMapTableEntries
            .putByte(Frame.SAME_FRAME_EXTENDED + numLocalDelta)
            .putShort(offsetDelta);
        putAbstractTypes(3 + previousNumlocal, 3 + numLocal);
        break;
      case Frame.FULL_FRAME:
      default:
        stackMapTableEntries.putByte(Frame.FULL_FRAME).putShort(offsetDelta).putShort(numLocal);
        putAbstractTypes(3, 3 + numLocal);
        stackMapTableEntries.putShort(numStack);
        putAbstractTypes(3 + numLocal, 3 + numLocal + numStack);
        break;
    }
  }",Put a frame into the stack map table.
"public static String computeGrantFormsHash(Document xml) throws Exception {
		XPathExecutor executor = new XPathExecutor(null);
		executor.setDoc(xml);
		GrantApplicationXpath xpath = new GrantApplicationXpath(null);
		xpath.setExecutor(executor);
		return _hash(xpath);
	}",Compute the grant forms hash for the given XML document.
"public void addHttpSessionListener(ArrayList al, String j2eeName) {
        if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_CORE.isLoggable(Level.FINE)) {
            LoggingUtil.SESSION_LOGGER_CORE.entering(methodClassName, methodNames[ADD_HTTP_SESSION_LISTENER], ""addHttpSessionListener:"" + al);
        }
        if (j2eeName != null) {
            addToJ2eeNameList(j2eeName, al.size(), mHttpSessionListenersJ2eeNames);
        }
        synchronized (mHttpSessionListeners) {
            mHttpSessionListeners.addAll(al);
            if (mHttpSessionListeners.size() > 0) {
                sessionListener = true;
                _coreHttpSessionManager.getIStore().setHttpSessionListener(true);
                boolean mIBMSessionListenerImplemented = isIBMSessionListenerImplemented(al); // PQ81248
                if (mIBMSessionListenerImplemented) {
                    wasHttpSessionObserver.setDoesContainIBMSessionListener(true);
                }
            }
        }

        if (com.ibm.ejs.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_CORE.isLoggable(Level.FINE)) {
            LoggingUtil.SESSION_LOGGER_CORE.exiting(methodClassName, methodNames[ADD_HTTP_SESSION_LISTENER], ""addHttpSessionListener:"" + al);
        }
    }",Add a HttpSessionListener to the list of HttpSessionListeners
"public EClass getLNC() {
		if (lncEClass == null) {
			lncEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(285);
		}
		return lncEClass;
	}",Get the LNCEClass.
"private static void free(ByteBuffer buf) {
        Cleaner cleaner = ((DirectBuffer)buf).cleaner();
        if (cleaner != null) {
            cleaner.clean();
        }
    }",Free the CRA - DIMs from a ByteBuffer.
"public boolean matches(String surt, Date captureDate, Date retrievalDate, String who2) {
        return (who == null || who.length() == 0 || who.equals(who2))
        	&& matches(surt, captureDate, retrievalDate);
    }",Checks if the given string matches the CACR coding.
"void registerTaskStarted(Task task) {
        synchronized (m_activeTasks) {
            String mapKey = createMapKey(task.getTenant(), task.getTaskID());
            if (m_activeTasks.put(mapKey, task) != null) {
                m_logger.warn(""Task {} registered as started but was already running"", mapKey);
            }
        }
    }",Register a task as started.
"@Override
  public synchronized void start() {
    if (thread != null) {
      throw new IllegalThreadStateException(""Parser already started"");
    }

    String name = getThreadName() + ""("" + getUri().toString() + "")"";

    CountDownLatch startSignal = new CountDownLatch(1);
    Runnable runnable = getRunnable(startSignal);

    thread = new Thread(runnable, name);
    thread.start();

    // Block until the thread has started
    try {
      startSignal.await();
    } catch (InterruptedException e) {
      Thread.currentThread().interrupt();
    }
  }",Start the XML parser.
"public final void setCssLinkFlavor(String cssLinkFlavor) {
		if (CSSHTMLBundleLinkRenderer.FLAVORS_HTML.equalsIgnoreCase(cssLinkFlavor)
				|| CSSHTMLBundleLinkRenderer.FLAVORS_XHTML.equalsIgnoreCase(cssLinkFlavor)
				|| CSSHTMLBundleLinkRenderer.FLAVORS_XHTML_EXTENDED.equalsIgnoreCase(cssLinkFlavor))
			CSSHTMLBundleLinkRenderer.setClosingTag(cssLinkFlavor);
		else {
			throw new IllegalArgumentException(""The value for the jawr.csslinks.flavor "" + ""property ["" + cssLinkFlavor
					+ ""] is invalid. "" + ""Please check the docs for valid values "");
		}
	}",Sets the CSS link flavor
"public void marshall(UploadArchiveRequest uploadArchiveRequest, ProtocolMarshaller protocolMarshaller) {

        if (uploadArchiveRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(uploadArchiveRequest.getVaultName(), VAULTNAME_BINDING);
            protocolMarshaller.marshall(uploadArchiveRequest.getAccountId(), ACCOUNTID_BINDING);
            protocolMarshaller.marshall(uploadArchiveRequest.getArchiveDescription(), ARCHIVEDESCRIPTION_BINDING);
            protocolMarshaller.marshall(uploadArchiveRequest.getChecksum(), CHECKSUM_BINDING);
            protocolMarshaller.marshall(uploadArchiveRequest.getBody(), BODY_BINDING);
            protocolMarshaller.marshall(uploadArchiveRequest.getContentLength(), CONTENTLENGTH_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given UploadArchiveRequest to the given protocolMarshaller.
"public static String emptyToNull(String string) {
    return string == null || string.isEmpty() ? null : string;
  }",Returns null if the string is empty.
"@Override
    public EnhanceEntity findById(Object primaryKey, EntityMetadata m, Client client)
    {
        List<String> relationNames = m.getRelationNames();
        if (relationNames != null && !relationNames.isEmpty())
        {
            Set<String> keys = new HashSet<String>(1);
            keys.add(primaryKey.toString());
            String query = getSqlQueryFromJPA(m, relationNames, keys);
            List<EnhanceEntity> results = populateEnhanceEntities(m, relationNames, client, query);
            return results != null && !results.isEmpty() ? results.get(0) : null;
        }
        else
        {
            Object o;
            try
            {
                o = client.find(m.getEntityClazz(), primaryKey);
            }
            catch (Exception e)
            {
                throw new PersistenceException(e);
            }
            return o != null ? new EnhanceEntity(o, getId(o, m), null) : null;
        }

        // return super.findById(primaryKey, m, client);
    }",Override findById to retrieve an entity from database.
"public IOProvider.Readable getIOProviderFrom(String name, AbstractClassLoader first) {
		if (name.length() == 0) return null;
		if (name.charAt(0) == '/') name = name.substring(1);
		IOProvider.Readable provider = null;
    	// try with the first one
    	if (first != null)
   			provider = first.get(name);
    	// then, try on other libraries
    	if (provider == null) {
        	for (int i = 0; i < libs.size(); i++) {
        		AbstractClassLoader cl = libs.get(i);
        		if (cl == first) continue;
       			provider = cl.get(name);
        		if (provider != null) break;
        	}
        }
        if (provider != null)
        	return provider;
       	// then try on the core one
        return coreIOProvider.get(name);
	}",Gets the IOProvider from the given name.
"public VALUEFROM decodeFromRaw(Object o) {
        if (o == null && !isOptional()) return null;
        return decodeFromRawInternal(o);
    }",Decode a raw object to a value from the IDE.
"protected void checkLPSEnablement() {
        if (tc.isEntryEnabled())
            Tr.entry(tc, ""checkLPSEnablement"");

        // If this is in a tran enabled for LPS via beginLPSEnabledTx return without
        // checking for LPS enablement
        if (_LPSEnabledTx) {
            if (tc.isEntryEnabled())
                Tr.exit(tc, ""checkLPSEnablement - LPSEnabledTx"");
            return;
        }

        final boolean debug = tc.isDebugEnabled();

        // If we are not debugging and LPS is disabled, return immediately.
        if (!debug) {
            if (_LPSProhibited) {
                if (tc.isEntryEnabled())
                    Tr.exit(tc, ""checkLPSEnablement"");
                return;
            }
        }

        final boolean isLPSEnabled = _transaction._configProvider.getRuntimeMetaDataProvider().isHeuristicHazardAccepted();

        if (debug)
            Tr.debug(tc, ""LPSEnabled"", isLPSEnabled);

        // If this application does not allow the LPS function then ensure that we record
        // this fact. This flag will remain false until the first application that does
        // not allow LPS drives an enlist. At this point it will be set to true and is
        // not changed back to false.
        if (!isLPSEnabled) {
            _LPSProhibited = true;
        }

        if (tc.isEntryEnabled())
            Tr.exit(tc, ""checkLPSEnablement : LPSEnabled="" + isLPSEnabled + "" LPSProhibited="" + _LPSProhibited);
    }",Check if LPS is enabled for this application.
"@SuppressWarnings(""unchecked"")
    public static <T> T[] tail(T[] self) {
        if (self.length == 0) {
            throw new NoSuchElementException(""Cannot access tail() for an empty array"");
        }
        T[] result = createSimilarArray(self, self.length - 1);
        System.arraycopy(self, 1, result, 0, self.length - 1);
        return result;
    }",Returns a copy of the array of the class level elements of the specified array.
"public synchronized void checkIfCreateNonPersistentTimerAllowed(EJBModuleMetaDataImpl mmd) {
        if (ivStopping) {
            throw new EJBStoppedException(ivName);
        }

        if (mmd != null && mmd.ivStopping) {
            throw new EJBStoppedException(mmd.getJ2EEName().toString());
        }
    }",check if create non persistent timer is allowed
"private JSONObject getNodeConfig() {
    JSONObject res = new JSONObject();
    try {
      res.put(""class"", ""org.openqa.grid.common.RegistrationRequest"");
      res.put(""configuration"", getConfiguration());
      JSONArray caps = new JSONArray();
      JSONArray devices = driver.getSupportedDevices();
      for (int i = 0; i < devices.length(); i++) {
        JSONObject device = (JSONObject) devices.get(i);
        for (int x = 0; x < driver.getSupportedApps().length(); x++) {
          caps.put(getDeviceConfig(device, driver.getSupportedApps().getJSONObject(x)));
        }
      }
      res.put(""capabilities"", caps);
    } catch (JSONException e) {
      throw new SelendroidException(e.getMessage(), e);
    }
    return res;
  }",Get the node configuration
"public boolean delete(String geoPackage, String tableName, long id) {
        return delete(getGeoPackageId(geoPackage), tableName, id);
    }",Delete a single record from a GeoPackage table.
"@SuppressWarnings({""unchecked""})
    public static <T> T[] arrayOf(T firstElement, T... moreElements) {
        checkArgNotNull(moreElements, ""moreElements"");
        Class elementType = moreElements.getClass().getComponentType();
        T[] array = (T[]) Array.newInstance(elementType, moreElements.length + 1);
        array[0] = firstElement;
        System.arraycopy(moreElements, 0, array, 1, moreElements.length);
        return array;
    }",Create an array of the type specified by the first element and the more elements.
"public static String getEventName(String channelName) {
        int i = channelName.indexOf(EVENT_PREFIX);
        return i < 0 ? channelName : channelName.substring(i + EVENT_PREFIX.length());
    }",Get the event name from a channel name.
"public static void readShape(Connection connection, String fileName, String tableReference,String forceEncoding) throws IOException, SQLException {
        File file = URIUtilities.fileFromString(fileName);
        if (FileUtil.isFileImportable(file, ""shp"")) {
            SHPDriverFunction shpDriverFunction = new SHPDriverFunction();
            shpDriverFunction.importFile(connection, TableLocation.parse(tableReference, true).toString(true),
                    file, new EmptyProgressVisitor(), forceEncoding);
        }
    }",Read a shape from a file.
"private static void recursiveFindBadNodesInTable(Node n, Node cellroot, Vector<Node> nodes)
    {
        Node cell = cellroot;
        
        if (n.getNodeType() == Node.ELEMENT_NODE)
        {
            String tag = n.getNodeName();
            if (tag.equalsIgnoreCase(""table""))
            {
                if (cell != null) //do not enter nested tables
                    return;
            }
            else if (tag.equalsIgnoreCase(""tbody"") || 
                     tag.equalsIgnoreCase(""thead"") || 
                     tag.equalsIgnoreCase(""tfoot"") ||
                     tag.equalsIgnoreCase(""tr"") ||
                     tag.equalsIgnoreCase(""col"") ||
                     tag.equalsIgnoreCase(""colgroup""))
            {
            }
            else if (tag.equalsIgnoreCase(""td"") || tag.equalsIgnoreCase(""th"") || tag.equalsIgnoreCase(""caption""))
            {
                cell = n;
            }
            else //other elements
            {
                if (cell == null)
                {
                    nodes.add(n);
                    return;
                }
            }
        } //other nodes
        else if (n.getNodeType() == Node.TEXT_NODE)
        {
            if (cell == null && n.getNodeValue().trim().length() > 0)
            {
                nodes.add(n);
                return;
            }
        }
        
        NodeList child = n.getChildNodes();
        for (int i = 0; i < child.getLength(); i++)
            recursiveFindBadNodesInTable(child.item(i), cell, nodes);
    }",Recursive method to find bad nodes in table.
"@Override
  public NamingRegisterRequest decode(final byte[] buf) {
    final AvroNamingRegisterRequest avroNamingRegisterRequest =
        AvroUtils.fromBytes(buf, AvroNamingRegisterRequest.class);
    return new NamingRegisterRequest(
        new NameAssignmentTuple(factory.getNewInstance(avroNamingRegisterRequest.getId().toString()),
            new InetSocketAddress(avroNamingRegisterRequest.getHost().toString(), avroNamingRegisterRequest.getPort()))
    );
  }",Decode a NamingRegisterRequest from bytes.
"public List<String> getCategories(){
		List<String> categories = FieldUtil.getCategories(getField());

		if(categories != null && !categories.isEmpty()){
			return categories;
		}

		return null;
	}",Get the categories of this field.
"private File createJar( List<String> classPath, String mainClass )
        throws IOException
    {
        File file = File.createTempFile( ""maven-exec"", "".jar"" );
        file.deleteOnExit();
        FileOutputStream fos = new FileOutputStream( file );
        JarOutputStream jos = new JarOutputStream( fos );
        jos.setLevel( JarOutputStream.STORED );
        JarEntry je = new JarEntry( ""META-INF/MANIFEST.MF"" );
        jos.putNextEntry( je );

        Manifest man = new Manifest();

        // we can't use StringUtils.join here since we need to add a '/' to
        // the end of directory entries - otherwise the jvm will ignore them.
        StringBuilder cp = new StringBuilder();
        for ( String el : classPath )
        {
            // NOTE: if File points to a directory, this entry MUST end in '/'.
            cp.append( new URL( new File( el ).toURI().toASCIIString() ).toExternalForm() + "" "" );
        }

        man.getMainAttributes().putValue( ""Manifest-Version"", ""1.0"" );
        man.getMainAttributes().putValue( ""Class-Path"", cp.toString().trim() );
        man.getMainAttributes().putValue( ""Main-Class"", mainClass );

        man.write( jos );
        jos.close();

        return file;
    }",Create a jar file with the specified class path and main class.
"public I_CmsExtractionResult extractContent(
        CmsObject cms,
        CmsResource resource,
        I_CmsSearchIndex index,
        Locale forceLocale)
    throws CmsException {

        logContentExtraction(resource, index);
        I_CmsExtractionResult ex = null;
        try {
            CmsFile file = readFile(cms, resource);
            CmsXmlContainerPage containerPage = CmsXmlContainerPageFactory.unmarshal(cms, file);

            List<I_CmsExtractionResult> all = new ArrayList<I_CmsExtractionResult>();
            CmsContainerPageBean containerBean = containerPage.getContainerPage(cms);
            if (containerBean != null) {
                for (CmsContainerElementBean element : containerBean.getElements()) {
                    // check all elements in this container
                    // get the formatter configuration for this element
                    try {
                        element.initResource(cms);
                        CmsResource elementResource = element.getResource();
                        if (!(cms.readProject(index.getProject()).isOnlineProject()
                            && elementResource.isExpired(System.currentTimeMillis()))) {
                            CmsADEConfigData adeConfig = OpenCms.getADEManager().lookupConfiguration(
                                cms,
                                file.getRootPath());
                            CmsFormatterConfiguration formatters = adeConfig.getFormatters(cms, element.getResource());
                            if ((formatters != null)
                                && (element.getFormatterId() != null)
                                && formatters.isSearchContent(element.getFormatterId())) {
                                // the content of this element must be included for the container page
                                all.add(
                                    CmsSolrDocumentXmlContent.extractXmlContent(
                                        cms,
                                        elementResource,
                                        index,
                                        forceLocale));
                            }
                        }
                    } catch (CmsException e) {
                        LOG.debug(
                            Messages.get().getBundle().key(
                                Messages.LOG_SKIPPING_CONTAINERPAGE_ELEMENT_WITH_UNREADABLE_RESOURCE_2,
                                file.getRootPath(),
                                element.getId()),
                            e);
                    }
                }
            }
            // we have to overwrite the resource and content locales with the one from this container page
            // TODO: Is this really the wanted behavior? It seems to be done like this before.
            Map<String, String> fieldMappings = new HashMap<String, String>(1);
            // Add to each container page the contents in all available locales,
            // in case one containerpage is used in multiple languages.
            List<Locale> localesAvailable = OpenCms.getLocaleManager().getAvailableLocales(cms, resource);
            Map<Locale, LinkedHashMap<String, String>> multilingualValues = new HashMap<Locale, LinkedHashMap<String, String>>(
                localesAvailable.size());
            for (Locale localeAvailable : localesAvailable) {
                multilingualValues.put(localeAvailable, new LinkedHashMap<String, String>());
            }
            Locale locale = forceLocale != null
            ? forceLocale
            : index.getLocaleForResource(cms, resource, containerPage.getLocales());
            ex = new CmsExtractionResult(locale, multilingualValues, fieldMappings);
            ex = ex.merge(all);
            return ex;
        } catch (Exception e) {
            throw new CmsIndexException(
                Messages.get().container(Messages.ERR_TEXT_EXTRACTION_1, resource.getRootPath()),
                e);
        }
    }",Extracts the content of a single resource from the OpenCms VFS.
"public static <E> E notNull(E obj, String msg) {
        if (obj == null) {
            throw (msg == null) ? new NullPointerException() : new NullPointerException(msg);
        }
        return obj;
    }",This method checks if the object is not null.
"public static void e(String msg, Element element) {
		messager.printMessage(Diagnostic.Kind.ERROR, msg, element);
	}",Print an error message.
"private static boolean polygonContainsMultiPoint_(Polygon polygon_a,
			MultiPoint multipoint_b, double tolerance,
			ProgressTracker progress_tracker) {
		Envelope2D env_a = new Envelope2D(), env_b = new Envelope2D();
		polygon_a.queryEnvelope2D(env_a);
		multipoint_b.queryEnvelope2D(env_b);

		// Quick envelope rejection test for false equality.
		if (!envelopeInfContainsEnvelope_(env_a, env_b, tolerance))
			return false;

		// Quick rasterize test to see whether the the geometries are disjoint,
		// or if one is contained in the other.
		int relation = tryRasterizedContainsOrDisjoint_(polygon_a,
				multipoint_b, tolerance, false);

		if (relation == Relation.disjoint)
			return false;

		if (relation == Relation.contains)
			return true;

        boolean b_interior = false;
        Point2D ptB;

        MultiPathImpl polygon_a_impl = (MultiPathImpl)polygon_a._getImpl();

        Polygon pa = null;
        Polygon p_polygon_a = polygon_a;

        boolean b_checked_polygon_a_quad_tree = false;

        for (int i = 0; i < multipoint_b.getPointCount(); i++)
        {
            ptB = multipoint_b.getXY(i);

            if (!env_a.contains(ptB))
                return false;

            PolygonUtils.PiPResult result = PolygonUtils.isPointInPolygon2D(p_polygon_a, ptB, tolerance);

            if (result == PolygonUtils.PiPResult.PiPInside)
                b_interior = true;
            else if (result == PolygonUtils.PiPResult.PiPOutside)
                return false;

            if (!b_checked_polygon_a_quad_tree) {
                if (PointInPolygonHelper.quadTreeWillHelp(polygon_a, multipoint_b.getPointCount() - 1) && (polygon_a_impl._getAccelerators() == null || polygon_a_impl._getAccelerators().getQuadTree() == null)) {
                    pa = new Polygon();
                    polygon_a.copyTo(pa);
                    ((MultiPathImpl) pa._getImpl())._buildQuadTreeAccelerator(Geometry.GeometryAccelerationDegree.enumMedium);
                    p_polygon_a = pa;
                } else {
                    p_polygon_a = polygon_a;
                }

                b_checked_polygon_a_quad_tree = true;
            }
        }

        return b_interior;
	}",Returns true if polygon_a contains multipoint_b.
"public static File getCanonicalFile(final File file) {

        // Check sanity
        Validate.notNull(file, ""file"");

        // All done
        try {
            return file.getCanonicalFile();
        } catch (IOException e) {
            throw new IllegalArgumentException(""Could not acquire the canonical file for [""
                    + file.getAbsolutePath() + ""]"", e);
        }
    }",Get the canonical file for a file.
"public void removeSprite (Sprite sprite)
    {
        _metamgr.removeSprite(sprite);

        if (((sprite instanceof ActionSprite) ||
             (sprite instanceof HoverSprite)) && (--_actionSpriteCount == 0)) {
            removeMouseListener(_actionHandler);
            removeMouseMotionListener(_actionHandler);
        }
    }",Removes a sprite from the image.
"public static int indexOfDifference(String[] strs) {
        if (strs == null || strs.length <= 1) {
            return INDEX_NOT_FOUND;
        }
        boolean anyStringNull = false;
        boolean allStringsNull = true;
        int arrayLen = strs.length;
        int shortestStrLen = Integer.MAX_VALUE;
        int longestStrLen = 0;

        // find the min and max string lengths; this avoids checking to make
        // sure we are not exceeding the length of the string each time through
        // the bottom loop.
        for (int i = 0; i < arrayLen; i++) {
            if (strs[i] == null) {
                anyStringNull = true;
                shortestStrLen = 0;
            } else {
                allStringsNull = false;
                shortestStrLen = Math.min(strs[i].length(), shortestStrLen);
                longestStrLen = Math.max(strs[i].length(), longestStrLen);
            }
        }

        // handle lists containing all nulls or all empty strings
        if (allStringsNull || (longestStrLen == 0 && !anyStringNull)) {
            return INDEX_NOT_FOUND;
        }

        // handle lists containing some nulls or some empty strings
        if (shortestStrLen == 0) {
            return 0;
        }

        // find the position with the first difference across all strings
        int firstDiff = -1;
        for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {
            char comparisonChar = strs[0].charAt(stringPos);
            for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {
                if (strs[arrayPos].charAt(stringPos) != comparisonChar) {
                    firstDiff = stringPos;
                    break;
                }
            }
            if (firstDiff != -1) {
                break;
            }
        }

        if (firstDiff == -1 && shortestStrLen != longestStrLen) {
            // we compared all of the characters up to the length of the
            // shortest string and didn't find a match, but the string lengths
            // vary, so return the length of the shortest string.
            return shortestStrLen;
        }
        return firstDiff;
    }",Returns the index of the first difference between the two strings in the array.
"public static List<CPDefinition> findByUuid_C(String uuid, long companyId) {
		return getPersistence().findByUuid_C(uuid, companyId);
	}",Returns the cp definitions matching the UUID and company.
"public void marshall(EnableAWSOrganizationsAccessRequest enableAWSOrganizationsAccessRequest, ProtocolMarshaller protocolMarshaller) {

        if (enableAWSOrganizationsAccessRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",Creates a protocolMarshaller instance for the ANSPECIAL_Service object.
"DownloadState query(Uri uri) {
    synchronized (currentRequests) {
      for (DownloadRequest request : currentRequests) {
        if (request.uri().toString().equals(uri.toString())) {
          return request.downloadState();
        }
      }
    }

    return DownloadState.INVALID;
  }",Query for download state
"@Nonnull
  public ClassLoader getClassLoader ()
  {
    return m_aBestCandidate == null ? Thread.currentThread ().getContextClassLoader ()
                                    : m_aBestCandidate.getClassLoader ();
  }",Get the class loader for the best candidate.
"private void populateMetaData() throws SQLException
   {
      m_meta.clear();

      ResultSetMetaData meta = m_rs.getMetaData();
      int columnCount = meta.getColumnCount() + 1;
      for (int loop = 1; loop < columnCount; loop++)
      {
         String name = meta.getColumnName(loop);
         Integer type = Integer.valueOf(meta.getColumnType(loop));
         m_meta.put(name, type);
      }
   }",Populates the meta data.
"public static InputStream decrypt(InputStream inputStream, byte[] key) {
        checkNotNull(inputStream);
        checkNotNull(key);
        AESFastEngine aesEngine = new AESFastEngine();
        PaddedBufferedBlockCipher cipher =
                new PaddedBufferedBlockCipher(aesEngine, new PKCS7Padding());
        cipher.init(false, new KeyParameter(key));
        return new CipherInputStream(inputStream, cipher);
    }",Decrypt an input stream using the specified key.
"@SuppressWarnings(""unchecked"")
	private <T> T createMockResultOfCall() throws IOException {
		final Object result;
		final String request = url.toString();
		if (!request.contains(HttpParameter.PART.getName() + '=')
				&& !request.contains(HttpParameter.JMX_VALUE.getName())
				|| request.contains(HttpPart.DEFAULT_WITH_CURRENT_REQUESTS.getName())) {
			final String message = request.contains(""/test2"") ? null
					: ""ceci est message pour le rapport"";
			result = Arrays.asList(new Counter(Counter.HTTP_COUNTER_NAME, null),
					new Counter(""services"", null), new Counter(Counter.ERROR_COUNTER_NAME, null),
					new JavaInformations(null, true), message);
		} else {
			result = LabradorMock.createMockResultOfPartCall(request);
		}
		return (T) result;
	}","Creates mock result of
	."
"@Pure
	public Iterable<BusItineraryHalt> busHalts() {
		final MultiCollection<BusItineraryHalt> halts = new MultiCollection<>();
		halts.addCollection(this.validHalts);
		halts.addCollection(this.invalidHalts);
		return Collections.unmodifiableCollection(halts);
	}",Replies the bus halts.
"protected File createSREManifestFile(File filename) throws MojoExecutionException, MojoFailureException {
		try {
			final Manifest manifest = createSREManifest();
			final File manifestFile;
			if (filename == null) {
				final File parent = new File(getMavenProject().getBuild().getOutputDirectory());
				manifestFile = new File(parent.getParentFile(), ""SRE-MANIFEST.MF""); //$NON-NLS-1$
			} else {
				manifestFile = filename;
			}

			try (FileOutputStream fos = new FileOutputStream(manifestFile)) {
				manifest.write(fos);
			}

			return manifestFile;
		} catch (MojoFailureException exception) {
			throw exception;
		} catch (IOException exception) {
			throw new MojoFailureException(exception.getLocalizedMessage(), exception);
		}
	}",Creates the SRE manifest file.
"public boolean removeKey(long key) {
	int i = indexOfKey(key);
	if (i<0) return false; // key not contained

	this.state[i]=REMOVED;
	this.values[i]=0; // delta
	this.distinct--;

	if (this.distinct < this.lowWaterMark) {
		int newCapacity = chooseShrinkCapacity(this.distinct,this.minLoadFactor, this.maxLoadFactor);
		rehash(newCapacity);
	}
	
	return true;	
}",Removes the specified key from this map.
"private DataSet doFixedLengthFile(final Reader dataSource) throws IOException {

        final DefaultDataSet ds = new DefaultDataSet(getPzMetaData(), this);

        try (BufferedReader br = new BufferedReader(dataSource)) {
            // gather the conversion properties
            ds.setPZConvertProps(ParserUtils.loadConvertProperties());

            final Map<String, Integer> recordLengths = ParserUtils.calculateRecordLengths(getPzMetaData());

            // Read in the flat file
            String line = null;
            int lineCount = 0;
            // map of record lengths corresponding to the ID's in the columnMD
            // array loop through each line in the file
            while ((line = br.readLine()) != null) {
                lineCount++;
                // empty line skip past it
                if (line.trim().length() == 0) {
                    continue;
                }

                final String mdkey = FixedWidthParserUtils.getCMDKey(getPzMetaData(), line);
                final int recordLength = recordLengths.get(mdkey);

                if (line.length() > recordLength) {
                    // Incorrect record length on line log the error. Line will not
                    // be included in the
                    // dataset
                    if (isIgnoreExtraColumns()) {
                        // user has choosen to ignore the fact that we have too many bytes in the fixed
                        // width file. Truncate the line to the correct length
                        line = line.substring(0, recordLength);
                        addError(ds, ""TRUNCATED LINE TO CORRECT LENGTH"", lineCount, 1);
                    } else {
                        addError(ds, ""LINE TOO LONG. LINE IS "" + line.length() + "" LONG. SHOULD BE "" + recordLength, lineCount, 2,
                                isStoreRawDataToDataError() ? line : null);
                        continue;
                    }
                } else if (line.length() < recordLength) {
                    if (isHandlingShortLines()) {
                        // We can pad this line out
                        line += ParserUtils.padding(recordLength - line.length(), ' ');

                        // log a warning
                        addError(ds, ""PADDED LINE TO CORRECT RECORD LENGTH"", lineCount, 1);

                    } else {
                        addError(ds, ""LINE TOO SHORT. LINE IS "" + line.length() + "" LONG. SHOULD BE "" + recordLength, lineCount, 2,
                                isStoreRawDataToDataError() ? line : null);
                        continue;
                    }
                }

                final Row row = new Row();
                row.setMdkey(mdkey.equals(FPConstants.DETAIL_ID) ? null : mdkey); // try

                final List<ColumnMetaData> cmds = ParserUtils.getColumnMetaData(mdkey, getPzMetaData());
                row.addColumn(FixedWidthParserUtils.splitFixedText(cmds, line, isPreserveLeadingWhitespace(), isPreserveTrailingWhitespace()));
                row.setRowNumber(lineCount);

                if (isFlagEmptyRows()) {
                    // user has elected to have the parser flag rows that are empty
                    row.setEmpty(ParserUtils.isListElementsEmpty(row.getCols()));
                }
                if (isStoreRawDataToDataSet()) {
                    // user told the parser to keep a copy of the raw data in the row
                    // WARNING potential for high memory usage here
                    row.setRawData(line);
                }

                // add the row to the array
                ds.addRow(row);
            }
        } finally {
            closeReaders();
        }
        return ds;
    }",Read the data set from the fixed length file.
"@Override
    public void setUsers(final String[] theUsers) {
        mUsers = theUsers;
        // Cleanup new line and ws
        for (int i = 0; i < theUsers.length; i++) {
            mUsers[i] = mUsers[i].trim();
        }
    }",Sets the users.
"public static void removeBottomSeparators(JPopupMenu popupMenu) {
        int indexLastComponent = popupMenu.getComponentCount() - 1;
        while (indexLastComponent >= 0 && isPopupMenuSeparator(popupMenu.getComponent(indexLastComponent))) {
            popupMenu.remove(indexLastComponent);
            indexLastComponent -= 1;
        }
    }",Remove bottom separators from popup menu.
"public static boolean isGreaterOrEqual(BigDecimal bigNum1, BigDecimal bigNum2) {
		Assert.notNull(bigNum1);
		Assert.notNull(bigNum2);
		return bigNum1.compareTo(bigNum2) >= 0;
	}",Checks if the first argument is greater than or equal to the second argument.
"public static String packValues(List<String> unpackedValues) {
        if (hasItems(unpackedValues)) {
            final Iterator<String> it = unpackedValues.iterator();
            final StringBuilder b = new StringBuilder();
            while (it.hasNext()) {
                b.append(it.next());
                if (it.hasNext()) {
                    b.append(PACKED_VALUES_DELIMITER);
                }
            }

            return b.toString();
        }

        return null;
    }",Pack the values in a list of strings into a string.
"@Override
	public Tuple2<Long,Long> getCurrentState() throws IOException {
		return new Tuple2<>(this.stream.getPos(), this.currentTransactionCounterInBlock);
	}",Returns the current state of the block.
"public static Tag uri(RequestEvent event) {
        ContainerResponse response = event.getContainerResponse();
        if (response != null) {
            int status = response.getStatus();
            if (isRedirection(status)) {
                return URI_REDIRECTION;
            }
            if (status == 404) {
                return URI_NOT_FOUND;
            }
        }
        String matchingPattern = getMatchingPattern(event);
        if (matchingPattern.equals(""/"")) {
            return URI_ROOT;
        }
        return Tag.of(""uri"", matchingPattern);
    }",Get the uri tag from the request event.
"private static byte[] idInBytes(final short idwidth, final long lid) {
    if (idwidth <= 0) {
      throw new AssertionError(""negative idwidth: "" + idwidth);
    }
    final byte[] id = Bytes.fromLong(lid);
    for (int i = 0; i < id.length - idwidth; i++) {
      if (id[i] != 0) {
        System.err.println(lid + "" is too large to fit on "" + idwidth
            + "" bytes.  Maybe you forgot to adjust --idwidth?"");
        return null;
      }
    }
    return Arrays.copyOfRange(id, id.length - idwidth, id.length);
  }",ID in bytes.
"protected ItemState getLastItemState(String identifer)
   {
      List<ItemState> allStates = changesLog.getAllStates();
      for (int i = allStates.size() - 1; i >= 0; i--)
      {
         ItemState state = allStates.get(i);
         if (state.getData().getIdentifier().equals(identifer))
            return state;
      }
      return null;
   }",Get the last item state from changes log
"@Override
    final public ManagedConnection matchManagedConnections(
                                                           final Set connectionSet, final Subject subject,
                                                           final ConnectionRequestInfo requestInfo) {

        if (TraceComponent.isAnyTracingEnabled() && TRACE.isEntryEnabled()) {
            SibTr.entry(TRACE, ""matchManagedConnections"", new Object[] {
                                                                        connectionSet,
                                                                        JmsJcaManagedConnection.subjectToString(subject),
                                                                        requestInfo });
        }

        final SICoreConnection coreConnection = (requestInfo instanceof JmsJcaConnectionRequestInfo) ? ((JmsJcaConnectionRequestInfo) requestInfo)
                        .getSICoreConnection()
                        : null;

        final JmsJcaUserDetails userDetails = getUserDetails(subject,
                                                             requestInfo);

        if (TraceComponent.isAnyTracingEnabled() && TRACE.isDebugEnabled()) {

            if (userDetails != null) {
                SibTr.debug(TRACE, ""Got a username and password"");
            } else {
                SibTr.debug(TRACE, ""Using subject"");
            }

        }

        JmsJcaManagedConnection matchedConnection = null;

        // Go through the set of managed connections and try and match one

        for (final Iterator iterator = connectionSet.iterator(); iterator
                        .hasNext();) {

            final Object object = iterator.next();

            // Skip over any non JmsJcaManagedConnections
            if (object instanceof JmsJcaManagedConnection) {

                final JmsJcaManagedConnection managedConnection = (JmsJcaManagedConnection) object;

                // If we have a user name and password from either the
                // requestInfo or subject then we must try and match againgst
                // those
                if (userDetails != null) {

                    if (managedConnection.match(userDetails, coreConnection)) {

                        matchedConnection = managedConnection;
                        if (TraceComponent.isAnyTracingEnabled() && TRACE.isDebugEnabled()) {
                            SibTr
                                            .debug(TRACE,
                                                   ""Matched a connection against the subject username and password"");
                        }
                        break;

                    }

                } else {

                    // This is a subject where we couldnt get the userName and
                    // password from..

                    if (managedConnection.match(subject, coreConnection)) {

                        matchedConnection = managedConnection;
                        if (TraceComponent.isAnyTracingEnabled() && TRACE.isDebugEnabled()) {
                            SibTr.debug(TRACE,
                                        ""Matched a connection against the subject"");
                        }
                        break;

                    }

                }
            }
        }

        if (TraceComponent.isAnyTracingEnabled() && TRACE.isEntryEnabled()) {
            SibTr.exit(TRACE, ""matchManagedConnections"", matchedConnection);
        }
        return matchedConnection;

    }",Match a set of managed connections against a subject.
"private static <K, V> void log(RedwoodChannels channels, String description, Map<K, V> mapping) {
    Redwood.startTrack(description);
    if (mapping == null) {
      channels.log(""(mapping is null)"");
    } else if (mapping.size() == 0) {
      channels.log(""(empty)"");
    } else {
      // convert keys to sorted list, if possible
      List<K> keys = new LinkedList<K>();
      for (K key : mapping.keySet()) {
        keys.add(key);
      }
      Collections.sort(keys, new Comparator<K>() {
        @SuppressWarnings(""unchecked"")
        public int compare(K a, K b) {
          if (a != null && Comparable.class.isAssignableFrom(a.getClass())) {
            return ((Comparable) a).compareTo(b);
          } else {
            return 0;
          }
        }
      });
      // log key/value pairs
      int entryCounter = 0;
      for (K key : keys) {
        V value = mapping.get(key);
        if (!dispatchable(key) && dispatchable(value)) {
          log(channels, key.toString(), value);
        } else if (dispatchable(key) || dispatchable(value)) {
          Redwood.startTrack(""Entry "" + entryCounter);
          if (dispatchable(key)) {
            log(channels, ""Key"", key);
          } else {
            channels.logf(""Key %s"", key);
          }

          if (dispatchable(value)) {
            log(channels, ""Value"", value);
          } else {
            channels.logf(""Value %s"", value);
          }
          Redwood.endTrack(""Entry "" + entryCounter);
        } else {
          channels.logf(""%s = %s"", key, value);
        }
        entryCounter++;
      }
    }
    Redwood.endTrack(description);
  }",Logs the specified description and mapping.
"private void addNormalizationRollback(CodeBuilder b, Label doTryStart,
                                          List<PropertyCopy> unnormalized)
    {
        if (unnormalized == null) {
            return;
        }

        Label doTryEnd = b.createLabel().setLocation();

        b.dup();
        Label success = b.createLabel();
        b.ifZeroComparisonBranch(success, ""!="");

        for (int i=0; i<2; i++) {
            if (i == 0) {
            } else {
                b.exceptionHandler(doTryStart, doTryEnd, null);
            }
            // Rollback normalized properties.
            for (PropertyCopy copy : unnormalized) {
                copy.restore(b);
            }
            if (i == 0) {
                b.branch(success);
            } else {
                b.throwObject();
            }
        }

        success.setLocation();
    }",Add normalizing rollback for a single entry.
"private String createKeyDefinition(final List<FieldDefinition> keyDefinitionList) {
        final StringBuilder sql = new StringBuilder();

        sql.append("" PRIMARY KEY"");
        boolean isFirst = true;

        for (FieldDefinition fieldDefinition : keyDefinitionList) {
            if (isFirst) {
                sql.append(""("");
                isFirst = false;
            } else {
                sql.append("","");
            }

            sql.append(fieldDefinition.getName());
        }

        sql.append("")"");
        return sql.toString();
    }",Create a key definition.
"public static List<IdName> getParameterValues(Connection con, QueryParameter qp, Map<String, QueryParameter> map,
                                                  Map<String, Serializable> vals) throws Exception {    	    	

        Map<String, Object> objVals = new HashMap<String, Object>();
        for (String key : vals.keySet()) {
            Serializable s = vals.get(key);
            if (s instanceof Serializable[]) {
                Serializable[] array = (Serializable[]) s;
                Object[] objArray = new Object[array.length];
                for (int i = 0, size = array.length; i < size; i++) {
                    objArray[i] = array[i];
                }
                s = objArray;
            }
            objVals.put(key, s);            
        }

        QueryExecutor executor = null;
        try {
            List<IdName> values = new ArrayList<IdName>();
            
            Query query = new Query(qp.getSource());
            executor = new QueryExecutor(query, map, objVals, con, false, false, false);
            executor.setTimeout(10000);
            executor.setMaxRows(0);
            QueryResult qr = executor.execute();
            //int count = qr.getRowCount();

            // one or two columns in manual select source
            //for (int i = 0; i < count; i++) {
            while (qr.hasNext()) {
                IdName in = new IdName();
                in.setId((Serializable) qr.nextValue(0));
                if (qr.getColumnCount() == 1) {
                    in.setName((Serializable) qr.nextValue(0));
                } else {
                    in.setName((Serializable) qr.nextValue(1));
                }
                values.add(in);
            }
            return values;
        } catch (Exception ex) {
            ex.printStackTrace();
            throw new Exception(ex);
        } finally {
        	if (executor != null)  {
        		executor.close();
        	}
        }
    }",Get parameter values.
"public Observable<ServiceResponse<List<EntityRole>>> getHierarchicalEntityRolesWithServiceResponseAsync(UUID appId, String versionId, UUID hEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException(""Parameter this.client.endpoint() is required and cannot be null."");
        }
        if (appId == null) {
            throw new IllegalArgumentException(""Parameter appId is required and cannot be null."");
        }
        if (versionId == null) {
            throw new IllegalArgumentException(""Parameter versionId is required and cannot be null."");
        }
        if (hEntityId == null) {
            throw new IllegalArgumentException(""Parameter hEntityId is required and cannot be null."");
        }
        String parameterizedHost = Joiner.on("", "").join(""{Endpoint}"", this.client.endpoint());
        return service.getHierarchicalEntityRoles(appId, versionId, hEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<EntityRole>>>>() {
                @Override
                public Observable<ServiceResponse<List<EntityRole>>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<List<EntityRole>> clientResponse = getHierarchicalEntityRolesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }",Gets the roles of a hierarchical entity.
"@Override
  public void writeMmap(long mmapAddress,
                        long []mmapBlocks,
                        long mmapOffset,
                        long mmapLength)
    throws IOException
  {
    _socket.writeMmap(mmapAddress, mmapBlocks, mmapOffset, mmapLength);
  }",Override this method to write a single mmap block to the underlying socket.
"@BetaApi
  public final Operation recreateInstancesRegionInstanceGroupManager(
      String instanceGroupManager,
      RegionInstanceGroupManagersRecreateRequest
          regionInstanceGroupManagersRecreateRequestResource) {

    RecreateInstancesRegionInstanceGroupManagerHttpRequest request =
        RecreateInstancesRegionInstanceGroupManagerHttpRequest.newBuilder()
            .setInstanceGroupManager(instanceGroupManager)
            .setRegionInstanceGroupManagersRecreateRequestResource(
                regionInstanceGroupManagersRecreateRequestResource)
            .build();
    return recreateInstancesRegionInstanceGroupManager(request);
  }",Recreate instances region group manager in the specified request.
"@Beta
    public static <E extends Throwable> void check(boolean condition, E throwable) throws E {
        checkArgument(throwable != null, ""Expected non-null reference"");
        if (!condition) {
            throw throwable;
        }
    }",Checks if the exception is a problem with the exception.
"@Deprecated
	public static <S, T extends Plugin<S>> OrderAwarePluginRegistry<T, S> create(List<? extends T> plugins) {
		return of(plugins, DEFAULT_COMPARATOR);
	}",Create an ordered registry of the given plugins.
"@Override
    public AdminGetUserResult adminGetUser(AdminGetUserRequest request) {
        request = beforeClientExecution(request);
        return executeAdminGetUser(request);
    }",Returns information about an administrator user.
"public static CommerceCountry fetchByG_N(long groupId, int numericISOCode,
		boolean retrieveFromCache) {
		return getPersistence()
				   .fetchByG_N(groupId, numericISOCode, retrieveFromCache);
	}",Returns the commerce country with the matching numeric ISO code from the database.
"public static boolean deleteAttachment(Attachment attachment) {
        File attachmentFile = new File(getResultsDirectory(), attachment.getSource());
        return attachmentFile.exists() && attachmentFile.canWrite() && attachmentFile.delete();
    }",Delete an attachment.
"private void initComponents() {

        jTabbedPane6 = new javax.swing.JTabbedPane();
        jPanel2 = new javax.swing.JPanel();
        jTabbedPane3 = new javax.swing.JTabbedPane();
        jScrollPane7 = new javax.swing.JScrollPane();
        jTextArea7 = new javax.swing.JTextArea();
        jTabbedPane1 = new javax.swing.JTabbedPane();
        jScrollPane3 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jLabel2 = new javax.swing.JLabel();
        jTabbedPane2 = new javax.swing.JTabbedPane();
        jScrollPane4 = new javax.swing.JScrollPane();
        jTextArea4 = new javax.swing.JTextArea();
        jTabbedPane4 = new javax.swing.JTabbedPane();
        jScrollPane5 = new javax.swing.JScrollPane();
        jTextArea5 = new javax.swing.JTextArea();
        jTabbedPane5 = new javax.swing.JTabbedPane();
        jScrollPane6 = new javax.swing.JScrollPane();
        jTextArea6 = new javax.swing.JTextArea();
        jButton2 = new javax.swing.JButton();
        jTextField1 = new HistoryComboBox();
        jButton4 = new javax.swing.JButton();
        jButton5 = new javax.swing.JButton();
        jButton6 = new javax.swing.JButton();
        jButton8 = new javax.swing.JButton();
        jButton9 = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        jLabel1 = new javax.swing.JLabel();
        jComboBox1 = new javax.swing.JComboBox();
        jLabel3 = new javax.swing.JLabel();
        jLabel4 = new javax.swing.JLabel();
        jComboBox2 = new javax.swing.JComboBox();
        jComboBox3 = new javax.swing.JComboBox();
        jLabel5 = new javax.swing.JLabel();
        jComboBox4 = new javax.swing.JComboBox();
        jLabel6 = new javax.swing.JLabel();
        jComboBox5 = new javax.swing.JComboBox();
        jLabel7 = new javax.swing.JLabel();
        jComboBox6 = new javax.swing.JComboBox();
        jLabel12 = new javax.swing.JLabel();
        jTextField5 = new javax.swing.JTextField();
        jLabel10 = new javax.swing.JLabel();
        jLabel9 = new javax.swing.JLabel();
        jTextField3 = new javax.swing.JTextField();
        jTextField2 = new javax.swing.JTextField();
        jLabel11 = new javax.swing.JLabel();
        jLabel8 = new javax.swing.JLabel();
        jTextField4 = new javax.swing.JTextField();
        jLabel13 = new javax.swing.JLabel();
        jTextField7 = new javax.swing.JTextField();
        jTextField6 = new javax.swing.JTextField();
        jLabel14 = new javax.swing.JLabel();
        jComboBox7 = new javax.swing.JComboBox();
        jLabel15 = new javax.swing.JLabel();
        jComboBox8 = new javax.swing.JComboBox();
        jPanel3 = new javax.swing.JPanel();
        jTabbedPane7 = new javax.swing.JTabbedPane();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextPane1 = new javax.swing.JTextPane();
        jScrollPane17 = new javax.swing.JScrollPane();
        jTextPane12 = new javax.swing.JTextPane();
        jScrollPane16 = new javax.swing.JScrollPane();
        jTextPane11 = new javax.swing.JTextPane();
        jScrollPane2 = new javax.swing.JScrollPane();
        jTextPane2 = new javax.swing.JTextPane();
        jScrollPane15 = new javax.swing.JScrollPane();
        jTextPane10 = new javax.swing.JTextPane();
        jScrollPane8 = new javax.swing.JScrollPane();
        jTextPane3 = new javax.swing.JTextPane();
        jScrollPane9 = new javax.swing.JScrollPane();
        jTextPane4 = new javax.swing.JTextPane();
        jScrollPane10 = new javax.swing.JScrollPane();
        jTextPane5 = new javax.swing.JTextPane();
        jScrollPane11 = new javax.swing.JScrollPane();
        jTextPane6 = new javax.swing.JTextPane();
        jScrollPane12 = new javax.swing.JScrollPane();
        jTextPane7 = new javax.swing.JTextPane();
        jScrollPane13 = new javax.swing.JScrollPane();
        jTextPane8 = new javax.swing.JTextPane();
        jScrollPane14 = new javax.swing.JScrollPane();
        jTextPane9 = new javax.swing.JTextPane();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        java.util.ResourceBundle bundle = java.util.ResourceBundle.getBundle(""com/github/moneytostr/messages_ru""); // NOI18N
        setTitle(bundle.getString(""MONEYTOSTR"")); // NOI18N

        jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder(""""));
        jPanel2.setMaximumSize(new java.awt.Dimension(610, 444));
        jPanel2.setPreferredSize(new java.awt.Dimension(662, 447));

        jScrollPane7.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        jTextArea7.setColumns(20);
        jTextArea7.setRows(5);
        jScrollPane7.setViewportView(jTextArea7);

        jTabbedPane3.addTab(bundle.getString(""fromCapitalLetter""), jScrollPane7); // NOI18N

        jScrollPane3.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        jTextArea1.setColumns(20);
        jTextArea1.setRows(5);
        jScrollPane3.setViewportView(jTextArea1);

        jTabbedPane1.addTab(bundle.getString(""result""), jScrollPane3); // NOI18N

        jLabel2.setText(bundle.getString(""enterTheDigitalAmount"")); // NOI18N

        jScrollPane4.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        jTextArea4.setColumns(20);
        jTextArea4.setRows(5);
        jScrollPane4.setViewportView(jTextArea4);

        jTabbedPane2.addTab(bundle.getString(""penniesByDigits""), jScrollPane4); // NOI18N

        jScrollPane5.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        jTextArea5.setColumns(20);
        jTextArea5.setRows(5);
        jScrollPane5.setViewportView(jTextArea5);

        jTabbedPane4.addTab(bundle.getString(""withVat""), jScrollPane5); // NOI18N

        jScrollPane6.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);

        jTextArea6.setColumns(20);
        jTextArea6.setRows(5);
        jScrollPane6.setViewportView(jTextArea6);

        jTabbedPane5.addTab(bundle.getString(""withVatByString""), jScrollPane6); // NOI18N

        jButton2.setText(""*"");
        jButton2.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jButton2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton2ActionPerformed(evt);
            }
        });

        jTextField1.setEditable(true);
        jTextField1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextField1ActionPerformed(evt);
            }
        });

        jButton4.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/com/github/moneytostr/copy.png""))); // NOI18N
        jButton4.setToolTipText(bundle.getString(""copyToTheBuffer"")); // NOI18N
        jButton4.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jButton4.setFocusable(false);
        jButton4.setMaximumSize(new java.awt.Dimension(30, 30));
        jButton4.setMinimumSize(new java.awt.Dimension(30, 30));
        jButton4.setPreferredSize(new java.awt.Dimension(30, 30));
        jButton4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton4ActionPerformed(evt);
            }
        });

        jButton5.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/com/github/moneytostr/copy.png""))); // NOI18N
        jButton5.setToolTipText(bundle.getString(""copyToTheBuffer"")); // NOI18N
        jButton5.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jButton5.setFocusable(false);
        jButton5.setMaximumSize(new java.awt.Dimension(30, 30));
        jButton5.setMinimumSize(new java.awt.Dimension(30, 30));
        jButton5.setPreferredSize(new java.awt.Dimension(30, 30));
        jButton5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton5ActionPerformed(evt);
            }
        });

        jButton6.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/com/github/moneytostr/copy.png""))); // NOI18N
        jButton6.setToolTipText(bundle.getString(""copyToTheBuffer"")); // NOI18N
        jButton6.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jButton6.setFocusable(false);
        jButton6.setMaximumSize(new java.awt.Dimension(30, 30));
        jButton6.setMinimumSize(new java.awt.Dimension(30, 30));
        jButton6.setPreferredSize(new java.awt.Dimension(30, 30));
        jButton6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton6ActionPerformed(evt);
            }
        });

        jButton8.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/com/github/moneytostr/copy.png""))); // NOI18N
        jButton8.setToolTipText(bundle.getString(""copyToTheBuffer"")); // NOI18N
        jButton8.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jButton8.setFocusable(false);
        jButton8.setMaximumSize(new java.awt.Dimension(30, 30));
        jButton8.setMinimumSize(new java.awt.Dimension(30, 30));
        jButton8.setPreferredSize(new java.awt.Dimension(30, 30));
        jButton8.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton8ActionPerformed(evt);
            }
        });

        jButton9.setIcon(new javax.swing.ImageIcon(getClass().getResource(""/com/github/moneytostr/copy.png""))); // NOI18N
        jButton9.setToolTipText(bundle.getString(""copyToTheBuffer"")); // NOI18N
        jButton9.setBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED));
        jButton9.setFocusable(false);
        jButton9.setMaximumSize(new java.awt.Dimension(30, 30));
        jButton9.setMinimumSize(new java.awt.Dimension(30, 30));
        jButton9.setPreferredSize(new java.awt.Dimension(30, 30));
        jButton9.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton9ActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout jPanel2Layout = new org.jdesktop.layout.GroupLayout(jPanel2);
        jPanel2.setLayout(jPanel2Layout);
        jPanel2Layout.setHorizontalGroup(
            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                    .add(jTabbedPane2)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jTabbedPane5)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jTabbedPane4)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jTabbedPane3)
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel2Layout.createSequentialGroup()
                        .add(jLabel2)
                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                        .add(jTextField1, 0, 636, Short.MAX_VALUE))
                    .add(org.jdesktop.layout.GroupLayout.LEADING, jTabbedPane1))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jButton8, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 29, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                        .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jButton2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 29, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jButton4, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 29, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                        .add(jButton5, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 29, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(org.jdesktop.layout.GroupLayout.TRAILING, jButton6, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 29, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                    .add(jButton9, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 29, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addContainerGap())
        );
        jPanel2Layout.setVerticalGroup(
            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2Layout.createSequentialGroup()
                .addContainerGap()
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel2)
                    .add(jButton2)
                    .add(jTextField1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 112, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jPanel2Layout.createSequentialGroup()
                        .add(23, 23, 23)
                        .add(jButton4, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jTabbedPane3, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 106, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2Layout.createSequentialGroup()
                        .add(jButton6, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(52, 52, 52)))
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jTabbedPane4, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 107, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2Layout.createSequentialGroup()
                        .add(jButton5, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(53, 53, 53)))
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jTabbedPane5, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 112, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2Layout.createSequentialGroup()
                        .add(jButton8, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(57, 57, 57)))
                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jTabbedPane2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 112, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2Layout.createSequentialGroup()
                        .add(jButton9, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                        .add(58, 58, 58)))
                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        jTabbedPane6.addTab(bundle.getString(""converter""), jPanel2); // NOI18N

        jLabel1.setText(bundle.getString(""language"")); // NOI18N

        jComboBox1.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""Русский"", ""Украинский"", ""Английсикй"" }));
        jComboBox1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox1ActionPerformed(evt);
            }
        });

        jLabel3.setText(bundle.getString(""currency"")); // NOI18N

        jLabel4.setText(bundle.getString(""pennies"")); // NOI18N

        jComboBox2.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""RUR"", ""UAH"", ""USD"", ""Custom"" }));
        jComboBox2.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox2ActionPerformed(evt);
            }
        });

        jComboBox3.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""Цифрами"", ""Прописью"" }));
        jComboBox3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox3ActionPerformed(evt);
            }
        });

        jLabel5.setText(bundle.getString(""toCopyToTheBuffer"")); // NOI18N

        jComboBox4.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""не копировать"", ""Результат"", ""С заглавной буквы"", ""С НДС"", ""С НДС прописью"", ""Копейки цифрами"" }));
        jComboBox4.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox4ActionPerformed(evt);
            }
        });

        jLabel6.setText(bundle.getString(""vat"")); // NOI18N

        jComboBox5.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""10%"", ""12%"", ""18%"", ""20%"", ""22%"", ""25%"" }));
        jComboBox5.setSelectedIndex(2);
        jComboBox5.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox5ActionPerformed(evt);
            }
        });

        jLabel7.setText(bundle.getString(""interfaceLanguage"")); // NOI18N

        jComboBox6.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""Русский"", ""Украинский"" }));
        jComboBox6.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox6ActionPerformed(evt);
            }
        });

        jLabel12.setText(bundle.getString(""kopTwoUnit"")); // NOI18N

        jTextField5.setText(""евроцент"");
        jTextField5.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTextField5KeyTyped(evt);
            }
        });

        jLabel10.setText(bundle.getString(""rubFiveUnit"")); // NOI18N

        jLabel9.setText(bundle.getString(""rubTwoUnit"")); // NOI18N

        jTextField3.setText(""евро"");
        jTextField3.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTextField3KeyTyped(evt);
            }
        });

        jTextField2.setText(""евро"");
        jTextField2.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTextField2KeyTyped(evt);
            }
        });

        jLabel11.setText(bundle.getString(""kopOneUnit"")); // NOI18N

        jLabel8.setText(bundle.getString(""rubOneUnit"")); // NOI18N

        jTextField4.setText(""евро"");
        jTextField4.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTextField4KeyTyped(evt);
            }
        });

        jLabel13.setText(bundle.getString(""kopFiveUnit"")); // NOI18N

        jTextField7.setText(""евроцентов"");
        jTextField7.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTextField7KeyTyped(evt);
            }
        });

        jTextField6.setText(""евроцента"");
        jTextField6.addKeyListener(new java.awt.event.KeyAdapter() {
            public void keyTyped(java.awt.event.KeyEvent evt) {
                jTextField6KeyTyped(evt);
            }
        });

        jLabel14.setText(bundle.getString(""rubSex"")); // NOI18N

        jComboBox7.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""M"", ""F"" }));
        jComboBox7.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox7ActionPerformed(evt);
            }
        });

        jLabel15.setText(bundle.getString(""kopSex"")); // NOI18N

        jComboBox8.setModel(new javax.swing.DefaultComboBoxModel(new String[] { ""M"", ""F"" }));
        jComboBox8.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jComboBox8ActionPerformed(evt);
            }
        });

        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1Layout.createSequentialGroup()
                .add(23, 23, 23)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jLabel1)
                            .add(jLabel3)
                            .add(jLabel4)
                            .add(jLabel5)
                            .add(jLabel6)
                            .add(jLabel7))
                        .add(29, 29, 29)
                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jComboBox5, 0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .add(jComboBox2, 0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jComboBox3, 0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jComboBox4, 0, 658, Short.MAX_VALUE)
                            .add(jComboBox1, 0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                            .add(jComboBox6, 0, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                    .add(jPanel1Layout.createSequentialGroup()
                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jLabel9)
                            .add(jLabel8)
                            .add(jLabel10)
                            .add(jLabel11)
                            .add(jLabel12)
                            .add(jLabel13)
                            .add(jLabel14)
                            .add(jLabel15))
                        .add(25, 25, 25)
                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                            .add(jTextField7)
                            .add(jTextField6)
                            .add(jTextField5)
                            .add(jTextField4)
                            .add(jTextField2)
                            .add(jTextField3, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 659, Short.MAX_VALUE)
                            .add(jPanel1Layout.createSequentialGroup()
                                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                                    .add(jComboBox8, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                                    .add(jComboBox7, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                                .add(0, 0, Short.MAX_VALUE)))))
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jPanel1Layout.createSequentialGroup()
                .add(23, 23, 23)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel1)
                    .add(jComboBox1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel3)
                    .add(jComboBox2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel8)
                    .add(jTextField2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel9)
                    .add(jTextField3, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel10)
                    .add(jTextField4, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .add(10, 10, 10)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jComboBox7, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                    .add(jLabel14))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel11)
                    .add(jTextField5, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel12)
                    .add(jTextField6, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel13)
                    .add(jTextField7, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jLabel15)
                    .add(jComboBox8, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .add(8, 8, 8)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel4)
                    .add(jComboBox3, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                    .add(jLabel5)
                    .add(jComboBox4, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel6)
                    .add(jComboBox5, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(org.jdesktop.layout.LayoutStyle.UNRELATED)
                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                    .add(jLabel7)
                    .add(jComboBox6, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                .addContainerGap(207, Short.MAX_VALUE))
        );

        jTabbedPane6.addTab(bundle.getString(""settings""), jPanel1); // NOI18N

        jTabbedPane7.setTabPlacement(javax.swing.JTabbedPane.LEFT);

        jScrollPane1.setBorder(null);

        jTextPane1.setEditable(false);
        jTextPane1.setBorder(null);
        jTextPane1.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane1.setViewportView(jTextPane1);

        jTabbedPane7.addTab(""c#"", jScrollPane1);

        jScrollPane17.setBorder(null);

        jTextPane12.setEditable(false);
        jTextPane12.setBorder(null);
        jTextPane12.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane17.setViewportView(jTextPane12);

        jTabbedPane7.addTab(""c++"", jScrollPane17);

        jScrollPane16.setBorder(null);

        jTextPane11.setEditable(false);
        jTextPane11.setBorder(null);
        jTextPane11.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane16.setViewportView(jTextPane11);

        jTabbedPane7.addTab(""coffeescript"", jScrollPane16);

        jScrollPane2.setBorder(null);

        jTextPane2.setEditable(false);
        jTextPane2.setBorder(null);
        jTextPane2.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane2.setViewportView(jTextPane2);

        jTabbedPane7.addTab(""dart"", jScrollPane2);

        jScrollPane15.setBorder(null);

        jTextPane10.setEditable(false);
        jTextPane10.setBorder(null);
        jTextPane10.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane15.setViewportView(jTextPane10);

        jTabbedPane7.addTab(""groovy"", jScrollPane15);

        jScrollPane8.setBorder(null);

        jTextPane3.setEditable(false);
        jTextPane3.setBorder(null);
        jTextPane3.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane8.setViewportView(jTextPane3);

        jTabbedPane7.addTab(""java"", jScrollPane8);

        jScrollPane9.setBorder(null);

        jTextPane4.setEditable(false);
        jTextPane4.setBorder(null);
        jTextPane4.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane9.setViewportView(jTextPane4);

        jTabbedPane7.addTab(""js"", jScrollPane9);

        jScrollPane10.setBorder(null);

        jTextPane5.setEditable(false);
        jTextPane5.setBorder(null);
        jTextPane5.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane10.setViewportView(jTextPane5);

        jTabbedPane7.addTab(""php"", jScrollPane10);

        jScrollPane11.setBorder(null);

        jTextPane6.setEditable(false);
        jTextPane6.setBorder(null);
        jTextPane6.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane11.setViewportView(jTextPane6);

        jTabbedPane7.addTab(""python"", jScrollPane11);

        jScrollPane12.setBorder(null);

        jTextPane7.setEditable(false);
        jTextPane7.setBorder(null);
        jTextPane7.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane12.setViewportView(jTextPane7);

        jTabbedPane7.addTab(""ruby"", jScrollPane12);

        jScrollPane13.setBorder(null);

        jTextPane8.setEditable(false);
        jTextPane8.setBorder(null);
        jTextPane8.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane13.setViewportView(jTextPane8);

        jTabbedPane7.addTab(""scala"", jScrollPane13);

        jScrollPane14.setBorder(null);

        jTextPane9.setEditable(false);
        jTextPane9.setBorder(null);
        jTextPane9.setFont(new java.awt.Font(""SansSerif"", 0, 14)); // NOI18N
        jScrollPane14.setViewportView(jTextPane9);

        jTabbedPane7.addTab(""typescript"", jScrollPane14);

        org.jdesktop.layout.GroupLayout jPanel3Layout = new org.jdesktop.layout.GroupLayout(jPanel3);
        jPanel3.setLayout(jPanel3Layout);
        jPanel3Layout.setHorizontalGroup(
            jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jTabbedPane7, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 825, Short.MAX_VALUE)
        );
        jPanel3Layout.setVerticalGroup(
            jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jTabbedPane7, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 614, Short.MAX_VALUE)
        );

        jTabbedPane6.addTab(bundle.getString(""sourceCodes""), jPanel3); // NOI18N

        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jTabbedPane6)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
            .add(jTabbedPane6)
        );

        pack();
    }",Initialize the components of the NCSIDictionary.
"@Override
    public void removePolicy(String sec, String ptype, List<String> rule) {
        throw new Error(""not implemented"");
    }",Remove a policy from the resource.
"public static void endStenoWrapper(
            final ILoggingEvent event,
            final String eventName,
            @Nullable final List<String> contextKeys,
            @Nullable final List<Object> contextValues,
            final JsonGenerator jsonGenerator,
            final ObjectMapper objectMapper,
            final StenoEncoder encoder)
            throws IOException {

        jsonGenerator.writeFieldName(""context"");
        objectMapper.writeValue(
                jsonGenerator,
                StenoSerializationHelper.createContext(
                        encoder,
                        event,
                        objectMapper,
                        contextKeys,
                        contextValues));
        jsonGenerator.writeObjectField(""id"", StenoSerializationHelper.createId());
        jsonGenerator.writeObjectField(""version"", ""0"");
        jsonGenerator.writeEndObject(); // End log message
        jsonGenerator.writeRaw('\n');
        jsonGenerator.flush();
    }",End the standard Steno wrapper.
"public static <T extends MethodDescription> ElementMatcher.Junction<T> isVirtual() {
        return new MethodSortMatcher<T>(MethodSortMatcher.Sort.VIRTUAL);
    }",Matches any method that is a virtual method.
"public void checkpoint(ObjectEnvelope mod)
            throws org.apache.ojb.broker.PersistenceBrokerException
    {
        mod.doUpdate();
    }",This method is called by the OSGi framework to update the object envelope.
"public String authenticationUrl(String redirect, String scope) {
        return authenticationUrl(redirect, scope, null);
    }",Returns the URL of the authentication page for the given redirect and scope.
"public static void configureDefaults(final String ident,
                                       final Level level,
                                       final ReplaceNewLines replaceNewLines) {
    // Call configureSyslogDefaults if the SPOTIFY_SYSLOG_HOST or SPOTIFY_SYSLOG_PORT env var is
    // set. If this causes a problem, we could introduce a configureConsoleDefaults method which
    // users could call instead to avoid this behavior.
    final String syslogHost = getSyslogHost();
    final int syslogPort = getSyslogPort();
    if (syslogHost != null || syslogPort != -1) {
      configureSyslogDefaults(ident, level, syslogHost, syslogPort, replaceNewLines);
      return;
    }

    final Logger rootLogger = (Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME);

    // Setup context
    final LoggerContext context = setupLoggerContext(rootLogger, ident);

    // Setup stderr output
    rootLogger.addAppender(getStdErrAppender(context, replaceNewLines));

    // Setup logging level
    rootLogger.setLevel(level.logbackLevel);

    // Log uncaught exceptions
    UncaughtExceptionLogger.setDefaultUncaughtExceptionHandler();
  }",Configure the default values for the Logger.
"public static String toHex(byte[] bytes) {
    StringBuffer buffer = new StringBuffer();

    for (byte b : bytes) {
      buffer.append(String.format(""%02X"", b));
    }

    return buffer.toString();
  }",Converts a byte array to a hex string.
"private String inferSourceName(TypeElement type) {
    if (!ElementUtil.isPublic(type)) {
      String srcFile = ElementUtil.getSourceFile(type);
      if (srcFile != null && srcFile.endsWith("".java"")) {
        int lastSlash = Math.max(srcFile.lastIndexOf('/'), srcFile.lastIndexOf('\\'));
        String baseName = lastSlash > -1 ? srcFile.substring(lastSlash + 1) : srcFile;
        return baseName.substring(0, baseName.length() - 5); // Remove .java suffix.
      }
    }
    return ElementUtil.getName(type);
  }",Infer the source name of a type.
"protected boolean isTransparent(BufferedImage image) {
		boolean transparent = false;
		if (image != null) {
			WritableRaster raster = image.getAlphaRaster();
			if (raster != null) {
				transparent = true;
				done: for (int x = 0; x < image.getWidth(); x++) {
					for (int y = 0; y < image.getHeight(); y++) {
						if (raster.getSample(x, y, 0) > 0) {
							transparent = false;
							break done;
						}
					}
				}
			}
		}
		return transparent;
	}",Checks if the image is transparent.
"@RequestMapping(value = ""branches/{branchId}/template"", method = RequestMethod.PUT)
    public Branch createTemplateInstance(@PathVariable ID branchId, @RequestBody @Valid BranchTemplateInstanceSingleRequest request) {
        return branchTemplateService.createTemplateInstance(branchId, request);
    }",Create a new template
"protected
    @Nullable
    Spannable getFinalAttributeValue(@NonNull JSONObject hit, @NonNull View view, @NonNull String attribute, @Nullable String attributeValue) {
        Spannable attributeText = null;
        if (attributeValue != null) {
            if (RenderingHelper.getDefault().shouldHighlight(view, attribute)) {
                final int highlightColor = RenderingHelper.getDefault().getHighlightColor(view, attribute);
                final String prefix = BindingHelper.getPrefix(view);
                final String suffix = BindingHelper.getSuffix(view);
                final boolean snippetted = RenderingHelper.getDefault().shouldSnippet(view, attribute);
                attributeText = Highlighter.getDefault().setInput(hit, attribute, prefix, suffix, false, snippetted)
                        .setStyle(highlightColor).render();
            } else {
                attributeText = new SpannableString(attributeValue);
            }
        }
        return attributeText;
    }",Gets the final attribute value.
"public String interpolate(final String message, final Map<String, ?> vars) {
        return interpolate(message, vars, false);
    }",Interpolate a message with the given vars.
"public Yoke set(@NotNull String key, Object value) {
        if (value == null) {
            defaultContext.remove(key);
        } else {
            defaultContext.put(key, value);
        }

        return this;
    }",Sets a value for a key in the default context.
"public void recolorQuery() {
		String input = parent.getText();
		resetStyles();

		doc.setCharacterAttributes(0, doc.getLength(), plainStyle, true);

		// Locating all SELECTS
		input = input.replaceAll(""[Ss][Ee][Ll][Ee][Cc][Tt]"", ""SELECT"");
		int offset = 0;
		for (int index = input.indexOf(""SELECT"", offset); index != -1; index = input.indexOf(""SELECT"", offset)) {
			doc.setCharacterAttributes(index, index + 6, boldStyle, true);
			offset = index + 6;
			doc.setCharacterAttributes(offset, offset  +1, plainStyle, true);
		}
		
		input = input.replaceAll(""([Ff][Rr][Oo][Mm])"", ""FROM"");
		offset = 0;
		for (int index = input.indexOf(""FROM"", offset); index != -1; index = input.indexOf(""FROM"", offset)) {
			doc.setCharacterAttributes(index, index + 4, boldStyle, false);
			offset = index + 4 ;
			doc.setCharacterAttributes(offset, offset + 1, plainStyle, true);
		}

		input = input.replaceAll(""([Ww][hH][Ee][Rr][Ee])"", ""WHERE"");
		offset = 0;
		for (int index = input.indexOf(""WHERE"", offset); index != -1; index = input.indexOf(""WHERE"", offset)) {
			doc.setCharacterAttributes(index, index + 5, boldStyle, false);
			offset = index + 5;
			doc.setCharacterAttributes(offset, offset + 1, plainStyle, true);
		}
		parent.revalidate();
	}",Recolor the query.
"public Object[][] getContents()
  {
    return new Object[][] {

  /** Error message ID that has a null message, but takes in a single object.    */
  {""ER0000"" , ""{0}"" },

    { ER_NO_CURLYBRACE,                            
      ""Error: Can not have '{' within expression""},

    { ER_ILLEGAL_ATTRIBUTE , 
     ""{0} has an illegal attribute: {1}""},

  {ER_NULL_SOURCENODE_APPLYIMPORTS ,
      ""sourceNode is null in xsl:apply-imports!""},

  {ER_CANNOT_ADD,
      ""Can not add {0} to {1}""},

    { ER_NULL_SOURCENODE_HANDLEAPPLYTEMPLATES, 
      ""sourceNode is null in handleApplyTemplatesInstruction!""},

    { ER_NO_NAME_ATTRIB, 
     ""{0} must have a name attribute.""},

    {ER_TEMPLATE_NOT_FOUND,
     ""Could not find template named: {0}""},

    {ER_CANT_RESOLVE_NAME_AVT,
      ""Could not resolve name AVT in xsl:call-template.""},

    {ER_REQUIRES_ATTRIB,
     ""{0} requires attribute: {1}""},

    { ER_MUST_HAVE_TEST_ATTRIB, 
      ""{0} must have a ''test'' attribute.""},

    {ER_BAD_VAL_ON_LEVEL_ATTRIB,
      ""Bad value on level attribute: {0}""},

    {ER_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML, 
      ""processing-instruction name can not be 'xml'""},

    { ER_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""processing-instruction name must be a valid NCName: {0}""},

    { ER_NEED_MATCH_ATTRIB,
      ""{0} must have a match attribute if it has a mode.""},

    { ER_NEED_NAME_OR_MATCH_ATTRIB,
      ""{0} requires either a name or a match attribute.""},

    {ER_CANT_RESOLVE_NSPREFIX,
      ""Can not resolve namespace prefix: {0}""},

    { ER_ILLEGAL_VALUE,
     ""xml:space has an illegal value: {0}""},

    { ER_NO_OWNERDOC,
      ""Child node does not have an owner document!""},

    { ER_ELEMTEMPLATEELEM_ERR,
     ""ElemTemplateElement error: {0}""},

    { ER_NULL_CHILD,
     ""Trying to add a null child!""},

    { ER_NEED_SELECT_ATTRIB,
     ""{0} requires a select attribute.""},

    { ER_NEED_TEST_ATTRIB ,
      ""xsl:when must have a 'test' attribute.""},

    { ER_NEED_NAME_ATTRIB,
      ""xsl:with-param must have a 'name' attribute.""},

    { ER_NO_CONTEXT_OWNERDOC,
      ""context does not have an owner document!""},

    {ER_COULD_NOT_CREATE_XML_PROC_LIAISON,
      ""Could not create XML TransformerFactory Liaison: {0}""},

    {ER_PROCESS_NOT_SUCCESSFUL,
      ""Xalan: Process was not successful.""},

    { ER_NOT_SUCCESSFUL,
     ""Xalan: was not successful.""},

    { ER_ENCODING_NOT_SUPPORTED,
     ""Encoding not supported: {0}""},

    {ER_COULD_NOT_CREATE_TRACELISTENER,
      ""Could not create TraceListener: {0}""},

    {ER_KEY_REQUIRES_NAME_ATTRIB,
      ""xsl:key requires a 'name' attribute!""},

    { ER_KEY_REQUIRES_MATCH_ATTRIB,
      ""xsl:key requires a 'match' attribute!""},

    { ER_KEY_REQUIRES_USE_ATTRIB,
      ""xsl:key requires a 'use' attribute!""},

    { ER_REQUIRES_ELEMENTS_ATTRIB,
      ""(StylesheetHandler) {0} requires an ''elements'' attribute!""},

    { ER_MISSING_PREFIX_ATTRIB,
      ""(StylesheetHandler) {0} attribute ''prefix'' is missing""},

    { ER_BAD_STYLESHEET_URL,
     ""Stylesheet URL is bad: {0}""},

    { ER_FILE_NOT_FOUND,
     ""Stylesheet file was not found: {0}""},

    { ER_IOEXCEPTION,
      ""Had IO Exception with stylesheet file: {0}""},

    { ER_NO_HREF_ATTRIB, 
      ""(StylesheetHandler) Could not find href attribute for {0}""},

    { ER_STYLESHEET_INCLUDES_ITSELF, 
      ""(StylesheetHandler) {0} is directly or indirectly including itself!""},

    { ER_PROCESSINCLUDE_ERROR,
      ""StylesheetHandler.processInclude error, {0}""},

    { ER_MISSING_LANG_ATTRIB,
      ""(StylesheetHandler) {0} attribute ''lang'' is missing""},

    { ER_MISSING_CONTAINER_ELEMENT_COMPONENT,
      ""(StylesheetHandler) misplaced {0} element?? Missing container element ''component''""},

    { ER_CAN_ONLY_OUTPUT_TO_ELEMENT,
      ""Can only output to an Element, DocumentFragment, Document, or PrintWriter.""},

    { ER_PROCESS_ERROR,
     ""StylesheetRoot.process error""},

    { ER_UNIMPLNODE_ERROR,
     ""UnImplNode error: {0}""},

    { ER_NO_SELECT_EXPRESSION,
      ""Error! Did not find xpath select expression (-select).""},

    { ER_CANNOT_SERIALIZE_XSLPROCESSOR, 
      ""Can not serialize an XSLProcessor!""},

    { ER_NO_INPUT_STYLESHEET,
      ""Stylesheet input was not specified!""},

    { ER_FAILED_PROCESS_STYLESHEET,
      ""Failed to process stylesheet!""},

    { ER_COULDNT_PARSE_DOC,       
     ""Could not parse {0} document!""},

    { ER_COULDNT_FIND_FRAGMENT,
     ""Could not find fragment: {0}""},

    { ER_NODE_NOT_ELEMENT,
      ""Node pointed to by fragment identifier was not an element: {0}""},

    { ER_FOREACH_NEED_MATCH_OR_NAME_ATTRIB,
      ""for-each must have either a match or name attribute""},

    { ER_TEMPLATES_NEED_MATCH_OR_NAME_ATTRIB, 
      ""templates must have either a match or name attribute""},

    { ER_NO_CLONE_OF_DOCUMENT_FRAG,
      ""No clone of a document fragment!""},

    { ER_CANT_CREATE_ITEM,
      ""Can not create item in result tree: {0}""},

    { ER_XMLSPACE_ILLEGAL_VALUE,
      ""xml:space in the source XML has an illegal value: {0}""},

    { ER_NO_XSLKEY_DECLARATION,
      ""There is no xsl:key declaration for {0}!""},

    { ER_CANT_CREATE_URL, 
     ""Error! Cannot create url for: {0}""},

    { ER_XSLFUNCTIONS_UNSUPPORTED,
     ""xsl:functions is unsupported""},

    { ER_PROCESSOR_ERROR, 
     ""XSLT TransformerFactory Error""},

    { ER_NOT_ALLOWED_INSIDE_STYLESHEET,
      ""(StylesheetHandler) {0} not allowed inside a stylesheet!""},

    { ER_RESULTNS_NOT_SUPPORTED, 
      ""result-ns no longer supported!  Use xsl:output instead.""},

    { ER_DEFAULTSPACE_NOT_SUPPORTED, 
      ""default-space no longer supported!  Use xsl:strip-space or xsl:preserve-space instead.""},

    { ER_INDENTRESULT_NOT_SUPPORTED,
      ""indent-result no longer supported!  Use xsl:output instead.""},

    { ER_ILLEGAL_ATTRIB,
      ""(StylesheetHandler) {0} has an illegal attribute: {1}""},

    { ER_UNKNOWN_XSL_ELEM,
     ""Unknown XSL element: {0}""},

    { ER_BAD_XSLSORT_USE,
      ""(StylesheetHandler) xsl:sort can only be used with xsl:apply-templates or xsl:for-each.""},

    { ER_MISPLACED_XSLWHEN,
      ""(StylesheetHandler) misplaced xsl:when!""},

    { ER_XSLWHEN_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:when not parented by xsl:choose!""},

    { ER_MISPLACED_XSLOTHERWISE,
      ""(StylesheetHandler) misplaced xsl:otherwise!""},

    { ER_XSLOTHERWISE_NOT_PARENTED_BY_XSLCHOOSE,
      ""(StylesheetHandler) xsl:otherwise not parented by xsl:choose!""},

    { ER_NOT_ALLOWED_INSIDE_TEMPLATE,
      ""(StylesheetHandler) {0} is not allowed inside a template!""},

    { ER_UNKNOWN_EXT_NS_PREFIX, 
      ""(StylesheetHandler) {0} extension namespace prefix {1} unknown""},

    { ER_IMPORTS_AS_FIRST_ELEM, 
      ""(StylesheetHandler) Imports can only occur as the first elements in the stylesheet!""},

    { ER_IMPORTING_ITSELF,
      ""(StylesheetHandler) {0} is directly or indirectly importing itself!""},

    { ER_XMLSPACE_ILLEGAL_VAL,
      ""(StylesheetHandler) "" + ""xml:space has an illegal value: {0}""},

    { ER_PROCESSSTYLESHEET_NOT_SUCCESSFUL,
      ""processStylesheet not succesfull!""},

    { ER_SAX_EXCEPTION, 
     ""SAX Exception""},

//  add this message to fix bug 21478
    { ER_FUNCTION_NOT_SUPPORTED, 
     ""Function not supported!""},

    { ER_XSLT_ERROR,
     ""XSLT Error""},

    { ER_CURRENCY_SIGN_ILLEGAL,
      ""currency sign is not allowed in format pattern string""},

    { ER_DOCUMENT_FUNCTION_INVALID_IN_STYLESHEET_DOM,
      ""Document function not supported in Stylesheet DOM!""},

    { ER_CANT_RESOLVE_PREFIX_OF_NON_PREFIX_RESOLVER,
      ""Can't resolve prefix of non-Prefix resolver!""},

    { ER_REDIRECT_COULDNT_GET_FILENAME,
      ""Redirect extension: Could not get filename - file or select attribute must return vald string.""},

    { ER_CANNOT_BUILD_FORMATTERLISTENER_IN_REDIRECT,
      ""Can not build FormatterListener in Redirect extension!""},

    { ER_INVALID_PREFIX_IN_EXCLUDERESULTPREFIX,
      ""Prefix in exclude-result-prefixes is not valid: {0}""},

    { ER_MISSING_NS_URI, 
      ""Missing namespace URI for specified prefix""},

    { ER_MISSING_ARG_FOR_OPTION,
      ""Missing argument for option: {0}""},

    { ER_INVALID_OPTION,
     ""Invalid option: {0}""},

    { ER_MALFORMED_FORMAT_STRING,
     ""Malformed format string: {0}""},

    { ER_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet requires a 'version' attribute!""},

    { ER_ILLEGAL_ATTRIBUTE_VALUE,
      ""Attribute: {0} has an illegal value: {1}""},

    { ER_CHOOSE_REQUIRES_WHEN,
     ""xsl:choose requires an xsl:when""},

    { ER_NO_APPLY_IMPORT_IN_FOR_EACH,
      ""xsl:apply-imports not allowed in a xsl:for-each""},

    { ER_CANT_USE_DTM_FOR_OUTPUT,
      ""Cannot use a DTMLiaison for an output DOM node... pass a org.apache.xpath.DOM2Helper instead!""},

    { ER_CANT_USE_DTM_FOR_INPUT,
      ""Cannot use a DTMLiaison for a input DOM node... pass a org.apache.xpath.DOM2Helper instead!""},

    { ER_CALL_TO_EXT_FAILED,
      ""Call to extension element failed: {0}""},

    { ER_PREFIX_MUST_RESOLVE,
      ""Prefix must resolve to a namespace: {0}""},

    { ER_INVALID_UTF16_SURROGATE,
      ""Invalid UTF-16 surrogate detected: {0} ?""},

    { ER_XSLATTRSET_USED_ITSELF,
      ""xsl:attribute-set {0} used itself, which will cause an infinite loop.""},

    { ER_CANNOT_MIX_XERCESDOM,
      ""Can not mix non Xerces-DOM input with Xerces-DOM output!""},

    { ER_TOO_MANY_LISTENERS,
      ""addTraceListenersToStylesheet - TooManyListenersException""},

    { ER_IN_ELEMTEMPLATEELEM_READOBJECT,
      ""In ElemTemplateElement.readObject: {0}""},

    { ER_DUPLICATE_NAMED_TEMPLATE,
      ""Found more than one template named: {0}""},

    { ER_INVALID_KEY_CALL,
      ""Invalid function call: recursive key() calls are not allowed""},

    { ER_REFERENCING_ITSELF,
      ""Variable {0} is directly or indirectly referencing itself!""},

    { ER_ILLEGAL_DOMSOURCE_INPUT,
      ""The input node can not be null for a DOMSource for newTemplates!""},

    { ER_CLASS_NOT_FOUND_FOR_OPTION,
	""Class file not found for option {0}""},

    { ER_REQUIRED_ELEM_NOT_FOUND,
	""Required Element not found: {0}""},

    { ER_INPUT_CANNOT_BE_NULL,
	""InputStream cannot be null""},

    { ER_URI_CANNOT_BE_NULL,
	""URI cannot be null""},

    { ER_FILE_CANNOT_BE_NULL,
	""File cannot be null""},

    { ER_SOURCE_CANNOT_BE_NULL,
		""InputSource cannot be null""},

    { ER_CANNOT_INIT_BSFMGR,
		""Could not initialize BSF Manager""},

    { ER_CANNOT_CMPL_EXTENSN,
		""Could not compile extension""},

    { ER_CANNOT_CREATE_EXTENSN,
      ""Could not create extension: {0} because of: {1}""},

    { ER_INSTANCE_MTHD_CALL_REQUIRES,
      ""Instance method call to method {0} requires an Object instance as first argument""},

    { ER_INVALID_ELEMENT_NAME,
      ""Invalid element name specified {0}""},

    { ER_ELEMENT_NAME_METHOD_STATIC,
      ""Element name method must be static {0}""},

    { ER_EXTENSION_FUNC_UNKNOWN,
             ""Extension function {0} : {1} is unknown""},

    { ER_MORE_MATCH_CONSTRUCTOR,
             ""More than one best match for constructor for {0}""},

    { ER_MORE_MATCH_METHOD,
             ""More than one best match for method {0}""},

    { ER_MORE_MATCH_ELEMENT,
             ""More than one best match for element method {0}""},

    { ER_INVALID_CONTEXT_PASSED,
             ""Invalid context passed to evaluate {0}""},

    { ER_POOL_EXISTS,
             ""Pool already exists""},

    { ER_NO_DRIVER_NAME,
             ""No driver Name specified""},

    { ER_NO_URL,
             ""No URL specified""},

    { ER_POOL_SIZE_LESSTHAN_ONE,
             ""Pool size is less than one!""},

    { ER_INVALID_DRIVER,
             ""Invalid driver name specified!""},

    { ER_NO_STYLESHEETROOT,
             ""Did not find the stylesheet root!""},

    { ER_ILLEGAL_XMLSPACE_VALUE,
         ""Illegal value for xml:space""},

    { ER_PROCESSFROMNODE_FAILED,
         ""processFromNode failed""},

    { ER_RESOURCE_COULD_NOT_LOAD,
        ""The resource [ {0} ] could not load: {1} \n {2} \t {3}""},

    { ER_BUFFER_SIZE_LESSTHAN_ZERO,
        ""Buffer size <=0""},

    { ER_UNKNOWN_ERROR_CALLING_EXTENSION,
        ""Unknown error when calling extension""},

    { ER_NO_NAMESPACE_DECL,
        ""Prefix {0} does not have a corresponding namespace declaration""},

    { ER_ELEM_CONTENT_NOT_ALLOWED,
        ""Element content not allowed for lang=javaclass {0}""},

    { ER_STYLESHEET_DIRECTED_TERMINATION,
        ""Stylesheet directed termination""},

    { ER_ONE_OR_TWO,
        ""1 or 2""},

    { ER_TWO_OR_THREE,
        ""2 or 3""},

    { ER_COULD_NOT_LOAD_RESOURCE,
        ""Could not load {0} (check CLASSPATH), now using just the defaults""},

    { ER_CANNOT_INIT_DEFAULT_TEMPLATES,
        ""Cannot initialize default templates""},

    { ER_RESULT_NULL,
        ""Result should not be null""},

    { ER_RESULT_COULD_NOT_BE_SET,
        ""Result could not be set""},

    { ER_NO_OUTPUT_SPECIFIED,
        ""No output specified""},

    { ER_CANNOT_TRANSFORM_TO_RESULT_TYPE,
        ""Can''t transform to a Result of type {0}""},

    { ER_CANNOT_TRANSFORM_SOURCE_TYPE,
        ""Can''t transform a Source of type {0}""},

    { ER_NULL_CONTENT_HANDLER,
        ""Null content handler""},

    { ER_NULL_ERROR_HANDLER,
        ""Null error handler""},

    { ER_CANNOT_CALL_PARSE,
        ""parse can not be called if the ContentHandler has not been set""},

    { ER_NO_PARENT_FOR_FILTER,
        ""No parent for filter""},

    { ER_NO_STYLESHEET_IN_MEDIA,
         ""No stylesheet found in: {0}, media= {1}""},

    { ER_NO_STYLESHEET_PI,
         ""No xml-stylesheet PI found in: {0}""},

    { ER_NOT_SUPPORTED,
       ""Not supported: {0}""},

    { ER_PROPERTY_VALUE_BOOLEAN,
       ""Value for property {0} should be a Boolean instance""},

    { ER_COULD_NOT_FIND_EXTERN_SCRIPT,
         ""Could not get to external script at {0}""},

    { ER_RESOURCE_COULD_NOT_FIND,
        ""The resource [ {0} ] could not be found.\n {1}""},

    { ER_OUTPUT_PROPERTY_NOT_RECOGNIZED,
        ""Output property not recognized: {0}""},

    { ER_FAILED_CREATING_ELEMLITRSLT,
        ""Failed creating ElemLiteralResult instance""},

  //Earlier (JDK 1.4 XALAN 2.2-D11) at key code '204' the key name was ER_PRIORITY_NOT_PARSABLE
  // In latest Xalan code base key name is  ER_VALUE_SHOULD_BE_NUMBER. This should also be taken care
  //in locale specific files like XSLTErrorResources_de.java, XSLTErrorResources_fr.java etc.
  //NOTE: Not only the key name but message has also been changed. 
    { ER_VALUE_SHOULD_BE_NUMBER,
        ""Value for {0} should contain a parsable number""},

    { ER_VALUE_SHOULD_EQUAL,
        ""Value for {0} should equal yes or no""},

    { ER_FAILED_CALLING_METHOD,
        ""Failed calling {0} method""},

    { ER_FAILED_CREATING_ELEMTMPL,
        ""Failed creating ElemTemplateElement instance""},

    { ER_CHARS_NOT_ALLOWED,
        ""Characters are not allowed at this point in the document""},

    { ER_ATTR_NOT_ALLOWED,
        ""\""{0}\"" attribute is not allowed on the {1} element!""},

    { ER_BAD_VALUE,
     ""{0} bad value {1} ""},

    { ER_ATTRIB_VALUE_NOT_FOUND,
     ""{0} attribute value not found ""},

    { ER_ATTRIB_VALUE_NOT_RECOGNIZED,
     ""{0} attribute value not recognized ""},

    { ER_NULL_URI_NAMESPACE,
     ""Attempting to generate a namespace prefix with a null URI""},

    { ER_NUMBER_TOO_BIG,
     ""Attempting to format a number bigger than the largest Long integer""},

    { ER_CANNOT_FIND_SAX1_DRIVER,
     ""Cannot find SAX1 driver class {0}""},

    { ER_SAX1_DRIVER_NOT_LOADED,
     ""SAX1 driver class {0} found but cannot be loaded""},

    { ER_SAX1_DRIVER_NOT_INSTANTIATED,
     ""SAX1 driver class {0} loaded but cannot be instantiated""},

    { ER_SAX1_DRIVER_NOT_IMPLEMENT_PARSER,
     ""SAX1 driver class {0} does not implement org.xml.sax.Parser""},

    { ER_PARSER_PROPERTY_NOT_SPECIFIED,
     ""System property org.xml.sax.parser not specified""},

    { ER_PARSER_ARG_CANNOT_BE_NULL,
     ""Parser argument must not be null""},

    { ER_FEATURE,
     ""Feature: {0}""},

    { ER_PROPERTY,
     ""Property: {0}""},

    { ER_NULL_ENTITY_RESOLVER,
     ""Null entity resolver""},

    { ER_NULL_DTD_HANDLER,
     ""Null DTD handler""},

    { ER_NO_DRIVER_NAME_SPECIFIED,
     ""No Driver Name Specified!""},

    { ER_NO_URL_SPECIFIED,
     ""No URL Specified!""},

    { ER_POOLSIZE_LESS_THAN_ONE,
     ""Pool size is less than 1!""},

    { ER_INVALID_DRIVER_NAME,
     ""Invalid Driver Name Specified!""},

    { ER_ERRORLISTENER,
     ""ErrorListener""},


// Note to translators:  The following message should not normally be displayed
//   to users.  It describes a situation in which the processor has detected
//   an internal consistency problem in itself, and it provides this message
//   for the developer to help diagnose the problem.  The name
//   'ElemTemplateElement' is the name of a class, and should not be
//   translated.
    { ER_ASSERT_NO_TEMPLATE_PARENT,
     ""Programmer's error! The expression has no ElemTemplateElement parent!""},


// Note to translators:  The following message should not normally be displayed
//   to users.  It describes a situation in which the processor has detected
//   an internal consistency problem in itself, and it provides this message
//   for the developer to help diagnose the problem.  The substitution text
//   provides further information in order to diagnose the problem.  The name
//   'RedundentExprEliminator' is the name of a class, and should not be
//   translated.
    { ER_ASSERT_REDUNDENT_EXPR_ELIMINATOR,
     ""Programmer''s assertion in RedundentExprEliminator: {0}""},

    { ER_NOT_ALLOWED_IN_POSITION,
     ""{0} is not allowed in this position in the stylesheet!""},

    { ER_NONWHITESPACE_NOT_ALLOWED_IN_POSITION,
     ""Non-whitespace text is not allowed in this position in the stylesheet!""},

  // This code is shared with warning codes.
  // SystemId Unknown
    { INVALID_TCHAR,
     ""Illegal value: {1} used for CHAR attribute: {0}.  An attribute of type CHAR must be only 1 character!""},

    // Note to translators:  The following message is used if the value of
    // an attribute in a stylesheet is invalid.  ""QNAME"" is the XML data-type of
    // the attribute, and should not be translated.  The substitution text {1} is
    // the attribute value and {0} is the attribute name.
  //The following codes are shared with the warning codes...
    { INVALID_QNAME,
     ""Illegal value: {1} used for QNAME attribute: {0}""},

    // Note to translators:  The following message is used if the value of
    // an attribute in a stylesheet is invalid.  ""ENUM"" is the XML data-type of
    // the attribute, and should not be translated.  The substitution text {1} is
    // the attribute value, {0} is the attribute name, and {2} is a list of valid
    // values.
    { INVALID_ENUM,
     ""Illegal value: {1} used for ENUM attribute: {0}.  Valid values are: {2}.""},

// Note to translators:  The following message is used if the value of
// an attribute in a stylesheet is invalid.  ""NMTOKEN"" is the XML data-type
// of the attribute, and should not be translated.  The substitution text {1} is
// the attribute value and {0} is the attribute name.
    { INVALID_NMTOKEN,
     ""Illegal value: {1} used for NMTOKEN attribute: {0} ""},

// Note to translators:  The following message is used if the value of
// an attribute in a stylesheet is invalid.  ""NCNAME"" is the XML data-type
// of the attribute, and should not be translated.  The substitution text {1} is
// the attribute value and {0} is the attribute name.
    { INVALID_NCNAME,
     ""Illegal value: {1} used for NCNAME attribute: {0} ""},

// Note to translators:  The following message is used if the value of
// an attribute in a stylesheet is invalid.  ""boolean"" is the XSLT data-type
// of the attribute, and should not be translated.  The substitution text {1} is
// the attribute value and {0} is the attribute name.
    { INVALID_BOOLEAN,
     ""Illegal value: {1} used for boolean attribute: {0} ""},

// Note to translators:  The following message is used if the value of
// an attribute in a stylesheet is invalid.  ""number"" is the XSLT data-type
// of the attribute, and should not be translated.  The substitution text {1} is
// the attribute value and {0} is the attribute name.
     { INVALID_NUMBER,
     ""Illegal value: {1} used for number attribute: {0} ""},


  // End of shared codes...

// Note to translators:  A ""match pattern"" is a special form of XPath expression
// that is used for matching patterns.  The substitution text is the name of
// a function.  The message indicates that when this function is referenced in
// a match pattern, its argument must be a string literal (or constant.)
// ER_ARG_LITERAL - new error message for bugzilla //5202
    { ER_ARG_LITERAL,
     ""Argument to {0} in match pattern must be a literal.""},

// Note to translators:  The following message indicates that two definitions of
// a variable.  A ""global variable"" is a variable that is accessible everywher
// in the stylesheet.
// ER_DUPLICATE_GLOBAL_VAR - new error message for bugzilla #790
    { ER_DUPLICATE_GLOBAL_VAR,
     ""Duplicate global variable declaration.""},


// Note to translators:  The following message indicates that two definitions of
// a variable were encountered.
// ER_DUPLICATE_VAR - new error message for bugzilla #790
    { ER_DUPLICATE_VAR,
     ""Duplicate variable declaration.""},

    // Note to translators:  ""xsl:template, ""name"" and ""match"" are XSLT keywords
    // which must not be translated.
    // ER_TEMPLATE_NAME_MATCH - new error message for bugzilla #789
    { ER_TEMPLATE_NAME_MATCH,
     ""xsl:template must have a name or match attribute (or both)""},

    // Note to translators:  ""exclude-result-prefixes"" is an XSLT keyword which
    // should not be translated.  The message indicates that a namespace prefix
    // encountered as part of the value of the exclude-result-prefixes attribute
    // was in error.
    // ER_INVALID_PREFIX - new error message for bugzilla #788
    { ER_INVALID_PREFIX,
     ""Prefix in exclude-result-prefixes is not valid: {0}""},

    // Note to translators:  An ""attribute set"" is a set of attributes that can
    // be added to an element in the output document as a group.  The message
    // indicates that there was a reference to an attribute set named {0} that
    // was never defined.
    // ER_NO_ATTRIB_SET - new error message for bugzilla #782
    { ER_NO_ATTRIB_SET,
     ""attribute-set named {0} does not exist""},
     
    // Note to translators:  This message indicates that there was a reference
    // to a function named {0} for which no function definition could be found.
    { ER_FUNCTION_NOT_FOUND,
     ""The function named {0} does not exist""},

    // Note to translators:  This message indicates that the XSLT instruction
    // that is named by the substitution text {0} must not contain other XSLT
    // instructions (content) or a ""select"" attribute.  The word ""select"" is
    // an XSLT keyword in this case and must not be translated.
    { ER_CANT_HAVE_CONTENT_AND_SELECT,
     ""The {0} element must not have both content and a select attribute.""},

    // Note to translators:  This message indicates that the value argument
    // of setParameter must be a valid Java Object.
    { ER_INVALID_SET_PARAM_VALUE,
     ""The value of param {0} must be a valid Java Object""},

    { ER_INVALID_NAMESPACE_URI_VALUE_FOR_RESULT_PREFIX_FOR_DEFAULT,
      ""The result-prefix attribute of an xsl:namespace-alias element has the value '#default', but there is no declaration of the default namespace in scope for the element""},

    { ER_INVALID_NAMESPACE_URI_VALUE_FOR_RESULT_PREFIX,
      ""The result-prefix attribute of an xsl:namespace-alias element has the value ''{0}'', but there is no namespace declaration for the prefix ''{0}'' in scope for the element.""},

    { ER_SET_FEATURE_NULL_NAME,
      ""The feature name cannot be null in TransformerFactory.setFeature(String name, boolean value).""},
    
    { ER_GET_FEATURE_NULL_NAME,
      ""The feature name cannot be null in TransformerFactory.getFeature(String name).""},
    
    { ER_UNSUPPORTED_FEATURE,
      ""Cannot set the feature ''{0}'' on this TransformerFactory.""},
    
    { ER_EXTENSION_ELEMENT_NOT_ALLOWED_IN_SECURE_PROCESSING,
  	  ""Use of the extension element ''{0}'' is not allowed when the secure processing feature is set to true.""},
    
    { ER_NAMESPACE_CONTEXT_NULL_NAMESPACE, 		
      ""Cannot get the prefix for a null namespace uri.""},

    { ER_NAMESPACE_CONTEXT_NULL_PREFIX, 		
      ""Cannot get the namespace uri for null prefix.""},

    { ER_XPATH_RESOLVER_NULL_QNAME, 		
      ""The function name cannot be null.""},

    { ER_XPATH_RESOLVER_NEGATIVE_ARITY, 		
      ""The arity cannot be negative.""},
  // Warnings...

    { WG_FOUND_CURLYBRACE,
      ""Found '}' but no attribute template open!""},

    { WG_COUNT_ATTRIB_MATCHES_NO_ANCESTOR,
      ""Warning: count attribute does not match an ancestor in xsl:number! Target = {0}""},

    { WG_EXPR_ATTRIB_CHANGED_TO_SELECT,
      ""Old syntax: The name of the 'expr' attribute has been changed to 'select'.""},

    { WG_NO_LOCALE_IN_FORMATNUMBER,
      ""Xalan doesn't yet handle the locale name in the format-number function.""},

    { WG_LOCALE_NOT_FOUND,
      ""Warning: Could not find locale for xml:lang={0}""},

    { WG_CANNOT_MAKE_URL_FROM,
      ""Can not make URL from: {0}""},

    { WG_CANNOT_LOAD_REQUESTED_DOC,
      ""Can not load requested doc: {0}""},

    { WG_CANNOT_FIND_COLLATOR,
      ""Could not find Collator for <sort xml:lang={0}""},

    { WG_FUNCTIONS_SHOULD_USE_URL,
      ""Old syntax: the functions instruction should use a url of {0}""},

    { WG_ENCODING_NOT_SUPPORTED_USING_UTF8,
      ""encoding not supported: {0}, using UTF-8""},

    { WG_ENCODING_NOT_SUPPORTED_USING_JAVA,
      ""encoding not supported: {0}, using Java {1}""},

    { WG_SPECIFICITY_CONFLICTS,
      ""Specificity conflicts found: {0} Last found in stylesheet will be used.""},

    { WG_PARSING_AND_PREPARING,
      ""========= Parsing and preparing {0} ==========""},

    { WG_ATTR_TEMPLATE,
     ""Attr Template, {0}""},

    { WG_CONFLICT_BETWEEN_XSLSTRIPSPACE_AND_XSLPRESERVESPACE,
      ""Match conflict between xsl:strip-space and xsl:preserve-space""},

    { WG_ATTRIB_NOT_HANDLED,
      ""Xalan does not yet handle the {0} attribute!""},

    { WG_NO_DECIMALFORMAT_DECLARATION,
      ""No declaration found for decimal format: {0}""},

    { WG_OLD_XSLT_NS,
     ""Missing or incorrect XSLT Namespace. ""},

    { WG_ONE_DEFAULT_XSLDECIMALFORMAT_ALLOWED,
      ""Only one default xsl:decimal-format declaration is allowed.""},

    { WG_XSLDECIMALFORMAT_NAMES_MUST_BE_UNIQUE,
      ""xsl:decimal-format names must be unique. Name \""{0}\"" has been duplicated.""},

    { WG_ILLEGAL_ATTRIBUTE,
      ""{0} has an illegal attribute: {1}""},

    { WG_COULD_NOT_RESOLVE_PREFIX,
      ""Could not resolve namespace prefix: {0}. The node will be ignored.""},

    { WG_STYLESHEET_REQUIRES_VERSION_ATTRIB,
      ""xsl:stylesheet requires a 'version' attribute!""},

    { WG_ILLEGAL_ATTRIBUTE_NAME,
      ""Illegal attribute name: {0}""},

    { WG_ILLEGAL_ATTRIBUTE_VALUE,
      ""Illegal value used for attribute {0}: {1}""},

    { WG_EMPTY_SECOND_ARG,
      ""Resulting nodeset from second argument of document function is empty. Return an empty node-set.""},

  //Following are the new WARNING keys added in XALAN code base after Jdk 1.4 (Xalan 2.2-D11)

    // Note to translators:  ""name"" and ""xsl:processing-instruction"" are keywords
    // and must not be translated.
    { WG_PROCESSINGINSTRUCTION_NAME_CANT_BE_XML,
      ""The value of the 'name' attribute of xsl:processing-instruction name must not be 'xml'""},

    // Note to translators:  ""name"" and ""xsl:processing-instruction"" are keywords
    // and must not be translated.  ""NCName"" is an XML data-type and must not be
    // translated.
    { WG_PROCESSINGINSTRUCTION_NOTVALID_NCNAME,
      ""The value of the ''name'' attribute of xsl:processing-instruction must be a valid NCName: {0}""},

    // Note to translators:  This message is reported if the stylesheet that is
    // being processed attempted to construct an XML document with an attribute in a
    // place other than on an element.  The substitution text specifies the name of
    // the attribute.
    { WG_ILLEGAL_ATTRIBUTE_POSITION,
      ""Cannot add attribute {0} after child nodes or before an element is produced.  Attribute will be ignored.""},

    { NO_MODIFICATION_ALLOWED_ERR,
      ""An attempt is made to modify an object where modifications are not allowed.""
    },

    //Check: WHY THERE IS A GAP B/W NUMBERS in the XSLTErrorResources properties file?

  // Other miscellaneous text used inside the code...
  { ""ui_language"", ""en""},
  {  ""help_language"",  ""en"" },
  {  ""language"",  ""en"" },
  { ""BAD_CODE"", ""Parameter to createMessage was out of bounds""},
  {  ""FORMAT_FAILED"", ""Exception thrown during messageFormat call""},
  {  ""version"", "">>>>>>> Xalan Version ""},
  {  ""version2"",  ""<<<<<<<""},
  {  ""yes"", ""yes""},
  { ""line"", ""Line #""},
  { ""column"",""Column #""},
  { ""xsldone"", ""XSLProcessor: done""},


  // Note to translators:  The following messages provide usage information
  // for the Xalan Process command line.  ""Process"" is the name of a Java class,
  // and should not be translated.
  { ""xslProc_option"", ""Xalan-J command line Process class options:""},
  { ""xslProc_option"", ""Xalan-J command line Process class options\u003a""},
  { ""xslProc_invalid_xsltc_option"", ""The option {0} is not supported in XSLTC mode.""},
  { ""xslProc_invalid_xalan_option"", ""The option {0} can only be used with -XSLTC.""},
  { ""xslProc_no_input"", ""Error: No stylesheet or input xml is specified. Run this command without any option for usage instructions.""},
  { ""xslProc_common_options"", ""-Common Options-""},
  { ""xslProc_xalan_options"", ""-Options for Xalan-""},
  { ""xslProc_xsltc_options"", ""-Options for XSLTC-""},
  { ""xslProc_return_to_continue"", ""(press <return> to continue)""},

   // Note to translators: The option name and the parameter name do not need to
   // be translated. Only translate the messages in parentheses.  Note also that
   // leading whitespace in the messages is used to indent the usage information
   // for each option in the English messages.
   // Do not translate the keywords: XSLTC, SAX, DOM and DTM.
  { ""optionXSLTC"", ""   [-XSLTC (use XSLTC for transformation)]""},
  { ""optionIN"", ""   [-IN inputXMLURL]""},
  { ""optionXSL"", ""   [-XSL XSLTransformationURL]""},
  { ""optionOUT"",  ""   [-OUT outputFileName]""},
  { ""optionLXCIN"", ""   [-LXCIN compiledStylesheetFileNameIn]""},
  { ""optionLXCOUT"", ""   [-LXCOUT compiledStylesheetFileNameOutOut]""},
  { ""optionPARSER"", ""   [-PARSER fully qualified class name of parser liaison]""},
  {  ""optionE"", ""   [-E (Do not expand entity refs)]""},
  {  ""optionV"",  ""   [-E (Do not expand entity refs)]""},
  {  ""optionQC"", ""   [-QC (Quiet Pattern Conflicts Warnings)]""},
  {  ""optionQ"", ""   [-Q  (Quiet Mode)]""},
  {  ""optionLF"", ""   [-LF (Use linefeeds only on output {default is CR/LF})]""},
  {  ""optionCR"", ""   [-CR (Use carriage returns only on output {default is CR/LF})]""},
  { ""optionESCAPE"", ""   [-ESCAPE (Which characters to escape {default is <>&\""\'\\r\\n}]""},
  { ""optionINDENT"", ""   [-INDENT (Control how many spaces to indent {default is 0})]""},
  { ""optionTT"", ""   [-TT (Trace the templates as they are being called.)]""},
  { ""optionTG"", ""   [-TG (Trace each generation event.)]""},
  { ""optionTS"", ""   [-TS (Trace each selection event.)]""},
  {  ""optionTTC"", ""   [-TTC (Trace the template children as they are being processed.)]""},
  { ""optionTCLASS"", ""   [-TCLASS (TraceListener class for trace extensions.)]""},
  { ""optionVALIDATE"", ""   [-VALIDATE (Set whether validation occurs.  Validation is off by default.)]""},
  { ""optionEDUMP"", ""   [-EDUMP {optional filename} (Do stackdump on error.)]""},
  {  ""optionXML"", ""   [-XML (Use XML formatter and add XML header.)]""},
  {  ""optionTEXT"", ""   [-TEXT (Use simple Text formatter.)]""},
  {  ""optionHTML"", ""   [-HTML (Use HTML formatter.)]""},
  {  ""optionPARAM"", ""   [-PARAM name expression (Set a stylesheet parameter)]""},
  {  ""noParsermsg1"", ""XSL Process was not successful.""},
  {  ""noParsermsg2"", ""** Could not find parser **""},
  { ""noParsermsg3"",  ""Please check your classpath.""},
  { ""noParsermsg4"", ""If you don't have IBM's XML Parser for Java, you can download it from""},
  { ""noParsermsg5"", ""IBM's AlphaWorks: http://www.alphaworks.ibm.com/formula/xml""},
  { ""optionURIRESOLVER"", ""   [-URIRESOLVER full class name (URIResolver to be used to resolve URIs)]""},
  { ""optionENTITYRESOLVER"",  ""   [-ENTITYRESOLVER full class name (EntityResolver to be used to resolve entities)]""},
  { ""optionCONTENTHANDLER"",  ""   [-CONTENTHANDLER full class name (ContentHandler to be used to serialize output)]""},
  {  ""optionLINENUMBERS"",  ""   [-L use line numbers for source document]""},
  { ""optionSECUREPROCESSING"", ""   [-SECURE (set the secure processing feature to true.)]""},

    // Following are the new options added in XSLTErrorResources.properties files after Jdk 1.4 (Xalan 2.2-D11)


  {  ""optionMEDIA"",  ""   [-MEDIA mediaType (use media attribute to find stylesheet associated with a document.)]""},
  {  ""optionFLAVOR"",  ""   [-FLAVOR flavorName (Explicitly use s2s=SAX or d2d=DOM to do transform.)] ""}, // Added by sboag/scurcuru; experimental
  { ""optionDIAG"", ""   [-DIAG (Print overall milliseconds transform took.)]""},
  { ""optionINCREMENTAL"",  ""   [-INCREMENTAL (request incremental DTM construction by setting http://xml.apache.org/xalan/features/incremental true.)]""},
  {  ""optionNOOPTIMIMIZE"",  ""   [-NOOPTIMIMIZE (request no stylesheet optimization processing by setting http://xml.apache.org/xalan/features/optimize false.)]""},
  { ""optionRL"",  ""   [-RL recursionlimit (assert numeric limit on stylesheet recursion depth.)]""},
  {   ""optionXO"",  ""   [-XO [transletName] (assign the name to the generated translet)]""},
  {  ""optionXD"", ""   [-XD destinationDirectory (specify a destination directory for translet)]""},
  {  ""optionXJ"",  ""   [-XJ jarfile (packages translet classes into a jar file of name <jarfile>)]""},
  {   ""optionXP"",  ""   [-XP package (specifies a package name prefix for all generated translet classes)]""},

  //AddITIONAL  STRINGS that need L10n
  // Note to translators:  The following message describes usage of a particular
  // command-line option that is used to enable the ""template inlining""
  // optimization.  The optimization involves making a copy of the code
  // generated for a template in another template that refers to it.
  { ""optionXN"",  ""   [-XN (enables template inlining)]"" },
  { ""optionXX"",  ""   [-XX (turns on additional debugging message output)]""},
  { ""optionXT"" , ""   [-XT (use translet to transform if possible)]""},
  { ""diagTiming"","" --------- Transform of {0} via {1} took {2} ms"" },
  { ""recursionTooDeep"",""Template nesting too deep. nesting = {0}, template {1} {2}"" },
  { ""nameIs"", ""name is"" },
  { ""matchPatternIs"", ""match pattern is"" }

  };
  }",Get the contents of the C ++ NC   .
"public void marshall(DeleteVPCEConfigurationRequest deleteVPCEConfigurationRequest, ProtocolMarshaller protocolMarshaller) {

        if (deleteVPCEConfigurationRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(deleteVPCEConfigurationRequest.getArn(), ARN_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given DeleteVPCEConfigurationRequest to the JSON - compatible parameter object.
"private NodeDO modelToDo(Node node) {
        NodeDO nodeDo = new NodeDO();
        try {
            nodeDo.setId(node.getId());
            nodeDo.setIp(node.getIp());
            nodeDo.setName(node.getName());
            nodeDo.setPort(node.getPort());
            nodeDo.setDescription(node.getDescription());
            nodeDo.setStatus(node.getStatus());
            nodeDo.setParameters(node.getParameters());
            nodeDo.setGmtCreate(node.getGmtCreate());
            nodeDo.setGmtModified(node.getGmtModified());
        } catch (Exception e) {
            logger.error(""ERROR ## change the node Model to Do has an exception"");
            throw new ManagerException(e);
        }
        return nodeDo;
    }",Method modelToDo.
"public boolean isInRange(final Level minLevel, final Level maxLevel) {
        return this.intLevel >= minLevel.intLevel && this.intLevel <= maxLevel.intLevel;
    }",Check if the class level is in the range of the given levels.
"public static RAExpression joinOn(RAExpression re1, RAExpression re2,
                                      java.util.function.Function<ImmutableMap<QualifiedAttributeID, Term>, ImmutableList<Function>> getAtomOnExpression,
                                      TermFactory termFactory) throws IllegalJoinException {

        RAExpressionAttributes attributes =
                RAExpressionAttributes.crossJoin(re1.attributes, re2.attributes);

        return new RAExpression(union(re1.dataAtoms, re2.dataAtoms),
                union(re1.filterAtoms, re2.filterAtoms,
                        getAtomOnExpression.apply(attributes.getAttributes())), attributes, termFactory);
    }",Join two RA expressions on the same attribute.
"public static void updateFileFromUrl(final String sourceUrl, final String destinationFilePath) throws
        UpdateException {
        updateFileFromUrl(sourceUrl, destinationFilePath, null, null);
    }",Update a file from a URL.
"private void parseResources(CloudTrailEventData eventData) throws IOException {
        JsonToken nextToken = jsonParser.nextToken();
        if (nextToken == JsonToken.VALUE_NULL) {
            eventData.add(CloudTrailEventField.resources.name(), null);
            return;
        }

        if (nextToken != JsonToken.START_ARRAY) {
            throw new JsonParseException(""Not a list of resources object"", jsonParser.getCurrentLocation());
        }

        List<Resource> resources = new ArrayList<Resource>();

        while (jsonParser.nextToken() != JsonToken.END_ARRAY) {
            resources.add(parseResource());
        }

        eventData.add(CloudTrailEventField.resources.name(), resources);
    }",Parses the resources field.
"private Set<String> getDeployableConfigPaths() {

    ConfigurationBuilder cb =
        new ConfigurationBuilder().setUrls(ClasspathHelper.forClassLoader()).setScanners(new ResourcesScanner())
            .filterInputsBy(new FilterBuilder().include(String.format("".*%s.*"", this.classpathRootName)));

    Reflections reflections = new Reflections(cb);
    Pattern pattern = Pattern.compile("".*"");

    return reflections.getResources(pattern);
  }",Get the deployable config paths
"public boolean retainIndex(Collection<FeatureIndexType> types) {
        Set<FeatureIndexType> delete = new HashSet<>(indexLocationQueryOrder);
        delete.removeAll(types);
        return deleteIndex(delete);
    }",Retain index of feature types.
"public BusItinerary getBusItinerary(UUID uuid) {
		if (uuid == null) {
			return null;
		}
		for (final BusItinerary busItinerary : this.itineraries) {
			if (uuid.equals(busItinerary.getUUID())) {
				return busItinerary;
			}
		}
		return null;
	}",Replies the bus itinerary with the given uuid.
"public static boolean iconExists(@NonNull Context context, @NonNull String icon) {
        try {
            ITypeface font = findFont(context, icon.substring(0, 3));
            icon = icon.replace(""-"", ""_"");
            font.getIcon(icon);
            return true;
        } catch (Exception ignore) {
            return false;
        }
    }",Check if an icon exists in the context.
"private void populatePut(Put p, byte[] family, String key, String groupName, String counterName,
      Long counterValue) {
    byte[] counterPrefix = null;

    try {
      switch (JobHistoryKeys.valueOf(JobHistoryKeys.class, key)) {
      case COUNTERS:
      case TOTAL_COUNTERS:
      case TASK_COUNTERS:
      case TASK_ATTEMPT_COUNTERS:
        counterPrefix = Bytes.add(Constants.COUNTER_COLUMN_PREFIX_BYTES, Constants.SEP_BYTES);
        break;
      case MAP_COUNTERS:
        counterPrefix = Bytes.add(Constants.MAP_COUNTER_COLUMN_PREFIX_BYTES, Constants.SEP_BYTES);
        break;
      case REDUCE_COUNTERS:
        counterPrefix =
            Bytes.add(Constants.REDUCE_COUNTER_COLUMN_PREFIX_BYTES, Constants.SEP_BYTES);
        break;
      default:
        throw new IllegalArgumentException(""Unknown counter type "" + key.toString());
      }
    } catch (IllegalArgumentException iae) {
      throw new ProcessingException(""Unknown counter type "" + key, iae);
    } catch (NullPointerException npe) {
      throw new ProcessingException(""Null counter type "" + key, npe);
    }

    byte[] groupPrefix = Bytes.add(counterPrefix, Bytes.toBytes(groupName), Constants.SEP_BYTES);
    byte[] qualifier = Bytes.add(groupPrefix, Bytes.toBytes(counterName));

    /*
     * store the map and reduce mb millis counter value
     */
    if (Constants.JOB_COUNTER_HADOOP2.equals(groupName)) {
      if (Constants.MB_MILLIS_MAPS.equals(counterName)) {
        this.mapMbMillis = counterValue;
      } else if (Constants.MB_MILLIS_REDUCES.equals(counterName)) {
          this.reduceMbMillis = counterValue;
      }
    }

    /*
     * correct and populate map and reduce slot millis
     */
    if ((Constants.SLOTS_MILLIS_MAPS.equals(counterName)) ||
        (Constants.SLOTS_MILLIS_REDUCES.equals(counterName))) {
      counterValue = getStandardizedCounterValue(counterName, counterValue);
    }

    p.addColumn(family, qualifier, Bytes.toBytes(counterValue));

  }",Populate put.
"public int getSeqPos(int aligSeq, Point p) {

		int x = p.x - DEFAULT_X_SPACE - DEFAULT_LEGEND_SIZE;
		int y = p.y - DEFAULT_Y_SPACE ;

		y -=  (DEFAULT_LINE_SEPARATION * aligSeq) - DEFAULT_CHAR_SIZE;

		int lineNr = y / DEFAULT_Y_STEP;
		int linePos = x / DEFAULT_CHAR_SIZE;
		return lineNr * DEFAULT_LINE_LENGTH + linePos ;

	}",Get the position of a sequence of points.
"public static String getMimeTypeForFile(URL url) {
        if (url == null) {
            //The input url is null so we can't retrieve a mimetype, therefore we return null.
            return null;
        }
        String external = url.toExternalForm();
        if (external.indexOf('.') == -1) {
            return BINARY;
        } else {
            String ext = external.substring(external.lastIndexOf('.') + 1);
            String mime = KnownMimeTypes.getMimeTypeByExtension(ext);
            if (mime == null) {
                return BINARY;
            } else {
                return mime;
            }
        }
    }",Get the mime type for a file.
"public @Nullable Page getPage(@NotNull Page basePage) {
    return getPage((Predicate<Page>)null, basePage);
  }",Get a Page from the PageCollection.
"public CouchDbGoogleAuthenticatorAccount update(final OneTimeTokenAccount account) {
        setId(account.getId());
        setUsername(account.getUsername());
        setSecretKey(account.getSecretKey());
        setValidationCode(account.getValidationCode());
        setScratchCodes(account.getScratchCodes());
        setRegistrationDate(account.getRegistrationDate());
        return this;
    }",Update one time token account.
"public ClientResponseImpl call(Object... paramListIn) {
        m_perCallStats = m_statsCollector.beginProcedure();

        // if we're keeping track, calculate parameter size
        if (m_perCallStats != null) {
            StoredProcedureInvocation invoc = (m_txnState != null ? m_txnState.getInvocation() : null);
            ParameterSet params = (invoc != null ? invoc.getParams() : ParameterSet.fromArrayNoCopy(paramListIn));
            m_perCallStats.setParameterSize(params.getSerializedSize());
        }

        ClientResponseImpl result = coreCall(paramListIn);

        // if we're keeping track, calculate result size
        if (m_perCallStats != null) {
            m_perCallStats.setResultSize(result.getResults());
        }

        m_statsCollector.endProcedure(result.getStatus() == ClientResponse.USER_ABORT,
                                      (result.getStatus() != ClientResponse.USER_ABORT) &&
                                      (result.getStatus() != ClientResponse.SUCCESS),
                                      m_perCallStats);
        // allow the GC to collect per-call stats if this proc isn't called for a while
        m_perCallStats = null;

        return result;
    }",Call the database procedure.
"public FieldDescriptorDef getField(String name)
    {
        FieldDescriptorDef fieldDef = null;

        for (Iterator it = _fields.iterator(); it.hasNext(); )
        {
            fieldDef = (FieldDescriptorDef)it.next();
            if (fieldDef.getName().equals(name))
            {
                return fieldDef;
            }
        }
        return null;
    }",Gets the field with the specified name.
"@XmlElementDecl(namespace = PROV_NS, name = ""plan"")
    public JAXBElement<Plan> createPlan(Plan value) {
        return new JAXBElement<Plan>(_Plan_QNAME, Plan.class, null, value);
    }",Create an instance of the plan property.
"public int getZoomLevelProgress(int zoomLevel) {
		Integer zoomProgress = zoomLevelProgress.get(zoomLevel);
		if (zoomProgress == null) {
			zoomProgress = 0;
		}
		return zoomProgress;
	}",Get the zoom level progress.
"public HttpHubConnectionBuilder withHeader(String name, String value) {
        if (headers == null) {
            this.headers = new HashMap<>();
        }
        this.headers.put(name, value);
        return this;
    }",Sets the header value for the HTTP request.
"public static int compressTime(long date) {
		Long lowResolutionDate = new Long((date - TIME_ZERO) / MS_IN_SEC);
		return lowResolutionDate.intValue();
	}",Compress a time value.
"public static KeyChain configure(final Name name) throws SecurityException {
    PrivateKeyStorage keyStorage = new MemoryPrivateKeyStorage();
    IdentityStorage identityStorage = new MemoryIdentityStorage();
    KeyChain keyChain = new KeyChain(new IdentityManager(identityStorage, keyStorage),
            new SelfVerifyPolicyManager(identityStorage));

    // create keys, certs if necessary
    if (!identityStorage.doesIdentityExist(name)) {
      keyChain.createIdentityAndCertificate(name);
    }

    // set default identity
    keyChain.getIdentityManager().setDefaultIdentity(name);

    return keyChain;
  }",Create a new key chain with the specified name.
"private void addExecutionGoals(MavenPluginExecutionDescriptor executionDescriptor, PluginExecution pluginExecution, Store store) {
        List<String> goals = pluginExecution.getGoals();
        for (String goal : goals) {
            MavenExecutionGoalDescriptor goalDescriptor = store.create(MavenExecutionGoalDescriptor.class);
            goalDescriptor.setName(goal);
            executionDescriptor.getGoals().add(goalDescriptor);
        }

    }",Add execution goals.
"public static String getOneEffectiveSign(String bucketName, String cosPath, Credentials cred)
			throws AbstractCosException {
		return appSignatureBase(cred, bucketName, cosPath, 0, true);
	}",Get one effective signature for a bucket and a Cos path.
"public static String getStatusText(int status) {
		switch (status) {
		case SSH_FX_OK:
			return ""OK"";
		case SSH_FX_EOF:
			return ""EOF"";
		case SSH_FX_NO_SUCH_FILE:
			return ""No such file."";
		case SSH_FX_PERMISSION_DENIED:
			return ""Permission denied."";
		case SSH_FX_FAILURE:
			return ""Server responded with an unknown failure."";
		case SSH_FX_BAD_MESSAGE:
			return ""Server responded to a bad message."";
		case SSH_FX_NO_CONNECTION:
			return ""No connection available."";
		case SSH_FX_CONNECTION_LOST:
			return ""Connection lost."";
		case SSH_FX_OP_UNSUPPORTED:
			return ""The operation is unsupported."";
		case SSH_FX_INVALID_HANDLE:
		case INVALID_HANDLE:
			return ""Invalid file handle."";
		case SSH_FX_NO_SUCH_PATH:
			return ""No such path."";
		case SSH_FX_FILE_ALREADY_EXISTS:
			return ""File already exists."";
		case SSH_FX_WRITE_PROTECT:
			return ""Write protect error."";
		case SSH_FX_NO_MEDIA:
			return ""No media at location"";
		case SSH_FX_NO_SPACE_ON_FILESYSTEM:
			return ""No space on filesystem"";
		case SSH_FX_QUOTA_EXCEEDED:
			return ""Quota exceeded"";
		case SSH_FX_UNKNOWN_PRINCIPAL:
			return ""Unknown principal"";
		case SSH_FX_LOCK_CONFLICT:
			return ""Lock conflict"";
		case SSH_FX_DIR_NOT_EMPTY:
			return ""Dir not empty"";
		case SSH_FX_NOT_A_DIRECTORY:
			return ""Not a directory"";
		case SSH_FX_INVALID_FILENAME:
			return ""Invalid filename"";
		case SSH_FX_LINK_LOOP:
			return ""Link loop"";
		case SSH_FX_CANNOT_DELETE:
			return ""Cannot delete"";
		case SSH_FX_INVALID_PARAMETER:
			return ""Invalid parameter"";
		case SSH_FX_FILE_IS_A_DIRECTORY:
			return ""File is a directory"";
		case SSH_FX_BYTE_RANGE_LOCK_CONFLICT:
			return ""Byte range lock conflict"";
		case SSH_FX_BYTE_RANGE_LOCK_REFUSED:
			return ""Byte range lock refused"";
		case SSH_FX_DELETE_PENDING:
			return ""Delete pending"";
		case SSH_FX_FILE_CORRUPT:
			return ""File corrupt"";
		case SSH_FX_OWNER_INVALID:
			return ""Owner invalid"";
		case SSH_FX_GROUP_INVALID:
			return ""Group invalid"";
		case SSH_FX_NO_MATCHING_BYTE_RANGE_LOCK:
			return ""No matching byte range lock"";
		case INVALID_RESUME_STATE:
			return ""Invalid resume state"";
		default:
			return ""Unknown status type "" + String.valueOf(status);
		}
	}",Get the status text for the given status code.
"@Override
	public <T extends SearchEntity> EntityIdBoundaries searchForIdBoundaries(Class<T> entityClass) {
		return handleSearchForIdBoundaries(entityClass);
	}",Override this method to search for entity id boundaries.
"public static String decodeUri(String uri) {
    try {
      return URLDecoder.decode(uri, ""UTF-8"");
    } catch (UnsupportedEncodingException e) {
      // UTF-8 encoding guaranteed to be supported by JVM
      throw new RuntimeException(e);
    }
  }",Decode a URI string.
"private static char[] getIndent(int indentSize, Map<Integer, char[]> indentCache) {
        char[] indent = indentCache.get(indentSize);
        if (indent == null) {
            indent = new char[indentSize];
            Arrays.fill(indent, SPACE);
            indentCache.put(indentSize, indent);
        }

        return indent;
    }",Get the indent of a class file.
"public static Assignments cluster(Matrix matrix,
                                      int numClusters,
                                      int numRepetitions,
                                      CriterionFunction criterion) {
        return cluster(matrix, numClusters, numRepetitions,
                       new RandomSeed(), criterion);
    }",Cluster a matrix into a number of clusters.
"@Pure
	@Inline(value = ""new Vector2d(Math.cos($1), Math.sin($1))"", imported = {Vector2d.class, Math.class})
	public static Vector2d toOrientationVector(double angle) {
		return new Vector2d(Math.cos(angle), Math.sin(angle));
	}",Convert a angle in radians to an orientation vector.
"public void setHeaderVisible(boolean visible) {

        String style = I_CmsSitemapLayoutBundle.INSTANCE.sitemapCss().headerContainerVaadinMode();
        if (visible) {
            m_headerContainer.removeStyleName(style);
        } else {
            m_headerContainer.addStyleName(style);
        }
    }",Sets the visibility of the header.
"@Override
	public List<CommerceShipmentItem> findAll(int start, int end) {
		return findAll(start, end, null);
	}",Returns a range of all the commerce shipment items.
"public Object decode(final Class c, final Object fromDBObject, final MappedField mf) {
        Class toDecode = c;
        if (toDecode == null) {
            toDecode = fromDBObject.getClass();
        }
        return getEncoder(toDecode).decode(toDecode, fromDBObject, mf);
    }",Decode a single object from a DBObject.
"public static boolean needClassFileTransformer(PersistenceUnitMetadata pu) {
        boolean result = true;
        String provider = pu.getPersistenceProviderClassName();
        if (pu.getProperties().containsKey(Configuration.JPA_CONTAINER_CLASS_TRANSFORMER)) {
            result = Boolean.parseBoolean(pu.getProperties().getProperty(Configuration.JPA_CONTAINER_CLASS_TRANSFORMER));
        }
        else if (isHibernateProvider(provider)) {
            result = (Boolean.TRUE.toString().equals(pu.getProperties().getProperty(HIBERNATE_USE_CLASS_ENHANCER))
                    || Boolean.TRUE.toString().equals(pu.getProperties().getProperty(HIBERNATE_ENABLE_DIRTY_TRACKING))
                    || Boolean.TRUE.toString().equals(pu.getProperties().getProperty(HIBERNATE_ENABLE_LAZY_INITIALIZATION))
                    || Boolean.TRUE.toString().equals(pu.getProperties().getProperty(HIBERNATE_ENABLE_ASSOCIATION_MANAGEMENT)));
        }
        return result;
    }",Check if the persistence unit metadata needs a class file transformer.
"void removeLog(PlainChangesLog log)
   {
      if (LOG.isDebugEnabled())
      {
         LOG.debug(""tx removeLog() "" + this + (transactionLog != null ? ""\n"" + transactionLog.dump() : ""[NULL]""));
      }

      if (txStarted())
      {
         transactionLog.removeLog(log);
         if (transactionLog.getSize() == 0)
         {
            // Clear tx changes log if there is no log left
            transactionLog = null;
         }
      }
   }",Remove the given changes log from the transaction.
"public JavaField export(JavaClass cl, JavaClass target)
  {
    JavaField field = new JavaField();
    field.setName(_name);
    field.setDescriptor(_descriptor);
    field.setAccessFlags(_accessFlags);

    target.getConstantPool().addUTF8(_name);
    target.getConstantPool().addUTF8(_descriptor);

    for (int i = 0; i < _attributes.size(); i++) {
      Attribute attr = _attributes.get(i);

      field.addAttribute(attr.export(cl, target));
    }

    return field;
  }",Export the field.
"public static MessageBatcher createBatcher(String name,
			MessageProcessor processor) {
		MessageBatcher batcher = batcherMap.get(name);
		if (batcher == null) {
			synchronized (BatcherFactory.class) {
				batcher = batcherMap.get(name);
				if (batcher == null) {
					batcher = new MessageBatcher(name, processor);
					batcherMap.put(name, batcher);
				}
			}
		}
		return batcher;
	}",Creates a new MessageBatcher with the specified name and message processor.
"public ConfigResponse getLuceneIndexes(LuceneIndexesData luceneIndexesData) throws ApiException {
        ApiResponse<ConfigResponse> resp = getLuceneIndexesWithHttpInfo(luceneIndexesData);
        return resp.getData();
    }",Get Index Get Index
"public JsonWriter value(Number value) throws IOException {
    if (value == null) {
      return nullValue();
    }

    writeDeferredName();
    String string = value.toString();
    if (!lenient
        && (string.equals(""-Infinity"") || string.equals(""Infinity"") || string.equals(""NaN""))) {
      throw new IllegalArgumentException(""Numeric values must be finite, but was "" + value);
    }
    beforeValue(false);
    out.append(string);
    return this;
  }",Write a number value.
"private void iterateGroupNodes(long groupdId, NodeReader nodeReader)
    {
        // while the index can be a long, the value is always an int
        int currentPointer = (int) headPointers.get(groupdId);
        checkArgument(currentPointer != NULL, ""valid group must have non-null head pointer"");

        while (currentPointer != NULL) {
            checkState(currentPointer < nextNodePointer, ""error, corrupt pointer; max valid %s, found %s"", nextNodePointer, currentPointer);
            nodeReader.read(currentPointer);
            currentPointer = nextPointers.get(currentPointer);
        }
    }",Iterate over all nodes in the group.
"private boolean consistentCache(int accessor) {
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) JmfTr.entry(this, tc, ""consistentCache"", new Object[]{Integer.valueOf(accessor)});

    JSType field = findDominatingCase(fields[accessor]);
    JSVariant parent = (JSVariant) field.getParent();

    boolean result = (parent == null) || (choiceCache[parent.getIndex()] == field.getSiblingPosition());

    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) JmfTr.exit(this, tc, ""consistentCache"", Boolean.valueOf(result));
    return result;
  }",Check if the cache contains a node in the variant.
"@Override
	public Set<StringTextValue<?>> asSet()
	{
		final Set<StringTextValue<?>> allSettings = new HashSet<>();
		allSettings.add(getOpen());
		allSettings.add(getClose());
		allSettings.add(getAccordion());
		allSettings.add(getPersist());
		allSettings.add(getQuery());
		allSettings.add(getClickQuery());
		return allSettings;
	}",Returns the settings as a set.
"public double addNewSample(double newSample) {
        final double sample = calculateLog(newSample);
        return Double.longBitsToDouble(valueEncodedAsLong.updateAndGet(value -> {
            return Double.doubleToRawLongBits(sample * newSampleWeight + (1.0 - newSampleWeight) * Double.longBitsToDouble(value));
        }));
    }",Add a new sample to the logarithmic value.
"CloseableIterator<T> createIterator(int resultFlags) {
		try {
			SelectIterator<T, ID> iterator =
					statementExecutor.buildIterator(this, connectionSource, resultFlags, objectCache);
			return iterator;
		} catch (Exception e) {
			throw new IllegalStateException(""Could not build iterator for "" + dataClass, e);
		}
	}",Creates an iterator for the given result flags.
"private List<String> removeSeLionArgumentsAndValues(List<String> args) {
        // assume all of the ProcessLauncherConfiguration and LauncherConfiguration arguments should not be forwarded
        Set<Field> fields = new HashSet<>();
        fields.addAll(Arrays.asList(ProcessLauncherConfiguration.class.getDeclaredFields()));
        fields.addAll(Arrays.asList(LauncherConfiguration.class.getDeclaredFields()));

        for (Field field : fields) {
            // we need jcommander parameter fields only
            Parameter parameter = field.getAnnotation(Parameter.class);
            if (parameter == null) {
                continue;
            }

            // get the ""arity"" (how many values it can have on the command line) of the parameter/argument.
            // for example ""-foo bar bar2""  --> argument = -foo --> arity = 2 --> values = {bar, bar2}
            final Class<?> fieldType = field.getType();
            final int arity = (parameter.arity() != -1) ? parameter.arity() :
                (fieldType.equals(Integer.class) || fieldType.equals(Long.class) || fieldType.equals(String.class) ||
                    fieldType.equals(int.class) || fieldType.equals(long.class)) ? 1 : 0;

            if (arity > 0) {
                for (String arg : args) {
                    // when the arg we are processing is one of the @Parameter names
                    if (Arrays.asList(parameter.names()).contains(arg)) {
                        // replace each value with """"
                        for (int x = 1; x <= arity; x += 1 ) {
                            args.set(args.indexOf(arg) + x, """");
                        }
                        // replace the argument with """"
                        args.set(args.indexOf(arg), """");
                    }
                }
                // remove all """"
                args.removeAll(Arrays.asList(""""));
            } else {
                // the ""arity"" of the argument 0. there are no values to worry about.
                // remove all instances of the argument (and/or one of its names) from args
                args.removeAll(Arrays.asList(parameter.names()));
            }
        }

        return args;
    }",Remove all SeLion arguments and values from the list of arguments.
"public boolean hasMoreMessages() {
    if (!rqueue.isEmpty()) {
      return true;
    } else {
      synchronized (omap) {
        Iterator<TapStream> itr = omap.keySet().iterator();
        while (itr.hasNext()) {
          TapStream ts = itr.next();
          if (ts.isCompleted() || ts.isCancelled() || ts.hasErrored()) {
            omap.get(ts).shutdown();
            omap.remove(ts);
          }
        }
        if (omap.size() > 0) {
          return true;
        }
      }
    }
    return false;
  }",Returns true if there are more messages in the queue.
"public int insert(Connection conn, Entity record) throws SQLException {
		checkConn(conn);
		if(CollectionUtil.isEmpty(record)){
			throw new SQLException(""Empty entity provided!"");
		}
		PreparedStatement ps = null;
		try {
			ps = dialect.psForInsert(conn, record);
			return ps.executeUpdate();
		} catch (SQLException e) {
			throw e;
		} finally {
			DbUtil.close(ps);
		}
	}",Insert a new entity into the database.
"public Form add(Field field) {
		if (field.mode() == null) {
			field.mode(mode);
		}

		if (field.layout() == null) {
			field.layout(layout);
		}

		fields.add(field);
		return this;
	}",Adds a field to the form.
"private void onClickAdd() {

        if (m_currentLocation.isPresent()) {
            CmsFavoriteEntry entry = m_currentLocation.get();
            List<CmsFavoriteEntry> entries = getEntries();
            entries.add(entry);
            try {
                m_favDao.saveFavorites(entries);
            } catch (Exception e) {
                CmsErrorDialog.showErrorDialog(e);
            }
            m_context.close();
        }
    }",Click on add button.
"public static void notifyAboutCloudSize(InetAddress ip, int port, InetAddress leaderIp, int leaderPort, int size) {
    if (ARGS.notify_local != null && !ARGS.notify_local.trim().isEmpty()) {
      final File notifyFile = new File(ARGS.notify_local);
      final File parentDir = notifyFile.getParentFile();
      if (parentDir != null && !parentDir.isDirectory()) {
        if (!parentDir.mkdirs()) {
          Log.err(""Cannot make parent dir for notify file."");
          H2O.exit(-1);
        }
      }
      try(BufferedWriter output = new BufferedWriter(new FileWriter(notifyFile))) {
        output.write(SELF_ADDRESS.getHostAddress());
        output.write(':');
        output.write(Integer.toString(API_PORT));
        output.flush();
      } catch ( IOException e ) {
        e.printStackTrace();
      }
    }
    if (embeddedH2OConfig == null) { return; }
    embeddedH2OConfig.notifyAboutCloudSize(ip, port, leaderIp, leaderPort, size);
  }",Notify about Cloud Size
"public double getMedian() {
        if (DATA_LIST.size() > 2) {
            sortData();

            if (sortedList.size() % 2 != 0) {
                return sortedList.get((sortedList.size() / 2));
            } else {
                return (sortedList.get(sortedList.size() / 2 - 1) + sortedList.get(sortedList.size() / 2)) / 2.0;
            }
        }
        return 0;
    }",Get the median value of the data.
"public static UserCustomColumn createRelatedIdColumn(int index) {
		return UserCustomColumn.createColumn(index, COLUMN_RELATED_ID,
				GeoPackageDataType.INTEGER, true, null);
	}",Create a related id column.
"public byte[] getScreenImage() {
        logger.entering();
        logger.exiting(this.screenImage);
        return Arrays.copyOf(screenImage, screenImage.length);
    }",Gets the screen image.
"private static String toJavaCipherSuitePrefix(String protocolVersion) {
        final char c;
        if (protocolVersion == null || protocolVersion.isEmpty()) {
            c = 0;
        } else {
            c = protocolVersion.charAt(0);
        }

        switch (c) {
            case 'T':
                return ""TLS"";
            case 'S':
                return ""SSL"";
            default:
                return ""UNKNOWN"";
        }
    }",Returns the Java cipher suite prefix for the protocol version.
"@Override
    public boolean startsWith(final String other) {
        if (other == null) {
            throw new IllegalArgumentException(""other path input must be specified"");
        }
        final Path otherPath = this.fromString(other);
        return this.startsWith(otherPath);
    }",Check if this path starts with the other path.
"protected void jobStarting()
    {
        this.jobContext.pushCurrentJob(this);

        this.observationManager.notify(new JobStartedEvent(getRequest().getId(), getType(), this.request), this);

        if (this.status instanceof AbstractJobStatus) {
            ((AbstractJobStatus<R>) this.status).setStartDate(new Date());
            ((AbstractJobStatus<R>) this.status).setState(JobStatus.State.RUNNING);

            ((AbstractJobStatus) this.status).startListening();
        }

        if (getRequest().isVerbose()) {
            if (getStatus().getRequest().getId() != null) {
                this.logger.info(LOG_BEGIN_ID, ""Starting job of type [{}] with identifier [{}]"", getType(),
                    getStatus().getRequest().getId());
            } else {
                this.logger.info(LOG_BEGIN, ""Starting job of type [{}]"", getType());
            }
        }
    }",This method is called when a job is starting.
"public Subscription withEventSubscriptions(EventSubscription... eventSubscriptions) {
        if (this.eventSubscriptions == null) {
            setEventSubscriptions(new java.util.ArrayList<EventSubscription>(eventSubscriptions.length));
        }
        for (EventSubscription ele : eventSubscriptions) {
            this.eventSubscriptions.add(ele);
        }
        return this;
    }",A list of event subscriptions.
"public static void runExample(AdWordsServicesInterface adWordsServices, AdWordsSession session,
      List<Long> campaignIds, Long labelId) throws RemoteException {
    // Get the CampaignService.
    CampaignServiceInterface campaignService =
        adWordsServices.get(session, CampaignServiceInterface.class);

    // Create label operations.
    List<CampaignLabelOperation> operations = new ArrayList<>(
        campaignIds.size());
    for (Long campaignId : campaignIds) {
      CampaignLabel campaignLabel = new CampaignLabel();
      campaignLabel.setCampaignId(campaignId);
      campaignLabel.setLabelId(labelId);

      CampaignLabelOperation operation = new CampaignLabelOperation();
      operation.setOperand(campaignLabel);
      operation.setOperator(Operator.ADD);

      operations.add(operation);
    }

    // Display campaign labels.
    for (CampaignLabel campaignLabelResult : campaignService.mutateLabel(
        operations.toArray(new CampaignLabelOperation[operations.size()])).getValue()) {
      System.out.printf(""Campaign label for campaign ID %d and label ID %d was added.%n"",
          campaignLabelResult.getCampaignId(), campaignLabelResult.getLabelId());
    }
  }",Example of adding a label to a CDN.
"private static byte hexVal(byte ch) throws IOException {
        if ((ch >= '0') && (ch <= '9')) {
            return (byte) ((char) ch - '0');
        } else if ((ch >= 'a') && (ch <= 'f')) {
            return (byte) ((char) ch - 'a' + 10);
        } else {
            throw new ProtocolException(""Expected hex character"");
        }
    }",Returns the value of the hex character.
"public void initializeForUOW(MCWrapper mcWrapper, boolean originIsDeferred) throws ResourceException {

        final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();
        if (isTraceOn && tc.isEntryEnabled()) {
            Tr.entry(this, tc, ""initializeForUOW"");
        }

        boolean registeredForSync = false;
        boolean enlisted = false;

        UOWCoordinator uowCoord = mcWrapper.getUOWCoordinator();

        // See allocateMCWrapper for a discussion on the checks being done here
        if (uowCoord == null) {

            if (isTraceOn && tc.isDebugEnabled()) {
                Tr.debug(this, tc, ""Transaction context does NOT exist"");
            }

            if (!mcWrapper.gConfigProps.isDynamicEnlistmentSupported()) {

                if (isTraceOn && tc.isDebugEnabled()) {
                    Tr.debug(this, tc, ""Not marked for dynamic transaction enlistment"");
                }

                // Only log warnings or throw exception for LocalTransaction and XATransaction RAs...
                if ((mcWrapper.gConfigProps.transactionSupport == TransactionSupport.TransactionSupportLevel.LocalTransaction) ||
                    (mcWrapper.gConfigProps.transactionSupport == TransactionSupport.TransactionSupportLevel.XATransaction)) { // 144070 WS14620.01

                    // deleted check for RRSTransactional support
                    if (mcWrapper.gConfigProps.logMissingTranContext) {
                        Tr.warning(tc, ""MISSING_TRANSACTION_CONTEXT_J2CA0075"", ""initializeForUOW"");
                    }
                    // Remove check for whether connector runtime supports no transaction mode

                }

            }

        } else {

            // If there is an UOWCoordinator context then consider this ManagedConnection
            // for association with this transaction

            if (isTraceOn && tc.isDebugEnabled()) {
                Tr.debug(this, tc, ""Transaction context exists"");
            }

            /*
             * If this ManagedConnection is not already associated then perform the
             * enlistment and create necessary associations. No synchronisation is
             * necessary here because we are in a global transaction context and the
             * ManagedConnection was reserved under this context and the context is
             * thread specific so no ManagedConnection can be being manipulated by
             * two threads at the saem time.
             */

            TranWrapper wrapper = null;

            // Note:  in future this logic for determining which kind of tran wrapper to create
            // Can be reorganized (see truth table)
            if (mcWrapper.isEnlistmentDisabled()) {

                if (isTraceOn && tc.isDebugEnabled()) {
                    Tr.debug(this, tc, ""Creating NoTransactionWrapper, since this a a non-transactional datasource"");
                }

                wrapper = mcWrapper.getNoTransactionWrapper();

            } else { // transactional datasource

                // When the adapter is RRSTransactional, if
                // possible, perform standard J2EE local tran
                // processing under the RRS Local tran. If not,
                // use an RRSLocalTranactionWrapper to handle
                // transaction processing.
                // To determine if standard J2EE local tran
                // processing can be performed, check if the
                // level of J2EE transaction support defined
                // by the adapter is one of the following:
                // TransactionSupport.TransactionSupportLevel.LocalTransaction
                // TransactionSupport.TransactionSupportLevel.XATransaction
                // If not, then perform RRSLocalTransaction
                // processing. On the other hand, if it is
                // one of these and is not the CICS ECI
                // resource adapter, perform J2EE Local
                // transaction processing.
                // In the case of the CICS ECI resource adapter,
                // even though it indicates that it
                // SupportsLocalTransactions, WAS z/OS cannot
                // currently use the CICS resource adapter SPI
                // Local Transaction Support when the adapter
                // is running as an RRSTransactional adapter.
                // This is because CICS attempts to establish a
                // private transaction context with RRS and
                // this fails because an authorized transaction
                // context (created by WAS) already exists.
                // To allow for the possibility that CICS could
                // change it's support in the future, a check
                // will be made to see if the CICS adapter
                // supports CCI Local Transaction processing.
                // When CICS does change it's SPI J2EE Local
                // transaction support, it has agreed that they
                // will also support CCI Local Transaction
                // support at that time. Thus, if the adapter
                // supports CCI Local Transaction processing,
                // then it will be assumed that the SPI
                // Local Transaction processing will now also
                // work OK under WAS z/OS.

                switch (mcWrapper.gConfigProps.transactionSupport) {

                    // resource adapter supports neither resource manager nor JTA transactions
                    case NoTransaction:

                        if (!rrsTransactional) { // No RRS-coordinated transaction support
                            if (isTraceOn && tc.isDebugEnabled()) {
                                if (uowCoord.isGlobal()) {
                                    Tr.debug(this, tc, ""Creating NoTransactionWrapper for use in Global Transaction. RA supports No Transaction."");
                                } else {
                                    Tr.debug(this, tc, ""Creating NoTransactionWrapper for use in Local Transaction. RA supports No Transaction."");
                                }
                            }

                            wrapper = mcWrapper.getNoTransactionWrapper();
                        } else { // RRS-coordinated transaction support
                            if (uowCoord.isGlobal()) { // global transaction scope
                                if (isTraceOn && tc.isDebugEnabled()) {
                                    Tr.debug(this, tc, ""Creating RRSGlobalTransactionWrapper for use in Global Transaction. RA supports RRS Coordinated Transactions."");
                                }
                                wrapper = mcWrapper.getRRSGlobalTransactionWrapper();
                            } else { // local transaction scope
                                if (!localTranSupportSet) {
                                    mcWrapper.gConfigProps.setLocalTranSupport(false); // not CICS ECI resource adapter
                                    localTranSupportSet = true;
                                }
                                if (mcWrapper.gConfigProps.cciLocalTranSupported) { // CICS ECI resource adapter
                                    if (isTraceOn && tc.isDebugEnabled()) {
                                        Tr.debug(this, tc, ""Creating LocalTransactionWrapper for use in Local Transaction under RRSTransactional adapter."");
                                    }
                                    wrapper = mcWrapper.getLocalTransactionWrapper(rrsTransactional);
                                } else { // not CICS ECI resource adapter
                                    if (isTraceOn && tc.isDebugEnabled()) {
                                        Tr.debug(this, tc, ""Creating RRSLocalTransactionWrapper for use in Local Transaction under RRSTransactional adapter."");
                                    }
                                    wrapper = mcWrapper.getRRSLocalTransactionWrapper();
                                }
                            } // end local scope
                        } // end RRS-coordinated

                        break;

                    // resource adapter supports resource manager local transactios
                    case LocalTransaction:

                        if (!rrsTransactional) { // No RRS-coordinated transaction support
                            if (isTraceOn && tc.isDebugEnabled()) {
                                if (uowCoord.isGlobal()) { // global transaction scope
                                    Tr.debug(this, tc, ""Creating LocalTransactionWrapper for use in Global Transaction. RA supports Local Transaction."");
                                } else { // local transaction scope
                                    Tr.debug(this, tc, ""Creating LocalTransactionWrapper for use in Local Transaction. RA supports Local Transaction."");
                                }
                            } // end if (TraceComponent.isAnyTracingEnabled()  && tc.isDebugEnabled())
                            wrapper = mcWrapper.getLocalTransactionWrapper();
                        } else { // RRS-coordinated transaction support
                            if (uowCoord.isGlobal()) { // global transaction scope
                                if (isTraceOn && tc.isDebugEnabled()) {
                                    Tr.debug(this, tc, ""Creating RRSGlobalTransactionWrapper for use in Global Transaction. RA supports RRS Coordinated Transactions."");
                                }
                                wrapper = mcWrapper.getRRSGlobalTransactionWrapper();
                            } else { // local transaction scope
                                if (!localTranSupportSet) {
                                    String mcfClass = mcWrapper.get_managedConnectionFactory().getClass().getName();
                                    if (mcfClass.equals(""com.ibm.connector2.cics.ECIManagedConnectionFactory"")) {
                                        mcWrapper.gConfigProps.setLocalTranSupport(raSupportsCCILocalTran(mcWrapper.get_managedConnectionFactory()));
                                        localTranSupportSet = true;

                                    }
                                }

                                if (mcWrapper.gConfigProps.cciLocalTranSupported) { // CICS ECI resource adapter
                                    if (isTraceOn && tc.isDebugEnabled()) {
                                        Tr.debug(this, tc, ""Creating LocalTransactionWrapper for use in Local Transaction under RRSTransactional adapter."");
                                    }
                                    wrapper = mcWrapper.getLocalTransactionWrapper(rrsTransactional);
                                } else { // not CICS ECI resource adapter
                                    if (isTraceOn && tc.isDebugEnabled()) {
                                        Tr.debug(this, tc, ""Creating RRSLocalTransactionWrapper for use in Local Transaction under RRSTransactional adapter."");
                                    }
                                    wrapper = mcWrapper.getRRSLocalTransactionWrapper();
                                }
                            } // end else (local scopr)
                        } // end else (RRS-coordinated)

                        break;

                    // resource adapter supports both resource manager local and JTA transactions
                    case XATransaction:

                        if (!rrsTransactional) { // No RRS-coordinated transaction support
                            if (uowCoord.isGlobal()) { // global transaction scope
                                if (isJDBC && mcWrapper.getManagedConnection().getXAResource() instanceof com.ibm.tx.jta.OnePhaseXAResource) {
                                    if (isTraceOn && tc.isDebugEnabled()) {
                                        Tr.debug(this, tc, ""Creating LocalTransactionWrapper for use in Global Transaction.  The resource adapter supports XA Transaction"");
                                    }
                                    wrapper = mcWrapper.getLocalTransactionWrapper();
                                } else { // xaResource is two-phase
                                    if (isTraceOn && tc.isDebugEnabled()) {
                                        Tr.debug(this, tc, ""Creating XATransactionWrapper for use in Global Transaction.  The resource adapter supports XA Transaction"");
                                    }
                                    wrapper = mcWrapper.getXATransactionWrapper();
                                }
                            } // end of global transaction scope
                            else { // local transaction scope
                                if (isTraceOn && tc.isDebugEnabled()) {
                                    Tr.debug(this, tc, ""Creating LocalTransactionWrapper for use in Local Transaction. The resource adapter supports XA Transaction."");
                                }
                                wrapper = mcWrapper.getLocalTransactionWrapper();
                            }
                        } else { // RRS-coordinated transaction support
                            if (uowCoord.isGlobal()) { // global transaction scope
                                if (isTraceOn && tc.isDebugEnabled()) {
                                    Tr.debug(this, tc, ""Creating RRSGlobalTransactionWrapper for use in Global Transaction. RA supports RRS Coordinated Transactions."");
                                }
                                wrapper = mcWrapper.getRRSGlobalTransactionWrapper();
                            } else { // local transaction scope
                                if (!localTranSupportSet) {
                                    String mcfClass = mcWrapper.get_managedConnectionFactory().getClass().getName();
                                    if (mcfClass.equals(""com.ibm.connector2.cics.ECIManagedConnectionFactory"")) {
                                        mcWrapper.gConfigProps.setLocalTranSupport(raSupportsCCILocalTran(mcWrapper.get_managedConnectionFactory()));
                                        localTranSupportSet = true;
                                    }
                                }
                                if (mcWrapper.gConfigProps.cciLocalTranSupported) { // CICS ECI resource adapter
                                    if (isTraceOn && tc.isDebugEnabled()) {
                                        Tr.debug(this, tc, ""Creating LocalTransactionWrapper for use in Local Transaction under RRSTransactional adapter."");
                                    }
                                    wrapper = mcWrapper.getLocalTransactionWrapper(rrsTransactional);
                                } else { // Not CICS ECI resource adapter
                                    wrapper = mcWrapper.getRRSLocalTransactionWrapper();
                                    if (isTraceOn && tc.isDebugEnabled()) {
                                        Tr.debug(this, tc, ""Created RRSLocalTransactionWrapper for use in Local Transaction under RRSTransactional adapter."");
                                    }
                                }
                            } // end local scope
                        } // end RRS-coordinated transaction support

                        break;
                    default:
                } // end of switch
            } // end else transactional datasource

            if (isTraceOn && tc.isDebugEnabled()) {
                Tr.debug(this, tc, ""Created transaction wrapper@"" + Integer.toHexString(wrapper.hashCode()));
            }

            /*
             * If we experience a problem during the addSync we won't have registered for synchronisation
             * so we need to tidy up properly here. Once we have registered for synchronisation we can always
             * tidy up at transaction completion.
             */

            try {
                registeredForSync = wrapper.addSync();
                // TODO The following code would exit regardless if we just registered for
                // synchronization in an LTC or a global transaction.  Is that what we want?
                // We're waiting for some data from JetStream or Transactions to determine
                // the proper course of action.
                if (mcWrapper.isConnectionSynchronizationProvider()) {
                    /*
                     * If this is a connection synchronization provider, they are
                     * resposible for all of the remaining transactions work.
                     */
                    if (isTraceOn && tc.isDebugEnabled()) {
                        Tr.debug(this, tc, ""This managed connection is a synchronization provider."");
                    }
                    if (isTraceOn && tc.isEntryEnabled()) {
                        Tr.exit(this, tc, ""initializeForUOW"");
                    }
                    return;
                }

            } catch (ResourceException e) {

                // Note: the wrapper handles all the appropriate logging of the exception.
                //  We catch it here so that we can do the appropriate cleanup.
                com.ibm.ws.ffdc.FFDCFilter.processException(e, ""com.ibm.ejs.j2c.ConnectionManager.initializeForUOW"", ""730"", this);
                if (isTraceOn && tc.isDebugEnabled())
                    Tr.debug(this, tc, ""Exception:"" + e);
                try {
                    mcWrapper.releaseToPoolManager();
                } catch (Exception ex) { // ignore.
                }
                throw e;

            } // end catch ResourceException

            //NOTE: only global transactions or local transaction with resolution control 'container at boundary'
            //  will be enlisted during allocate.
            //  Local transactions with resolution control 'application' will be enlisted during the
            //  localTransactionStarted event on the connectionEventListner.

            try {

                if (uowCoord != null) {

                    if (uowCoord.isGlobal()) {

                        // In global tran.

                        // If deferred enlistment is supported by the RA, then enlistment in a global tran
                        // will happen in the interactionPending() method of the ConnectionEventListener.
                        // Otherwise, enlist here.
                        //
                        // RRS Global Trans will opt out of deferred enlistment because in some cases it will be
                        //  necessary to track states via the enlistment, and this needs to be done as soon as
                        //  the connection is obtained

                        if (!mcWrapper.gConfigProps.isDynamicEnlistmentSupported() || rrsTransactional) {

                            wrapper.enlist();
                            enlisted = true;

                        }

                    } else {

                        // delete check for rrsTransactional
                        if (J2CUtilityClass.isContainerAtBoundary(mcWrapper.pm.connectorSvc.transactionManager)) {
                            // LTC with resolution of ContainerAtBoundary. Agressively enlist in the transaction.
                            wrapper.enlist();
                            enlisted = true;
                        }

                    }
                }

            } // end try
            catch (ResourceException e) {

                // NOTE: we only need to catch ResourceException here because our wrapper
                //  code only throws resource exceptions.

                // clean everything up!
                com.ibm.ws.ffdc.FFDCFilter.processException(e, ""com.ibm.ejs.j2c.ConnectionManager.initializeForUOW"", ""762"", this);

                // Only mark stale and throw exception at this time since we've already registered
                // for synchronization.  Allow the transaction to be rolled back to clean this up.
                // mcWrapper.markStale(); 154675 - already marked stale
                // mcWrapper.releaseToPoolManager();

                if (isTraceOn && tc.isEntryEnabled()) {
                    Tr.exit(this, tc, ""initializeForUOW"", ""completed cleanup due to exception."");
                }
                throw e;

            } // end catch ResourceException

        } // end UOW.GLOBAL_TRAN_ACTIVE

        // If we have not registered for Synchronization and have not enlisted, then we
        // are not involved in any way with the current transaction, thus we need to reset the
        // UOWCoord in the mcWrapper so that deferred enlistment will work for JMS.
        if (!registeredForSync && !enlisted && !originIsDeferred) {
            mcWrapper.setUOWCoordinator(null);
        }

        if (isTraceOn && tc.isEntryEnabled()) {
            Tr.exit(this, tc, ""initializeForUOW"");
        }

    }",Initialize for a single UOW.
"@GwtIncompatible(""To be supported"")
  CacheBuilder<K, V> valueEquivalence(Equivalence<Object> equivalence) {
    checkState(valueEquivalence == null,
        ""value equivalence was already set to %s"", valueEquivalence);
    this.valueEquivalence = checkNotNull(equivalence);
    return this;
  }",Sets the value equivalence.
"@Override
    public ReplicationGroup increaseReplicaCount(IncreaseReplicaCountRequest request) {
        request = beforeClientExecution(request);
        return executeIncreaseReplicaCount(request);
    }",Increase the number of replicas of a resource.
"@Override
    public void setStatementParameters(PreparedStatement statement, boolean setDefaultId) throws SQLException {
        int oneBasedIndex = 1;
        if (!setDefaultId) statement.setInt(oneBasedIndex++, id);
        statement.setString(oneBasedIndex++, pattern_id);
        statement.setString(oneBasedIndex++, route_id);
        statement.setString(oneBasedIndex++, name);
        // Editor-specific fields
        setIntParameter(statement, oneBasedIndex++, direction_id);
        // Note: pattern#use_frequency is set in JdbcGtfsSnapshotter here:
        // https://github.com/conveyal/gtfs-lib/blob/0c6aca98a83d534853b74011e6cc7bf376592581/src/main/java/com/conveyal/gtfs/loader/JdbcGtfsSnapshotter.java#L196-L211
        setIntParameter(statement, oneBasedIndex++, INT_MISSING); // use_frequency
        // FIXME: Shape set might be null?
        statement.setString(oneBasedIndex++, associatedShapes.iterator().next());
    }",Set the parameters of the SQL statement.
"protected void addSummaryType(ProgramElementDoc member,
            Content tdSummaryType) {
        ClassDoc cd = (ClassDoc)member;
        addModifierAndType(cd, null, tdSummaryType);
    }",Add the summary type.
"public static AccountInfo adaptAccountInfo(
      final RippleAccountBalances account, final String username) {

    // Adapt account balances to XChange balances
    final Map<String, List<Balance>> balances = new HashMap<>();
    for (final RippleBalance balance : account.getBalances()) {
      final String walletId;
      if (balance.getCurrency().equals(""XRP"")) {
        walletId = null;
      } else {
        walletId = balance.getCounterparty();
      }
      if (!balances.containsKey(walletId)) {
        balances.put(walletId, new LinkedList<Balance>());
      }
      balances
          .get(walletId)
          .add(new Balance(Currency.getInstance(balance.getCurrency()), balance.getValue()));
    }

    final List<Wallet> accountInfo = new ArrayList<>(balances.size());
    for (final Map.Entry<String, List<Balance>> wallet : balances.entrySet()) {
      accountInfo.add(new Wallet(wallet.getKey(), wallet.getValue()));
    }

    return new AccountInfo(username, BigDecimal.ZERO, accountInfo);
  }",Adapts an account to an AccountInfo object.
"@Override
	public void onStopwatchStop(Split split, StopwatchSample sample) {
		logger.debug(marker, ""SIMON STOP: {} ({})"", sample.toString(), split.runningFor());
	}",Called when a stop event occurs.
"public static Spliterator.OfLong spliterator(long[] array, int fromIndex, int toIndex,
                                                 int additionalCharacteristics) {
        checkFromToBounds(Objects.requireNonNull(array).length, fromIndex, toIndex);
        return new LongArraySpliterator(array, fromIndex, toIndex, additionalCharacteristics);
    }",Create a long spliterator from the given long array.
"public void addFreeConnection(ThriftConnectionHandle<T> thriftConnectionHandle)
			throws ThriftConnectionPoolException {
		thriftConnectionHandle.setOriginatingPartition(this);
		// 更新创建的连接数 创建数 +1
		updateCreatedConnections(1);

		if (!this.freeConnections.offer(thriftConnectionHandle)) {
			// 将连接放入队列失败 创建数 - 1
			updateCreatedConnections(-1);

			// 关闭原始连接
			thriftConnectionHandle.internalClose();
		}
	}",Add a free connection to the pool.
"@SuppressWarnings(""unchecked"")
    private void readObject(final ObjectInputStream in) throws IOException, ClassNotFoundException {
        in.defaultReadObject();
        elements = (E[]) new Object[maxElements];
        final int size = in.readInt();
        for (int i = 0; i < size; i++) {
            elements[i] = (E) in.readObject();
        }
        start = 0;
        full = size == maxElements;
        if (full) {
            end = 0;
        } else {
            end = size;
        }
    }",Read the object from the stream.
"private String[] getMarkType(String label) {
		String[] types = new String[2];

		if(NoSegLabel){
			types[0] = """";
			types[1] = label;
			return types;
		}

		int idx = label.indexOf('-');
		if(idx!=-1){
			types[0] = label.substring(0,idx);
			types[1] = label.substring(idx+1);
		}else{
			types[0] = label;
			types[1] = """";
		}

		return types;
	}",Gets the getMarkType method for a single label.
"private static ClientFactory instantiateClientFactory(String persistenceUnit, Map<String, Object> puProperties,
            final KunderaMetadata kunderaMetadata)
    {
        ClientFactory clientFactory = null;
        logger.info(""Initializing client factory for: "" + persistenceUnit);
        PersistenceUnitMetadata persistenceUnitMetadata = kunderaMetadata.getApplicationMetadata()
                .getPersistenceUnitMetadata(persistenceUnit);
        String kunderaClientFactory = puProperties != null ? (String) puProperties
                .get(PersistenceProperties.KUNDERA_CLIENT_FACTORY) : null;
        if (kunderaClientFactory == null)
        {
            kunderaClientFactory = persistenceUnitMetadata.getProperties().getProperty(
                    PersistenceProperties.KUNDERA_CLIENT_FACTORY);
        }

        if (kunderaClientFactory == null)
        {
            throw new ClientResolverException(
                    ""<kundera.client.lookup.class> is missing from persistence.xml, please provide specific client factory. e.g., <property name=\""kundera.client.lookup.class\"" value=\""com.impetus.client.cassandra.pelops.PelopsClientFactory\"" />"");
        }
        try
        {
            clientFactory = (ClientFactory) Class.forName(kunderaClientFactory).newInstance();

            Method m = GenericClientFactory.class.getDeclaredMethod(""setPersistenceUnit"", String.class);
            if (!m.isAccessible())
            {
                m.setAccessible(true);
            }

            m.invoke(clientFactory, persistenceUnit);

            m = GenericClientFactory.class.getDeclaredMethod(""setExternalProperties"", Map.class);
            if (!m.isAccessible())
            {
                m.setAccessible(true);
            }

            m.invoke(clientFactory, puProperties);
            
            m = GenericClientFactory.class.getDeclaredMethod(""setKunderaMetadata"", KunderaMetadata.class);
            if (!m.isAccessible())
            {
                m.setAccessible(true);
            }

            m.invoke(clientFactory, kunderaMetadata);
            
        }
        catch (InstantiationException e)
        {
            onError(e);
        }
        catch (IllegalAccessException e)
        {
            onError(e);
        }
        catch (ClassNotFoundException e)
        {
            onError(e);
        }
        catch (SecurityException e)
        {
            onError(e);
        }
        catch (NoSuchMethodException e)
        {
            onError(e);
        }
        catch (IllegalArgumentException e)
        {
            onError(e);
        }
        catch (InvocationTargetException e)
        {
            onError(e);
        }

        if (clientFactory == null)
        {
            logger.error(""Client Factory Not Configured For Specified Client Type : "");
            throw new ClientResolverException(""Client Factory Not Configured For Specified Client Type."");
        }
        logger.info(""Finishing factory initialization"");
        return clientFactory;
    }",Creates a client factory for the given persistence unit and persistence properties.
"public int totalCount(int outputNum) {
        assertIndex(outputNum);
        return countTruePositive[outputNum] + countTrueNegative[outputNum] + countFalseNegative[outputNum]
                        + countFalsePositive[outputNum];
    }",Returns the total number of tokens in the sequence.
"private Object getRowData(final Object rowId) {
		// We cache row id --> row bean mapping per request for performance (to avoid nested loops)
		Map dataByRowId = (Map) getScratchMap().get(SCRATCHMAP_DATA_BY_ROW_ID_KEY);

		if (dataByRowId == null) {
			dataByRowId = createRowIdCache();
		}

		Object data = dataByRowId.get(rowId);

		if (data == null && !dataByRowId.containsKey(rowId)) {
			// Ok, new data has probably been added. We need to cache the new data.
			dataByRowId = createRowIdCache();
			data = dataByRowId.get(rowId);
		}

		return data;
	}",Get the row data for the given row id.
"public static IEntityGroup findGroup(String key) throws GroupsException {
        LOGGER.trace(""Invoking findGroup for key='{}'"", key);
        return instance().ifindGroup(key);
    }",Find the IEntityGroup for the given key.
"public static AWSCloudCollector prototype() {
		AWSCloudCollector protoType = new AWSCloudCollector();
		protoType.setName(""AWSCloud"");
		protoType.setOnline(true);
        protoType.setEnabled(true);
		protoType.setCollectorType(CollectorType.Cloud);
		protoType.setLastExecuted(System.currentTimeMillis());

		return protoType;
	}",Creates a prototype of the AWSCloudCollector class.
"@Override
    public JedisRedisClient create() throws Exception {
        JedisRedisClient redisClient = new JedisRedisClient();
        redisClient.setRedisHost(redisHost).setRedisPort(redisPort).setRedisUsername(redisUser)
                .setRedisPassword(redisPassword);
        redisClient.init();
        return redisClient;
    }",Create a JedisRedisClient instance.
"public void setSpecifiedWidth(String width)
    {
        colwidth = width;
        try {
            content = new Dimension(0, 0);
            content.width = Integer.parseInt(width);
            bounds.width = content.width;
            abswidth = content.width;
            wset = true;
        } catch (NumberFormatException e) {
            if (!width.equals(""""))
                log.warn(""Invalid width value: "" + width);
        }
    }",Sets the specified width.
"public void init(Record record, BaseField fldDest, BaseField fldSource, Converter convCheckMark, boolean bMoveOnNew, boolean bMoveOnValid, boolean bMoveOnSelect, boolean bMoveOnAdd, boolean bMoveOnUpdate, String strSource, boolean bDontMoveNullSource)
    {
        m_fldDest = fldDest;
        m_fldSource = fldSource;
        m_convCheckMark = convCheckMark;
        m_strSource = strSource;
        m_bMoveOnNew = bMoveOnNew;
        m_bMoveOnValid = bMoveOnValid;
        m_bMoveOnSelect = bMoveOnSelect;
        m_bMoveOnAdd = bMoveOnAdd;
        m_bMoveOnUpdate = bMoveOnUpdate;
        m_bDontMoveNullSource = bDontMoveNullSource;
        super.init(record);
    }",Initialize this class.
"private void doPI(Node received) {
        if (log.isDebugEnabled()) {
            log.debug(""Ignored processing instruction ("" + received.getLocalName() + ""="" + received.getNodeValue() + "")"");
        }
    }",Handle a processing instruction.
"public CmsStateBean parseState(String state, String baseOU) {

        String path = baseOU;
        String filter = """";
        I_CmsOuTreeType type = CmsOuTreeType.OU;
        CmsUUID groupId = null;
        List<String> fields = CmsStringUtil.splitAsList(state, STATE_SEPERATOR);
        if (!fields.isEmpty()) {
            if (fields.size() > 1) {
                path = fields.get(1);
                //Make sure to only show OUs which are under baseOU
                if (path.equals("""") | !path.startsWith(baseOU)) {
                    path = baseOU;
                }
            }
            for (I_CmsOuTreeType ty : getTreeTypeProvider().getTreeTypes()) {
                if (fields.get(0).equals(ty.getId())) {
                    type = ty;
                }
            }
            if (fields.size() > 2) {
                if (!CmsStringUtil.isEmptyOrWhitespaceOnly(fields.get(2))) {
                    groupId = new CmsUUID(fields.get(2));
                }
            }
            if (fields.size() > 3) {
                filter = fields.get(3);
            }
        }
        return new CmsStateBean(path, type, groupId, filter);
    }",Parses the given state string.
"public ValidationSuccess simplyValidate(Object form) { // for e.g. response bean validator
        assertArgumentNotNull(""form"", form);
        return doValidate(form, unused -> {}, () -> {
            throw new IllegalStateException(""unused here, no way"");
        });
    }",Validate the given form object using the validation rules.
"public T header(Header name, String value, boolean isOverride) {
		return header(name.toString(), value, isOverride);
	}",Add a header to the response.
"public FileAppender append(String line) {
		if (list.size() >= capacity) {
			flush();
		}
		list.add(line);
		return this;
	}",Append a line to the end of the file.
"public Query addCustomUrlParamsByString(String values) {
    if (values == null) {
      return this;
    }
    String[] params = values.split(""&"");
    for (String value : params) {
      if (StringUtils.isNotBlank(value)) {
        String[] keyValue = value.split(""="");
        if (keyValue.length == 2 && StringUtils.isNotBlank(keyValue[0]) && StringUtils.isNotBlank(keyValue[1])) {
          customUrlParams.add(new CustomUrlParam().setKey(keyValue[0]).setValue(keyValue[1]));
        }
      }
    }
    return this;
  }",Add custom url params by string
"private boolean isRelated(Task task, List<Relation> list)
   {
      boolean result = false;
      for (Relation relation : list)
      {
         if (relation.getTargetTask().getUniqueID().intValue() == task.getUniqueID().intValue())
         {
            result = true;
            break;
         }
      }
      return result;
   }",isRelated returns true if relation is related to task
"public static void sleepUninterruptibly(final long timeoutInMillis) {
        if (timeoutInMillis <= 0) {
            return;
        }

        boolean interrupted = false;

        try {
            long remainingNanos = TimeUnit.MILLISECONDS.toNanos(timeoutInMillis);
            final long sysNanos = System.nanoTime();
            final long end = remainingNanos >= Long.MAX_VALUE - sysNanos ? Long.MAX_VALUE : sysNanos + remainingNanos;

            while (true) {
                try {
                    // TimeUnit.sleep() treats negative timeouts just like zero.
                    TimeUnit.NANOSECONDS.sleep(remainingNanos);
                    return;
                } catch (InterruptedException e) {
                    interrupted = true;
                    remainingNanos = end - System.nanoTime();
                }
            }
        } finally {
            if (interrupted) {
                Thread.currentThread().interrupt();
            }
        }
    }",Sleep for the specified amount of time.
"protected static <T extends Address, S extends AddressSegment> Iterator<T> iterator(T original, AddressCreator<T, ?, ?, S> creator) {
		return IPAddressSection.iterator(original, creator, null);
	}",Returns an iterator over the address sections of the given address.
"private void checkId(FieldDescriptorDef fieldDef, String checkLevel) throws ConstraintException
    {
        if (CHECKLEVEL_NONE.equals(checkLevel))
        {
            return;
        }

        String id = fieldDef.getProperty(PropertyHelper.OJB_PROPERTY_ID);

        if ((id != null) && (id.length() > 0))
        {
            try
            {
                Integer.parseInt(id);
            }
            catch (NumberFormatException ex)
            {
                throw new ConstraintException(""The id attribute of field ""+fieldDef.getName()+"" in class ""+fieldDef.getOwner().getName()+"" is not a valid number"");
            }
        }
    }",Checks if the id attribute of the given field is valid and if it is a valid number then throw a ConstraintException.
"public static XLinkConnector[] getLocalToolFromRegistrations(List<XLinkConnectorRegistration> registrations) {
        List<XLinkConnector> tools = new ArrayList<XLinkConnector>();
        for (XLinkConnectorRegistration registration : registrations) {
            XLinkConnector newLocalTools 
                = new XLinkConnector(
                        registration.getConnectorId(), 
                        registration.getToolName(), 
                        getViewsOfRegistration(registration));
            tools.add(newLocalTools);
        }
        return tools.toArray(new XLinkConnector[0]);
    }",Get the local tool from the list of registration.
"private void addChildrenForRolesNode(String ouItem) {

        try {
            List<CmsRole> roles = OpenCms.getRoleManager().getRoles(m_cms, ouItem.substring(1), false);
            CmsRole.applySystemRoleOrder(roles);
            for (CmsRole role : roles) {
                String roleId = ouItem + ""/"" + role.getId();
                Item roleItem = m_treeContainer.addItem(roleId);
                if (roleItem == null) {
                    roleItem = getItem(roleId);
                }
                roleItem.getItemProperty(PROP_NAME).setValue(getIconCaptionHTML(role, CmsOuTreeType.ROLE));
                roleItem.getItemProperty(PROP_TYPE).setValue(CmsOuTreeType.ROLE);
                setChildrenAllowed(roleId, false);
                m_treeContainer.setParent(roleId, ouItem);
            }
        } catch (CmsException e) {
            LOG.error(""Can not read group"", e);
        }
    }",Add children for roles node.
"@Override
	public void eUnset(int featureID) {
		switch (featureID) {
			case AfplibPackage.ECP__RS_NAME:
				setRSName(RS_NAME_EDEFAULT);
				return;
		}
		super.eUnset(featureID);
	}",Declarative Services method for setting the value of the featureID attribute.
"public ValueMap getProperties() {
    if (this.properties == null) {
      this.properties = new ValueMapDecorator(new HashMap<String, Object>());
    }
    return this.properties;
  }",Gets the properties.
"public Map<K, V> getMapSortByValueUp(Map<K, V> sourceMap) {
        return sortByValue(sourceMap, GROW_UP);
    }",Get a map sorted by value up.
"public void handleNonCORS(final HttpServletRequest request,
            final HttpServletResponse response, final FilterChain filterChain)
            throws IOException, ServletException {
        // Let request pass.
        filterChain.doFilter(request, response);
    }","Handle the
ALT or
ALT headers."
"public void paintChildren(){
        Graphics2D g = getGraphics();
        Object anti = g.getRenderingHint(RenderingHints.KEY_ANTIALIASING);
        Object textAnti = g.getRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING);
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
        super.paintChildren();
        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, anti);
        g.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, textAnti);
    }",Override paintChildren to set the appropriate rendering hints.
"protected boolean isSameSnakSet(Iterator<Snak> snaks1, Iterator<Snak> snaks2) {
		ArrayList<Snak> snakList1 = new ArrayList<>(5);
		while (snaks1.hasNext()) {
			snakList1.add(snaks1.next());
		}

		int snakCount2 = 0;
		while (snaks2.hasNext()) {
			snakCount2++;
			Snak snak2 = snaks2.next();
			boolean found = false;
			for (int i = 0; i < snakList1.size(); i++) {
				if (snak2.equals(snakList1.get(i))) {
					snakList1.set(i, null);
					found = true;
					break;
				}
			}
			if (!found) {
				return false;
			}
		}

		return snakCount2 == snakList1.size();
	}",Checks if two iterators are the same.
"public boolean hasUnnamedParameters(String originalSql) {
        boolean hasUnnamedParameters = false;
        String preProcessedSql = null;

        // removing comments and text blocks
        preProcessedSql = removeBlocks(originalSql);

        // adding whitespace in the end to allow proper processing if ""?"" would be the last symbol
        preProcessedSql = preProcessedSql + "" "";

        // parsing sql(without comments and text blocks)
        Pattern regexPattern = null;
        Matcher regexMatcher = null;

        regexPattern = Pattern.compile(REGEX_UNNAMED_PARAMETER_SEARCH, Pattern.CASE_INSENSITIVE);
        regexMatcher = regexPattern.matcher(preProcessedSql);

        if (regexMatcher.find() == true) {
            hasUnnamedParameters = true;
        }

        return hasUnnamedParameters;
    }",Checks if the original SQL has any unnamed parameters.
"@Override
    public ConnectionTypeResponse connectionType(InetAddress ipAddress)
            throws IOException, GeoIp2Exception {
        return this.get(ipAddress, ConnectionTypeResponse.class,
                ""GeoIP2-Connection-Type"");
    }",Get a ConnectionTypeResponse for a given IP Address
"public void delete(String columnName, String... keys) {
    Mutator<String> m = createMutator(keyspace, serializer);
    for (String key: keys) {
      m.addDeletion(key, columnFamilyName,  columnName, serializer);
    }
    m.execute();
  }",Delete a set of records from the database.
"public static String getDescription(Object object)
   {
      StringBuffer buffer = new StringBuffer();
      describe(buffer, object);
      return buffer.toString();
   }",Get description of a single object.
"static GVRPickedObject makeHitMesh(long colliderPointer, float distance, float hitx, float hity, float hitz,
                                   int faceIndex, float barycentricx, float barycentricy, float barycentricz,
                                   float texu, float texv,  float normalx, float normaly, float normalz)
    {
        GVRCollider collider = GVRCollider.lookup(colliderPointer);
        if (collider == null)
        {
            Log.d(TAG, ""makeHit: cannot find collider for %x"", colliderPointer);
            return null;
        }
        return new GVRPicker.GVRPickedObject(collider, new float[] { hitx, hity, hitz }, distance, faceIndex,
                new float[] {barycentricx, barycentricy, barycentricz},
                new float[]{ texu, texv },
                new float[]{normalx, normaly, normalz});
    }",Make a hit mesh from the collider pointer.
"public JsonNode wbSetAliases(String id, String site, String title,
			String newEntity, String language, List<String> add,
			List<String> remove, List<String> set,
			boolean bot, long baserevid, String summary)
					throws IOException, MediaWikiApiErrorException {
		Validate.notNull(language,
				""Language parameter cannot be null when setting aliases"");
		
		Map<String, String> parameters = new HashMap<String, String>();
		parameters.put(""language"", language);
		if (set != null) {
			if (add != null || remove != null) {
				throw new IllegalArgumentException(
						""Cannot use parameters \""add\"" or \""remove\"" when using \""set\"" to edit aliases"");
			}
			parameters.put(""set"", ApiConnection.implodeObjects(set));
		}
		if (add != null) {
			parameters.put(""add"", ApiConnection.implodeObjects(add));
		}
		if (remove != null) {
			parameters.put(""remove"", ApiConnection.implodeObjects(remove));
		}
		
		JsonNode response = performAPIAction(""wbsetaliases"", id, site, title, newEntity, parameters, summary, baserevid, bot);
		return response;
	}",Sets the aliases for a given entity.
"public DescribeComplianceByConfigRuleResult withComplianceByConfigRules(ComplianceByConfigRule... complianceByConfigRules) {
        if (this.complianceByConfigRules == null) {
            setComplianceByConfigRules(new com.amazonaws.internal.SdkInternalList<ComplianceByConfigRule>(complianceByConfigRules.length));
        }
        for (ComplianceByConfigRule ele : complianceByConfigRules) {
            this.complianceByConfigRules.add(ele);
        }
        return this;
    }",Adds the value of the complianceByConfigRules property.
"private void clearEntityAttributes(CmsEntity entity) {

        for (CmsEntityAttribute attribute : entity.getAttributes()) {
            if (attribute.isComplexValue()) {
                for (CmsEntity child : attribute.getComplexValues()) {
                    clearEntityAttributes(child);
                    removeEntity(child.getId());
                }
            }
            entity.removeAttributeSilent(attribute.getAttributeName());
        }
    }",Clears all attributes of the given entity.
"public void queueBuffers (Buffer... buffers)
    {
        IntBuffer idbuf = BufferUtils.createIntBuffer(buffers.length);
        for (int ii = 0; ii < buffers.length; ii++) {
            Buffer buffer = buffers[ii];
            _queue.add(buffer);
            idbuf.put(ii, buffer.getId());
        }
        AL10.alSourceQueueBuffers(_id, idbuf);
    }",Queue the buffers in the source.
"public static List<MethodNode> findMethodsWithName(Collection<MethodNode> methodNodes, String name) {
        Validate.notNull(methodNodes);
        Validate.notNull(name);
        Validate.noNullElements(methodNodes);
        
        
        List<MethodNode> ret = new ArrayList<>();
        for (MethodNode methodNode : methodNodes) {
            if (methodNode.name.equals(name)) {
                ret.add(methodNode);
            }
        }

        return ret;
    }",Find methods with the given name.
"private int readBlock() {
    blockSize = read();
    int n = 0;
    if (blockSize > 0) {
      int count = 0;
      try {
        while (n < blockSize) {
          count = blockSize - n;
          rawData.get(block, n, count);

          n += count;
        }
      } catch (Exception e) {
        if (Log.isLoggable(TAG, Log.DEBUG)) {
          Log.d(TAG,
              ""Error Reading Block n: "" + n + "" count: "" + count + "" blockSize: "" + blockSize, e);
        }
        header.status = GifDecoder.STATUS_FORMAT_ERROR;
      }
    }
    return n;
  }",Read a block from the input stream.
"public void uploadContent(@NonNull final String folder, @NonNull final ContentData data, @Nullable Callback<ComapiResult<UploadContentResponse>> callback) {
        adapter.adapt(uploadContent(folder, data), callback);
    }",Upload content.
"static boolean areInSameRuntimeClassLoader (Class type1, Class type2) {
		if (type1.getPackage() != type2.getPackage()) {
			return false;
		}
		ClassLoader loader1 = type1.getClassLoader();
		ClassLoader loader2 = type2.getClassLoader();
		ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();
		if (loader1 == null) {
			return (loader2 == null || loader2 == systemClassLoader);
		}
		if (loader2 == null) return loader1 == systemClassLoader;
		return loader1 == loader2;
	}",Checks if two classes are in the same runtime class loader.
"public OrientBaseGraph configure(final Settings iSetting) {
    makeActive();

    if (iSetting != null) {
      if (settings == null) {
        settings = iSetting;
      } else {
        settings.copyFrom(iSetting);
      }
    }
    return this;
  }",Configure the graph with the specified settings.
"public String getTitle() {
        return getSlide().getContent() == null || getSlide().getContent().isEmpty() || getSlide().getContent().get(0).getTitle() == null ? null
                : getSlide().getContent().get(0).getTitle().replaceAll(""\\\\n"", ""\n"");
    }",Get the title of the page.
"public synchronized void rename(String oldName, String newName) throws IOException {
        boolean touched = false;
        if (original != null) {
            if (original.getName().equals(oldName)) {
                original.setName(newName);
                touched = true;
            }
        }
        
        if (usages != null) {
            RangeSet r = usages.get(oldName);
            if (r != null) {
                usages.put(newName, r);
                usages.remove(oldName);
                touched = true;
            }
        }
        
        if (touched) {
            save();
        }
    }",Renames the original file to the new name.
"public void addUnreplicatedFactor(String factorName, BoostingFactorFamily factor) {
    super.addUnreplicatedFactor(factorName, factor, factor.getVariables());
  }",Add an uncreplicated factor to the formula.
"public void setToInverseL( double a[] ) {

        // the more direct method which takes full advantage of the sparsity of the data structures proved to
        // be difficult to get right due to the conjugates and reordering.
        // See comparable real number code for an example.
        for (int col = 0; col < n; col++) {
            Arrays.fill(vv,0);
            vv[col*2] = 1;
            TriangularSolver_ZDRM.solveL_diagReal(t, vv, n);
            TriangularSolver_ZDRM.solveConjTranL_diagReal(t, vv, n);
            for( int i = 0; i < n; i++ ) {
                a[(i*numCols+col)*2  ] = vv[i*2];
                a[(i*numCols+col)*2+1] = vv[i*2+1];
            }
        }
        // NOTE: If you want to make inverse faster take advantage of the sparsity
    }",Sets the inverse of the matrix to the inverse of the matrix.
"public LofPoint deepCopy()
    {
        LofPoint result = new LofPoint();
        result.setDataId(this.dataId);
        result.setkDistance(this.kDistance);

        double[] copiedArray = Arrays.copyOf(this.dataPoint, this.dataPoint.length);
        result.setDataPoint(copiedArray);

        List<String> copiedList = new ArrayList<>();
        if (this.kDistanceNeighbor != null)
        {
            copiedList.addAll(this.kDistanceNeighbor);
        }

        result.setkDistanceNeighbor(copiedList);
        result.setLrd(this.lrd);
        return result;
    }",Copy the object.
"@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case AfplibPackage.ATTRIBUTE_QUALIFIER__SEQ_NUM:
				setSeqNum((Integer)newValue);
				return;
			case AfplibPackage.ATTRIBUTE_QUALIFIER__LEV_NUM:
				setLevNum((Integer)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}",Override the eSet method to set the value of the featureID attribute.
"public void setCP(String newCP) {
		String oldCP = cp;
		cp = newCP;
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, AfplibPackage.GCCHST__CP, oldCP, cp));
	}",Sets the value cp.
"@Override
	public <T extends SyntacticItem> T getParent(Class<T> kind) {
		return parent.getParent(this, kind);
	}",Get the parent of this item.
"public static void main(String[] args) throws IOException {
    if (args.length == 0) {
      System.err.println(""java Morphology [-rebuildVerbTable file|-stem word+|file+]"");
    } else if (args.length == 2 && args[0].equals(""-rebuildVerbTable"")) {
      String verbs = IOUtils.slurpFile(args[1]);
      String[] words = verbs.split(""\\s+"");
      System.out.print("" private static final String[] verbStems = { "");
      for (int i = 0; i < words.length; i++) {
        System.out.print(""\"""" + words[i] + ""\"""");
        if (i != words.length - 1) {
          System.out.print("", "");
          if (i % 5 == 0) {
            System.out.println();
            System.out.print(""    "");
          }
        }
      }
      System.out.println("" };"");
    } else if (args[0].equals(""-stem"")) {
      for (int i = 1; i < args.length; i++) {
        System.out.println(args[i] + "" --> "" + stemStatic(WordTag.valueOf(args[i], ""_"")));
      }
    } else {
      int flags = 0;
      for (String arg :  args) {
        if (arg.charAt(0) == '-') {
          try {
            flags = Integer.parseInt(arg.substring(1));
          } catch (NumberFormatException nfe) {
            System.err.println(""Couldn't handle flag: "" + arg + ""\n"");
            // ignore flag
          }
        } else {
          Morphology morph = new Morphology(new FileReader(arg), flags);
          for (Word next; (next = morph.next()) != null; ) {
            System.out.print(next);
          }
        }
      }
    }
  }","Main method to handle the
 banner command."
"public int doRecordChange(FieldInfo field, int iChangeType, boolean bDisplayOption)
    { // Read a valid record
        int iErrorCode = super.doRecordChange(field, iChangeType, bDisplayOption);      // Initialize the record
        if (iErrorCode != DBConstants.NORMAL_RETURN)
            return iErrorCode;
        if (iChangeType == m_iEventToTrigger)
            return this.syncRecords();
        return iErrorCode;
    }","The Field has Changed. Read the record
       ."
"public static String brief(String str, int len) {
        if (Strings.isBlank(str) || (str.length() + 3) <= len)
            return str;
        int w = len / 2;
        int l = str.length();
        return str.substring(0, len - w) + "" ... "" + str.substring(l - w);
    }",Returns a string of length len containing a brief sequence of tokens.
"public static int getColor(GraphicFactory graphicFactory, String colorString) {
        return getColor(graphicFactory, colorString, null, null);
    }",Get the color value of a resource.
"private final void close(String modName, boolean remove) //PK59717
    {
        synchronized (puScopes) {
            JPAScopeInfo scopeInfo = puScopes.get(modName);
            if (scopeInfo != null) {
                scopeInfo.close();
                if (remove) //PK59717
                    puScopes.remove(modName);
            }
        }
    }",Close the JPAScopeInfo object.
"public int compareTo(Field field)
    {
        if (field instanceof BaseField) if (!this.isSameType((BaseField)field))
            return super.compareTo(field);
        float float1 = Float.MIN_VALUE, float2 = Float.MIN_VALUE;
        Float floatField = (Float)this.getData(); // Get the physical data
        if (floatField != null)
            float1 = floatField.floatValue();
        floatField = (Float)field.getData();    // Get the physical data
        if (floatField != null)
            float2 = floatField.floatValue();
        if (float1 == float2)
            return 0;
        if (float1 < float2)
            return -1;
        else
            return 1;
    }",Compare this field to another field.
"public UTF8String rpad(int len, UTF8String pad) {
    int spaces = len - this.numChars(); // number of char need to pad
    if (spaces <= 0 || pad.numBytes() == 0) {
      // no padding at all, return the substring of the current string
      return substring(0, len);
    } else {
      int padChars = pad.numChars();
      int count = spaces / padChars; // how many padding string needed
      // the partial string of the padding
      UTF8String remain = pad.substring(0, spaces - padChars * count);

      byte[] data = new byte[this.numBytes + pad.numBytes * count + remain.numBytes];
      copyMemory(this.base, this.offset, data, BYTE_ARRAY_OFFSET, this.numBytes);
      int offset = this.numBytes;
      int idx = 0;
      while (idx < count) {
        copyMemory(pad.base, pad.offset, data, BYTE_ARRAY_OFFSET + offset, pad.numBytes);
        ++ idx;
        offset += pad.numBytes;
      }
      copyMemory(remain.base, remain.offset, data, BYTE_ARRAY_OFFSET + offset, remain.numBytes);

      return UTF8String.fromBytes(data);
    }
  }",Returns a new string of length len with the specified padding string.
"public JSON with(PrettyPrinter pp)
    {
        if (_prettyPrinter == pp) {
            return this;
        }
        return _with(_features, _streamFactory, _treeCodec,
                _reader, _writer, pp);
    }",Returns a copy of this object with the specified pretty printer.
"protected void printStandard(ResultEntry resultEntry) {
        PreciseTimestamp start = resultEntry.getStartTimestamp();
        PreciseTimestamp stop = resultEntry.getStopTimestamp();

        printStream.println();

        printStream.printf(""=== Algorithm %s used on problem %s ===\n"",
                resultEntry.getAlgorithm(), resultEntry.getProblem());
        printStream.printf(""  CPU Time:              %10d [ms]\n"", start.getCpuTimeSpent(stop));
        printStream.printf(""  System Time:           %10d [ms]\n"", start.getSystemTimeSpent(stop));
        printStream.printf(""  User Time:             %10d [ms]\n"", start.getUserTimeSpent(stop));
        printStream.printf(""  Clock Time:            %10d [ms]\n"", start.getClockTimeSpent(stop));

        printStream.printf(""  Optimize counter:      %10d [-]\n"", resultEntry.getOptimizeCounter());
        printStream.printf(""  Optimize/sec (CPU):    %10d [1/s]\n"",
                resultEntry.getOptimizeCounter() * 1000 / start.getCpuTimeSpent(stop));
        printStream.printf(""  Optimize/sec (Clock):  %10d [1/s]\n"",
                resultEntry.getOptimizeCounter() * 1000 / start.getClockTimeSpent(stop));

        printStream.printf(""  Best solution:         %10s\n"", resultEntry.getBestConfiguration());

        if (resultEntry.getBestConfiguration() != null) {
            printStream.printf(""  Depth:                 %10d [-]\n"",
                    resultEntry.getBestConfiguration().getOperationHistory().getCounter());
            printStream.printf(""  Fitness:               %10.1f [-]\n"", resultEntry.getBestFitness());
        }

        if (resultEntry.getException() == null)
            printStream.println(""  Ended without exception"");
        else
            printStream.printf(""  Ended with exception:  %10s\n"", resultEntry.getException());
    }",Print standard result entry
"public void addAction(M element, byte value)
    {
        actions.put(element, Byte.valueOf(value));
    }",Add an action to the sequence.
"public static int stringSize(int x) {
    if(x < 0) {
      // Avoid overflow on extreme negative
      return (x == Integer.MIN_VALUE) ? 11 : stringSize(-x) + 1;
    }
    // This is almost a binary search - 10 cases is not a power of two, and we
    // assume that the smaller values are more frequent.
    return //
    (x < 10000) // 1-4 vs. 5-10
        ? (x < 100) // 1-2 vs. 3-4
            ? ((x < 10) ? 1 : 2) //
            : ((x < 1000) ? 3 : 4) //
        : (x < 1000000) // 5-6 vs. 7-10
            ? ((x < 100000) ? 5 : 6) // 5-6
            : (x < 100000000) // 7-8 vs. 9-10
                ? ((x < 10000000) ? 7 : 8) // 7-8
                : ((x < 1000000000) ? 9 : 10); // 9-10
  }",Returns the size of a string in the range [ 0 11 ).
"@Override
    public RegisterTaskDefinitionResult registerTaskDefinition(RegisterTaskDefinitionRequest request) {
        request = beforeClientExecution(request);
        return executeRegisterTaskDefinition(request);
    }",Registers a task definition.
"public void updateServiceInstanceInternalStatus(String serviceName, String instanceId, OperationalStatus status){
        ProtocolHeader header = new ProtocolHeader();
        header.setType(ProtocolType.UpdateServiceInstanceInternalStatus);

        UpdateServiceInstanceInternalStatusProtocol protocol = new UpdateServiceInstanceInternalStatusProtocol(serviceName, instanceId, status);
        connection.submitRequest(header, protocol, null);
    }",Update ServiceInstance internal status.
"public static String toEnvironmentVariableName(String bootiqueVariable) {
		if (Strings.isNullOrEmpty(bootiqueVariable)) {
			return null;
		}
		final StringBuilder name = new StringBuilder();
		final Pattern pattern = Pattern.compile(""((?:[a-z0_9_]+)|(?:[A-Z]+[^A-Z]*))""); //$NON-NLS-1$
		for (final String component : bootiqueVariable.split(""[^a-zA-Z0_9_]+"")) { //$NON-NLS-1$
			final Matcher matcher = pattern.matcher(component);
			while (matcher.find()) {
				final String word = matcher.group(1);
				if (name.length() > 0) {
					name.append(""_""); //$NON-NLS-1$
				}
				name.append(word.toUpperCase());
			}
		}
		return name.toString();
	}",Convert a bootique variable to an environment variable name.
"public String getMarshaledName() {
    String serializedName = getSerializedName();
    if (!serializedName.isEmpty()) {
      return serializedName;
    }
    return names.raw;
  }",Get the serialized name of the name.
"public static DataSource createDataSource(final byte[] yamlBytes) throws SQLException, IOException {
        YamlOrchestrationShardingRuleConfiguration config = unmarshal(yamlBytes);
        return createDataSource(config.getDataSources(), config.getShardingRule(), config.getProps(), config.getOrchestration());
    }",Create a DataSource from a YAML byte array.
"public EClass getIfcCableCarrierSegmentType() {
		if (ifcCableCarrierSegmentTypeEClass == null) {
			ifcCableCarrierSegmentTypeEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc2x3tc1Package.eNS_URI)
					.getEClassifiers().get(64);
		}
		return ifcCableCarrierSegmentTypeEClass;
	}",Get the Ifc2x3tc1CarrierSegmentTypeEClass from the EPackage. Registry. INSTANCE.
"public TypeSpec createCurrencyUtil(String className, Map<String, CurrencyData> currencies) {
    TypeSpec.Builder type = TypeSpec.classBuilder(className)
        .addModifiers(Modifier.PUBLIC);
    
    CurrencyData defaultData = currencies.get(""DEFAULT"");
    currencies.remove(""DEFAULT"");
    
    MethodSpec.Builder code = MethodSpec.methodBuilder(""getCurrencyDigits"")
        .addModifiers(PUBLIC, STATIC)
        .addParameter(Types.CLDR_CURRENCY_ENUM, ""code"")
        .returns(int.class);
    
    code.beginControlFlow(""switch (code)"");
    for (Map.Entry<String, CurrencyData> entry : currencies.entrySet()) {
      CurrencyData data = entry.getValue();
      code.addStatement(""case $L: return $L"", entry.getKey(), data.digits);
    }
    code.addStatement(""default: return $L"", defaultData.digits);
    code.endControlFlow();
    
    type.addMethod(code.build());
    return type.build();
  }",Create a currency util class.
"public JBBPTextWriter Double(final double[] values, int off, int len) throws IOException {
    while (len-- > 0) {
      this.Double(values[off++]);
    }
    return this;
  }",Print double values.
"public void initialize(final JsMessagingEngine engine) {

        final String methodName = ""initialize"";
        if (TRACE.isEntryEnabled()) {
            SibTr.entry(this, TRACE, methodName, engine);
        }

        final Set listeners;

        _messagingEngine = engine;

        synchronized (MESSAGING_ENGINES) {

            // Do we already have a set of initialized MEs on this bus?
            Set messagingEngines = (Set) MESSAGING_ENGINES.get(engine
                    .getBusName());

            // If not, create a new set and add it to the map
            if (messagingEngines == null) {

                messagingEngines = new HashSet();
                MESSAGING_ENGINES.put(engine.getBusName(), messagingEngines);

            }

            // Add the initializing ME to the set
            messagingEngines.add(engine);

            // Get listeners to notify
            listeners = getListeners(_messagingEngine.getBusName());

        }

        // Notify listeners
        for (final Iterator iterator = listeners.iterator(); iterator.hasNext();) {

            final SibRaMessagingEngineListener listener = (SibRaMessagingEngineListener) iterator
                    .next();
            listener.messagingEngineInitializing(_messagingEngine);

        }

        if (TRACE.isEntryEnabled()) {
            SibTr.exit(this, TRACE, methodName);
        }

    }",Initialize the application of a single ME.
"public void setPageMargin(int marginPixels) {
        final int oldMargin = mPageMargin;
        mPageMargin = marginPixels;

        final int width = getWidth();
        recomputeScrollPosition(width, width, marginPixels, oldMargin);

        requestLayout();
    }",Sets the page margin.
"@Override
    public List<SearchResult> search(EntityMetadata m, String persistenceUnit, ConsistencyLevel consistencyLevel,
            Map<Boolean, List<IndexClause>> indexClauseMap)
    {

        return super.search(m, persistenceUnit, consistencyLevel, indexClauseMap);
    }",Override the search method to return a list of SearchResult objects.
"public void setAction(PdfAction action, float llx, float lly, float urx, float ury) {
        pdf.setAction(action, llx, lly, urx, ury);
    }",Sets the action of the page.
"@Nullable
    public Animator onDisappear(@NonNull final ViewGroup sceneRoot,
                                @Nullable TransitionValues startValues,
                                int startVisibility,
                                @Nullable TransitionValues endValues,
                                int endVisibility) {
        if ((mMode & MODE_OUT) != MODE_OUT) {
            return null;
        }

        View startView = (startValues != null) ? startValues.view : null;
        View endView = (endValues != null) ? endValues.view : null;
        View overlayView = null;
        View viewToKeep = null;
        boolean reusingCreatedOverlayView = false;
        boolean createOverlayFromStartView = false;
        if (endView == null || endView.getParent() == null) {
            if (endView != null) {
                // endView was removed from its parent - add it to the overlay
                overlayView = endView;
            } else if (startView != null) {
                createOverlayFromStartView = true;
            }
        } else {
            // visibility change
            if (endVisibility == View.INVISIBLE) {
                viewToKeep = endView;
            } else {
                // Becoming GONE
                if (startView == endView || startView == null) {
                    viewToKeep = endView;
                } else {
                    createOverlayFromStartView = true;
                }
            }
        }

        if (createOverlayFromStartView) {
            // endView does not exist. Use startView only under certain
            // conditions, because placing a view in an overlay necessitates
            // it being removed from its current parent
            if (startView.getTag(R.id.overlay_view) != null) {
                // we've already created overlay for the start view.
                // it means that we are applying two visibility
                // transitions for the same view
                overlayView = (View) startView.getTag(R.id.overlay_view);
                reusingCreatedOverlayView = true;
            } else if (startView.getParent() == null) {
                // no parent - safe to use
                overlayView = startView;
            } else if (startView.getParent() instanceof View) {
                View startParent = (View) startView.getParent();
                TransitionValues startParentValues = getTransitionValues(startParent, true);
                TransitionValues endParentValues = getMatchedTransitionValues(startParent,
                    true);
                VisibilityInfo parentVisibilityInfo =
                    getVisibilityChangeInfo(startParentValues, endParentValues);
                if (!parentVisibilityInfo.visibilityChange) {
                    overlayView = TransitionUtils.copyViewImage(sceneRoot, startView, startParent);
                } else if (startParent.getParent() == null) {
                    int id = startParent.getId();
                    if (id != View.NO_ID && sceneRoot.findViewById(id) != null
                        && mCanRemoveViews) {
                        // no parent, but its parent is unparented  but the parent
                        // hierarchy has been replaced by a new hierarchy with the same id
                        // and it is safe to un-parent startView
                        overlayView = startView;
                    }
                }
            }
        }

        if (overlayView != null && startValues != null) {
            // TODO: Need to do this for general case of adding to overlay
            final int[] screenLoc = (int[]) startValues.values.get(PROPNAME_SCREEN_LOCATION);
            if (!reusingCreatedOverlayView) {
                ViewGroupOverlayUtils.addOverlay(sceneRoot, overlayView, screenLoc[0], screenLoc[1]);
            }
            Animator animator = onDisappear(sceneRoot, overlayView, startValues, endValues);
            if (animator == null) {
                ViewGroupOverlayUtils.removeOverlay(sceneRoot, overlayView);
            } else if (!reusingCreatedOverlayView) {
                final View finalOverlayView = overlayView;
                final View finalStartView = startView;
                finalStartView.setTag(R.id.overlay_view, finalOverlayView);
                addListener(new TransitionListenerAdapter() {

                    @Override
                    public void onTransitionPause(@NonNull Transition transition) {
                        ViewGroupOverlayUtils.removeOverlay(sceneRoot, finalOverlayView);
                    }

                    @Override
                    public void onTransitionResume(@NonNull Transition transition) {
                        if (finalOverlayView.getParent() == null) {
                            ViewGroupOverlayUtils.addOverlay(sceneRoot, finalOverlayView, screenLoc[0], screenLoc[1]);
                        }
                        else {
                            cancel();
                        }
                    }

                    @Override
                    public void onTransitionEnd(@NonNull Transition transition) {
                        finalStartView.setTag(R.id.overlay_view, null);
                        ViewGroupOverlayUtils.removeOverlay(sceneRoot, finalOverlayView);
                        transition.removeListener(this);
                    }
                });
            }
            return animator;
        }

        if (viewToKeep != null) {
            int originalVisibility = -1;
            final boolean isForcedVisibility = mForcedStartVisibility != -1 ||
                    mForcedEndVisibility != -1;
            if (!isForcedVisibility) {
                originalVisibility = viewToKeep.getVisibility();
                ViewUtils.setTransitionVisibility(viewToKeep, View.VISIBLE);
            }
            Animator animator = onDisappear(sceneRoot, viewToKeep, startValues, endValues);
            if (animator != null) {
                DisappearListener disappearListener = new DisappearListener(viewToKeep,
                        endVisibility, isForcedVisibility);
                animator.addListener(disappearListener);
                AnimatorUtils.addPauseListener(animator, disappearListener);
                addListener(disappearListener);
            } else if (!isForcedVisibility) {
                ViewUtils.setTransitionVisibility(viewToKeep, originalVisibility);
            }
            return animator;
        }
        return null;
    }",On disappear Animator is created for the view which is being disappeared.
"protected AuthenticationBuilder authenticateInternal(final AuthenticationTransaction transaction) throws AuthenticationException {
        val credentials = transaction.getCredentials();
        LOGGER.debug(""Authentication credentials provided for this transaction are [{}]"", credentials);

        if (credentials.isEmpty()) {
            LOGGER.error(""Resolved authentication handlers for this transaction are empty"");
            throw new AuthenticationException(""Resolved credentials for this transaction are empty"");
        }

        val builder = new DefaultAuthenticationBuilder(NullPrincipal.getInstance());
        credentials.forEach(cred -> builder.addCredential(new BasicCredentialMetaData(cred)));
        
        val handlerSet = this.authenticationEventExecutionPlan.getAuthenticationHandlersForTransaction(transaction);
        LOGGER.debug(""Candidate resolved authentication handlers for this transaction are [{}]"", handlerSet);

        if (handlerSet.isEmpty()) {
            LOGGER.error(""Resolved authentication handlers for this transaction are empty"");
            throw new AuthenticationException(builder.getFailures(), builder.getSuccesses());
        }

        try {
            val it = credentials.iterator();
            AuthenticationCredentialsThreadLocalBinder.clearInProgressAuthentication();
            while (it.hasNext()) {
                val credential = it.next();
                LOGGER.debug(""Attempting to authenticate credential [{}]"", credential);

                val itHandlers = handlerSet.iterator();
                var proceedWithNextHandler = true;
                while (proceedWithNextHandler && itHandlers.hasNext()) {
                    val handler = itHandlers.next();
                    if (handler.supports(credential)) {
                        try {
                            val resolver = getPrincipalResolverLinkedToHandlerIfAny(handler, transaction);
                            LOGGER.debug(""Attempting authentication of [{}] using [{}]"", credential.getId(), handler.getName());
                            authenticateAndResolvePrincipal(builder, credential, resolver, handler);

                            val authnResult = builder.build();
                            AuthenticationCredentialsThreadLocalBinder.bindInProgress(authnResult);
                            val failures = evaluateAuthenticationPolicies(authnResult, transaction, handlerSet);
                            proceedWithNextHandler = !failures.getKey();
                        } catch (final Exception e) {
                            LOGGER.error(""Authentication has failed. Credentials may be incorrect or CAS cannot ""
                                + ""find authentication handler that supports [{}] of type [{}]. Examine the configuration to ""
                                + ""ensure a method of authentication is defined and analyze CAS logs at DEBUG level to trace ""
                                + ""the authentication event."", credential, credential.getClass().getSimpleName());

                            handleAuthenticationException(e, handler.getName(), builder);
                            proceedWithNextHandler = true;
                        }
                    } else {
                        LOGGER.debug(""Authentication handler [{}] does not support the credential type [{}]. Trying next..."", handler.getName(), credential);
                    }
                }
            }
            evaluateFinalAuthentication(builder, transaction, handlerSet);
            return builder;
        } finally {
            AuthenticationCredentialsThreadLocalBinder.clearInProgressAuthentication();
        }
    }",Authenticate internal.
"public void marshall(ListBackupSelectionsRequest listBackupSelectionsRequest, ProtocolMarshaller protocolMarshaller) {

        if (listBackupSelectionsRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(listBackupSelectionsRequest.getBackupPlanId(), BACKUPPLANID_BINDING);
            protocolMarshaller.marshall(listBackupSelectionsRequest.getNextToken(), NEXTTOKEN_BINDING);
            protocolMarshaller.marshall(listBackupSelectionsRequest.getMaxResults(), MAXRESULTS_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given list of backup sources to the JSON file.
"@Override
	@Transactional(enabled = false)
	public CommerceDiscountUserSegmentRel createCommerceDiscountUserSegmentRel(
		long commerceDiscountUserSegmentRelId) {
		return commerceDiscountUserSegmentRelPersistence.create(commerceDiscountUserSegmentRelId);
	}",Creates a new commerce discount user segment rel with the primary key. Also notifies the appropriate model listeners.
"@Override
	public CommercePriceList findByCompanyId_First(long companyId,
		OrderByComparator<CommercePriceList> orderByComparator)
		throws NoSuchPriceListException {
		CommercePriceList commercePriceList = fetchByCompanyId_First(companyId,
				orderByComparator);

		if (commercePriceList != null) {
			return commercePriceList;
		}

		StringBundler msg = new StringBundler(4);

		msg.append(_NO_SUCH_ENTITY_WITH_KEY);

		msg.append(""companyId="");
		msg.append(companyId);

		msg.append(""}"");

		throw new NoSuchPriceListException(msg.toString());
	}",Returns the commerce price list in the ordered set where company = &#63 ; and service = &#63 ;.
"public static List<Long> lengths(final Iterable<Range<Long>> ranges) {
        checkNotNull(ranges);
        List<Long> lengths = new ArrayList<Long>();
        for (Range<Long> range : ranges) {
            lengths.add(length(range));
        }
        return lengths;
    }",Gets the lengths of the set of time stamp ranges.
"public Observable<ServiceResponse<GatewayRouteListResultInner>> beginGetAdvertisedRoutesWithServiceResponseAsync(String resourceGroupName, String virtualNetworkGatewayName, String peer) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");
        }
        if (virtualNetworkGatewayName == null) {
            throw new IllegalArgumentException(""Parameter virtualNetworkGatewayName is required and cannot be null."");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");
        }
        if (peer == null) {
            throw new IllegalArgumentException(""Parameter peer is required and cannot be null."");
        }
        final String apiVersion = ""2018-07-01"";
        return service.beginGetAdvertisedRoutes(resourceGroupName, virtualNetworkGatewayName, this.client.subscriptionId(), peer, apiVersion, this.client.acceptLanguage(), this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<GatewayRouteListResultInner>>>() {
                @Override
                public Observable<ServiceResponse<GatewayRouteListResultInner>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<GatewayRouteListResultInner> clientResponse = beginGetAdvertisedRoutesDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }",Get advertised routes.
"public void interpret( Specification table )
    {
        final Example row = table.nextExample();

        Document document = Document.text( ExampleWrapper.sandbox( row ) );
        document.execute(new FitInterpreterSelector(sud));
        table.exampleDone( document.getStatistics() );

        while (table.hasMoreExamples()) table.nextExample();
    }",Interprets a table of XML.
"public Result decodeRow(int rowNumber,
                          BitArray row,
                          int[] startGuardRange,
                          Map<DecodeHintType,?> hints)
      throws NotFoundException, ChecksumException, FormatException {

    ResultPointCallback resultPointCallback = hints == null ? null :
        (ResultPointCallback) hints.get(DecodeHintType.NEED_RESULT_POINT_CALLBACK);

    if (resultPointCallback != null) {
      resultPointCallback.foundPossibleResultPoint(new ResultPoint(
          (startGuardRange[0] + startGuardRange[1]) / 2.0f, rowNumber
      ));
    }

    StringBuilder result = decodeRowStringBuffer;
    result.setLength(0);
    int endStart = decodeMiddle(row, startGuardRange, result);

    if (resultPointCallback != null) {
      resultPointCallback.foundPossibleResultPoint(new ResultPoint(
          endStart, rowNumber
      ));
    }

    int[] endRange = decodeEnd(row, endStart);

    if (resultPointCallback != null) {
      resultPointCallback.foundPossibleResultPoint(new ResultPoint(
          (endRange[0] + endRange[1]) / 2.0f, rowNumber
      ));
    }


    // Make sure there is a quiet zone at least as big as the end pattern after the barcode. The
    // spec might want more whitespace, but in practice this is the maximum we can count on.
    int end = endRange[1];
    int quietEnd = end + (end - endRange[0]);
    if (quietEnd >= row.getSize() || !row.isRange(end, quietEnd, false)) {
      throw NotFoundException.getNotFoundInstance();
    }

    String resultString = result.toString();
    // UPC/EAN should never be less than 8 chars anyway
    if (resultString.length() < 8) {
      throw FormatException.getFormatInstance();
    }
    if (!checkChecksum(resultString)) {
      throw ChecksumException.getChecksumInstance();
    }

    float left = (startGuardRange[1] + startGuardRange[0]) / 2.0f;
    float right = (endRange[1] + endRange[0]) / 2.0f;
    BarcodeFormat format = getBarcodeFormat();
    Result decodeResult = new Result(resultString,
        null, // no natural byte representation for these barcodes
        new ResultPoint[]{
            new ResultPoint(left, rowNumber),
            new ResultPoint(right, rowNumber)},
        format);

    int extensionLength = 0;

    try {
      Result extensionResult = extensionReader.decodeRow(rowNumber, row, endRange[1]);
      decodeResult.putMetadata(ResultMetadataType.UPC_EAN_EXTENSION, extensionResult.getText());
      decodeResult.putAllMetadata(extensionResult.getResultMetadata());
      decodeResult.addResultPoints(extensionResult.getResultPoints());
      extensionLength = extensionResult.getText().length();
    } catch (ReaderException re) {
      // continue
    }

    int[] allowedExtensions =
        hints == null ? null : (int[]) hints.get(DecodeHintType.ALLOWED_EAN_EXTENSIONS);
    if (allowedExtensions != null) {
      boolean valid = false;
      for (int length : allowedExtensions) {
        if (extensionLength == length) {
          valid = true;
          break;
        }
      }
      if (!valid) {
        throw NotFoundException.getNotFoundInstance();
      }
    }

    if (format == BarcodeFormat.EAN_13 || format == BarcodeFormat.UPC_A) {
      String countryID = eanManSupport.lookupCountryIdentifier(resultString);
      if (countryID != null) {
        decodeResult.putMetadata(ResultMetadataType.POSSIBLE_COUNTRY, countryID);
      }
    }

    return decodeResult;
  }",Decode a single row of data.
"@Pure
	public static int compareAttrNames(String arg0, String arg1) {
		if (arg0 == arg1) {
			return 0;
		}
		if (arg0 == null) {
			return Integer.MAX_VALUE;
		}
		if (arg1 == null) {
			return Integer.MIN_VALUE;
		}
		return arg0.compareToIgnoreCase(arg1);
	}",Compare two attribute names.
"private static Document loadXML(InputSource source, boolean useNamespace) {
		try {
			org.w3c.dom.Document doc = getDocumentBuilder(null, useNamespace).parse(source);
			return new DocumentImpl(doc);
		} catch (Exception e) {
			throw new DomException(e);
		} finally {
			close(source);
		}
	}",Load a DOM Document from an input source.
"@Override
	public Later<Boolean> delete(String object) {
		this.checkForBatchExecution();
		
		// Something is fucked up with java's ability to perform DELETE.  FB's servers always return
		// 400 Bad Request even though the code is correct.  We will switch all deletes to posts.
		//GraphRequest<Boolean> req = new GraphRequest<Boolean>(object, HttpMethod.DELETE, mapper.getTypeFactory().constructType(Boolean.class), new Param[0]);

		GraphRequest<Boolean> req =
			new GraphRequest<Boolean>(object, HttpMethod.POST, new Param[] { new Param(""method"", ""DELETE"") }, this.mapper,
				this.<Boolean>createMappingChain(mapper.getTypeFactory().constructType(Boolean.class)));
		
		this.graphRequests.add(req);
		return req;
	}",Creates a new DELETE GraphRequest and adds it to the batch execution.
"public List<String> listDocuments(String location) throws Exception
    {
        FileObject root = getFileObject( location );
        if (!root.exists()) return Collections.emptyList();

        List<String> names = new ArrayList<String>();
        if (isDirectory(root))
        {
            for (FileObject child : root.findFiles(NOT_HIDDEN_FILE_TYPE_SELECTOR))
            {
                names.addAll( listDocuments(child.getName().getURI()));
            }
        }
        else
        {
            names.add(root.getName().getURI());
        }
        return names;
    }",List all the documents in the specified location.
"public void setReadReplicaDBClusterIdentifiers(java.util.Collection<String> readReplicaDBClusterIdentifiers) {
        if (readReplicaDBClusterIdentifiers == null) {
            this.readReplicaDBClusterIdentifiers = null;
            return;
        }

        this.readReplicaDBClusterIdentifiers = new com.amazonaws.internal.SdkInternalList<String>(readReplicaDBClusterIdentifiers);
    }",Sets the value of the readReplicaDBClusterIdentifiers property.
"public boolean syncMonitors(NewRelicCache cache)
    {
        boolean ret = true;

        if(apiClient == null)
            throw new IllegalArgumentException(""null API client"");

        // Get the Synthetics configuration using the REST API
        if(cache.isSyntheticsEnabled())
        {
            ret = false;

            logger.info(""Getting the monitors"");
            cache.monitors().add(syntheticsApiClient.monitors().list());
            cache.setUpdatedAt();

            ret = true;
        }

        return ret;
    }",Synchronize the cache with the Synthetics API client.
"public static boolean validateHKCard(String idCard) {
        String card = idCard.replaceAll(""[\\(|\\)]"", """");
        Integer sum;
        if (card.length() == 9) {
            sum = ((int) card.substring(0, 1).toUpperCase().toCharArray()[0] - 55) * 9
                    + ((int) card.substring(1, 2).toUpperCase().toCharArray()[0] - 55) * 8;
            card = card.substring(1, 9);
        } else {
            sum = 522 + ((int) card.substring(0, 1).toUpperCase().toCharArray()[0] - 55) * 8;
        }
        String mid = card.substring(1, 7);
        String end = card.substring(7, 8);
        char[] chars = mid.toCharArray();
        Integer iflag = 7;
        for (char c : chars) {
            sum = sum + Integer.valueOf(c + """") * iflag;
            iflag--;
        }
        if (end.toUpperCase().equals(""A"")) {
            sum = sum + 10;
        } else {
            sum = sum + Integer.valueOf(end);
        }
        return (sum % 11 == 0);
    }",Validate HK card.
"public static byte[] getEncodedInternal(X509CRL crl) throws CRLException {
        if (crl instanceof X509CRLImpl) {
            return ((X509CRLImpl)crl).getEncodedInternal();
        } else {
            return crl.getEncoded();
        }
    }",Get the encoded form of the given X509CRL.
"@Override
    public Asset<?> assetAt(String path) {
        List<WebJarLib> candidates = findLibsContaining(path);

        if (candidates.size() == 1) {
            // Perfect ! only one match
            return new DefaultAsset<>(
                    ""/libs/"" + candidates.get(0).name + ""/"" + candidates.get(0).version + ""/"" + path,
                    candidates.get(0).get(path),
                    candidates.get(0).toString(),
                    candidates.get(0).lastModified(),
                    CacheUtils.computeEtag(candidates.get(0).lastModified(), configuration, crypto)
            );
        } else if (candidates.size() > 1) {
            // Several candidates
            logger().warn(""{} WebJars provide '{}' - returning the one from {}-{}"", candidates.size(), path,
                    candidates.get(0).name, candidates.get(0).version);
            return new DefaultAsset<>(
                    ""/libs/"" + candidates.get(0).name + ""/"" + candidates.get(0).version + ""/"" + path,
                    candidates.get(0).get(path),
                    candidates.get(0).toString(),
                    candidates.get(0).lastModified(),
                    CacheUtils.computeEtag(candidates.get(0).lastModified(), configuration, crypto)
            );
        } else {
            Matcher matcher = PATTERN.matcher(path);
            if (!matcher.matches()) {
                // It should have been handled by the path match.
                return null;
            }

            final String name = matcher.group(1);
            final String version = matcher.group(3);
            if (version != null) {
                String rel = matcher.group(4);
                // We have a name and a version
                // Try to find the matching library
                WebJarLib lib = find(name, version);
                if (lib != null) {
                    return new DefaultAsset<>(
                            rel,
                            lib.get(rel),
                            lib.toString(),
                            lib.lastModified(),
                            CacheUtils.computeEtag(lib.lastModified(), configuration, crypto)
                    );
                }
                // If not found, it may be because the version is not really the version but a segment of the path.
            }
            // If we reach this point it means that the name/version lookup has failed, try without the version
            String rel = matcher.group(4);
            if (version != null) {
                // We have a group 3
                rel = version + ""/"" + rel;
            }

            List<WebJarLib> libs = find(name);
            if (libs.size() == 1) {
                // Only on library has the given name
                if (libs.get(0).contains(rel)) {
                    WebJarLib lib = libs.get(0);
                    return new DefaultAsset<>(
                            ""/libs/"" + lib.name + ""/"" + lib.version + ""/"" + rel,
                            lib.get(rel),
                            lib.toString(),
                            lib.lastModified(),
                            CacheUtils.computeEtag(lib.lastModified(), configuration, crypto)
                    );
                }
            } else if (libs.size() > 1) {
                // Several candidates
                WebJarLib higher = null;
                ComparableVersion higherVersion = null;
                for (WebJarLib lib: libs) {
                    if (lib.contains(rel)) {
                        if(higher == null) {
                            higher = lib;
                            higherVersion = new ComparableVersion(higher.version);
                        } else {
                            ComparableVersion newVersion = new ComparableVersion(lib.version);
                            if(newVersion.compareTo(higherVersion) > 0) {
                                higher = lib;
                                higherVersion = new ComparableVersion(higher.version);
                            }
                        }
                    }
                }
                if(higher != null) {
                    logger().warn(""{} WebJars match the request '{}' - returning the resource from {}-{}"",
                            libs.size(), path, higher.name, higher.version);
                    return new DefaultAsset<>(
                            ""/libs/"" + higher.name + ""/"" + higher.version + ""/"" + rel,
                            higher.get(rel),
                            higher.toString(),
                            higher.lastModified(),
                            CacheUtils.computeEtag(higher.lastModified(), configuration, crypto)
                    );
                }

            }

            return null;
        }
    }",Get the asset at the given path.
"public static float convertToFloat (@Nullable final Object aSrcValue, final float fDefault)
  {
    final Float aValue = convert (aSrcValue, Float.class, null);
    return aValue == null ? fDefault : aValue.floatValue ();
  }",Convert the passed value to a float.
"@Override
    public RawCollationKey getRawCollationKey(String source, RawCollationKey key) {
        if (source == null) {
            return null;
        }
        CollationBuffer buffer = null;
        try {
            buffer = getCollationBuffer();
            return getRawCollationKey(source, key, buffer);
        } finally {
            releaseCollationBuffer(buffer);
        }
    }",Get the raw collation key from the source string.
"public static Flow perform(ServletRewrite<?, ?> event, EvaluationContext context, Flow subflow,
            SubflowTask subflowTask)
   {
      Flow flow = event.getFlow();
      try
      {
         event.setFlow(subflow);
         subflowTask.performInSubflow(event, context);
         return event.getFlow();
      }
      finally
      {
         event.setFlow(flow);
      }
   }",Perform the action in the subflow
"private void readStagingPluginValues() {
        versioning = VERSIONING.valueOf(defaultVersioning);

        createVcsTag = defaultVcsConfig.isCreateTag();
        overrideCredentials = defaultVcsConfig.isOverrideCredentials();
        username = defaultVcsConfig.getUsername();
        password = defaultVcsConfig.getPassword();
        tagUrl = defaultVcsConfig.getTagUrlOrName();
        tagComment = defaultVcsConfig.getTagComment();
        nextDevelCommitComment = defaultVcsConfig.getNextDevelopmentVersionComment();
        createReleaseBranch = defaultVcsConfig.isUseReleaseBranch();
        releaseBranch = defaultVcsConfig.getReleaseBranchName();
        stagingRepositoryKey = defaultPromotionConfig.getTargetRepository();
        stagingComment = defaultPromotionConfig.getComment();

        switch (versioning) {
            case GLOBAL:
                doGlobalVersioning();
                break;
            case PER_MODULE:
                doPerModuleVersioning(defaultModules);
        }
    }",Read the plugin values from the staging plugin.
"public final void doesNotContain(@NullableDecl Object element) {
    if (Iterables.contains(actual(), element)) {
      failWithActual(""expected not to contain"", element);
    }
  }",Fails if the element is not contained in the list.
"public void updateEntry(final Entry entry, String fsid) throws Exception {
        synchronized (FileStore.getFileStore()) {

            final Feed f = getFeedDocument();

            if (fsid.endsWith("".media-link"")) {
                fsid = fsid.substring(0, fsid.length() - "".media-link"".length());
            }

            updateTimestamps(entry);

            updateEntryAppLinks(entry, fsid, false);
            updateFeedDocumentWithExistingEntry(f, entry);

            final String entryPath = getEntryPath(fsid);
            final OutputStream os = FileStore.getFileStore().getFileOutputStream(entryPath);
            updateEntryAppLinks(entry, fsid, true);
            Atom10Generator.serializeEntry(entry, new OutputStreamWriter(os, ""UTF-8""));
            os.flush();
            os.close();
        }
    }",Update entry.
"@Override
	public <T> List<T> dynamicQuery(DynamicQuery dynamicQuery) {
		return cpOptionCategoryPersistence.findWithDynamicQuery(dynamicQuery);
	}",Executes a dynamic query on the database.
"public final void updateByte(final int n) {
        this.currentByte = n;
        if ((panel != null) && (n % 10000 == 0)) {
            panel.setCurrentByte(n);
        }
    }","Updates the byte value of the
 banner."
"protected void compareText(CharacterData control, CharacterData test,
                               DifferenceListener listener)
        throws DifferenceFoundException {
        compareCharacterData(control, test, listener,
                             control instanceof CDATASection ? CDATA_VALUE : TEXT_VALUE);
    }",Compare text.
"public void valueUnbound( HttpSessionBindingEvent event )
    {
        //
        // We may have lost our transient ServletContext reference.  Try to get the ServletContext reference from the
        // HttpSession object if necessary.
        //
        ServletContext servletContext = getServletContext();
        HttpSession session = event.getSession();

        if ( servletContext == null && session != null )
        {
            servletContext = session.getServletContext();
        }

        if ( servletContext != null )
        {
            if ( !_isDestroyed && Handlers.get( servletContext ).getStorageHandler().allowBindingEvent( event ) )
            {
                destroy( session );
                _isDestroyed = true;
            }
        }
    }",ValueUnbound Method.
"public static List<File> findFilesRecursive(final File dir, final String filenameToSearch)
	{
		final List<File> foundedFileList = new ArrayList<>();
		final String regex = RegExExtensions.replaceWildcardsWithRE(filenameToSearch);
		// Get all files
		final File[] children = dir.getAbsoluteFile().listFiles();
		if (children == null || children.length < 1)
		{
			return foundedFileList;
		}
		for (final File element : children)
		{
			// if the entry is a directory
			if (element.isDirectory())
			{ // then
				// find recursively in the directory and put it in a List.
				final List<File> foundedFiles = findFilesRecursive(element, filenameToSearch);
				// Put the founded files in the main List.
				foundedFileList.addAll(foundedFiles);
			}
			else
			{
				// entry is a file
				final String filename = element.getName();
				if (filename.matches(regex))
				{
					foundedFileList.add(element.getAbsoluteFile());
				}
			}
		}
		return foundedFileList;
	}",Find files recursively.
"@DoesServiceRequest
    public FileOutputStream openWriteExisting() throws StorageException, URISyntaxException {
        return this
                .openOutputStreamInternal(null /* length */, null /* accessCondition */, null /* options */, null /* opContext */);
    }",Returns a new file output stream for writing to the file system.
"public static long distance(CommonSynonymDictionary.SynonymItem itemA, CommonSynonymDictionary.SynonymItem itemB)
    {
        return itemA.distance(itemB);
    }",Get distance between two words.
"public static void cleanDir(final File destDir) throws IOException {
		checkExists(destDir);
		checkIsDirectory(destDir);

		File[] files = destDir.listFiles();
		if (files == null) {
			throw new IOException(""Failed to list contents of: "" + destDir);
		}

		IOException exception = null;
		for (File file : files) {
			try {
				if (file.isDirectory()) {
					deleteDir(file);
				} else {
					file.delete();
				}
			} catch (IOException ioex) {
				exception = ioex;
				continue;
			}
		}

		if (exception != null) {
			throw exception;
		}
	}",Deletes all files in the given directory.
"@Override
	public void writeToOutput(final ChannelWriterOutputView output, final int start, int num) throws IOException {
		int currentMemSeg = start / this.indexEntriesPerSegment;
		int offset = (start % this.indexEntriesPerSegment) * this.indexEntrySize;
		
		while (num > 0)
		{
			final MemorySegment currentIndexSegment = this.sortIndex.get(currentMemSeg++);
			// check whether we have a full or partially full segment
			if (num >= this.indexEntriesPerSegment && offset == 0) {
				// full segment
				for (;offset <= this.lastIndexEntryOffset; offset += this.indexEntrySize) {
					final long pointer = currentIndexSegment.getLong(offset);
					this.recordBuffer.setReadPosition(pointer);
					this.serializer.copy(this.recordBuffer, output);
				}
				num -= this.indexEntriesPerSegment;
			} else {
				// partially filled segment
				for (; num > 0 && offset <= this.lastIndexEntryOffset; num--, offset += this.indexEntrySize)
				{
					final long pointer = currentIndexSegment.getLong(offset);
					this.recordBuffer.setReadPosition(pointer);
					this.serializer.copy(this.recordBuffer, output);
				}
			}
			offset = 0;
		}
	}",Write to output.
"@Override
  public Object get(String attributeName) {
    if (cachedValueMap == null) {
      cachedValueMap = new LinkedHashMap<>();
    }

    Object value;
    if (cachedValueMap.containsKey(attributeName)) {
      value = cachedValueMap.get(attributeName);
    } else {
      Integer col = colNamesMap.get(attributeName);
      if (col != null) {
        Cell cell = row.getCell(col);
        if (cell != null) {
          value = ExcelUtils.toValue(cell, cellProcessors);
        } else {
          value = null;
        }
      } else {
        value = null;
      }

      cachedValueMap.put(attributeName, value);
    }
    return value;
  }",Get the value of the attribute with the specified name.
"protected Collection<AbstractElement> getElementsToParse(AbstractElement root) {
		if (root instanceof Alternatives)
			return ((CompoundElement) root).getElements();
		return Collections.singleton(root);
	}",Get the elements to parse.
"public static int[] unbox (Integer[] list)
    {
        if (list == null) {
            return null;
        }
        int[] unboxed = new int[list.length];
        for (int ii = 0; ii < list.length; ii++) {
            unboxed[ii] = list[ii];
        }
        return unboxed;
    }",Unbox a Integer array.
"public static List<Device> feedback(Object keystore, String password, boolean production) throws CommunicationException, KeystoreException {
		List<Device> devices = new Vector<Device>();
		FeedbackServiceManager feedbackManager = new FeedbackServiceManager();
		AppleFeedbackServer server = new AppleFeedbackServerBasicImpl(keystore, password, production);
		devices.addAll(feedbackManager.getDevices(server));
		return devices;
	}",Get a list of devices from a keystore.
"public static byte[] hashTwice(byte[] input1, byte[] input2) {
        MessageDigest digest = newDigest();
        digest.update(input1);
        digest.update(input2);
        return digest.digest(digest.digest());
    }",Hash two bytes.
"private void createAreas(final BufferedImage IMAGE) {
        final double ORIGIN_CORRECTION;
        final double ANGLE_STEP;

        switch (getOrientation()) {
            case NORTH:
                ORIGIN_CORRECTION = 135;
                break;
            case EAST:
                ORIGIN_CORRECTION = 135;
                break;
            case SOUTH:
                ORIGIN_CORRECTION = 135;
                break;
            case WEST:
                ORIGIN_CORRECTION = 225;
                break;
            default:
                ORIGIN_CORRECTION = 135;
                break;
        }

        if (bImage != null) {
            if (!isLogScale()) {
                ANGLE_STEP = Math.toDegrees(getModel().getAngleRange()) / (getMaxValue() - getMinValue());
            } else {
                ANGLE_STEP = Math.toDegrees(getModel().getAngleRange()) / UTIL.logOfBase(BASE, getMaxValue() - getMinValue());
            }

            if (bImage != null && !getAreas().isEmpty()) {
                final double OUTER_RADIUS = bImage.getWidth() * 0.44f;
                final double RADIUS;
                if (isSectionsVisible()) {
                    RADIUS = isExpandedSectionsEnabled() ? OUTER_RADIUS - bImage.getWidth() * 0.12f : OUTER_RADIUS - bImage.getWidth() * 0.04f;
                } else {
                    RADIUS = OUTER_RADIUS;
                }
                final double FREE_AREA = bImage.getWidth() / 2.0 - RADIUS;
                final Rectangle2D AREA_FRAME = new Rectangle2D.Double(bImage.getMinX() + FREE_AREA, bImage.getMinY() + FREE_AREA, 2 * RADIUS, 2 * RADIUS);

                for (Section area : getAreas()) {
                    if (!isLogScale()) {
                        area.setFilledArea(new Arc2D.Double(AREA_FRAME, ORIGIN_CORRECTION - (area.getStart() * ANGLE_STEP) + (getMinValue() * ANGLE_STEP), -(area.getStop() - area.getStart()) * ANGLE_STEP, Arc2D.PIE));
                    } else {
                        area.setFilledArea(new Arc2D.Double(AREA_FRAME, ORIGIN_CORRECTION - (UTIL.logOfBase(BASE, area.getStart()) * ANGLE_STEP) + (UTIL.logOfBase(BASE, getMinValue()) * ANGLE_STEP), -UTIL.logOfBase(BASE, area.getStop() - area.getStart()) * ANGLE_STEP, Arc2D.PIE));
                    }
                }
            }
            // Draw the areas
            if (isAreasVisible() && IMAGE != null) {
                final Graphics2D G2 = IMAGE.createGraphics();
                G2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

                switch (getOrientation()) {
                    case EAST:
                        break;
                    case SOUTH:
                        break;
                    case WEST:
                        G2.translate(CENTER.getX() / 2.2, 0);
                        break;
                    case NORTH:

                    default:
                        G2.translate(0, CENTER.getY() / 2.2);
                        break;
                }

                for (Section area : getAreas()) {
                    G2.setColor(isTransparentAreasEnabled() ? area.getTransparentColor() : area.getColor());
                    G2.fill(area.getFilledArea());
                }
                G2.dispose();
            }
        }
    }",Create the areas.
"public void setLENGTH(Integer newLENGTH) {
		Integer oldLENGTH = length;
		length = newLENGTH;
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, AfplibPackage.BEGIN_SEGMENT_COMMAND__LENGTH, oldLENGTH, length));
	}",Sets the length of the segment.
"public AdminUpdateUserAttributesRequest withUserAttributes(AttributeType... userAttributes) {
        if (this.userAttributes == null) {
            setUserAttributes(new java.util.ArrayList<AttributeType>(userAttributes.length));
        }
        for (AttributeType ele : userAttributes) {
            this.userAttributes.add(ele);
        }
        return this;
    }",A list of Attributes that you want to update.
"public ConsulResponse<List<HealthCheck>> getNodeChecks(String node) {
        return getNodeChecks(node, null, null, RequestOptions.BLANK);
    }",Get node checks
"public HistoryEvent createFormPropertyUpdateEvt(ExecutionEntity execution, String propertyId, String propertyValue, String taskId) {

    final IdGenerator idGenerator = Context.getProcessEngineConfiguration().getIdGenerator();

    HistoricFormPropertyEventEntity historicFormPropertyEntity = newHistoricFormPropertyEvent();

    historicFormPropertyEntity.setId(idGenerator.getNextId());
    historicFormPropertyEntity.setEventType(HistoryEventTypes.FORM_PROPERTY_UPDATE.getEventName());
    historicFormPropertyEntity.setTimestamp(ClockUtil.getCurrentTime());
    historicFormPropertyEntity.setActivityInstanceId(execution.getActivityInstanceId());
    historicFormPropertyEntity.setExecutionId(execution.getId());
    historicFormPropertyEntity.setProcessDefinitionId(execution.getProcessDefinitionId());
    historicFormPropertyEntity.setProcessInstanceId(execution.getProcessInstanceId());
    historicFormPropertyEntity.setPropertyId(propertyId);
    historicFormPropertyEntity.setPropertyValue(propertyValue);
    historicFormPropertyEntity.setTaskId(taskId);
    historicFormPropertyEntity.setTenantId(execution.getTenantId());
    historicFormPropertyEntity.setUserOperationId(Context.getCommandContext().getOperationId());
    historicFormPropertyEntity.setRootProcessInstanceId(execution.getRootProcessInstanceId());

    if (isHistoryRemovalTimeStrategyStart()) {
      provideRemovalTime(historicFormPropertyEntity);
    }

    ProcessDefinitionEntity definition = execution.getProcessDefinition();
    if (definition != null) {
      historicFormPropertyEntity.setProcessDefinitionKey(definition.getKey());
    }

    // initialize sequence counter
    initSequenceCounter(execution, historicFormPropertyEntity);

    return historicFormPropertyEntity;
  }",Creates a form property update event.
"private Peer getPeer(HFClient client, String peerName) throws InvalidArgumentException {
        Peer peer = null;
        Node p = peers.get(peerName);
        if (p != null) {
            peer = client.newPeer(p.getName(), p.getUrl(), p.getProperties());
        }
        return peer;
    }",Get a peer from the cache.
"public EnumMap<Level, List<Message>> getMessages() {
        final EnumMap<Level, List<Message>> copyOfMessages = new EnumMap<Level, List<Message>>(Level.class);
        for (final Level level : Level.values()) {
            if (containsMessages(level)) {
                copyOfMessages.put(level, getMessages(level));
            }
        }
        return copyOfMessages;
    }",Gets the messages.
"protected static CapsVersionAndHash generateVerificationString(DiscoverInfo discoverInfo, String hash) {
        if (hash == null) {
            hash = DEFAULT_HASH;
        }
        // SUPPORTED_HASHES uses the format of MessageDigest, which is uppercase, e.g. ""SHA-1"" instead of ""sha-1""
        MessageDigest md = SUPPORTED_HASHES.get(hash.toUpperCase(Locale.US));
        if (md == null)
            return null;
        // Then transform the hash to lowercase, as this value will be put on the wire within the caps element's hash
        // attribute. I'm not sure if the standard is case insensitive here, but let's assume that even it is, there could
        // be ""broken"" implementation in the wild, so we *always* transform to lowercase.
        hash = hash.toLowerCase(Locale.US);

        DataForm extendedInfo =  DataForm.from(discoverInfo);

        // 1. Initialize an empty string S ('sb' in this method).
        StringBuilder sb = new StringBuilder(); // Use StringBuilder as we don't
                                                // need thread-safe StringBuffer

        // 2. Sort the service discovery identities by category and then by
        // type and then by xml:lang
        // (if it exists), formatted as CATEGORY '/' [TYPE] '/' [LANG] '/'
        // [NAME]. Note that each slash is included even if the LANG or
        // NAME is not included (in accordance with XEP-0030, the category and
        // type MUST be included.
        SortedSet<DiscoverInfo.Identity> sortedIdentities = new TreeSet<>();

        sortedIdentities.addAll(discoverInfo.getIdentities());

        // 3. For each identity, append the 'category/type/lang/name' to S,
        // followed by the '<' character.
        for (DiscoverInfo.Identity identity : sortedIdentities) {
            sb.append(identity.getCategory());
            sb.append('/');
            sb.append(identity.getType());
            sb.append('/');
            sb.append(identity.getLanguage() == null ? """" : identity.getLanguage());
            sb.append('/');
            sb.append(identity.getName() == null ? """" : identity.getName());
            sb.append('<');
        }

        // 4. Sort the supported service discovery features.
        SortedSet<String> features = new TreeSet<>();
        for (Feature f : discoverInfo.getFeatures())
            features.add(f.getVar());

        // 5. For each feature, append the feature to S, followed by the '<'
        // character
        for (String f : features) {
            sb.append(f);
            sb.append('<');
        }

        // only use the data form for calculation is it has a hidden FORM_TYPE
        // field
        // see XEP-0115 5.4 step 3.6
        if (extendedInfo != null && extendedInfo.hasHiddenFormTypeField()) {
            synchronized (extendedInfo) {
                // 6. If the service discovery information response includes
                // XEP-0128 data forms, sort the forms by the FORM_TYPE (i.e.,
                // by the XML character data of the <value/> element).
                SortedSet<FormField> fs = new TreeSet<>(new Comparator<FormField>() {
                    @Override
                    public int compare(FormField f1, FormField f2) {
                        return f1.getVariable().compareTo(f2.getVariable());
                    }
                });

                FormField ft = null;

                for (FormField f : extendedInfo.getFields()) {
                    if (!f.getVariable().equals(""FORM_TYPE"")) {
                        fs.add(f);
                    } else {
                        ft = f;
                    }
                }

                // Add FORM_TYPE values
                if (ft != null) {
                    formFieldValuesToCaps(ft.getValues(), sb);
                }

                // 7. 3. For each field other than FORM_TYPE:
                // 1. Append the value of the ""var"" attribute, followed by the
                // '<' character.
                // 2. Sort values by the XML character data of the <value/>
                // element.
                // 3. For each <value/> element, append the XML character data,
                // followed by the '<' character.
                for (FormField f : fs) {
                    sb.append(f.getVariable());
                    sb.append('<');
                    formFieldValuesToCaps(f.getValues(), sb);
                }
            }
        }
        // 8. Ensure that S is encoded according to the UTF-8 encoding (RFC
        // 3269).
        // 9. Compute the verification string by hashing S using the algorithm
        // specified in the 'hash' attribute (e.g., SHA-1 as defined in RFC
        // 3174).
        // The hashed data MUST be generated with binary output and
        // encoded using Base64 as specified in Section 4 of RFC 4648
        // (note: the Base64 output MUST NOT include whitespace and MUST set
        // padding bits to zero).
        byte[] bytes;
        try {
            bytes = sb.toString().getBytes(StringUtils.UTF8);
        }
        catch (UnsupportedEncodingException e) {
            throw new AssertionError(e);
        }
        byte[] digest;
        synchronized (md) {
            digest = md.digest(bytes);
        }
        String version = Base64.encodeToString(digest);
        return new CapsVersionAndHash(version, hash);
    }",Generate the verification string for the CapsVersionAndHash.
"private void showWindow(Window newWindow)
    {
        if (window != null)
        {
            window.remove(getGUIComponent());
            window.setVisible(false);
            window.dispose();
            window = null;
        }
        newWindow.add(getGUIComponent(), BorderLayout.CENTER);
        newWindow.pack();
        newWindow.setVisible(true);
        this.window = newWindow;
    }",Show the window.
"@Override
	public void initialize() {
		/*
		 * Two resource providers are defined. Each one handles a specific
		 * type of resource.
		 */
		List<IResourceProvider> providers = new ArrayList<>();
		providers.add(new PatientResourceProvider());
		providers.add(new OrganizationResourceProvider());
		setResourceProviders(providers);
		
		/*
		 * Use a narrative generator. This is a completely optional step, 
		 * but can be useful as it causes HAPI to generate narratives for
		 * resources which don't otherwise have one.
		 */
		INarrativeGenerator narrativeGen = new DefaultThymeleafNarrativeGenerator();
		getFhirContext().setNarrativeGenerator(narrativeGen);

		/*
		 * Enable CORS
		 */
		CorsConfiguration config = new CorsConfiguration();
		CorsInterceptor corsInterceptor = new CorsInterceptor(config);
		config.addAllowedHeader(""Accept"");
		config.addAllowedHeader(""Content-Type"");
		config.addAllowedOrigin(""*"");
		config.addExposedHeader(""Location"");
		config.addExposedHeader(""Content-Location"");
		config.setAllowedMethods(Arrays.asList(""GET"",""POST"",""PUT"",""DELETE"",""OPTIONS""));
		registerInterceptor(corsInterceptor);

		/*
		 * This server interceptor causes the server to return nicely
		 * formatter and coloured responses instead of plain JSON/XML if
		 * the request is coming from a browser window. It is optional,
		 * but can be nice for testing.
		 */
		registerInterceptor(new ResponseHighlighterInterceptor());
		
		/*
		 * Tells the server to return pretty-printed responses by default
		 */
		setDefaultPrettyPrint(true);
		
	}",Initializes the service.
"public void fieldToData(ComponentCache componentCache, int iRowIndex, int iColumnIndex)
    {
        if (componentCache.m_rgcompoments[iColumnIndex] != null)
        {
            Object object = this.getModel().getValueAt(iRowIndex, iColumnIndex);
            String string = """";
            if (object != null)
                string = object.toString();
            if (componentCache.m_rgcompoments[iColumnIndex] instanceof JTextComponent)
                ((JTextComponent)componentCache.m_rgcompoments[iColumnIndex]).setText(string);
            else if (componentCache.m_rgcompoments[iColumnIndex] instanceof JCheckBox)
            {
                boolean bIsSelected = false;
                if (string != null) if (string.equals(""1""))
                    bIsSelected = true;
                ((JCheckBox)componentCache.m_rgcompoments[iColumnIndex]).setSelected(bIsSelected);
            }
        }
    }",This method is called to convert this field to the data.
"@EventListener
    public void handleRegisteredServiceExpiredEvent(final CasRegisteredServiceExpiredEvent event) {
        val registeredService = event.getRegisteredService();
        val contacts = registeredService.getContacts();

        val mail = casProperties.getServiceRegistry().getMail();
        val sms = casProperties.getServiceRegistry().getSms();

        val serviceName = StringUtils.defaultIfBlank(registeredService.getName(), registeredService.getServiceId());
        if (communicationsManager.isMailSenderDefined()) {
            val message = mail.getFormattedBody(serviceName);
            contacts
                .stream()
                .filter(c -> StringUtils.isNotBlank(c.getEmail()))
                .forEach(c -> communicationsManager.email(mail, c.getEmail(), message));
        }
        if (communicationsManager.isSmsSenderDefined()) {
            val message = String.format(sms.getText(), serviceName);
            contacts
                .stream()
                .filter(c -> StringUtils.isNotBlank(c.getPhone()))
                .forEach(c -> communicationsManager.sms(sms.getFrom(), c.getPhone(), message));
        }

        servicesManager.load();
    }",Handle registered service expired event.
"public List<CmsAccessControlEntry> getAccessControlEntries(
        CmsDbContext dbc,
        CmsResource resource,
        boolean getInherited)
    throws CmsException {

        // get the ACE of the resource itself
        I_CmsUserDriver userDriver = getUserDriver(dbc);
        I_CmsVfsDriver vfsDriver = getVfsDriver(dbc);
        List<CmsAccessControlEntry> ace = userDriver.readAccessControlEntries(
            dbc,
            dbc.currentProject(),
            resource.getResourceId(),
            false);

        // sort and check if we got the 'overwrite all' ace to stop looking up
        boolean overwriteAll = sortAceList(ace);

        // get the ACE of each parent folder
        // Note: for the immediate parent, get non-inherited access control entries too,
        // if the resource is not a folder
        String parentPath = CmsResource.getParentFolder(resource.getRootPath());
        int d = (resource.isFolder()) ? 1 : 0;

        while (!overwriteAll && getInherited && (parentPath != null)) {
            resource = vfsDriver.readFolder(dbc, dbc.currentProject().getUuid(), parentPath);
            List<CmsAccessControlEntry> entries = userDriver.readAccessControlEntries(
                dbc,
                dbc.currentProject(),
                resource.getResourceId(),
                d > 0);

            // sort and check if we got the 'overwrite all' ace to stop looking up
            overwriteAll = sortAceList(entries);

            for (CmsAccessControlEntry e : entries) {
                e.setFlags(CmsAccessControlEntry.ACCESS_FLAGS_INHERITED);
            }

            ace.addAll(entries);
            parentPath = CmsResource.getParentFolder(resource.getRootPath());
            d++;
        }

        return ace;
    }",Returns the ACEs of the given resource.
"public Release rollback(String appName, String releaseUuid) {
        return connection.execute(new Rollback(appName, releaseUuid), apiKey);
    }",Rollback a release.
"public synchronized void suspendReceives() {
        receivesSuspended = true;
        if (receiver == null) {
            if(Thread.currentThread() == channel.getIoThread()) {
                channel.getSourceChannel().suspendReads();
            } else {
                channel.getIoThread().execute(new Runnable() {
                    @Override
                    public void run() {
                        channel.getSourceChannel().suspendReads();
                    }
                });
            }
        }
    }",Suspend the receipts.
"public static Node getClosestExistingAncestor(final Session session, final String path)
            throws RepositoryException {

        String potentialPath = path.startsWith(""/"") ? path : ""/"" + path;
        while (!potentialPath.isEmpty()) {
            if (session.nodeExists(potentialPath)) {
                return session.getNode(potentialPath);
            }
            potentialPath = potentialPath.substring(0, potentialPath.lastIndexOf('/'));
        }
        return session.getRootNode();
    }",Gets the closest existing ancestor node.
"public static boolean artifactIsNotExcluded(Collection<Exclusion> exclusions, Artifact artifact) {
        return Optional.ofNullable(exclusions).orElse(Collections.emptyList())
                .stream().noneMatch(selectedExclusion ->
                        null != artifact && selectedExclusion.getGroupId().equals(artifact.getGroupId()) &&
                                (selectedExclusion.getArtifactId().equals(artifact.getArtifactId()) || (selectedExclusion.getArtifactId().equals(ARTIFACT_STAR)))
                );
    }",Check if an artifact is excluded from the list of exclusions.
"public Content getResource(String key, Object o) {
        return configuration.getResource(key, o);
    }",Get a resource from the configuration.
"public void purchaseReservedVolume(String volumeId, int reservationLength, String reservationTimeUnit) {
        this.purchaseReservedVolume(new PurchaseReservedVolumeRequest()
                .withVolumeId(volumeId)
                .withBilling(new Billing().withReservation(new Reservation()
                        .withReservationLength(reservationLength)
                        .withReservationTimeUnit(reservationTimeUnit))));
    }",Purchase a reserved volume.
"public void setChangedNodes( Set<NodeKey> keys ) {
        if (keys != null) {
            this.nodeKeys = Collections.unmodifiableSet(new HashSet<NodeKey>(keys));
        }
    }",Sets the changed nodes.
"private void validateQuery(String query) throws URISyntaxException
  {
    if(query.length() == 0)
      return;

    Iterator<String> iter = SS.splitToIterator(query);

    while(iter.hasNext())
    {
      String s = iter.next();
      if(s.length() > 0)
      {
        int idx = s.indexOf('=');
        if(idx == -1)
          throw new URISyntaxException(query, ""missing equal sign in "" + s);
        if(s.lastIndexOf('=') != idx)
          throw new URISyntaxException(query, ""extra equal sign in "" + s);
      }
    }
  }",Validate the query.
"static String decryptMessageElement(OmemoElement element, CipherAndAuthTag cipherAndAuthTag)
            throws CryptoFailedException {
        if (!element.isMessageElement()) {
            throw new IllegalArgumentException(""decryptMessageElement cannot decrypt OmemoElement which is no MessageElement!"");
        }

        if (cipherAndAuthTag.getAuthTag() == null || cipherAndAuthTag.getAuthTag().length != 16) {
            throw new CryptoFailedException(""AuthenticationTag is null or has wrong length: ""
                    + (cipherAndAuthTag.getAuthTag() == null ? ""null"" : cipherAndAuthTag.getAuthTag().length));
        }

        byte[] encryptedBody = payloadAndAuthTag(element, cipherAndAuthTag.getAuthTag());

        try {
            String plaintext = new String(cipherAndAuthTag.getCipher().doFinal(encryptedBody), StringUtils.UTF8);
            return plaintext;

        } catch (UnsupportedEncodingException | IllegalBlockSizeException | BadPaddingException e) {
            throw new CryptoFailedException(""decryptMessageElement could not decipher message body: ""
                    + e.getMessage());
        }
    }",Decrypt a message element.
"private void closeRenameTmp2BaseFile()
    {
        try
        {
            this.currentWriter.close();
        }
        catch (IOException ex)
        {
            String logFormat = ""Failed to HDFS file close. Continue file switch. : TargetUri={0}"";
            String logMessage = MessageFormat.format(logFormat, this.currentOutputUri
                    + this.currentSuffix);
            logger.warn(logMessage, ex);
        }

        boolean isFileExists = true;

        try
        {
            isFileExists = this.fileSystem.exists(new Path(this.currentOutputUri));
        }
        catch (IOException ioex)
        {
            String logFormat = ""Failed to search target file exists. Skip file rename. : TargetUri={0}"";
            String logMessage = MessageFormat.format(logFormat, this.currentOutputUri);
            logger.warn(logMessage, ioex);
            return;
        }

        if (isFileExists)
        {
            String logFormat = ""File exists renamed target. Skip file rename. : BeforeUri={0} , AfterUri={1}"";
            String logMessage = MessageFormat.format(logFormat, this.currentOutputUri
                    + this.currentSuffix, this.currentOutputUri);
            logger.warn(logMessage);
        }
        else
        {
            try
            {
                this.fileSystem.rename(new Path(this.currentOutputUri + this.currentSuffix),
                        new Path(this.currentOutputUri));
            }
            catch (IOException ex)
            {
                String logFormat = ""Failed to HDFS file rename. Skip rename file. : BeforeUri={0} , AfterUri={1}"";
                String logMessage = MessageFormat.format(logFormat, this.currentOutputUri
                        + this.currentSuffix, this.currentOutputUri);
                logger.warn(logMessage, ex);
            }
        }

    }",Close rename the temp file.
"public static Link create(final String text, final TextStyle ts, final NamedObject table) {
		return new Link(text, ts, '#'+table.getName());
	}",Create a link with a text style and a table.
"public int toInt()
	{
		int day = ((year + 1900) * 12 + month) * 31 + (date - 1);

		if( day < TIME_BEGIN )
			day = TIME_BEGIN;
		else if( day > TIME_END )
			day = TIME_END;

		return day;
	}",toInt - Convert to a day of the month.
"private void init(Context context, AttributeSet attrs){
        setOnSeekBarChangeListener(new SeekBar.OnSeekBarChangeListener() {
            @Override
            public void onStartTrackingTouch(SeekBar seekBar) {
                superOldProgress = seekBar.getProgress();
            }

            @Override
            public void onProgressChanged(SeekBar seekBar, int progress, boolean fromUser) {
                if(fromUser)
                    fromUserCount+=1;
            }

            @Override
            public void onStopTrackingTouch(final SeekBar seekBar) {
                int oldProgress = seekBar.getProgress();
                final int newProgress;
                if((oldProgress % stepSize) >= stepSize/2F){
                    newProgress = (int)(((oldProgress/(int)stepSize)+1)*stepSize);
                } else {
                    newProgress = (int)(((oldProgress/(int)stepSize))*stepSize);
                }

                if(fromUserCount>1){ // SeekBar Dragged
                    ObjectAnimator animation = ObjectAnimator.ofInt(seekBar, PROGRESS_PROPERTY, oldProgress, newProgress);
                    animation.setDuration(getResources().getInteger(android.R.integer.config_mediumAnimTime));
                    animation.setInterpolator(new DecelerateInterpolator());
                    animation.start();
                } else { // SeekBar Clicked
                    ObjectAnimator animation = ObjectAnimator.ofInt(seekBar, PROGRESS_PROPERTY, superOldProgress, newProgress);
                    animation.setDuration(getResources().getInteger(android.R.integer.config_mediumAnimTime));
                    animation.setInterpolator(new DecelerateInterpolator());
                    animation.start();
                }

                fromUserCount = 0;
                if(onDiscreteSeekBarChangeListener != null){
                    onDiscreteSeekBarChangeListener.onPositionChanged(newProgress/MULTIPLIER);
                }
            }
        });
    }",Initialize the calendar.
"public static final List<Integer> getEQRAlignmentPos(AFPChain afpChain){
		List<Integer> lst = new ArrayList<Integer>();

		char[] s1 = afpChain.getAlnseq1();
		char[] s2 = afpChain.getAlnseq2();
		char[] symb = afpChain.getAlnsymb();
		boolean isFatCat = afpChain.getAlgorithmName().startsWith(""jFatCat"");

		for ( int i =0 ; i< s1.length; i++){
			char c1 = s1[i];
			char c2 = s2[i];

			if ( isAlignedPosition(i,c1,c2,isFatCat, symb)) {
				lst.add(i);
			}

		}
		return lst;

	}",Get the EQR alignment position of the alignment
"private String nameWithoutTrailingSeparator(Path file) {
    String fileName = file.getFileName().toString();
    int trailingSlash = fileName.indexOf('/');
    if (trailingSlash != -1) {
      fileName = fileName.substring(0, trailingSlash);
    }
    return fileName;
  }",Returns the name without the trailing separator
"public InternalRunner createStrictStubs(Class<?> klass) throws InvocationTargetException {
        return create(klass, new Supplier<MockitoTestListener>() {
            public MockitoTestListener get() {
                return new StrictStubsRunnerTestListener();
            }
        });
    }",Creates strict stubs for the specified class.
"@Bean
    public ClientHttpConnector clientHttpConnector(
            List<ArmeriaClientConfigurator> customizer,
            DataBufferFactoryWrapper<?> factoryWrapper) {
        return new ArmeriaClientHttpConnector(customizer, factoryWrapper);
    }",ClientHttpConnector bean.
"@CheckReturnValue
    @NonNull
    public final <C> ParallelFlowable<C> collect(@NonNull Callable<? extends C> collectionSupplier, @NonNull BiConsumer<? super C, ? super T> collector) {
        ObjectHelper.requireNonNull(collectionSupplier, ""collectionSupplier is null"");
        ObjectHelper.requireNonNull(collector, ""collector is null"");
        return RxJavaPlugins.onAssembly(new ParallelCollect<T, C>(this, collectionSupplier, collector));
    }",Creates a parallel stream that collects the items of this sequence using the specified collection supplier and collector.
"public ActionString getUserDataString(String value) {
        if (value == null) {
            return null;
        }
        ActionString output = null;
        if (mapAllMethods != null) {
            // handle all methods case.
            output = getUserDataStringFromAllMap(mapAllMethods, value);
        } else {
            output = getUserDataStringFromMethodsMap(value);
        }
        if (tc.isDebugEnabled())
            Tr.debug(tc, ""getUserDataString output: "" + output);
        return output;
    }",Get the user data string from the value.
"public void marshall(AdditionalLimit additionalLimit, ProtocolMarshaller protocolMarshaller) {

        if (additionalLimit == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(additionalLimit.getLimitName(), LIMITNAME_BINDING);
            protocolMarshaller.marshall(additionalLimit.getLimitValues(), LIMITVALUES_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the additionalLimit object to the JSON object.
"private Template getTemplate(final WComponent component) {
		String templateUrl = url;

		if (templateUrl == null && component instanceof AbstractWComponent) {
			templateUrl = ((AbstractWComponent) component).getTemplate();
		}

		if (templateUrl != null) {
			try {
				return VelocityEngineFactory.getVelocityEngine().getTemplate(templateUrl);
			} catch (Exception ex) {
				// If the resource is not available (eg if the template does not
				// exist), paint using a default layout and inform the user
				// of what's going on in the html comments.
				LOG.warn(""Could not open "" + templateUrl, ex);

				try {
					return VelocityEngineFactory.getVelocityEngine().getTemplate(NO_TEMPLATE_LAYOUT);
				} catch (Exception e) {
					LOG.error(""Failed to read no template layout"", e);
				}
			}
		}

		return null;
	}",Gets the template for the given component.
"public static Callable<Object> callable(final PrivilegedAction<?> action) {
        if (action == null)
            throw new NullPointerException();
        return new Callable<Object>() {
            public Object call() { return action.run(); }};
    }",A callable that is a wrapper around the given action.
"public void marshall(UpdateJobQueueRequest updateJobQueueRequest, ProtocolMarshaller protocolMarshaller) {

        if (updateJobQueueRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(updateJobQueueRequest.getJobQueue(), JOBQUEUE_BINDING);
            protocolMarshaller.marshall(updateJobQueueRequest.getState(), STATE_BINDING);
            protocolMarshaller.marshall(updateJobQueueRequest.getPriority(), PRIORITY_BINDING);
            protocolMarshaller.marshall(updateJobQueueRequest.getComputeEnvironmentOrder(), COMPUTEENVIRONMENTORDER_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given updateJobQueueRequest to the JSON object.
"protected VirtualConnection writeInternal(long numBytes, TCPWriteCompletedCallback writeCallback, boolean forceQueue, int time) {
        int timeout = time;
        if (timeout == IMMED_TIMEOUT) {
            immediateTimeout();
            return null;
        } else if (timeout == ABORT_TIMEOUT) {
            abort();
            immediateTimeout();
            return null;
        }

        // if using channel timeout, reset to that value
        if (timeout == TCPRequestContext.USE_CHANNEL_TIMEOUT) {
            timeout = getConfig().getInactivityTimeout();
        }
        setIOAmount(numBytes);
        setLastIOAmt(0);
        setIODoneAmount(0);
        setWriteCompletedCallback(writeCallback);
        setForceQueue(forceQueue);
        setTimeoutTime(timeout);

        return processAsyncWriteRequest();
    }",Write the data to the server.
"public static void borderTable(XWPFTable table, int size) {
        CTTblPr tblPr = getTblPr(table);
        CTTblBorders tblBorders = tblPr.getTblBorders();
        BigInteger borderSize = BigInteger.valueOf(size);
        tblBorders.getBottom().setSz(borderSize);
        tblBorders.getLeft().setSz(borderSize);
        tblBorders.getTop().setSz(borderSize);
        tblBorders.getRight().setSz(borderSize);
        tblBorders.getInsideH().setSz(borderSize);
        tblBorders.getInsideV().setSz(borderSize);
    }",Sets the border size of a table.
"public InboundNatRuleInner beginCreateOrUpdate(String resourceGroupName, String loadBalancerName, String inboundNatRuleName, InboundNatRuleInner inboundNatRuleParameters) {
        return beginCreateOrUpdateWithServiceResponseAsync(resourceGroupName, loadBalancerName, inboundNatRuleName, inboundNatRuleParameters).toBlocking().single().body();
    }",Creates or updates an existing load balancer inbound nat rule.
"public static void initApplication(Application app){
		
		// Add the Jawr tag handler to the MarkupParserFactory 
		MarkupFactory factory = new MarkupFactory(){
			
			public MarkupParser newMarkupParser(final MarkupResourceStream resource)
		    {
		       MarkupParser parser = new MarkupParser(new XmlPullParser(), resource);
		       parser.add(new JawrWicketLinkTagHandler());
		       return parser;
		    }
		};
		
		app.getMarkupSettings().setMarkupFactory(factory);
		
		// Add the Jawr link resolver
		app.getPageSettings().addComponentResolver(new JawrWicketLinkResolver());
	}",Initialize the application
"public static Method getMethod(final Class<?> clazz, final String methodName, Class<?>... parameterTypes) {
		Method method = MethodUtils.getMatchingMethod(clazz, methodName, parameterTypes);
		if (method != null) {
			makeAccessible(method);
		}
		return method;
	}",Gets the method with the given name and parameter types.
"public static CompactHeightfield buildCompactHeightfield(Context ctx, int walkableHeight, int walkableClimb,
            Heightfield hf) {

        ctx.startTimer(""BUILD_COMPACTHEIGHTFIELD"");

        CompactHeightfield chf = new CompactHeightfield();
        int w = hf.width;
        int h = hf.height;
        int spanCount = getHeightFieldSpanCount(ctx, hf);

        // Fill in header.
        chf.width = w;
        chf.height = h;
        chf.spanCount = spanCount;
        chf.walkableHeight = walkableHeight;
        chf.walkableClimb = walkableClimb;
        chf.maxRegions = 0;
        copy(chf.bmin, hf.bmin);
        copy(chf.bmax, hf.bmax);
        chf.bmax[1] += walkableHeight * hf.ch;
        chf.cs = hf.cs;
        chf.ch = hf.ch;
        chf.cells = new CompactCell[w * h];
        chf.spans = new CompactSpan[spanCount];
        chf.areas = new int[spanCount];
        int MAX_HEIGHT = 0xffff;
        for (int i = 0; i < chf.cells.length; i++) {
            chf.cells[i] = new CompactCell();
        }
        for (int i = 0; i < chf.spans.length; i++) {
            chf.spans[i] = new CompactSpan();
        }
        // Fill in cells and spans.
        int idx = 0;
        for (int y = 0; y < h; ++y) {
            for (int x = 0; x < w; ++x) {
                Span s = hf.spans[x + y * w];
                // If there are no spans at this cell, just leave the data to index=0, count=0.
                if (s == null)
                    continue;
                CompactCell c = chf.cells[x + y * w];
                c.index = idx;
                c.count = 0;
                while (s != null) {
                    if (s.area != RC_NULL_AREA) {
                        int bot = s.smax;
                        int top = s.next != null ? (int) s.next.smin : MAX_HEIGHT;
                        chf.spans[idx].y = RecastCommon.clamp(bot, 0, 0xffff);
                        chf.spans[idx].h = RecastCommon.clamp(top - bot, 0, 0xff);
                        chf.areas[idx] = s.area;
                        idx++;
                        c.count++;
                    }
                    s = s.next;
                }
            }
        }

        // Find neighbour connections.
        int MAX_LAYERS = RC_NOT_CONNECTED - 1;
        int tooHighNeighbour = 0;
        for (int y = 0; y < h; ++y) {
            for (int x = 0; x < w; ++x) {
                CompactCell c = chf.cells[x + y * w];
                for (int i = c.index, ni = c.index + c.count; i < ni; ++i) {
                    CompactSpan s = chf.spans[i];

                    for (int dir = 0; dir < 4; ++dir) {
                        RecastCommon.SetCon(s, dir, RC_NOT_CONNECTED);
                        int nx = x + RecastCommon.GetDirOffsetX(dir);
                        int ny = y + RecastCommon.GetDirOffsetY(dir);
                        // First check that the neighbour cell is in bounds.
                        if (nx < 0 || ny < 0 || nx >= w || ny >= h)
                            continue;

                        // Iterate over all neighbour spans and check if any of the is
                        // accessible from current cell.
                        CompactCell nc = chf.cells[nx + ny * w];
                        for (int k = nc.index, nk = nc.index + nc.count; k < nk; ++k) {
                            CompactSpan ns = chf.spans[k];
                            int bot = Math.max(s.y, ns.y);
                            int top = Math.min(s.y + s.h, ns.y + ns.h);

                            // Check that the gap between the spans is walkable,
                            // and that the climb height between the gaps is not too high.
                            if ((top - bot) >= walkableHeight && Math.abs(ns.y - s.y) <= walkableClimb) {
                                // Mark direction as walkable.
                                int lidx = k - nc.index;
                                if (lidx < 0 || lidx > MAX_LAYERS) {
                                    tooHighNeighbour = Math.max(tooHighNeighbour, lidx);
                                    continue;
                                }
                                RecastCommon.SetCon(s, dir, lidx);
                                break;
                            }
                        }

                    }
                }
            }
        }

        if (tooHighNeighbour > MAX_LAYERS) {
            throw new RuntimeException(""rcBuildCompactHeightfield: Heightfield has too many layers "" + tooHighNeighbour
                    + "" (max: "" + MAX_LAYERS + "")"");
        }
        ctx.stopTimer(""BUILD_COMPACTHEIGHTFIELD"");
        return chf;
    }",Build CompactHeightfield.
"public static Object[] deepBox(Class<?> resultType, final Object src) {
        Class<?> compType = resultType.getComponentType();
        if (compType.isArray()) {
            final Object[] src2 = (Object[]) src;
            final Object[] result = (Object[]) newArray(compType, src2.length);
            for (int i = 0; i < src2.length; i++) {
                result[i] = deepBox(compType, src2[i]);
            }
            return result;
        } else {
            return boxAll(compType, src, 0, -1);
        }
    }",Deep box.
"public static String getTypeName(Type type) {
		if(type instanceof Class) {
			Class<?> clazz = (Class<?>) type;
			return clazz.isArray() ? (getTypeName(clazz.getComponentType()) + ""[]"") : clazz.getName();
		} else {
			return type.toString();
		}
	}",Get the type name.
"public int
    ddsparse(String text, DDS dds) throws ParseException
    {
        return dapparse(text, dds, null, null);
    }",Parse a sequence of DDSs from a string.
"public static Method getMethodFromTarget(JoinPoint joinPoint, String methodName) {
        return getDeclaredMethod(joinPoint.getTarget().getClass(), methodName,
                getParameterTypes(joinPoint));
    }",Get Method from target Class and method name
"public static <V> Map<SNode, V> createSNodeMapFromIDs(Map<String, V> map,
    SDocumentGraph graph)
  {
    HashMap<SNode, V> result = new LinkedHashMap<>();

    if (map != null && graph != null)
    {
      for (Map.Entry<String, V> e : map.entrySet())
      {
        SNode n = graph.getNode(e.getKey());
        if (n != null)
        {
          result.put(n, e.getValue());
        }
      }
    }

    return result;
  }",Create a Map of SNode objects from a Map of SNode IDs and a SDocumentGraph.
"public static void isValidXpath(String locator) {
        logger.entering(locator);
        Preconditions.checkArgument(StringUtils.isNotBlank(locator), INVALID_LOCATOR_ERR_MSG);
        if (locator.startsWith(""xpath=/"") || locator.startsWith(""/"")) {
            throw new UnsupportedOperationException(
                    ""Use xpath dot notation to search for Container descendant elements. Example: \"".//myLocator\"". "");
        }
        logger.exiting();
    }",Validate that the locator string is a valid XPath.
"public Variant merge(Variant current, Collection<Variant> load) {
        isValidVariant(current);
        // Build alt list
        List<Pair<Variant, List<AlternateCoordinate>>> loadAlts =
                updateCollapseDeletions(current,
                        load.stream()
                                .map(v -> new MutablePair<>(v, buildAltList(v)))
                                .filter(p -> hasAnyOverlap(current, p.getLeft(), p.getRight()))
                ).collect(Collectors.toList());

        mergeVariants(current, loadAlts);
        return current;
    }",Merge a collection of variants into a single variant.
"protected static Action findAction(EObject grammarComponent, String assignmentName) {
		for (final Action action : GrammarUtil.containedActions(grammarComponent)) {
			if (GrammarUtil.isAssignedAction(action)) {
				if (Objects.equals(assignmentName, action.getFeature())) {
					return action;
				}
			}
		}
		return null;
	}",Replies the action for the given name.
"public static MchOrderInfoResult payPaporderquery(MchOrderquery mchOrderquery,String key){
		Map<String,String> map = MapUtil.objectToMap(mchOrderquery);
		String sign = SignatureUtil.generateSign(map,mchOrderquery.getSign_type(),key);
		mchOrderquery.setSign(sign);
		String closeorderXML = XMLConverUtil.convertToXML(mchOrderquery);
		HttpUriRequest httpUriRequest = RequestBuilder.post()
				.setHeader(xmlHeader)
				.setUri(baseURI()+ ""/pay/paporderquery"")
				.setEntity(new StringEntity(closeorderXML,Charset.forName(""utf-8"")))
				.build();
		return LocalHttpClient.executeXmlResult(httpUriRequest,MchOrderInfoResult.class,mchOrderquery.getSign_type(),key);
	}",Pay a pay order query
"private boolean checkEDBObjectModelType(EDBObject object, Class<?> model) {
        String modelClass = object.getString(EDBConstants.MODEL_TYPE);
        if (modelClass == null) {
            LOGGER.warn(String.format(""The EDBObject with the oid %s has no model type information.""
                    + ""The resulting model may be a different model type than expected."", object.getOID()));
        }
        if (modelClass != null && !modelClass.equals(model.getName())) {
            return false;
        }
        return true;
    }",Check the EDBObject model type.
"public void setItem(java.util.Collection<ExportJobResponse> item) {
        if (item == null) {
            this.item = null;
            return;
        }

        this.item = new java.util.ArrayList<ExportJobResponse>(item);
    }",Sets the value of the item property.
"@Override
    public void start(final Future<Void> startedResult) throws Exception {
        this.start();

        jerseyServer.start(ar -> {
            if (ar.succeeded()) {
                startedResult.complete();
            } else {
                startedResult.fail(ar.cause());
            }
        });

    }",Start the application.
"public void toFollower(int term) {
        role = RaftRole.FOLLOWER;
        leader = null;
        preCandidateState = null;
        leaderState = null;
        candidateState = null;
        this.term = term;
    }",Sets the following attributes of this object to be the following of the given term.
"public static Method getValueOfStringMethod(Class<?> clazz) {
		//System.err.println(""clazz=""+clazz);
		Method existing = valueOfStringMethods.get(clazz);
		if(existing==null) {
			Method newMethod;
			try {
				newMethod = clazz.getMethod(""valueOf"", String.class);
				int mod = newMethod.getModifiers();
				if(!Modifier.isStatic(mod) || !Modifier.isPublic(mod)) newMethod = notExists;
			} catch(NoSuchMethodException err) {
				newMethod = notExists;
			}
			existing = valueOfStringMethods.put(clazz, newMethod);
			if(existing==null) existing = newMethod;
		}
		return existing==notExists ? null : existing;
	}",Get the value of String method.
"private void mergerByScore(Term fromTerm, int to, boolean asc) {
		Term term = null;
		if (terms[to] != null) {
			term = terms[to];
			while (term != null) {
				// 关系式to.set(from)
				term.setPathSelfScore(fromTerm, asc);
				term = term.next();
			}
		}

	}",mergerByScore Method.
"public void validate(final String data)
      throws CssLintException {
    final StopWatch watch = new StopWatch();
    watch.start(""init"");
    final RhinoScriptBuilder builder = initScriptBuilder();
    watch.stop();
    watch.start(""cssLint"");
    LOG.debug(""options: {}"", this.options);
    final String script = buildCssLintScript(WroUtil.toJSMultiLineString(data));
    LOG.debug(""script: {}"", script);
    builder.evaluate(script, ""CSSLint.verify"").toString();
    final boolean valid = Boolean.parseBoolean(builder.evaluate(""result.length == 0"", ""checkNoErrors"").toString());
    if (!valid) {
      final String json = builder.addJSON().evaluate(""JSON.stringify(result)"", ""CssLint messages"").toString();
      LOG.debug(""json {}"", json);
      final Type type = new TypeToken<List<CssLintError>>() {}.getType();
      final List<CssLintError> errors = new Gson().fromJson(json, type);
      LOG.debug(""Errors: {}"", errors);
      throw new CssLintException().setErrors(errors);
    }
    LOG.debug(""isValid: {}"", valid);
    watch.stop();
    LOG.debug(watch.prettyPrint());
  }",Validate the CSS file.
"@Override
	public Object invoke(Object proxy, Method meth, Object[] args) throws Throwable {
		for (int i = 0; i<this.tries; i++) {
			try {
				return meth.invoke(this.raw, args);
			} catch (InvocationTargetException ex) {
				if (i == (this.tries - 1))
					log.error(""Memcache operation failed, giving up"", ex);
				else
					log.warn(""Error performing memcache operation, retrying: "" + meth, ex);
			}
		}
		
		// Will reach this point when we have exhausted our retries.
		return null;
	}",Override this method to perform a memcached operation.
"Rule xyDescriptor() {
        return NodeSequence(
                xyType(),
                push(new XYNode()),
                ZeroOrMore(Sequence(xyElement(), Newline()))
        );
    }",A XY descriptor.
"public static Object getFieldValue(final Field field, final Object instance) throws CoreRuntimeException {
        Object value = null;
        try {
            // store current visibility
            final boolean accessible = field.isAccessible();

            // let it accessible anyway
            field.setAccessible(true);

            // Call this method with right parameters
            value = field.get(instance);

            // Reset default visibility
            field.setAccessible(accessible);

        } catch (IllegalAccessException | IllegalArgumentException e) {
            throw new CoreRuntimeException(e);
        }
        return value;
    }",Get the value of a field from an object.
"public final void setIcon(@NonNull final Context context, @DrawableRes final int resourceId) {
        Condition.INSTANCE.ensureNotNull(context, ""The context may not be null"");
        this.icon = ContextCompat.getDrawable(context, resourceId);
    }",Sets the icon of the application.
"public static Query toQuery(Object o, Query defaultValue) {
	if (o instanceof Query) return (Query) o;
	else if (o instanceof ObjectWrap) {
	    return toQuery(((ObjectWrap) o).getEmbededObject(defaultValue), defaultValue);
	}
	return defaultValue;
    }",Converts an Object to a Query.
"protected void activate(ComponentContext context, Map<String, Object> properties) {
        final boolean trace = TraceComponent.isAnyTracingEnabled();
        if (trace && tc.isEntryEnabled())
            Tr.entry(this, tc, ""activate"", properties);

        bndCtx = priv.getBundleContext(context);

        // config.displayId contains the Xpath identifier.
        name = (String) properties.get(""config.displayId"");

        lock.writeLock().lock();
        try {
            this.properties = properties;
        } finally {
            lock.writeLock().unlock();
        }

        if (""file"".equals(properties.get(""config.source""))) {
            if (name.startsWith(""#APP-RESOURCE#"")) // avoid conflicts with app-defined data sources
                throw new IllegalArgumentException(ConnectorService.getMessage(""UNSUPPORTED_VALUE_J2CA8011"", name, ID, CONNECTION_MANAGER));
        }
        if (trace && tc.isEntryEnabled())
            Tr.exit(this, tc, ""activate"");
    }",This method is called by the component to activate the component.
"private void joinSynchronization()
      throws IOException, TimeoutException, InterruptedException {
    Message sync = MessageBuilder.buildSyncHistory(persistence.getLatestZxid());
    sendMessage(this.electedLeader, sync);
    MessageTuple tuple =
      filter.getExpectedMessage(MessageType.SYNC_HISTORY_REPLY, electedLeader,
                                config.getTimeoutMs());
    Message msg = tuple.getMessage();
    // Updates the sync timeout based on leader's suggestion.
    setSyncTimeoutMs(msg.getSyncHistoryReply().getSyncTimeout());
    // Waits for the first synchronization completes.
    waitForSync(this.electedLeader);

    // Gets the last zxid in disk after first synchronization.
    Zxid lastZxid = persistence.getLatestZxid();
    LOG.debug(""After first synchronization, the last zxid is {}"", lastZxid);
    // Then issues the JOIN message.
    Message join = MessageBuilder.buildJoin(lastZxid);
    sendMessage(this.electedLeader, join);

    /* -- Synchronizing phase -- */
    changePhase(Phase.SYNCHRONIZING);
    waitForSync(this.electedLeader);
    waitForNewLeaderMessage();
    waitForCommitMessage();
    persistence.setProposedEpoch(persistence.getAckEpoch());
  }",Joins the synchronization phase.
"public void marshall(FindingStatistics findingStatistics, ProtocolMarshaller protocolMarshaller) {

        if (findingStatistics == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(findingStatistics.getCountBySeverity(), COUNTBYSEVERITY_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given findingStatistics to the JSON object.
"private static void initStringDefinedHandler(String handler) {
		// split the class name and its label, if defined
		Tuple<String, Class> namedClass = splitClassAndName(handler);

		// create an instance of the handler
		Object handlerOrProviderObject = null;
		try {
			handlerOrProviderObject = namedClass.second.newInstance();
		} catch (Exception e) {
			logger.error(""Exception:"", e);
			throw new RuntimeException(""Could not instantiate handler class: "" + namedClass.second);
		}

		HttpHandler resolvedHandler;
		if (handlerOrProviderObject instanceof HttpHandler) {
			resolvedHandler = (HttpHandler) handlerOrProviderObject;
		} else if (handlerOrProviderObject instanceof HandlerProvider) {
			resolvedHandler = ((HandlerProvider) handlerOrProviderObject).getHandler();
		} else {
			throw new RuntimeException(""Unsupported type of handler provided: "" + handlerOrProviderObject);
		}
		registerMiddlewareHandler(resolvedHandler);
		handlers.put(namedClass.first, resolvedHandler);
		handlerListById.put(namedClass.first, Collections.singletonList(resolvedHandler));
	}",Initialize the string defined handler.
"@Override
    public Iterable<Tag> httpLongRequestTags(@Nullable HttpServletRequest request, @Nullable Object handler) {
        return Arrays.asList(WebMvcTags.method(request), WebMvcTags.uri(request, null));
    }",Returns the tag list for the HTTP long request.
"public Histogram histogram(int[] data, Color color) {
        return histogram((String) null, data, color);
    }",Create a histogram from a set of integer data.
"public Condition<S, D> and(Condition<S, D> condition) {
    Assert.notNull(condition, ""condition"");
    return Conditions.and(this, condition);
  }",Creates an AND condition from this condition and the given condition.
"public final void deleteKnowledgeBase(String name) {

    DeleteKnowledgeBaseRequest request =
        DeleteKnowledgeBaseRequest.newBuilder().setName(name).build();
    deleteKnowledgeBase(request);
  }",Delete a knowledge base.
"@Implementation
  protected static void createSystemAssetsInZygoteLocked() {
    _AssetManager28_ _assetManagerStatic_ = reflector(_AssetManager28_.class);
    AssetManager sSystem = _assetManagerStatic_.getSystem();
    if (sSystem != null) {
      return;
    }

    if (systemCppAssetManager2 == null) {
      // first time! let the framework create a CppAssetManager2 and an AssetManager, which we'll
      // hang on to.
      directlyOn(AssetManager.class, ""createSystemAssetsInZygoteLocked"");
      cachedSystemApkAssets = _assetManagerStatic_.getSystemApkAssets();
      cachedSystemApkAssetsSet = _assetManagerStatic_.getSystemApkAssetsSet();
    } else {
      // reuse the shared system CppAssetManager2; create a new AssetManager around it.
      _assetManagerStatic_.setSystemApkAssets(cachedSystemApkAssets);
      _assetManagerStatic_.setSystemApkAssetsSet(cachedSystemApkAssetsSet);

      sSystem = ReflectionHelpers.callConstructor(AssetManager.class,
          ClassParameter.from(boolean.class, true /*sentinel*/));
      sSystem.setApkAssets(cachedSystemApkAssets, false /*invalidateCaches*/);
      ReflectionHelpers.setStaticField(AssetManager.class, ""sSystem"", sSystem);
    }
  }",Create the system assets in the zygote.
"public Instances samoaInstances(weka.core.Instances instances) {
        Instances samoaInstances = samoaInstancesInformation(instances);
        //We assume that we have only one samoaInstanceInformation for WekaToSamoaInstanceConverter
        this.samoaInstanceInformation = samoaInstances;
        for (int i = 0; i < instances.numInstances(); i++) {
            samoaInstances.add(samoaInstance(instances.instance(i)));
        }
        return samoaInstances;
    }",Samoa instances.
"public static int floorDiv (int dividend, int divisor)
    {
        return ((dividend >= 0) == (divisor >= 0)) ?
            dividend / divisor : (divisor >= 0 ?
                    (dividend - divisor + 1) / divisor : (dividend - divisor - 1) / divisor);
    }",FloorDiv Method.
"@Override
    public boolean hasNext() {

        if (next == null) {

            while (next == null && !edgeIteratorStack.isEmpty()) {
                Iterator edgeIterator = (Iterator) edgeIteratorStack.peek();
                Object currentVertex = vertexStack.peek();

                //logger.debug(currentVertex);

                if (edgeIterator.hasNext()) {
                    Edge edge = (Edge) edgeIterator.next();
                    currentVertex = edge.oppositeVertex(currentVertex);
                    edgeIterator = shortestPathGraph.outgoingEdgesOf(currentVertex).iterator();

                    edgeIteratorStack.push(edgeIterator);
                    vertexStack.push(currentVertex);

                } else {
                    if (currentVertex == targetVertex) {
                        next = edgeList(g, vertexStack);
                    }
                    edgeIteratorStack.pop();
                    vertexStack.pop();
                }

            }

        }

        return (next != null);

    }",Returns true if there is at least one entry in the graph.
"public Object read(MessageBodyReaderContext context) throws IOException, WebApplicationException {

        Object encoding = context.getHeaders().getFirst(HttpHeaders.CONTENT_ENCODING);
        if (encoding != null && encoding.toString().equalsIgnoreCase(""lzf"")) {
            InputStream old = context.getInputStream();
            LZFInputStream is = new LZFInputStream(old);
            context.setInputStream(is);
            try {
                return context.proceed();
            } finally{
                context.setInputStream(old);
            }
        } else {
            return context.proceed();
        }
    }",read a single instance of a class from the message body reader context
"public static double[] createBoundingBox(double[] coordinates) {
        int maxActualCoords = Math.min(coordinates.length,3);// ignore potential M values, so 4 dimension (X Y Z M) becomes X Y Z
        double[] result = new double[maxActualCoords * 2];
        for (int i = 0; i < maxActualCoords; i++) {
            result[i] = coordinates[i];
            result[maxActualCoords + i] = coordinates[i];
        }
        return result;
    }",Create the bounding box of the given coordinates.
"synchronized public int getDTMIdentity(DTM dtm)
  {
	// Shortcut using DTMDefaultBase's extension hooks
	// %REVIEW% Should the lookup be part of the basic DTM API?
	if(dtm instanceof DTMDefaultBase)
	{
		DTMDefaultBase dtmdb=(DTMDefaultBase)dtm;
		if(dtmdb.getManager()==this)
			return dtmdb.getDTMIDs().elementAt(0);
		else
			return -1;
	}
				
    int n = m_dtms.length;

    for (int i = 0; i < n; i++)
    {
      DTM tdtm = m_dtms[i];

      if (tdtm == dtm && m_dtm_offsets[i]==0)
        return i << IDENT_DTM_NODE_BITS;
    }

    return -1;
  }",Get the identity of the DTM.
"@Override
	public void accept(final TransformContext transformContext) {
		int size = getChildSize();
		for (int i = 0; i < size; i++) {
			getChild(i).accept(transformContext);
		}
		pass();
	}",Override accept to accept the child elements.
"private List<Content> rewriteAnchor(Element element) {

    // detect empty anchor elements and insert at least an empty string to avoid ""self-closing"" elements
    // that are not handled correctly by most browsers
    if (element.getContent().isEmpty()) {
      element.setText("""");
    }

    // resolve link metadata from DOM element
    Link link = getAnchorLink(element);

    // build anchor for link metadata
    Element anchorElement = buildAnchorElement(link, element);

    // Replace anchor tag or remove anchor tag if invalid - add any sub-content in every case
    List<Content> content = new ArrayList<Content>();
    if (anchorElement != null) {
      anchorElement.addContent(element.cloneContent());
      content.add(anchorElement);
    }
    else {
      content.addAll(element.getContent());
    }
    return content;
  }",Rewrite anchor element.
"static FormattingTuple arrayFormat(final String messagePattern,
                                       final Object[] argArray) {
        if (argArray == null || argArray.length == 0) {
            return new FormattingTuple(messagePattern, null);
        }

        int lastArrIdx = argArray.length - 1;
        Object lastEntry = argArray[lastArrIdx];
        Throwable throwable = lastEntry instanceof Throwable? (Throwable) lastEntry : null;

        if (messagePattern == null) {
            return new FormattingTuple(null, throwable);
        }

        int j = messagePattern.indexOf(DELIM_STR);
        if (j == -1) {
            // this is a simple string
            return new FormattingTuple(messagePattern, throwable);
        }

        StringBuilder sbuf = new StringBuilder(messagePattern.length() + 50);
        int i = 0;
        int L = 0;
        do {
            boolean notEscaped = j == 0 || messagePattern.charAt(j - 1) != ESCAPE_CHAR;
            if (notEscaped) {
                // normal case
                sbuf.append(messagePattern, i, j);
            } else {
                sbuf.append(messagePattern, i, j - 1);
                // check that escape char is not is escaped: ""abc x:\\{}""
                notEscaped = j >= 2 && messagePattern.charAt(j - 2) == ESCAPE_CHAR;
            }

            i = j + 2;
            if (notEscaped) {
                deeplyAppendParameter(sbuf, argArray[L], null);
                L++;
                if (L > lastArrIdx) {
                    break;
                }
            } else {
                sbuf.append(DELIM_STR);
            }
            j = messagePattern.indexOf(DELIM_STR, i);
        } while (j != -1);

        // append the characters following the last {} pair.
        sbuf.append(messagePattern, i, messagePattern.length());
        return new FormattingTuple(sbuf.toString(), L <= lastArrIdx? throwable : null);
    }",Format an array of message patterns.
"public void marshall(ListDeploymentsRequest listDeploymentsRequest, ProtocolMarshaller protocolMarshaller) {

        if (listDeploymentsRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(listDeploymentsRequest.getGroupId(), GROUPID_BINDING);
            protocolMarshaller.marshall(listDeploymentsRequest.getMaxResults(), MAXRESULTS_BINDING);
            protocolMarshaller.marshall(listDeploymentsRequest.getNextToken(), NEXTTOKEN_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",Creates the marshalling method for the ANSWER service.
"public static HttpURLConnection downloadAttributes(final URI uri, final QueueRequestOptions queueOptions,
            final OperationContext opContext) throws IOException, URISyntaxException, StorageException {
        UriQueryBuilder builder = new UriQueryBuilder();

        builder.add(Constants.QueryConstants.COMPONENT, METADATA);
        final HttpURLConnection retConnection = BaseRequest.createURLConnection(uri, queueOptions, builder, opContext);

        retConnection.setRequestMethod(Constants.HTTP_HEAD);

        return retConnection;
    }",Download attributes.
"public final Object getAttribute(Object key, Object defaultValue) {
        return attributes.getAttribute(this, key, defaultValue);
    }",Get the attribute value.
"private void printKeySet() {
    Set<?> keys = keySet();
    System.out.println(""printing keyset:"");
    for (Object o: keys) {
      //System.out.println(Arrays.asList((Object[]) i.next()));
      System.out.println(o);
    }
  }",Print the keyset.
"public CloseableIterator<T> mergeSort(Iterator<T> values) throws IOException {
        ChunkSizeIterator<T> csi = new ChunkSizeIterator<T>(values, config.chunkSize);
        if (csi.isMultipleChunks()) {
            List<File> sortedChunks = writeSortedChunks(csi);
            return mergeSortedChunks(sortedChunks);
        } else {
            if (config.distinct) {
                SortedSet<T> list = new TreeSet<T>(comparator);
                while (csi.hasNext()) {
                    list.add(csi.next());
                }
                return new DelegatingMergeIterator<T>(list.iterator());
            } else {
                List<T> list = new ArrayList<T>(csi.getHeadSize());
                while (csi.hasNext()) {
                    list.add(csi.next());
                }
                Collections.sort(list, comparator);
                return new DelegatingMergeIterator<T>(list.iterator());
            }
        }
    }",Merge sort iterator.
"public SearchSmsResponse searchMessages(Date date, String to) throws IOException, NexmoClientException {
        return this.searchMessages(new SmsDateSearchRequest(date, to));
    }",Search for SMS messages in the specified date.
"void packageArtifacts(final File compileDir, final MavenProject project, final Set<String> bundles)
        throws IOException, XCodeException
  {

    File mainArtifact = createMainArtifactFile(project);

    attachBundle(compileDir, project, bundles, mainArtifact);

    final File mainArtifactFile = archiveMainArtifact(project, mainArtifact);
    setMainArtifact(project, mainArtifactFile);

  }",Package the main artifact files.
"protected String getPackaging(String packaging) {
        return this.packaging == null || this.packaging.length() == 0
                ? packaging
                : this.packaging;
    }",Get the packaging.
"public static <O> O deserialise(String json, Class<O> type) {
        Gson gson = getBuilder().create();
        return gson.fromJson(json, type);
    }",Deserialise a single record set from a JSON string.
"@Override
	public ControlFlow visitProperty(Decl.Property declaration, MaybeAssignedSet dummy) {
		MaybeAssignedSet environment = new MaybeAssignedSet();
		// Definitely assigned variables includes all parameters.
		environment = environment.addAll(declaration.getParameters());
		//
		return null;
	}",Override this method to add all variables to the environment.
"public Event mapToEvent(Message message) {
        Event event = new Event();
        MessageInfo messageInfo = new MessageInfo();
        Originator originator = new Originator();
        boolean isRestMessage = isRestMessage(message);

        event.setMessageInfo(messageInfo);
        event.setOriginator(originator);
        String content = getPayload(message);
        event.setContent(content);
        handleContentLength(event);
        event.setEventType(null);
        Date date = new Date();
        event.setTimestamp(date);

//        if (isRestMessage) {
//            String queryString = (String) message.get(Message.QUERY_STRING);
//            if (queryString == null && message.getExchange().getInMessage() != null) {
//                queryString = (String) message.getExchange().getInMessage().get(Message.QUERY_STRING);
//            }
//            if (queryString != null && queryString.contains(""_wadl"")) {
//                return null;
//            }
//        }

        messageInfo.setFlowId(FlowIdHelper.getFlowId(message));
        if (!isRestMessage) {
            messageInfo.setMessageId(getMessageId(message));
            ServiceInfo serviceInfo = message.getExchange().getBinding().getBindingInfo().getService();
            if (null != serviceInfo) {
                String portTypeName = serviceInfo.getInterface().getName().toString();
                messageInfo.setPortType(portTypeName);
                messageInfo.setOperationName(getOperationName(message));
            }
            SoapBinding soapBinding = (SoapBinding) message.getExchange().getBinding();
            if (soapBinding.getBindingInfo() instanceof SoapBindingInfo) {
                SoapBindingInfo soapBindingInfo = (SoapBindingInfo) soapBinding.getBindingInfo();
                messageInfo.setTransportType(soapBindingInfo.getTransportURI());
            }
        } else {
            messageInfo.setTransportType(""http://cxf.apache.org/transports/http"");
            messageInfo.setPortType(message.getExchange().getEndpoint().getEndpointInfo().getName()
                    .toString());
            String opName = getRestOperationName(message);
            messageInfo.setOperationName(opName);
        }

        if (messageInfo.getTransportType() == null) {
            messageInfo.setTransportType(""Unknown transport type"");
        }

        // add custom properties from CXF properties
        if (null != message.getExchange().getEndpoint().get(EventFeature.SAM_PROPERTIES)) {
            Map<String, String> customProp =
                    (Map<String, String>) message.getExchange().getEndpoint().get(EventFeature.SAM_PROPERTIES);
            event.getCustomInfo().putAll(customProp);
        }

        String addr = message.getExchange().getEndpoint().getEndpointInfo().getAddress();
        if (null != addr) {
            event.getCustomInfo().put(""address"", addr);
        }

        String correlationId = CorrelationIdHelper.getCorrelationId(message);
        if (null != correlationId) {
            event.getCustomInfo().put(""CorrelationID"", correlationId);
        }

        try {
            InetAddress inetAddress = InetAddress.getLocalHost();
            originator.setIp(inetAddress.getHostAddress());
            originator.setHostname(inetAddress.getHostName());
        } catch (UnknownHostException e) {
            originator.setHostname(""Unknown hostname"");
            originator.setIp(""Unknown ip address"");
        }
        originator.setProcessId(Converter.getPID());

        if (isRestMessage) {
            //String queryString = (String) message.get(Message.QUERY_STRING);
            //if (null == queryString && null != message.getExchange().getInMessage()) {
            //    queryString = (String) message.getExchange().getInMessage().get(Message.QUERY_STRING);
            //}
            //if (null != queryString) {
            //    event.getCustomInfo().put(""Query String"", queryString);
            //}

            String accept = (String) message.get(Message.ACCEPT_CONTENT_TYPE);
            if (null != accept) {
                event.getCustomInfo().put(""Accept Type"", accept);
            }

            //String httpMethod = (String) message.get(Message.HTTP_REQUEST_METHOD);
            //if (null != httpMethod) {
            //    event.getCustomInfo().put(""HTTP Method"", httpMethod);
            //}

            String contentType = (String) message.get(Message.CONTENT_TYPE);
            if (null != contentType) {
                event.getCustomInfo().put(""Content Type"", contentType);
            }

            Integer responseCode = (Integer) message.get(Message.RESPONSE_CODE);
            if (null != responseCode) {
                event.getCustomInfo().put(""Response Code"", responseCode.toString());
            }
        }

        SecurityContext sc = message.get(SecurityContext.class);
        if (sc != null && sc.getUserPrincipal() != null) {
            originator.setPrincipal(sc.getUserPrincipal().getName());
        }

        if (originator.getPrincipal() == null) {
            AuthorizationPolicy authPolicy = message.get(AuthorizationPolicy.class);
            if (authPolicy != null) {
                originator.setPrincipal(authPolicy.getUserName());
            }
        }

        EventTypeEnum eventType = getEventType(message);
        event.setEventType(eventType);

        CustomInfo customInfo = CustomInfo.getOrCreateCustomInfo(message);
        // System.out.println(""custom props: "" + customInfo);
        event.getCustomInfo().putAll(customInfo);

        return event;
    }",Maps a message to an event.
"protected void stopReceiving()
   {
      if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(this, tc, ""stopReceiving"");
      receivePhysicalCloseRequest = true;
      if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(this, tc, ""stopReceiving"", """"+receivePhysicalCloseRequest);
   }",Stop receiving a single PhysicalCloseRequest
"@Nonnull
  public static CronScheduleBuilder atHourAndMinuteOnGivenDaysOfWeek (final int hour,
                                                                      final int minute,
                                                                      final DayOfWeek... daysOfWeek)
  {
    ValueEnforcer.notEmptyNoNullValue (daysOfWeek, ""DaysOfWeek"");
    DateBuilder.validateHour (hour);
    DateBuilder.validateMinute (minute);

    final StringBuilder aSB = new StringBuilder ();
    aSB.append (""0 "")
       .append (minute)
       .append (' ')
       .append (hour)
       .append ("" ? * "")
       .append (PDTHelper.getCalendarDayOfWeek (daysOfWeek[0]));
    for (int i = 1; i < daysOfWeek.length; i++)
      aSB.append (',').append (PDTHelper.getCalendarDayOfWeek (daysOfWeek[i]));

    return _cronScheduleNoParseException (aSB.toString ());
  }

  /**
   * Create a CronScheduleBuilder with a cron-expression that sets the schedule
   * to fire one per week on the given day at the given time (hour and minute).
   *
   * @param dayOfWeek
   *        the day of the week to fire
   * @param hour
   *        the hour of day to fire
   * @param minute
   *        the minute of the given hour to fire
   * @return the new CronScheduleBuilder
   * @see CronExpression
   */
  @Nonnull
  public static CronScheduleBuilder weeklyOnDayAndHourAndMinute (final DayOfWeek dayOfWeek,
                                                                 final int hour,
                                                                 final int minute)
  {
    DateBuilder.validateDayOfWeek (dayOfWeek);
    DateBuilder.validateHour (hour);
    DateBuilder.validateMinute (minute);

    final String cronExpression = ""0 "" + minute + "" "" + hour + "" ? * "" + PDTHelper.getCalendarDayOfWeek (dayOfWeek);

    return _cronScheduleNoParseException (cronExpression);
  }

  /**
   * Create a CronScheduleBuilder with a cron-expression that sets the schedule
   * to fire one per month on the given day of month at the given time (hour and
   * minute).
   *
   * @param dayOfMonth
   *        the day of the month to fire
   * @param hour
   *        the hour of day to fire
   * @param minute
   *        the minute of the given hour to fire
   * @return the new CronScheduleBuilder
   * @see CronExpression
   */
  @Nonnull
  public static CronScheduleBuilder monthlyOnDayAndHourAndMinute (final int dayOfMonth,
                                                                  final int hour,
                                                                  final int minute)
  {
    DateBuilder.validateDayOfMonth (dayOfMonth);
    DateBuilder.validateHour (hour);
    DateBuilder.validateMinute (minute);

    final String cronExpression = ""0 "" + minute + "" "" + hour + "" "" + dayOfMonth + "" * ?"";
    return _cronScheduleNoParseException (cronExpression);
  }

  /**
   * The <code>TimeZone</code> in which to base the schedule.
   *
   * @param timezone
   *        the time-zone for the schedule.
   * @return the updated CronScheduleBuilder
   * @see CronExpression#getTimeZone()
   */
  @Nonnull
  public CronScheduleBuilder inTimeZone (final TimeZone timezone)
  {
    m_aCronExpression.setTimeZone (timezone);
    return this;
  }

  /**
   * If the Trigger misfires, use the
   * {@link ITrigger#MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY} instruction.
   *
   * @return the updated CronScheduleBuilder
   * @see ITrigger#MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY
   */
  @Nonnull
  public CronScheduleBuilder withMisfireHandlingInstructionIgnoreMisfires ()
  {
    m_nMisfireInstruction = ITrigger.MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY;
    return this;
  }

  /**
   * If the Trigger misfires, use the
   * {@link ICronTrigger#MISFIRE_INSTRUCTION_DO_NOTHING} instruction.
   *
   * @return the updated CronScheduleBuilder
   * @see ICronTrigger#MISFIRE_INSTRUCTION_DO_NOTHING
   */
  @Nonnull
  public CronScheduleBuilder withMisfireHandlingInstructionDoNothing ()
  {
    m_nMisfireInstruction = ICronTrigger.MISFIRE_INSTRUCTION_DO_NOTHING;
    return this;
  }

  /**
   * If the Trigger misfires, use the
   * {@link ICronTrigger#MISFIRE_INSTRUCTION_FIRE_ONCE_NOW} instruction.
   *
   * @return the updated CronScheduleBuilder
   * @see ICronTrigger#MISFIRE_INSTRUCTION_FIRE_ONCE_NOW
   */
  @Nonnull
  public CronScheduleBuilder withMisfireHandlingInstructionFireAndProceed ()
  {
    m_nMisfireInstruction = ICronTrigger.MISFIRE_INSTRUCTION_FIRE_ONCE_NOW;
    return this;
  }
}",Create a CronScheduleBuilder with a cron - expression that sets the schedule to fire at the given time.
"public final void reset() {
        successfulTests = 0;
        failedTests = 0;
        timeoutTests = 0;
        errorTests = 0;
        individualErrors = 0;

        startTime = null;
        endTime = null;
    }",Resets the internal state of this object.
"@Override
    public boolean authenticate() {
        UndertowLogger.SECURITY_LOGGER.debugf(""Attempting to authenticate %s, authentication required: %s"", exchange.getRequestPath(), isAuthenticationRequired());
        if(authenticationState == AuthenticationState.ATTEMPTED || (authenticationState == AuthenticationState.CHALLENGE_SENT && !exchange.isResponseStarted())) {
            //we are re-attempted, so we just reset the state
            //see UNDERTOW-263
            authenticationState = AuthenticationState.NOT_ATTEMPTED;
        }
        return !authTransition();
    }",This method is called by the authentication process to determine if the request should be retried.
"public boolean removeRef(Object obj)
        throws IOException
    {
        if (_refs != null) {
            _refs.remove(obj);

            return true;
        }
        else
            return false;
    }",Removes a reference to a single object from the set of references.
"private void processDelimiter()
    {
        assert (state == State.ACTIVE || state == State.WAITING_FOR_DELIMITER);

        if (state == State.ACTIVE) {
            state = State.DELIMITER_RECEIVED;
        }
        else {
            outpipe = null;
            sendPipeTermAck(peer);
            state = State.TERM_ACK_SENT;
        }
    }",Process a delimiter message.
"void processXmlSiteinfo() throws XMLStreamException {

		this.xmlReader.next(); // skip current start tag
		while (this.xmlReader.hasNext()) {
			switch (this.xmlReader.getEventType()) {

			case XMLStreamConstants.START_ELEMENT:
				switch (xmlReader.getLocalName()) {
				case MwRevisionDumpFileProcessor.E_SITENAME:
					this.sitename = this.xmlReader.getElementText();
					break;
				case MwRevisionDumpFileProcessor.E_NAMESPACE:
					Integer namespaceKey = Integer.parseInt(
							this.xmlReader.getAttributeValue(null,
									MwRevisionDumpFileProcessor.A_NSKEY));
					this.namespaces.put(namespaceKey,
							this.xmlReader.getElementText());
					break;
				case MwRevisionDumpFileProcessor.E_BASEURL:
					this.baseUrl = this.xmlReader.getElementText();
					break;
				}
				break;

			case XMLStreamConstants.END_ELEMENT:
				if (MwRevisionDumpFileProcessor.E_SITEINFO
						.equals(this.xmlReader.getLocalName())) {
					return;
				}
				break;

			}

			this.xmlReader.next();
		}
	}",Process the XML siteinfo tag.
"public int getIndex(final List<String> scopes) {
    this.checkInitialized();
    boolean _isNullOrUnknown = this.isNullOrUnknown(scopes);
    if (_isNullOrUnknown) {
      return (-1);
    }
    final Integer index = this.scopes.inverse().get(scopes);
    Integer _xifexpression = null;
    if ((index == null)) {
      _xifexpression = Integer.valueOf((-1));
    } else {
      _xifexpression = index;
    }
    return (_xifexpression).intValue();
  }",Gets the index of the specified scopes.
"public List<Jid> getUsersAndRoomsBlocked(DomainBareJid mucLightService)
            throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
        MUCLightBlockingIQ muclIghtBlockingIQResult = getBlockingList(mucLightService);

        List<Jid> jids = new ArrayList<>();
        if (muclIghtBlockingIQResult.getRooms() != null) {
            jids.addAll(muclIghtBlockingIQResult.getRooms().keySet());
        }

        if (muclIghtBlockingIQResult.getUsers() != null) {
            jids.addAll(muclIghtBlockingIQResult.getUsers().keySet());
        }

        return jids;
    }",Get users and rooms blocked.
"public void execute()
			throws BuildException
	{
		try
		{
			verboseHeaderToLog();

			List<String> args = buildCommandLine();

			verboseCommandLineToLog(args);

			doRun(args);

		}
        catch (BuildException ex) {
            throw ex;
        }
		catch (Exception ex)
		{
			throw new BuildException(""AntTaskRunner"", ex);
		}
	}",Execute the task.
"public String debugInfo() {
        if (!isDebug || debugEntries.size() == 0) {
            return """";
        }
        StringBuffer ret = new StringBuffer();
        for (int i = debugEntries.size() - 1;i >= 0;i--) {
            Entry entry = debugEntries.get(i);
            ret.append(entry.timestamp).append("": "").append(entry.message).append(""\n"");
            if (entry.throwable != null) {
                StringWriter writer = new StringWriter();
                entry.throwable.printStackTrace(new PrintWriter(writer));
                ret.append(writer.toString());
            }
        }
        return ret.toString();
    }",Get a string containing the information about the exception.
"private void disposeObtainedResult(SignInResult result, int rstCode) {
        if(result.isSuccess()){
            //可以获取帐号的 openid，昵称，头像 at信息
            SignInHuaweiId account = result.getSignInHuaweiId();
            onSignInResult(rstCode, account);
        } else {
            if(rstCode == HuaweiIdStatusCodes.SIGN_IN_UNLOGIN
                    || rstCode == HuaweiIdStatusCodes.SIGN_IN_AUTH
                    || rstCode == HuaweiIdStatusCodes.SIGN_IN_CHECK_PASSWORD){
                Activity curActivity = ActivityMgr.INST.getLastActivity();
                if (curActivity == null) {
                    HMSAgentLog.e(""activity is null"");
                    onSignInResult(HMSAgent.AgentResultCode.NO_ACTIVITY_FOR_USE, null);
                    return;
                }

                try {
                    signInResultForDispose = result;
                    Intent nxtIntent = new Intent(curActivity, HMSSignInAgentActivity.class);
                    curActivity.startActivity(nxtIntent);
                } catch (Exception e) {
                    HMSAgentLog.e(""start HMSSignInAgentActivity error:"" + e.getMessage());
                    onSignInResult(HMSAgent.AgentResultCode.START_ACTIVITY_ERROR, null);
                }
            } else {
                onSignInResult(rstCode, null);
            }
        }
    }",Dispose obtained result.
"public void marshall(TargetGroupInfo targetGroupInfo, ProtocolMarshaller protocolMarshaller) {

        if (targetGroupInfo == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(targetGroupInfo.getName(), NAME_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given targetGroupInfo to the JSON - compatible parameter object.
"public Value lookup(ILexNameToken name)
	{
		Value v = check(name);

		if (v == null)
		{
			VdmRuntimeError.abort(name.getLocation(), 4034, ""Name '"" + name
					+ ""' not in scope"", this);
		}

		return v;
	}",Lookup a name in the scope.
"static boolean parseBoolean(String booleanString, int rowIndex, String columnName) {
    if (booleanString.equalsIgnoreCase(TRUE.toString())) return true;
    else if (booleanString.equalsIgnoreCase(FALSE.toString())) return false;
    else
      throw new InvalidValueException(
          booleanString, columnName, ""TRUE, FALSE"", EMX_ATTRIBUTES, rowIndex);
  }",Parse a boolean value.
"public synchronized AcceleratedScreen getAcceleratedScreen(int[] attributes)
            throws GLException, UnsatisfiedLinkError {
        if (accScreen == null) {
            accScreen = new AcceleratedScreen(attributes);
        }
        return accScreen;
    }",Get the AcceleratedScreen object.
"public static <T extends Levenshtein> T cosine(String baseTarget, String compareTarget) {
		return cosine(baseTarget, compareTarget, null);
	}",Gets the cosine distance between two strings.
"private void validateType(DynamicType<?> dynamicType) {
        int size = dynamicType.getMetadata().size();
        if (size == 1) {
            if (dynamicType.isAbstract()) {
                throw new XOException(""Cannot create an instance of a single abstract type "" + dynamicType);
            }
        } else if (dynamicType.isFinal()) {
            throw new XOException(""Cannot create an instance overriding a final type "" + dynamicType);
        }
    }",Validate the type.
"public static void addFlushHandler(OperationContext context, ContentRepository contentRepository, OperationContext.ResultHandler handler) {
        if (context.getAttachment(CONTENT_REPOSITORY_FLUSH) == null) {
            context.attach(CONTENT_REPOSITORY_FLUSH, true);
            context.completeStep(new OperationContext.ResultHandler() {
                @Override
                public void handleResult(OperationContext.ResultAction resultAction, OperationContext context, ModelNode operation) {
                    handler.handleResult(resultAction, context, operation);
                    contentRepository.flush(resultAction == OperationContext.ResultAction.KEEP);
                    context.detach(CONTENT_REPOSITORY_FLUSH);
                }
            });
        } else {
            context.completeStep(handler);
        }
    }",Add flush handler.
"public static double fBeta(double beta, long tp, long fp, long fn) {
        double prec = tp / ((double) tp + fp);
        double recall = tp / ((double) tp + fn);
        return fBeta(beta, prec, recall);
    }",Compute the F - beta value for a single class segment.
"public void readConfiguration(File configFile) throws TracerFactory.Exception, FileNotFoundException {
    if (!configFile.exists())
      throw new FileNotFoundException(configFile + ""doesn't exist."");
    try (FileInputStream fileInputStream = new FileInputStream(configFile)) {
      readConfiguration(fileInputStream);
    }
    catch (IOException ex) {
      ex.printStackTrace(System.err);
    }
  }",Reads the configuration from the specified file.
"public static Dynamic bootstrap(String name, MethodDescription.InDefinedShape bootstrapMethod, List<?> rawArguments) {
            if (name.length() == 0 || name.contains(""."")) {
                throw new IllegalArgumentException(""Not a valid field name: "" + name);
            }
            List<Object> arguments = new ArrayList<Object>(rawArguments.size());
            for (Object argument : rawArguments) {
                if (argument == null) {
                    argument = ofNullConstant();
                } else if (argument instanceof Class) {
                    argument = ((Class<?>) argument).isPrimitive()
                            ? ofPrimitiveType((Class<?>) argument)
                            : TypeDescription.ForLoadedType.of((Class<?>) argument);
                } else if (argument instanceof TypeDescription && ((TypeDescription) argument).isPrimitive()) {
                    argument = ofPrimitiveType((TypeDescription) argument);
                } else if (JavaType.METHOD_HANDLE.isInstance(argument)) {
                    argument = MethodHandle.ofLoaded(argument);
                } else if (JavaType.METHOD_TYPE.isInstance(argument)) {
                    argument = MethodType.ofLoaded(argument);
                }
                arguments.add(argument);
            }
            if (!bootstrapMethod.isConstantBootstrap(arguments)) {
                throw new IllegalArgumentException(""Not a valid bootstrap method "" + bootstrapMethod + "" for "" + arguments);
            }
            Object[] asmifiedArgument = new Object[arguments.size()];
            int index = 0;
            for (Object argument : arguments) {
                if (argument instanceof TypeDescription) {
                    argument = Type.getType(((TypeDescription) argument).getDescriptor());
                } else if (argument instanceof JavaConstant) {
                    argument = ((JavaConstant) argument).asConstantPoolValue();
                }
                asmifiedArgument[index++] = argument;
            }
            return new Dynamic(new ConstantDynamic(name,
                    (bootstrapMethod.isConstructor()
                            ? bootstrapMethod.getDeclaringType()
                            : bootstrapMethod.getReturnType().asErasure()).getDescriptor(),
                    new Handle(bootstrapMethod.isConstructor() ? Opcodes.H_NEWINVOKESPECIAL : Opcodes.H_INVOKESTATIC,
                            bootstrapMethod.getDeclaringType().getInternalName(),
                            bootstrapMethod.getInternalName(),
                            bootstrapMethod.getDescriptor(),
                            false),
                    asmifiedArgument),
                    bootstrapMethod.isConstructor()
                            ? bootstrapMethod.getDeclaringType()
                            : bootstrapMethod.getReturnType().asErasure());
        }",Bootstrap a field.
"public CMAEntry publish(CMAEntry entry) {
    assertNotNull(entry, ""entry"");
    final String entryId = getResourceIdOrThrow(entry, ""entry"");
    final String environmentId = entry.getEnvironmentId();
    final String spaceId = getSpaceIdOrThrow(entry, ""entry"");

    return service.publish(
        entry.getSystem().getVersion(),
        spaceId,
        environmentId,
        entryId).blockingFirst();
  }",Publish an entry to the cluster.
"public XMLSerializer text(String text) throws IOException {
		// assert text != null;
		if (startTagIncomplete || setPrefixCalled)
			closeStartTag();
		if (doIndent && seenTag)
			seenTag = false;
		writeElementContent(text, out);
		return this;
	}",Write a text string.
"public void marshall(User user, ProtocolMarshaller protocolMarshaller) {

        if (user == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(user.getUserId(), USERID_BINDING);
            protocolMarshaller.marshall(user.getAccountId(), ACCOUNTID_BINDING);
            protocolMarshaller.marshall(user.getPrimaryEmail(), PRIMARYEMAIL_BINDING);
            protocolMarshaller.marshall(user.getPrimaryProvisionedNumber(), PRIMARYPROVISIONEDNUMBER_BINDING);
            protocolMarshaller.marshall(user.getDisplayName(), DISPLAYNAME_BINDING);
            protocolMarshaller.marshall(user.getLicenseType(), LICENSETYPE_BINDING);
            protocolMarshaller.marshall(user.getUserRegistrationStatus(), USERREGISTRATIONSTATUS_BINDING);
            protocolMarshaller.marshall(user.getUserInvitationStatus(), USERINVITATIONSTATUS_BINDING);
            protocolMarshaller.marshall(user.getRegisteredOn(), REGISTEREDON_BINDING);
            protocolMarshaller.marshall(user.getInvitedOn(), INVITEDON_BINDING);
            protocolMarshaller.marshall(user.getPersonalPIN(), PERSONALPIN_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given user to the JSON object.
"public Object getRealKey()
    {
        if(keyRealSubject != null)
        {
            return keyRealSubject;
        }
        else
        {
            TransactionExt tx = getTransaction();

            if((tx != null) && tx.isOpen())
            {
                prepareKeyRealSubject(tx.getBroker());
            }
            else
            {
                if(getPBKey() != null)
                {
                    PBCapsule capsule = new PBCapsule(getPBKey(), null);

                    try
                    {
                        prepareKeyRealSubject(capsule.getBroker());
                    }
                    finally
                    {
                        capsule.destroy();
                    }
                }
                else
                {
                    getLog().warn(""No tx, no PBKey - can't materialise key with Identity "" + getKeyOid());
                }
            }
        }
        return keyRealSubject;
    }",Gets the real key from the Identity.
"public static <T> HashSet<T> getLeaves(T root, Deps<T> deps) {
        return dfs(root, new HashSet<T>(), deps);
    }",Get the leaves of a tree.
"public void marshall(WriteCampaignRequest writeCampaignRequest, ProtocolMarshaller protocolMarshaller) {

        if (writeCampaignRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(writeCampaignRequest.getAdditionalTreatments(), ADDITIONALTREATMENTS_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getDescription(), DESCRIPTION_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getHoldoutPercent(), HOLDOUTPERCENT_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getHook(), HOOK_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getIsPaused(), ISPAUSED_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getLimits(), LIMITS_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getMessageConfiguration(), MESSAGECONFIGURATION_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getName(), NAME_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getSchedule(), SCHEDULE_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getSegmentId(), SEGMENTID_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getSegmentVersion(), SEGMENTVERSION_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getTags(), TAGS_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getTreatmentDescription(), TREATMENTDESCRIPTION_BINDING);
            protocolMarshaller.marshall(writeCampaignRequest.getTreatmentName(), TREATMENTNAME_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given writeCampaignRequest to the JSON object.
"public void parseMetaElements(Element ele, BeanMetadataAttributeAccessor attributeAccessor) {
    NodeList nl = ele.getChildNodes();
    for (int i = 0; i < nl.getLength(); i++) {
      Node node = nl.item(i);
      if (node instanceof Element && nodeNameEquals(node, META_ELEMENT)) {
        Element metaElement = (Element) node;
        String key = metaElement.getAttribute(KEY_ATTRIBUTE);
        String value = metaElement.getAttribute(VALUE_ATTRIBUTE);
        BeanMetadataAttribute attribute = new BeanMetadataAttribute(key, value);
        attribute.setSource(extractSource(metaElement));
        attributeAccessor.addMetadataAttribute(attribute);
      }
    }
  }",Parse the META_ELEMENT element of the given element and add it to the BeanMetadataAttributeAccessor.
"public static Double toDouble(Object o, Double defaultValue) {
	if (o instanceof Double) return (Double) o;
	double dbl = toDoubleValue(o, true, Double.NaN);
	if (Double.isNaN(dbl)) return defaultValue;
	return new Double(dbl);

    }",To double.
"private ReadResultEntryBase createDataNotAvailableRead(long streamSegmentOffset, int maxLength) {
        maxLength = getLengthUntilNextEntry(streamSegmentOffset, maxLength);
        long storageLength = this.metadata.getStorageLength();
        if (streamSegmentOffset < storageLength) {
            // Requested data exists in Storage.
            // Determine actual read length (until Storage Length) and make sure it does not exceed maxLength.
            long actualReadLength = storageLength - streamSegmentOffset;
            if (actualReadLength > maxLength) {
                actualReadLength = maxLength;
            }

            return createStorageRead(streamSegmentOffset, (int) actualReadLength);
        } else {
            // Note that Future Reads are not necessarily tail reads. They mean that we cannot return a result given
            // the current state of the metadata. An example of when we might return a Future Read that is not a tail read
            // is when we receive a read request immediately after recovery, but before the StorageWriter has had a chance
            // to refresh the Storage state (the metadata may be a bit out of date). In that case, we record a Future Read
            // which will be completed when the StorageWriter invokes triggerFutureReads() upon refreshing the info.
            return createFutureRead(streamSegmentOffset, maxLength);
        }
    }",Create a ReadResultEntryBase that is not available in Storage.
"@DeleteMapping(""/setting/delete/url"")
    public void deleteValidationUrl(HttpServletRequest req, @RequestBody ReqUrl reqUrl) {
        this.validationSessionComponent.sessionCheck(req);
        this.msgSettingService.deleteValidationData(reqUrl);
    }",Delete validation url.
"public void marshall(GetParameterRequest getParameterRequest, ProtocolMarshaller protocolMarshaller) {

        if (getParameterRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(getParameterRequest.getName(), NAME_BINDING);
            protocolMarshaller.marshall(getParameterRequest.getWithDecryption(), WITHDECRYPTION_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given parameter request to the JSON object.
"@Override
  public <T> long existsObject(String name, T obj) throws CpoException {
    return getCurrentResource().existsObject( name, obj);
  }",Override the existsObject method to check if the object exists in the object list.
"private synchronized String getCacheLocation() {
    if (metricsCacheLocation != null) {
      return metricsCacheLocation;
    }

    MetricsCacheLocation cacheLocation = stateManagerAdaptor.getMetricsCacheLocation(topologyName);
    metricsCacheLocation = String.format(""http://%s:%s/%s"", cacheLocation.getHost(),
        cacheLocation.getStatsPort(), PATH_STATS);
    return metricsCacheLocation;
  }",Get the cache location
"@Override
	public CommerceNotificationQueueEntry fetchByLtS_First(Date sentDate,
		OrderByComparator<CommerceNotificationQueueEntry> orderByComparator) {
		List<CommerceNotificationQueueEntry> list = findByLtS(sentDate, 0, 1,
				orderByComparator);

		if (!list.isEmpty()) {
			return list.get(0);
		}

		return null;
	}",Returns the commerce notification queue entry with a lower date and time from the ordered set.
"@Override
    public final void from(String path, ReadCache cache) throws IOException,
            ClassNotFoundException {
        if (cache == null) {
            from(path);
            return;
        }
        if (nulls(path)) throw new NullPointerException();
        FileInputStream fis = null;
        try {
            fis = new FileInputStream(new File(path));
            ObjectInputStream ois = new ObjectInputStream(fis);
            from(ois, cache);
            return;
        } finally {
            if (fis != null) fis.close();
        }
    }",This method is called to read a single SECTYPE from a file.
"@Override
    public void close() throws IOException {
        if (fis != null) {
            try {
                fis.close();
                fis = null;
            } catch (Throwable th) {
                //no-op
            }
        }
    }",Close the underlying file.
"@CheckReturnValue
    @NonNull
    public static <T> UnicastSubject<T> create(boolean delayError) {
        return new UnicastSubject<T>(bufferSize(), delayError);
    }",Create a new instance of a CRASubject.
"public static <T, E extends Exception> FloatList mapToFloat(final T[] a, final int fromIndex, final int toIndex,
            final Try.ToFloatFunction<? super T, E> func) throws E {
        checkFromToIndex(fromIndex, toIndex, len(a));
        N.checkArgNotNull(func);

        if (N.isNullOrEmpty(a)) {
            return new FloatList();
        }

        final FloatList result = new FloatList(toIndex - fromIndex);

        for (int i = fromIndex; i < toIndex; i++) {
            result.add(func.applyAsFloat(a[i]));
        }

        return result;
    }",Maps the specified array of type float to the number of elements of type float.
"public Response handle(AuthleteApi api, MultivaluedMap<String, String> parameters)
    {
        try
        {
            // Create a handler.
            IntrospectionRequestHandler handler = new IntrospectionRequestHandler(api);

            // Delegate the task to the handler.
            return handler.handle(parameters);
        }
        catch (WebApplicationException e)
        {
            // An error occurred in the handler.
            onError(e);

            // Convert the error to a Response.
            return e.getResponse();
        }
    }",Handle a request to the ACS API.
"public ByteBuffer encodePFrame(Picture pic, ByteBuffer _out) {
        frameNumber++;
        return doEncodeFrame(pic, _out, true, frameNumber, SliceType.P);
    }",Encode a Picture into a byte buffer.
"@Test
	public void getControlReturnsControl()
	{
		server().enqueue(new MockResponse().setBody(""<html><body>""
			+ ""<form name='f'>""
			+ ""<input type='text' name='x'/>""
			+ ""</form>""
			+ ""</body></html>""));
		
		Control actual = newBrowser().get(url(server()))
			.getForm(""f"")
			.getControl(""x"");
		
		assertThat(""form control"", actual.getName(), is(""x""));
	}",Test if a control returns a control.
"public FileAppender flush() {
		try(PrintWriter pw = writer.getPrintWriter(true)){
			for (String str : list) {
				pw.print(str);
				if (isNewLineMode) {
					pw.println();
				}
			}
		}
		list.clear();
		return this;
	}",Flushes the file to disk.
"public void marshall(WorkspaceBundle workspaceBundle, ProtocolMarshaller protocolMarshaller) {

        if (workspaceBundle == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(workspaceBundle.getBundleId(), BUNDLEID_BINDING);
            protocolMarshaller.marshall(workspaceBundle.getName(), NAME_BINDING);
            protocolMarshaller.marshall(workspaceBundle.getOwner(), OWNER_BINDING);
            protocolMarshaller.marshall(workspaceBundle.getDescription(), DESCRIPTION_BINDING);
            protocolMarshaller.marshall(workspaceBundle.getRootStorage(), ROOTSTORAGE_BINDING);
            protocolMarshaller.marshall(workspaceBundle.getUserStorage(), USERSTORAGE_BINDING);
            protocolMarshaller.marshall(workspaceBundle.getComputeType(), COMPUTETYPE_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given workspaceBundle to the JSON object.
"public Matrix4x3d ortho2D(double left, double right, double bottom, double top) {
        return ortho2D(left, right, bottom, top, this);
    }",Compute the orthographic 2D transformation.
"public static JsonObject rename(final JsonObject outdatedDBEntry, final String newName, final String... path) {
        // store root element
        JsonObject parent = outdatedDBEntry;

        // lookup element to rename
        for (int i = 0; i < path.length; i++) {
            final String propertyName = path[i];


            // property not found so nothing to rename
            if (!parent.has(propertyName)) {
                return outdatedDBEntry;
            }

            // if element to rename selected than rename otherwise contine with next element
            if (i == path.length - 1) {
                parent.add(newName, parent.remove(propertyName));

            } else {
                // prepare next round
                parent = parent.getAsJsonObject(propertyName);
            }
        }
        return outdatedDBEntry;
    }",Rename a single entry in a JsonObject.
"public static void writeU4(OutputStream dest, int u4) throws IOException {
        dest.write((byte) (u4 >> 24));
        dest.write((byte) (u4 >> 16));
        dest.write((byte) (u4 >>  8));
        dest.write((byte) u4);
    }",Write a u4 value to the output stream.
"@Deprecated
    public Document getDocument(String rootPath) {

        if (getDocument(CmsSearchField.FIELD_PATH, rootPath) != null) {
            return (Document)getDocument(CmsSearchField.FIELD_PATH, rootPath).getDocument();
        }
        return null;
    }",Gets the document for the given root path.
"public void actionMerge(I_CmsReport report) {

        m_report = report;
        m_report.println(Messages.get().container(Messages.RPT_MERGE_PAGES_BEGIN_0), I_CmsReport.FORMAT_HEADLINE);

        try {
            // collect all pages and sort them depending on their state
            collectResources();
            // merge all pages that can be merged
            mergePages();
            // cleanup
            cleanup();
        } catch (CmsException e) {
            m_report.println(e);
        }

    }",Action called to perform the merge action.
"public void abort() {
    LOG.info(""Aborting session driver"");
    running = false;
    cmNotifier.clearCalls();
    cmNotifier.doShutdown();
    server.stop();
    incomingCallExecutor.interrupt();
  }",Abort the session driver.
"public static boolean isEnabled(UICommand command, UIContext context)
   {
      return (command.isEnabled(context) && !(command instanceof UIWizardStep));
   }",Returns true if the command is enabled.
"@Override
    public DescribeAddressesResult describeAddresses(DescribeAddressesRequest request) {
        request = beforeClientExecution(request);
        return executeDescribeAddresses(request);
    }",Retrieves a list of addresses for a specific class.
"protected void setSubMenuPosition(final A_CmsContextMenuItem item) {

        int scrollLeft = Window.getScrollLeft();
        int scrollTop = Window.getScrollTop();

        // calculate the left space
        // add 10 because of the shadow and for avoiding that the browser's right window border touches the sub menu
        int leftSpace = item.getAbsoluteLeft() - (scrollLeft + 10);
        // calculate the right space
        // add 10 because of the shadow and for avoiding that the browser's left window border touches the sub menu
        int rightSpace = Window.getClientWidth() - (item.getAbsoluteLeft() + item.getOffsetWidth() + 10);
        // if the width of the sub menu is smaller than the right space, show the sub menu on the right
        boolean showRight = item.getSubMenu().getOffsetWidth() < rightSpace;
        if (!showRight) {
            // if the width of the sub menu is larger than the right space, compare the left space with the right space
            // and show the sub menu on the right if on the right is more space than on the left
            showRight = leftSpace < rightSpace;
        }

        // calculate the top space
        // add 10 because of the shadow and for avoiding that the browser's top window border touches the sub menu
        int topSpace = (item.getAbsoluteTop() - scrollTop) + 10;
        // calculate the bottom space
        // add 10 because of the shadow and for avoiding that the browser's bottom window border touches the sub menu
        int bottomSpace = (Window.getClientHeight() + scrollTop) - (item.getAbsoluteTop() + 10);
        // if the height of the sub menu is smaller than the bottom space, show the sub menu on the bottom
        boolean showBottom = item.getSubMenu().getOffsetHeight() < bottomSpace;
        if (!showBottom) {
            // if the height of the sub menu is larger than the bottom space, compare the top space with
            // the bottom space and show the sub menu on the bottom if on the bottom is more space than on the top
            showBottom = topSpace < bottomSpace;
        }

        int left;
        int top;

        if (showBottom) {
            top = item.getAbsoluteTop() - 4;
        } else {
            top = ((item.getAbsoluteTop() - item.getSubMenu().getOffsetHeight()) + item.getOffsetHeight()) - 4;
        }

        if (showRight) {
            left = (item.getAbsoluteLeft() + item.getOffsetWidth()) - 4;
        } else {
            left = item.getAbsoluteLeft() - item.getSubMenu().getOffsetWidth() - 4;
        }

        // in case of fixed popup position, subtract the scroll position
        if (m_isFixed) {
            left -= scrollLeft;
            top -= scrollTop;
        }

        // finally set the position of the popup
        m_popup.setPopupPosition(left, top);
    }",Sets the position of the sub menu.
"public StringAssert isString() {
        Node node = assertType(STRING);
        return new StringAssert((String) node.getValue()).as(""Different value found in node \""%s\"""", path);
    }",Assert that a string node is present in the resource store.
"public void openLoginTarget(String loginTarget, boolean isPublicPC) {

        // login was successful, remove login init data from session
        VaadinService.getCurrentRequest().getWrappedSession().removeAttribute(INIT_DATA_SESSION_ATTR);
        m_targetOpener.openTarget(loginTarget, isPublicPC);
    }",Open the login target.
"protected base_resource[] get_nitro_bulk_response(nitro_service service, String response) throws Exception
	{
		network_interface_responses result = (network_interface_responses) service.get_payload_formatter().string_to_resource(network_interface_responses.class, response);
		if(result.errorcode != 0)
		{
			if (result.errorcode == SESSION_NOT_EXISTS)
				service.clear_session();
			throw new nitro_exception(result.message, result.errorcode, (base_response [])result.network_interface_response_array);
		}
		network_interface[] result_network_interface = new network_interface[result.network_interface_response_array.length];
		
		for(int i = 0; i < result.network_interface_response_array.length; i++)
		{
			result_network_interface[i] = result.network_interface_response_array[i].network_interface[0];
		}
		
		return result_network_interface;
	}",Use this API to fetch array of network_interface_responses resources of given name.
"protected void addPoint(double time, RandomVariable value, boolean isParameter) {
		synchronized (rationalFunctionInterpolationLazyInitLock) {
			if(interpolationEntity == InterpolationEntity.LOG_OF_VALUE_PER_TIME && time == 0) {
				boolean containsOne = false; int index=0;
				for(int i = 0; i< value.size(); i++){if(value.get(i)==1.0) {containsOne = true; index=i; break;}}
				if(containsOne && isParameter == false) {
					return;
				} else {
					throw new IllegalArgumentException(""The interpolation method LOG_OF_VALUE_PER_TIME does not allow to add a value at time = 0 other than 1.0 (received 1 at index"" + index + "")."");
				}
			}

			RandomVariable interpolationEntityValue = interpolationEntityFromValue(value, time);

			int index = getTimeIndex(time);
			if(index >= 0) {
				if(points.get(index).value == interpolationEntityValue) {
					return;			// Already in list
				} else if(isParameter) {
					return;
				} else {
					throw new RuntimeException(""Trying to add a value for a time for which another value already exists."");
				}
			}
			else {
				// Insert the new point, retain ordering.
				Point point = new Point(time, interpolationEntityValue, isParameter);
				points.add(-index-1, point);

				if(isParameter) {
					// Add this point also to the list of parameters
					int parameterIndex = getParameterIndex(time);
					if(parameterIndex >= 0) {
						new RuntimeException(""CurveFromInterpolationPoints inconsistent."");
					}
					pointsBeingParameters.add(-parameterIndex-1, point);
				}
			}
			rationalFunctionInterpolation = null;
			curveCacheReference = null;
		}
	}",Adds a point to the curve.
"private void assignTotalPrivate(XAttributable element, Double total) {
		if (total != null && total > 0.0) {
			XAttributeContinuous attr = (XAttributeContinuous) ATTR_TOTAL
					.clone();
			attr.setValue(total);
			element.getAttributes().put(KEY_TOTAL, attr);
		}
	}",Assigns the total attribute to an element.
"@Override
	public void intervalAdded(ListDataEvent e) {
		//retrieve the most recently added process and display it
		DefaultListModel listModel = (DefaultListModel) e.getSource();
		ActiveProcess process = (ActiveProcess) listModel.get(listModel.getSize() - 1);
		addProcessTab(process, outputPanel);
	}",Called when an interval is added to the list.
"@Override
    public AbstractGauge init(final int WIDTH, final int HEIGHT) {
        if (WIDTH <= 1 || HEIGHT <= 1) {
            return this;
        }

        CENTER.setLocation(INNER_BOUNDS.getCenterX() - getInsets().top, INNER_BOUNDS.getCenterX() - getInsets().top);

        if (!isFrameVisible()) {
            setFramelessOffset(-getInnerBounds().width * 0.0841121495, -getInnerBounds().width * 0.0841121495);
        } else {
            setFramelessOffset(getInnerBounds().x, getInnerBounds().y);
        }

        // Create Background Image
        if (bImage != null) {
            bImage.flush();
        }
        bImage = UTIL.createImage(WIDTH, WIDTH, Transparency.TRANSLUCENT);

        // Create Foreground Image
        if (fImage != null) {
            fImage.flush();
        }
        fImage = UTIL.createImage(WIDTH, WIDTH, Transparency.TRANSLUCENT);

        if (isFrameVisible()) {
            switch (getFrameType()) {
                case ROUND:
                    FRAME_FACTORY.createRadialFrame(WIDTH, getFrameDesign(), getCustomFrameDesign(), getFrameEffect(), bImage);
                    break;
                case SQUARE:
                    FRAME_FACTORY.createLinearFrame(WIDTH, WIDTH, getFrameDesign(), getCustomFrameDesign(), getFrameEffect(), bImage);
                    break;
                default:
                    FRAME_FACTORY.createRadialFrame(WIDTH, getFrameDesign(), getCustomFrameDesign(), getFrameEffect(), bImage);
                    break;
            }
        }

        if (isBackgroundVisible()) {
            create_BACKGROUND_Image(WIDTH, bImage);
        }

        create_TICKMARKS_Image(WIDTH, bImage);

        if (hourImage != null) {
            hourImage.flush();
        }
        hourImage = create_HOUR_Image(WIDTH);

        if (hourShadowImage != null) {
            hourShadowImage.flush();
        }
        hourShadowImage = create_HOUR_SHADOW_Image(WIDTH);

        if (minuteImage != null) {
            minuteImage.flush();
        }
        minuteImage = create_MINUTE_Image(WIDTH);

        if (minuteShadowImage != null) {
            minuteShadowImage.flush();
        }
        minuteShadowImage = create_MINUTE_SHADOW_Image(WIDTH);

        if (knobImage != null) {
            knobImage.flush();
        }
        knobImage = create_KNOB_Image(WIDTH);

        if (secondImage != null) {
            secondImage.flush();
        }
        secondImage = create_SECOND_Image(WIDTH);

        if (secondShadowImage != null) {
            secondShadowImage.flush();
        }
        secondShadowImage = create_SECOND_SHADOW_Image(WIDTH);

        if (topKnobImage != null) {
            topKnobImage.flush();
        }
        topKnobImage = create_TOP_KNOB_Image(WIDTH);

        if (isForegroundVisible()) {
            switch (getFrameType()) {
                case SQUARE:
                    FOREGROUND_FACTORY.createLinearForeground(WIDTH, WIDTH, false, bImage);
                    break;

                case ROUND:

                default:
                    FOREGROUND_FACTORY.createRadialForeground(WIDTH, false, getForegroundType(), fImage);
                    break;
            }
        }

        if (disabledImage != null) {
            disabledImage.flush();
        }
        disabledImage = DISABLED_FACTORY.createRadialDisabled(WIDTH);

        return this;
    }",Initialize the AbstractGauge.
"@Override
	public EClass getIfcFan() {
		if (ifcFanEClass == null) {
			ifcFanEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI).getEClassifiers()
					.get(261);
		}
		return ifcFanEClass;
	}",Get the IfcFan feature from the IFFFanPackage.
"public static DoubleMatrix SVDValues(ComplexDoubleMatrix A) {
        int m = A.rows;
        int n = A.columns;
        DoubleMatrix S = new DoubleMatrix(min(m, n));
        double[] rwork = new double[5*min(m,n)];

        int info = NativeBlas.zgesvd('N', 'N', m, n, A.dup().data, 0, m, S.data, 0, null, 0, 1, null, 0, min(m,n), rwork, 0);

        if (info > 0) {
          throw new LapackConvergenceException(""GESVD"", info + "" superdiagonals of an intermediate bidiagonal form failed to converge."");
        }

        return S;
    }",Compute the SVD values of a complex matrix.
"private Document parseContents(Text node, Element domElement) throws UnmarshallingException {

    String textContent = node.getWholeText() != null ? node.getWholeText().trim() : null; 
    if (textContent == null || textContent.isEmpty()) {
      log.error(""Expected Base64 encoded address elements"");
      return null;
    }

    // First Base64-decode the contents ...
    //
    byte[] bytes = Base64.decode(textContent); 
    String addressElements = new String(bytes);

    // Then build a fake XML document holding the contents in element form.
    //

    // The elements represented in 'addressElements' may have a namespace prefix
    // so we find out if we need to include that in the XML definition.

    Map<String, String> bindings = getNamespaceBindings(domElement);

    StringBuilder sb = new StringBuilder();
    sb.append(""<?xml version=\""1.0\"" encoding=\""UTF-8\""?>"");
    sb.append(""<"" + domElement.getNodeName());
    for (Map.Entry<String, String> entry : bindings.entrySet()) {
      sb.append("" "" + entry.getKey() + ""=\"""" + entry.getValue() + ""\"""");
    }
    sb.append('>');
    sb.append(addressElements);
    sb.append(""</"" + domElement.getNodeName() + "">"");

    // Parse into an XML document.
    //
    try {
      Document doc = Configuration.getParserPool().parse(new ByteArrayInputStream(sb.toString().getBytes(""UTF-8"")));

      // Copy the input dom element and replace its child node with our new nodes.
      //
      Document newDoc = Configuration.getParserPool().newDocument();
      Element newDom = (Element) domElement.cloneNode(true);
      for (Map.Entry<String, String> entry : bindings.entrySet()) {
        newDom.setAttributeNS(XMLConstants.XMLNS_ATTRIBUTE_NS_URI, entry.getKey(), entry.getValue());
      }
      newDoc.adoptNode(newDom);
      for (Node child; (child = newDom.getFirstChild()) != null; newDom.removeChild(child))
        ;
      Node newChild = doc.getDocumentElement().getFirstChild();
      while (newChild != null) {
        Node importedChild = newDoc.importNode(newChild, true);
        newDom.appendChild(importedChild);
        newChild = newChild.getNextSibling();
      }
      newDoc.appendChild(newDom);

      return newDoc;
    }
    catch (IOException | XMLParserException e) {
      throw new UnmarshallingException(e);
    }
  }",Parse the contents of a text node into an XML document.
"private boolean checkForMagicBytes(int firstByte) throws IOException {
	byte[] fullMagic=null;
		for (int i=0;i<this.specificMagicByteArray.length;i++) {
			// compare first byte and decide if we want to read full magic
			int currentMagicFirstbyte=this.specificMagicByteArray[i][0] & 0xFF;
			if (firstByte==currentMagicFirstbyte) {
				if (fullMagic==null) { // read full magic
					fullMagic=new byte[4];
					fullMagic[0]=this.specificMagicByteArray[i][0];
					int maxByteRead=4;
					int totalByteRead=1;
					int readByte;
					while ((readByte=this.bin.read(fullMagic,totalByteRead,maxByteRead-totalByteRead))>-1) {
							totalByteRead+=readByte;
							if (totalByteRead>=maxByteRead) {
								break;
							}
					}
					if (totalByteRead!=maxByteRead) {
						return false;
					} 
				}
				// compare full magics
				if (BitcoinUtil.compareMagics(fullMagic,this.specificMagicByteArray[i])) {
					this.bin.reset();
					return true;
				}
			}
				
			} 
	return false;
}",Checks if the specific magic bytes are the same as the first byte.
"@Override
    public DeleteJobResult deleteJob(DeleteJobRequest request) {
        request = beforeClientExecution(request);
        return executeDeleteJob(request);
    }",Deletes an existing CDN image.
"private synchronized Producer<CloseableReference<CloseableImage>> getDataFetchSequence() {
    if (mDataFetchSequence == null) {
      Producer<EncodedImage> inputProducer = mProducerFactory.newDataFetchProducer();
      if (WebpSupportStatus.sIsWebpSupportRequired &&
          (!mWebpSupportEnabled || WebpSupportStatus.sWebpBitmapFactory == null)) {
        inputProducer = mProducerFactory.newWebpTranscodeProducer(inputProducer);
      }
      inputProducer = mProducerFactory.newAddImageTransformMetaDataProducer(inputProducer);
      inputProducer =
          mProducerFactory.newResizeAndRotateProducer(inputProducer, true, mImageTranscoderFactory);
      mDataFetchSequence = newBitmapCacheGetToDecodeSequence(inputProducer);
    }
    return mDataFetchSequence;
  }",Get the data fetch sequence.
"public ConsulResponse<List<HealthCheck>> getChecksByState(Status status) {
        return getChecksByState(status, null, null, RequestOptions.BLANK);
    }",Get checks by state
"public boolean isArtefactOfType(String artefactType, @SuppressWarnings(""rawtypes"") Class theClazz) {
        ArtefactHandler handler = artefactHandlersByName.get(artefactType);
        if (handler == null) {
            throw new GrailsConfigurationException(
                    ""Unable to locate arefact handler for specified type: "" + artefactType);
        }

        return handler.isArtefact(theClazz);
    }",Checks if an arefact of the specified type is associated with the specified class.
"@Override
    public void handle(Response<ByteSource> rs) throws RestEndpointIOException {
        if (!hasError(rs)) {
            return;
        }

        handleError(rs.getUri(), rs.getHttpMethod(), rs.getStatus(), rs.getReason(), rs.getBody());

    }",Handle a response from a REST endpoint.
"public static TimeZoneGenericNames getInstance(ULocale locale) {
        String key = locale.getBaseName();
        return GENERIC_NAMES_CACHE.getInstance(key, locale);
    }",Gets the generic names for the given locale.
"static void copy(final Configuration conf, final Arguments args
      ) throws IOException {
    DistCopier copier = getCopier(conf, args);
    
    if (copier != null) {
      try {
        JobClient client = copier.getJobClient();
        RunningJob job = client.submitJob(copier.getJobConf());
        try {
          if (!client.monitorAndPrintJob(copier.getJobConf(), job)) {
            throw new IOException(""Job failed!"");
          }
        } catch (InterruptedException ie) {
          Thread.currentThread().interrupt();
        }
        copier.finalizeCopiedFiles();
      } finally {
        copier.cleanupJob();
      }
    }
  }",Copy a single file from a source to another source.
"public static long readNumberFromFile(final Path filePath)
      throws IOException, NumberFormatException {
    final List<String> allLines = Files.readAllLines(filePath);
    if (!allLines.isEmpty()) {
      return Long.parseLong(allLines.get(0));
    } else {
      throw new NumberFormatException(""unable to parse empty file "" + filePath.toString());
    }
  }",Read number from file.
"public static AttributeType get(final String _name)
        throws CacheReloadException
    {
        final Cache<String, AttributeType> cache = InfinispanCache.get().<String, AttributeType>getCache(
                        AttributeType.NAMECACHE);
        if (!cache.containsKey(_name)) {
            AttributeType.getAttributeTypeFromDB(AttributeType.SQL_NAME, _name);
        }
        return cache.get(_name);
    }",Get the AttributeType object from cache.
"private String pathToItem(String id) {
		return subDirForId(id) + UNIX_PATH_SEPERATOR + id.substring(SUBDIR_POLICY);
	}",Returns the path to the item for the given id.
"public void setBrokerEngineTypes(java.util.Collection<BrokerEngineType> brokerEngineTypes) {
        if (brokerEngineTypes == null) {
            this.brokerEngineTypes = null;
            return;
        }

        this.brokerEngineTypes = new java.util.ArrayList<BrokerEngineType>(brokerEngineTypes);
    }",Sets the value of the brokerEngineTypes property.
"public static Bitmap createScreenshot(Context context) {
        if (!hasScreenshotPermission(context)) {
            LogUtils.log(ScreenshotUtils.class, Log.ERROR, ""Screenshot permission denied."");
            return null;
        }

        final WindowManager windowManager =
                (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);

        final Bitmap bitmap = SurfaceControlCompatUtils.screenshot(0, 0);

        // Bail if we couldn't take the screenshot.
        if (bitmap == null) {
            LogUtils.log(ScreenshotUtils.class, Log.ERROR, ""Failed to take screenshot."");
            return null;
        }

        final int width = bitmap.getWidth();
        final int height = bitmap.getHeight();
        final int rotation = windowManager.getDefaultDisplay().getRotation();

        final int outWidth;
        final int outHeight;
        final float rotationDegrees;

        switch (rotation) {
            case Surface.ROTATION_90:
                outWidth = height;
                outHeight = width;
                rotationDegrees = 90;
                break;
            case Surface.ROTATION_180:
                outWidth = width;
                outHeight = height;
                rotationDegrees = 180;
                break;
            case Surface.ROTATION_270:
                outWidth = height;
                outHeight = width;
                rotationDegrees = 270;
                break;
            default:
                return bitmap;
        }

        // Rotate the screenshot to match the screen orientation.
        final Bitmap rotatedBitmap =
                Bitmap.createBitmap(outWidth, outHeight, Bitmap.Config.RGB_565);
        final Canvas c = new Canvas(rotatedBitmap);

        c.translate(outWidth / 2.0f, outHeight / 2.0f);
        c.rotate(-rotationDegrees);
        c.translate(-width / 2.0f, -height / 2.0f);
        c.drawBitmap(bitmap, 0, 0, null);

        bitmap.recycle();

        return rotatedBitmap;
    }",Creates a screenshot of the application.
"public void requestFlushAtSource(boolean indoubtDiscard) throws SIMPRuntimeOperationFailedException, SIMPControllableNotFoundException
  {
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.entry(tc, ""requestFlushAtSource"", new Boolean(indoubtDiscard));

    assertValidControllable();

    SIBUuid8 source = streamSet.getRemoteMEUuid();
    SIBUuid12 destID = streamSet.getDestUuid();
    SIBUuid8 busID = streamSet.getBusUuid();
    try
    {
      //TODO pass through the indoubtDiscard flag      
      tsm.requestFlushAtSource(source, destID, busID, streamID, indoubtDiscard);
    }
    catch (SIException e)
    {
      FFDCFilter.processException(
        e,
        ""com.ibm.ws.sib.processor.runtime.TargetStreamSetControl.requestFlushAtSource"",
        ""1:152:1.16"",
        this);
      
      SIMPRuntimeOperationFailedException finalE =
        new SIMPRuntimeOperationFailedException(
          nls.getFormattedMessage(
            ""INTERNAL_MESSAGING_ERROR_CWSIP0003"",
            new Object[] {""TargetStreamSetControl.requestFlushAtSource"",
                ""1:160:1.16"",
                          e,
                          streamID},
            null), e);

      SibTr.exception(tc, finalE);
      if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(tc, ""requestFlushAtSource"", finalE);
      throw finalE;             
    }
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.exit(tc, ""requestFlushAtSource"");
  }",This method is called by the ControlHandler to request a flush of a single stream.
"public OvhFailoverIp project_serviceName_ip_failover_id_attach_POST(String serviceName, String id, String instanceId) throws IOException {
		String qPath = ""/cloud/project/{serviceName}/ip/failover/{id}/attach"";
		StringBuilder sb = path(qPath, serviceName, id);
		HashMap<String, Object>o = new HashMap<String, Object>();
		addBody(o, ""instanceId"", instanceId);
		String resp = exec(qPath, ""POST"", sb.toString(), o);
		return convertTo(resp, OvhFailoverIp.class);
	}",Attach an IP failover to an instance
"public void writeOut(Writer writer) throws IOException {

	Entity e = root;
	while (e.next != null) {
	    e = e.next;
	    writer.write(e.data);
	}
	writer.write(buffer, 0, pos);
    }",Write out the content of this node.
"public static <T> T[] addAll(final T[] array1, final T[] array2)
    {
        if (array1 == null)
        {
            return shallowCopy(array2);
        }
        else if (array2 == null)
        {
            return shallowCopy(array1);
        }
        final T[] newArray = (T[]) Array.newInstance(array1.getClass().getComponentType(), array1.length + array2.length);
        System.arraycopy(array1, 0, newArray, 0, array1.length);
        System.arraycopy(array2, 0, newArray, array1.length, array2.length);
        return newArray;
    }",Add all the elements of two array.
"private static void createCode(String packageName, 
            String className, ObjectSchema schema, Set<SyntaxToJavaClass.ClassInfo> imports, File outputFile) 
        throws IOException, TemplateException {
        
        Configuration freeMarkerConfiguration = new Configuration();

        freeMarkerConfiguration.setClassForTemplateLoading(DEFAULT_LOADER_CLASS, """");
        freeMarkerConfiguration.setObjectWrapper(new DefaultObjectWrapper());

        // Build the model for FreeMarker
        Map<String, Object> model = new HashMap<String, Object>();
        model.put(""package"", packageName);
        model.put(""class"", className);
        model.put(""schema"", schema);
        model.put(""imports"", imports); 
 
        // Have FreeMarker process the model with the template
        Template template = freeMarkerConfiguration.getTemplate(TEMPLATE_FILE);
        
        if (LOG.isDebugEnabled()) {
            Writer out = new OutputStreamWriter(System.out);
            template.process(model, out);
            out.flush();
        }
    
        LOG.debug(String.format(""Writing java to: %1$s"", outputFile.getAbsolutePath()));
    
        FileOutputStream outputStream=new FileOutputStream(outputFile);
        Writer out = new OutputStreamWriter(outputStream);
        template.process(model, out);
        out.flush(); 
        out.close(); 
    }",Create code for the CIDCTYPE
"public void setMatcher(Matcher<? super T> matcher) {
        this.matcher = matcher;
        if (matcher instanceof PathAware) {
            ((PathAware) matcher).setPathProvider(this);
        }
    }",Sets the matcher.
"public static double scale(double x, double fromMin, double fromMax,
            double toMin, double toMax, boolean bounded) {
        double result = (toMax - toMin) / (fromMax - fromMin) * (x - fromMin)
                + toMin;
        return bounded ? Op.bound(x, toMin, toMax) : result;
    }",Scales a value of a resource bundle by a number of points.
"public boolean setPassword(final String _name,
                               final String _newpasswd,
                               final String _oldpasswd)
        throws LoginException
    {
        boolean ret = false;

        final LoginContext login = new LoginContext(
                this.application,
                new SetPasswordCallbackHandler(ActionCallback.Mode.SET_PASSWORD, _name, _newpasswd, _oldpasswd));
        login.login();
        ret = true;
        return ret;
    }",Set the password.
"public void dispose() {
		removeAll();
		if (lightMap != null) lightMap.dispose();
		if (lightShader != null) lightShader.dispose();
	}",Disposes all the lights.
"public NotificationChain basicSetForExpression(XExpression newForExpression, NotificationChain msgs)
	{
		XExpression oldForExpression = forExpression;
		forExpression = newForExpression;
		if (eNotificationRequired())
		{
			ENotificationImpl notification = new ENotificationImpl(this, Notification.SET, XbasePackage.XFOR_LOOP_EXPRESSION__FOR_EXPRESSION, oldForExpression, newForExpression);
			if (msgs == null) msgs = notification; else msgs.add(notification);
		}
		return msgs;
	}",Add a basic set for expression notification.
"public static String parseFileExtension(String filename) {
        // if null, return null
        if (filename == null) {
            return null;
        }
        // find position of last period
        int pos = filename.lastIndexOf('.');
        // did one exist or have any length?
        if (pos < 0 || (pos+1) >= filename.length()) {
            return null;
        }
        // parse extension
        return filename.substring(pos+1);
    }",Parse the file extension.
"void copyToLocal(String[]argv, int pos) throws IOException {
    CommandFormat cf = new CommandFormat(""copyToLocal"", 2,2,""crc"",""ignoreCrc"");
    
    String srcstr = null;
    String dststr = null;
    try {
      List<String> parameters = cf.parse(argv, pos);
      srcstr = parameters.get(0);
      dststr = parameters.get(1);
    }
    catch(IllegalArgumentException iae) {
      System.err.println(""Usage: java FreightStreamer "" + GET_SHORT_USAGE);
      throw iae;
    }
    boolean copyCrc = cf.getOpt(""crc"");
    final boolean verifyChecksum = !cf.getOpt(""ignoreCrc"");

    if (dststr.equals(""-"")) {
      if (copyCrc) {
        System.err.println(""-crc option is not valid when destination is stdout."");
      }
      cat(srcstr, verifyChecksum);
    } else {
      File dst = new File(dststr);      
      Path srcpath = new Path(srcstr);
      FileSystem srcFS = getSrcFileSystem(srcpath, verifyChecksum);
      if (copyCrc && !(srcFS instanceof ChecksumFileSystem)) {
        System.err.println(""-crc option is not valid when source file system "" +
            ""does not have crc files. Automatically turn the option off."");
        copyCrc = false;
      }
      FileStatus[] srcs = srcFS.globStatus(srcpath);
      boolean dstIsDir = dst.isDirectory(); 
      if (srcs.length > 1 && !dstIsDir) {
        throw new IOException(""When copying multiple files, ""
                              + ""destination should be a directory."");
      }
      for (FileStatus status : srcs) {
        Path p = status.getPath();
        File f = dstIsDir? new File(dst, p.getName()): dst;
        copyToLocal(srcFS, p, f, copyCrc);
      }
    }
  }",Copy a file or directory to a local file system.
"protected final void notifyOnAreaHidden(@NonNull final Area area) {
        for (AreaListener listener : areaListeners) {
            listener.onAreaHidden(area);
        }
    }",Notifies all registered listeners that an area has been hidden.
"public ServiceFuture<CertificatePolicy> updateCertificatePolicyAsync(String vaultBaseUrl, String certificateName, CertificatePolicy certificatePolicy, final ServiceCallback<CertificatePolicy> serviceCallback) {
        return ServiceFuture.fromResponse(updateCertificatePolicyWithServiceResponseAsync(vaultBaseUrl, certificateName, certificatePolicy), serviceCallback);
    }",Updates a certificate policy.
"public void setMessage(String message) {
        requireArgument(message != null && !message.isEmpty(), ""Message cannot be null or empty."");
        this.message = message;
    }",Sets the message of the exception.
"public static Event post(@NonNull String eventKey) {
        return new Event.Builder(dispatcher, eventKey).post();
    }",Post an event to the application.
"@ArgumentsChecked
	@Throws({ IllegalNullArgumentException.class, IllegalNullElementsException.class })
	public static <T extends Iterable<?>> T noNullElements(@Nonnull final T iterable, final String name) {
		Check.notNull(iterable, ""iterable"");
		for (final Object element : iterable) {
			if (element == null) {
				throw new IllegalNullElementsException(name);
			}
		}
		return iterable;
	}",Returns an iterable that contains all elements that are null.
"public HttpResponse doHttpCall(final String urlString,
			final String stringToSend) throws IOException {
		return this.doHttpCall(urlString, stringToSend, """", """", """", 0,
				Collections.<String, String> emptyMap());
	}",Perform a HTTP call to a URL.
"@ArgumentsChecked
	@Throws(IllegalNullArgumentException.class)
	public static byte checkByte(@Nonnull final Number number) {
		Check.notNull(number, ""number"");
		if (!isInByteRange(number)) {
			throw new IllegalNumberRangeException(number.toString(), BYTE_MIN, BYTE_MAX);
		}

		return number.byteValue();
	}",Checks if a given number is in the range of a byte.
"public void decode(AsnInputStream ais) throws ParseException {

        try {
            AsnInputStream localAis = ais.readSequenceStream();

            int tag = localAis.readTag();
            if (tag != _TAG_IID || localAis.getTagClass() != Tag.CLASS_UNIVERSAL) {
                throw new ParseException(null, GeneralProblemType.MistypedComponent,
                        ""Error while decoding ReturnLast: bad tag or tag class for InvokeID: tag="" + tag + "", tagClass = ""
                                + localAis.getTagClass());
            }

            this.invokeId = localAis.readInteger();

            if (localAis.available() <= 0)
                return;

            tag = localAis.readTag();
            if (tag != Tag.SEQUENCE || localAis.getTagClass() != Tag.CLASS_UNIVERSAL) {
                throw new ParseException(null, GeneralProblemType.MistypedComponent,
                        ""Error while decoding ReturnLast: bad tag or tag class for sequence: tag="" + tag + "", tagClass = ""
                                + localAis.getTagClass());
            }

            // sequence of OperationCode
            AsnInputStream sequenceStream = localAis.readSequenceStream();

            tag = sequenceStream.readTag();
            if (tag != OperationCode._TAG_GLOBAL && tag != OperationCode._TAG_LOCAL
                    || localAis.getTagClass() != Tag.CLASS_UNIVERSAL) {
                throw new ParseException(null, GeneralProblemType.MistypedComponent,
                        ""Error while decoding ReturnLast: bad tag or tag class for operationCode: tag="" + tag + "", tagClass = ""
                                + localAis.getTagClass());
            }
            this.operationCode = TcapFactory.createOperationCode(tag, sequenceStream);

            tag = sequenceStream.readTag();
            this.parameter = TcapFactory.createParameter(tag, sequenceStream, true);

        } catch (IOException e) {
            throw new ParseException(null, GeneralProblemType.BadlyStructuredComponent,
                    ""IOException while decoding ReturnResult: "" + e.getMessage(), e);
        } catch (AsnException e) {
            throw new ParseException(null, GeneralProblemType.BadlyStructuredComponent,
                    ""AsnException while decoding ReturnResult: "" + e.getMessage(), e);
        } catch (ParseException e) {
            e.setInvokeId(this.invokeId);
            throw e;
        }

    }",Decode the ReturnLast value from the passed in AsnInputStream.
"protected void commitOrRollback(boolean doCommit) {
		if (log.isDebugEnabled()) {
			if (doCommit) {
				log.debug(""Commit JTX"");
			} else {
				log.debug(""Rollback JTX"");
			}
		}
		boolean forcedRollback = false;
		if (!isNoTransaction()) {
			if (isRollbackOnly()) {
				if (doCommit) {
					doCommit = false;
					forcedRollback = true;
				}
			} else if (!isActive()) {
				if (isCompleted()) {
					throw new JtxException(""TX is already completed, commit or rollback should be called once per TX"");
				}
				throw new JtxException(""No active TX to "" + (doCommit ? ""commit"" : ""rollback""));
			}
		}
		if (doCommit) {
			commitAllResources();
		} else {
			rollbackAllResources(forcedRollback);
		}
	}",Commit or rollback the transaction.
"protected void write(String toWrite) throws IOException  {
    if(!okToWrite)
      throw new IOException(""file not open for writing."");

    if(printToScreen)
      System.out.print(toWrite);

    try {
      fw.write(toWrite);
    } catch (IOException e) {
      okToWrite = false;
      throw e;
    }
  }",Write a string to the file.
"@SuppressWarnings({ ""unchecked"", ""rawtypes"" })
	private <K,V> Region<K,V> createRegion(String regionName)
	{
		if(regionName.startsWith(""/""))
			regionName = regionName.substring(1); //remove prefix
		
	
		
		CacheListenerBridge<K, V> listener = (CacheListenerBridge)this.listenerMap.get(regionName);
		
		if(listener != null)
		{
			ClientRegionFactory<K, V> listenerRegionFactory = null;
			
			if(this.cachingProxy)
				listenerRegionFactory = this.clientCache.createClientRegionFactory(ClientRegionShortcut.CACHING_PROXY);	
			else
				listenerRegionFactory = this.clientCache.createClientRegionFactory(ClientRegionShortcut.PROXY);
			
			listenerRegionFactory.addCacheListener((CacheListener)listener);
			
			Region<K,V> region = listenerRegionFactory.create(regionName);
			
			region.registerInterestRegex("".*"");
			return region;
			
		}
		
		if(this.cachingProxy)
			return (Region<K,V>)this.cachingRegionfactory.create(regionName);
		else
			return (Region<K,V>)this.proxyRegionfactory.create(regionName);
		
		
	}",Create a region.
"protected <C> List<List<C>> deserializeIntoList( JsonReader reader, JsonDeserializationContext ctx, JsonDeserializer<C> deserializer,
                                                     JsonDeserializerParameters params ) {
        List<List<C>> list;

        reader.beginArray();
        JsonToken token = reader.peek();

        if ( JsonToken.END_ARRAY == token ) {

            // empty array, no need to create a list
            list = Collections.emptyList();

        } else {

            list = doDeserializeIntoList( reader, ctx, deserializer, params, token );

        }

        reader.endArray();
        return list;
    }",Deserialize into list.
"public static boolean rename(File pFrom, String pTo, boolean pOverWrite) throws IOException {
        return rename(pFrom, new File(pTo), pOverWrite);
    }",Rename a file from one location to another.
"public QueryParameters getProcedureParameters(Connection conn, String catalogName, String schemaName, String procedureName,
                                                  boolean useCache) throws SQLException {
        DatabaseMetaData metaData = conn.getMetaData();

        String userName = metaData.getUserName();
        String dbProductName = MetadataUtils.processDatabaseProductName(metaData.getDatabaseProductName());

        String catalogNameProcessed = processCatalogName(dbProductName, userName, catalogName);
        String schemaNameProcessed = processSchemaName(dbProductName, userName, schemaName);
        String procedureNameProcessed = processProcedureName(dbProductName, procedureName);

        StoredProcedure requiredStoredProcedure = new StoredProcedure(catalogName, schemaName, procedureName);

        if (useCache == false || this.procedureParameters.containsKey(requiredStoredProcedure) == false) {
            updateCache(metaData, catalogNameProcessed, schemaNameProcessed, procedureNameProcessed);
        }

        List<StoredProcedure> foundStoredProcedures = new ArrayList<StoredProcedure>();

        // TODO Optimize
        for (StoredProcedure storedProcedure : this.procedureParameters.keySet()) {
            if (requiredStoredProcedure.equals(storedProcedure) == true) {
                foundStoredProcedures.add(storedProcedure);
            }
        }

        if (foundStoredProcedures.size() == 0) {
            throw new MjdbcSQLException(""Haven't found procedure matching required parameters: "" + requiredStoredProcedure);
        } else if (foundStoredProcedures.size() > 1) {
            throw new MjdbcSQLException(""Found more than one procedure matching required parameters. Searched: "" + requiredStoredProcedure + ""\nGot: "" + foundStoredProcedures.toString());
        }

        return this.procedureParameters.get(foundStoredProcedures.get(0));
    }",Gets the parameters of a single SQL statement.
"@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case AfplibPackage.OBJECT_FUNCTION_SET_SPECIFICATION__OBJ_TYPE:
				setObjType((Integer)newValue);
				return;
			case AfplibPackage.OBJECT_FUNCTION_SET_SPECIFICATION__ARCH_VRSN:
				setArchVrsn((Integer)newValue);
				return;
			case AfplibPackage.OBJECT_FUNCTION_SET_SPECIFICATION__DCA_FN_SET:
				setDCAFnSet((Integer)newValue);
				return;
			case AfplibPackage.OBJECT_FUNCTION_SET_SPECIFICATION__OCA_FN_SET:
				setOCAFnSet((Integer)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}",Override the eSet method for the featureID
"protected void precomputeInterestingRadii(DBIDs ids, RangeQuery<O> rangeQuery, WritableDataStore<DoubleIntArrayList> interestingDistances) {
    FiniteProgress progressPreproc = LOG.isVerbose() ? new FiniteProgress(""LOCI preprocessing"", ids.size(), LOG) : null;
    for(DBIDIter iditer = ids.iter(); iditer.valid(); iditer.advance()) {
      DoubleDBIDList neighbors = rangeQuery.getRangeForDBID(iditer, rmax);
      // build list of critical distances
      DoubleIntArrayList cdist = new DoubleIntArrayList(neighbors.size() << 1);
      {
        int i = 0;
        DoubleDBIDListIter ni = neighbors.iter();
        while(ni.valid()) {
          final double curdist = ni.doubleValue();
          ++i;
          ni.advance();
          // Skip, if tied to the next object:
          if(ni.valid() && curdist == ni.doubleValue()) {
            continue;
          }
          cdist.append(curdist, i);
          // Scale radius, and reinsert
          if(alpha != 1.) {
            final double ri = curdist / alpha;
            if(ri <= rmax) {
              cdist.append(ri, Integer.MIN_VALUE);
            }
          }
        }
      }
      cdist.sort();

      // fill the gaps to have fast lookups of number of neighbors at a given
      // distance.
      int lastk = 0;
      for(int i = 0, size = cdist.size(); i < size; i++) {
        final int k = cdist.getInt(i);
        if(k == Integer.MIN_VALUE) {
          cdist.setValue(i, lastk);
        }
        else {
          lastk = k;
        }
      }
      // TODO: shrink the list, removing duplicate radii?

      interestingDistances.put(iditer, cdist);
      LOG.incrementProcessed(progressPreproc);
    }
    LOG.ensureCompleted(progressPreproc);
  }",Precompute the interesting radii.
"public static <T> Spliterator<T> spliterator(Collection<? extends T> c,
                                                 int characteristics) {
        return new IteratorSpliterator<>(Objects.requireNonNull(c),
                                         characteristics);
    }",Creates a new iterator over the elements of the given collection of tokens.
"public VueTemplateCompilerResult compile(String htmlTemplate)
      throws VueTemplateCompilerException {
    ScriptObjectMirror templateCompilerResult;
    try {
      templateCompilerResult =
          (ScriptObjectMirror) engine.invokeFunction(""compile"", htmlTemplate);
    } catch (ScriptException | NoSuchMethodException e) {
      e.printStackTrace();
      throw new VueTemplateCompilerException(
          ""An error occurred while compiling the template: ""
              + htmlTemplate
              + "" -> ""
              + e.getMessage());
    }

    String renderFunction = (String) templateCompilerResult.get(""render"");
    String[] staticRenderFunctions =
        ((ScriptObjectMirror) templateCompilerResult.get(""staticRenderFns"")).to(String[].class);

    return new VueTemplateCompilerResult(renderFunction, staticRenderFunctions);
  }",Compile the HTML template
"protected Iterable<T> queryByField(Object ancestorKey, String fieldName, Object fieldValue) {
    Iterable values = supplier.queryIterable(getCurrentTransaction(), mapper, false, 0, -1,
      ancestorKey, null,
      null, false, null, false,
      Filter.equalsFilter(fieldName, fieldValue));
    return new MappingIterable<T, ID>(mapper, values.iterator());
  }",Query by field.
"File doDownload(String remoteRepos, String artifactAbsoluteHttpPath, String artifactRelativeHttpPath, ArtifactCoordinates artifactCoordinates, String packaging, File targetArtifactPomDirectory, File targetArtifactDirectory) {
        //Download POM
        File targetArtifactPomFile = new File(targetArtifactPomDirectory, toGradleArtifactFileName(artifactCoordinates, ""pom""));
        try {
            MavenArtifactUtil.downloadFile(artifactCoordinates + "":pom"", artifactAbsoluteHttpPath + ""pom"", targetArtifactPomFile);
        } catch (IOException e) {
            Module.getModuleLogger().trace(e, ""Could not doDownload '%s' from '%s' repository"", artifactRelativeHttpPath, remoteRepos);
            // try next one
        }

        //Download Artifact
        File targetArtifactFile = new File(targetArtifactDirectory, toGradleArtifactFileName(artifactCoordinates, packaging));
        try {
            MavenArtifactUtil.downloadFile(artifactCoordinates + "":"" + packaging, artifactAbsoluteHttpPath + packaging, targetArtifactFile);
            if (targetArtifactFile.exists()) {
                return targetArtifactFile;
            }
        } catch (IOException e) {
            Module.getModuleLogger().trace(e, ""Could not doDownload '%s' from '%s' repository"", artifactRelativeHttpPath, remoteRepos);
            // try next one
        }
        return null;
    }",Download a single image from the remote repository.
"public static String getRelativeURI( HttpServletRequest request, String uri, PageFlowController relativeTo )
    {
        String contextPath = request.getContextPath();
        if ( relativeTo != null ) contextPath += relativeTo.getModulePath();
        int overlap = uri.indexOf( contextPath + '/' );
        if ( overlap == -1 ) return null;
        return uri.substring( overlap + contextPath.length() );
    }",Get the relative URI of the URI.
"protected final PrcEmailMsgSave<RS>
    createPutPrcEmailMsgSave() throws Exception {
    PrcEmailMsgSave<RS> proc = new PrcEmailMsgSave<RS>();
    proc.setSrvOrm(getSrvOrm());
    proc.setEmailSender(getEmailSender());
    //assigning fully initialized object:
    this.processorsMap
      .put(PrcEmailMsgSave.class.getSimpleName(), proc);
    return proc;
  }",Create a PrcEmailMsgSave object.
"public static final Date getTimestampFromTenths(byte[] data, int offset)
   {
      long ms = ((long) getInt(data, offset)) * 6000;
      return (DateHelper.getTimestampFromLong(EPOCH + ms));
   }",Get a Date from the tenths.
"@SuppressWarnings(""unchecked"")
	public Q includeField(final String field) {
		if (this.fields == null) {
			this.fields = new HashSet<>();
		}

		if (field != null) {
			this.fields.add(field);
		}

		return (Q) this;
	}",Include a field in the result.
"public static CmsClientProperty createClientProperty(CmsProperty prop, boolean preserveOrigin) {

        CmsClientProperty result = new CmsClientProperty(
            prop.getName(),
            prop.getStructureValue(),
            prop.getResourceValue());
        if (preserveOrigin) {
            result.setOrigin(prop.getOrigin());
        }
        return result;
    }",Creates a new client property from a property.
"protected CrsId getCrsId(GeoJsonTo to) throws IllegalArgumentException {
        if (to.getCrs() == null) {
            return CrsId.UNDEFINED;
        } else {
            if (to.getCrs().getType() == null || !""name"".equals(to.getCrs().getType())) {
                throw new IllegalArgumentException(""If the crs is specified the type must be specified. Currently, only named crses are supported."");
            }
            if (to.getCrs().getProperties() == null || to.getCrs().getProperties().getName() == null) {
                throw new IllegalArgumentException(""A crs specification requires a properties value containing a name value."");
            }
            String sridString = to.getCrs().getProperties().getName();
            if (sridString.startsWith(""EPSG:"")) {
                Integer srid = parseDefault(sridString.substring(5), null);
                if (srid == null) {
                    throw new IllegalArgumentException(""Unable to derive SRID from crs name"");
                } else {
                    return new CrsId(""EPSG"", srid);
                }
            } else if (sridString.startsWith(""urn:ogc:def:crs:EPSG:"")) {
                String[] splits = sridString.split("":"");
                if (splits.length != 7) {
                    throw new IllegalArgumentException(""Unable to derive SRID from crs name"");
                } else {
                    Integer srid = parseDefault(splits[6], null);
                    if (srid == null) {
                        throw new IllegalArgumentException(""Unable to derive SRID from crs name"");
                    }
                    return new CrsId(""EPSG"", srid);
                }
            } else {
                throw new IllegalArgumentException(""Unable to derive SRID from crs name"");
            }
        }
    }",Get the SRID from the GeoJsonTo object.
"public static synchronized boolean removeDenyID(String id) {
		if(deniedID!=null && deniedID.remove(id)!=null) { 
			writeID();
			if(deniedID.isEmpty()) {
				deniedID=null;
			}

			return true;
		}
		return false;
	}",Removes a ID from the deniedID list.
"public int updateGridToMessage(BaseMessage message, boolean bReReadMessage, boolean bAddIfNotFound)
    {
        Record record = this.getRecord(); // Record changed
        int iHandleType = DBConstants.BOOKMARK_HANDLE;  // OBJECT_ID_HANDLE;
        if (this.getNextTable() instanceof org.jbundle.base.db.shared.MultiTable)
            iHandleType = DBConstants.FULL_OBJECT_HANDLE;
        Object bookmark = ((RecordMessageHeader)message.getMessageHeader()).getBookmark(iHandleType);
        int iRecordMessageType = ((RecordMessageHeader)message.getMessageHeader()).getRecordMessageType();
        // See if this record is currently displayed or buffered, if so, refresh and display.
        GridTable table = (GridTable)record.getTable();
        int iIndex = -1;
        if (iRecordMessageType == -1)
        {
            iIndex = table.bookmarkToIndex(bookmark, iHandleType);  // Find this bookmark in the table
        }
        else if (iRecordMessageType == DBConstants.CACHE_UPDATE_TYPE)
        {   // No need to update anything as this is just a notification that the cache has been updaed already.
            iIndex = table.bookmarkToIndex(bookmark, iHandleType);  // Find this bookmark in the table
        }
        else if (iRecordMessageType == DBConstants.SELECT_TYPE)
        {   // A secondary record was selected, update the secondary field to the new value.
            // Don't need to update the table for a select
        }
        else if (iRecordMessageType == DBConstants.AFTER_ADD_TYPE)
        {
            iIndex = table.refreshBookmark(bookmark, iHandleType, false);  // Double-check to see if it has already been added
            if (iIndex == -1)
            {
                if (bAddIfNotFound)
                {   // Note: It might be nice to check this filter in the message on the server, then I don't change to read and check it.
                    try {
                        record = record.setHandle(bookmark, iHandleType);
                        // Fake the handleCriteria to think this is a slave. NOTE: This is not cool in a multitasked environment.
                        int iDBMasterSlave = record.getTable().getCurrentTable().getDatabase().getMasterSlave();
                        record.getTable().getCurrentTable().getDatabase().setMasterSlave(RecordOwner.MASTER | RecordOwner.SLAVE);
                        boolean bMatch = record.handleRemoteCriteria(null, false, null);
                        record.getTable().getCurrentTable().getDatabase().setMasterSlave(iDBMasterSlave);
                        if (bMatch)
                        {
                            iHandleType = DBConstants.DATA_SOURCE_HANDLE;
                            bookmark = this.getDataRecord(m_bCacheRecordData, BaseBuffer.SELECTED_FIELDS);
                        }
                        else
                            bookmark = null;
                    } catch (DBException e) {
                        e.printStackTrace();
                    }
                    if (bookmark != null)
                        iIndex = table.addNewBookmark(bookmark, iHandleType);   // Add this new record to the table
                }
            }
        }
        else
        {
            iIndex = table.refreshBookmark(bookmark, iHandleType, bReReadMessage);  // Refresh the data for this bookmark
        }
        return iIndex;
    }",Update the grid table to the message.
"private List<String> getVariables(String routePath) {
		List<String> variables = new ArrayList<String>();

		Matcher matcher = Pattern.compile(Path.VAR_REGEXP).matcher(routePath);
		while (matcher.find()) {
			// group(0) always stands for the entire expression and we only want what is inside the {}
			variables.add(matcher.group(1));
		}

		return variables;
	}",Get the variables from the route path
"void createTable() {
        Connection con = null;
        java.sql.Statement s = null;

        //PK55900 We can pass in true to the getConnection method since this method,
        //createTable, is only called from the initDBSettings method.
        con = getConnection(true);
        if (con == null) {
            return;
        }

        try {

            try {
                s = con.createStatement();
                if (!getTableDefinition(con)) {
                    if (usingOracle) {
                        if (_smc.isUseOracleBlob()) { // cmd LI1963 start
                            s.executeUpdate(""create table ""
                                            + tableName
                                            + "" (id varchar(128) not null, propid varchar(128) not null, appname varchar(128) not null, listenercnt smallint, lastaccess integer, creationtime integer, maxinactivetime integer, username varchar(256), small raw(""
                                            + SMALLCOL_SIZE_ORACLE + ""), medium BLOB, large raw(1))"");
                        } else {
                            s.executeUpdate(""create table ""
                                            + tableName
                                            + "" (id varchar(128) not null, propid varchar(128) not null, appname varchar(128) not null, listenercnt smallint, lastaccess integer, creationtime integer, maxinactivetime integer, username varchar(256), small raw(""
                                            + SMALLCOL_SIZE_ORACLE + ""), medium long raw, large raw(1))"");
                        } // cmd LI1963 end
                    } else if (usingAS400DB2) {
                        try { //if using AS400, create collection first
                            s.executeUpdate(""CREATE COLLECTION "" + collectionName);
                        } catch (Exception e) {
                            com.ibm.ws.ffdc.FFDCFilter.processException(e, ""com.ibm.ws.session.store.db.DatabaseHashMap.createTable"", ""470"", con);
                        }
                        s.executeUpdate(""create table ""
                                        + tableName
                                        + "" (id varchar(128) not null, propid varchar(128) not null, appname varchar(128) not null, listenercnt smallint, lastaccess bigint, creationtime bigint, maxinactivetime integer, username varchar(256), small varchar(""
                                        + SMALLCOL_SIZE_DB2 + "") for bit data, medium long varchar for bit data, large BLOB(2M))"");
                    } else if (usingSybase) {
                        s.executeUpdate(""create table ""
                                        + tableName
                                        + "" (id varchar(128) not null, propid varchar(128) not null, appname varchar(128) not null, listenercnt smallint null, lastaccess numeric(21,0) null, creationtime numeric(21,0) null, maxinactivetime numeric(10,0) null, username varchar(255) null, small image null, medium image null, large image null)"");
                    } else if (usingSQLServer) {
                        s.executeUpdate(""create table ""
                                        + tableName
                                        + "" (id varchar(128) not null, propid varchar(128) not null, appname varchar(128) not null, listenercnt smallint null, lastaccess decimal(21,0) null, creationtime decimal(21,0) null, maxinactivetime integer null, username varchar(255) null, small image null, medium image null, large image null)"");
                    } else if (usingInformix) {
                        s.executeUpdate(""create table ""
                                        + tableName
                                        + "" (id varchar(128) not null, propid varchar(128) not null, appname varchar(128) not null, listenercnt smallint, lastaccess int8, creationtime int8, maxinactivetime integer, username varchar(255), small BYTE, medium BYTE, large BYTE)"");
                    } else if (usingCloudScape) {
                        s.executeUpdate(""create table ""
                                        + tableName
                                        + "" (id varchar(128) not null, propid varchar(128) not null, appname varchar(128) not null, listenercnt smallint, lastaccess bigint, creationtime bigint, maxinactivetime integer, username varchar(255), small LONG VARBINARY , medium char(1) , large char(1))"");
                    } else if (dbHandler != null) {
                        dbHandler.createTable(s, tableName);
                    } else if (!usingDB2Connect && !usingDB2zOS) { // LIDB2775.25 zOS
                        String tableSpaceName = "" "";
                        // a little overkill for this test
                        String configTableSpaceName = _smc.getTableSpaceName();
                        if (configTableSpaceName != null && !configTableSpaceName.equals("""") && configTableSpaceName.length() != 0)
                            tableSpaceName = "" in "" + configTableSpaceName;
                        if (usingSolidDB)
                            s.executeUpdate(""create table ""
                                        + tableName
                                        + "" (id varchar(128) not null, propid varchar(128) not null, appname varchar(128) not null, listenercnt smallint, lastaccess bigint, creationtime bigint, maxinactivetime integer, username varchar(256), small varchar(""
                                        + smallColSize + ""), medium long varchar, large BLOB(2M)) "" + tableSpaceName);
                        else
                            s.executeUpdate(""create table ""
                                        + tableName
                                        + "" (id varchar(128) not null, propid varchar(128) not null, appname varchar(128) not null, listenercnt smallint, lastaccess bigint, creationtime bigint, maxinactivetime integer, username varchar(256), small varchar(""
                                        + smallColSize + "") for bit data, medium long varchar for bit data, large BLOB(2M)) "" + tableSpaceName);
                    }
                }
                //            } catch (com.ibm.ejs.cm.portability.TableAlreadyExistsException eee) {
                //                // Do nothing since all is well!!
                //                com.ibm.ws.ffdc.FFDCFilter.processException(eee, ""com.ibm.ws.session.store.db.DatabaseHashMap.createTable"", ""495"", this);
            } catch (SQLException err) {
                com.ibm.ws.ffdc.FFDCFilter.processException(err, ""com.ibm.ws.session.store.db.DatabaseHashMap.createTable"", ""497"", this);
                if (!usingCloudScape) {
                    LoggingUtil.SESSION_LOGGER_WAS.logp(Level.SEVERE, methodClassName, methodNames[CREATE_TABLE], ""CommonMessage.exception"", err);
                } else {
                    if (err.getErrorCode() != 30000)
                        LoggingUtil.SESSION_LOGGER_WAS.logp(Level.SEVERE, methodClassName, methodNames[CREATE_TABLE], ""CommonMessage.exception"", err);
                }
            }

            if (!_smc.isSessionTableSkipIndexCreation()) { // PM37139

                //Creating index in a seperate step as we have seen customers missing this
                //step when they create the table manually
                try {
                    if (s == null)
                        s = con.createStatement();
                    if (usingSybase) {
                        s.executeUpdate(""create unique index sess_index on "" + tableName + "" (id, propid, appname)"");
                        s.executeUpdate(""alter table sessions lock datarows"");
                    } else if (usingSolidDB) {
                        s.executeUpdate(""create unique index sess_index on "" + tableName + "" (id, propid, appname)"");
                    } else if (usingAS400DB2) {
                        mediumColSize = mediumColSize - 2; //d154211
                        //PK56991: If multiple cluster members startup at the same time the
                        // combination of these DDLs can lock up for a substantial duration.
                        // We now execute these only if they do not exist.
                        if (!doesIndexExists(con, ""sess_index"")) {
                            s.executeUpdate(""create unique index "" + collectionName + "".sess_index on "" + tableName + "" (id,propid,appname)""); //tableName is already in the form of ""collectionName.tableName""
                            //PK56991 comment out marking table as volatile. The DB2 chief architect on iSeries
                            //team informed that VOLATILE clause is only compatible and improve performance on LUW
                            //s.executeUpdate(""alter table "" + tableName + "" volatile"");
                        } else if (com.ibm.websphere.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_WAS.isLoggable(Level.FINE)) {
                            LoggingUtil.SESSION_LOGGER_WAS.logp(Level.FINE, methodClassName, methodNames[CREATE_TABLE], ""Skip index creation"");
                        }
                    } else if (dbHandler != null) {
                        dbHandler.createIndex(con, s, tableName);
                    } else if (!usingDB2Connect && !usingDB2zOS) { // LIDB2775.25
                        //PK56991: Refer to detailed comment above
                        if (!doesIndexExists(con, ""sess_index"")) {
                            s.executeUpdate(""create unique index sess_index on "" + tableName + "" (id, propid, appname)"");//PK86373: changed sesscmd_index to sess_index
                        } else if (com.ibm.websphere.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_WAS.isLoggable(Level.FINE)) {
                            LoggingUtil.SESSION_LOGGER_WAS.logp(Level.FINE, methodClassName, methodNames[CREATE_TABLE], ""Skip index creation"");
                        }
                        //PK56991: We are marking the the session table as volatile if it is not
                        //done yet.
                        if (usingDB2 && !isTableMarkedVolatile(con)) {
                            s.executeUpdate(""alter table "" + tableName + "" volatile"");
                        } else if (com.ibm.websphere.ras.TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_WAS.isLoggable(Level.FINE)) {
                            LoggingUtil.SESSION_LOGGER_WAS.logp(Level.FINE, methodClassName, methodNames[CREATE_TABLE], ""Skip marking table volatile"");
                        }

                    }
                } catch (SQLException err) {
                    //Don't do any thing if it is only index already exists
                    //err.printStackTrace();
                    com.ibm.ws.ffdc.FFDCFilter.processException(err, ""com.ibm.ws.session.store.db.DatabaseHashMap.createTable"", ""526"", con);
                }
            } // END PM37139
        } finally {
            if (s != null)
                closeStatement(s);
                closeConnection(con); //findbugs for 106329
        }
    }",Create the table.
"@Override
    public <B> IdentityT<M, A> discardR(Applicative<B, MonadT<M, Identity<?>, ?>> appB) {
        return MonadT.super.discardR(appB).coerce();
    }",Coerce to Identity
"public void setNodeCollapsedImage(String nodeCollapsedImage)
    {
        String val = setNonEmptyValueAttribute(nodeCollapsedImage);
        if (val != null)
            _iState.setNodeCollapsedImage(setNonEmptyValueAttribute(val));
    }",Sets the nodeCollapsedImage.
"private ISymbol getSymbol( CharSequence strName, int iStartIndex )
  {
    for( int i = iStartIndex; i >= 0; i-- )
    {
      Object obj = _stackScopes.get( i );
      IScope scope = (IScope)obj;
      Object symbol = scope.get( strName );
      if( symbol != null )
      {
        return (ISymbol)symbol;
      }
      IActivationContext activationCtx = scope.getActivationCtx();
      if( activationCtx != null && !activationCtx.isTransparent() )
      {
        // An activation record marker.
        // Jump to the global symbols and look there.
        return getGlobalSymbol( strName );
      }
    }

    return null;
  }",Gets the symbol from the stack.
"public static <A extends Number & Comparable<?>> NumberExpression<Integer> sign(Expression<A> num) {
        return Expressions.numberOperation(Integer.class, Ops.MathOps.SIGN, num);
    }",Create an integer expression that evaluates to a sign
"private void makeSnapshotIfNeeded(long currentTime) {
    if (currentTime < 0) {
      currentTime = nanoTimer.getNano();
    }

    if (lastSnapshotTimestamp == -1)
      lastSnapshotTimestamp = 0;

    if (lastSnapshotTimestamp < 0 || currentTime - lastSnapshotTimestamp >= intervalBetweenSnapshots) {
      snapshot = new PerformanceSnapshot(performanceCountersHolder, countersByComponent, writCacheCountersHolder,
          storageCountersHolder, walCountersHolder);
      lastSnapshotTimestamp = currentTime;
    }

    if (cleanUpInterval > 0) {
      if (currentTime - lastCleanUpTimeStamp >= cleanUpInterval) {
        performanceCountersHolder.clean();

        for (PerformanceCountersHolder pch : countersByComponent.values()) {
          pch.clean();
        }

        if (writCacheCountersHolder != null)
          writCacheCountersHolder.clean();

        if (storageCountersHolder != null)
          storageCountersHolder.clean();

        if (writCacheCountersHolder != null)
          walCountersHolder.clean();

        lastCleanUpTimeStamp = currentTime;
      }
    }
  }",Make a snapshot if necessary.
"@Override
    public int lastIndexOf(Object o) {
        if (displacement != null) {
            return super.lastIndexOf(o) + displacement;
        }
        return super.lastIndexOf(o);
    }",Override lastIndexOf to add the displacement to the index of the object.
"public static <T extends Number> WindowOver<T> stddevSamp(Expression<T> expr) {
        return new WindowOver<T>(expr.getType(), SQLOps.STDDEVSAMP, expr);
    }",Create a standard deviation squared window over the given expression.
"private void adaptDividerVisibilities(final boolean scrolledToTop,
                                          final boolean scrolledToBottom, final boolean animate) {
        if (topDivider != null && !topDivider.isVisibleByDefault()) {
            topDivider.setVisibility(
                    scrolledToTop || !showDividersOnScroll ? View.INVISIBLE : View.VISIBLE,
                    animate);
        }

        if (bottomDivider != null && !bottomDivider.isVisibleByDefault()) {
            bottomDivider.setVisibility(
                    scrolledToBottom || !showDividersOnScroll ? View.INVISIBLE : View.VISIBLE,
                    animate);
        }
    }",Adapts the visibilities of the dividers.
"public static MonetaryRounding getRounding(RoundingQuery roundingQuery) {
        return Optional.ofNullable(monetaryRoundingsSingletonSpi()).orElseThrow(
                () -> new MonetaryException(""No MonetaryRoundingsSpi loaded, query functionality is not available.""))
                .getRounding(roundingQuery);
    }",Get the MonetaryRounding object for the given query.
"public static Predicate<GHEventsSubscriber> isApplicableFor(final Item item) {
        return new NullSafePredicate<GHEventsSubscriber>() {
            @Override
            protected boolean applyNullSafe(@Nonnull GHEventsSubscriber subscriber) {
                return subscriber.safeIsApplicable(item);
            }
        };
    }",Returns a predicate that returns true if the subscriber is applicable to the given item.
"public void log(Throwable exception) {
		if (exception instanceof CoreException) {
			getILog().log(new Status(IStatus.ERROR, PLUGIN_ID,
					exception.getMessage(), exception.getCause()));
		} else if (exception != null) {
			getILog().log(new Status(IStatus.ERROR, PLUGIN_ID,
					MessageFormat.format(Messages.SARLMavenEclipsePlugin_0, exception.getMessage()), exception));
		} else {
			getILog().log(new Status(IStatus.ERROR, PLUGIN_ID,
					""Internal Error"", exception));   //$NON-NLS-1$
		}
	}",Log an exception.
"private Entry<E> getEntry(int index) {
    Entry<E> entry = indexToEntry.get(index);
    return entry;
  }",Gets the entry with the given index.
"@VisibleForTesting
    protected int intToInt(final Integer exp) {
        final Integer value = fieldConstraints.getIntMappingValue(exp);
        if (value != null) {
            return value;
        }
        return exp;
    }",Get the int value of a CRASSCTYPE.
"public static boolean isPrimitiveType(Type type) {
	String className = type.getClassName();
	if (className.indexOf('.') != -1) return false;

	if (""boolean"".equals(className)) return true;
	if (""short"".equals(className)) return true;
	if (""float"".equals(className)) return true;
	if (""long"".equals(className)) return true;
	if (""double"".equals(className)) return true;
	if (""char"".equals(className)) return true;
	if (""int"".equals(className)) return true;
	if (""byte"".equals(className)) return true;

	return false;
    }",Checks if the given type is a primitive type.
"public static XAbstractFeatureCall getRootFeatureCall(XAbstractFeatureCall featureCall) {
		final EObject container = featureCall.eContainer();
		final XAbstractFeatureCall rootFeatureCall;
		if (container instanceof XMemberFeatureCall || container instanceof XFeatureCall) {
			rootFeatureCall = (XAbstractFeatureCall) getFirstContainerForPredicate(featureCall,
					it -> it.eContainer() != null && !(it.eContainer() instanceof XMemberFeatureCall || it.eContainer() instanceof XFeatureCall));
		} else {
			rootFeatureCall = featureCall;
		}
		return rootFeatureCall;
	}",Replies the root feature call.
"protected void sendBindingMessage(BeanMetaData bmd,
                                      String beanName,
                                      String interfaceName,
                                      int interfaceIndex,
                                      boolean local) {
        EJBModuleMetaDataImpl mmd = bmd._moduleMetaData;
        String logicalAppName = mmd.getEJBApplicationMetaData().getLogicalName();
        String logicalModuleName = mmd.ivLogicalName;
        String jndiName = logicalAppName == null ? ""java:global/"" + logicalModuleName + '/' + beanName + '!'
                                                   + interfaceName : ""java:global/"" + logicalAppName + '/' + logicalModuleName + '/' + beanName + '!' + interfaceName;

        Tr.info(tc, ""JNDI_BINDING_LOCATION_INFO_CNTR0167I"",
                new Object[] { interfaceName,
                               bmd.j2eeName.getComponent(),
                               bmd.j2eeName.getModule(),
                               bmd.j2eeName.getApplication(),
                               jndiName });
    }",This method is called by the EJB container to send a binding message to the EJB container.
"public static long getTimestampFromRollupQualifier(final byte[] qualifier, 
                  final long base_time, 
                  final RollupInterval interval,
                  final int offset) {
    return (base_time * 1000) + 
            getOffsetFromRollupQualifier(qualifier, offset, interval);
  }",Gets timestamp from rollup qualifier.
"private static MutablePicoContainer createContainer(ComponentContainer parent) {
    ComponentMonitor componentMonitor = new NullComponentMonitor();
    ReflectionLifecycleStrategy lifecycleStrategy = new StopSafeReflectionLifecycleStrategy(componentMonitor) {
      @Override
      public boolean isLazy(ComponentAdapter<?> adapter) {
        return true;
      }
    };
    return new DefaultPicoContainer(new OptInCaching(), lifecycleStrategy, parent.getPicoContainer(), componentMonitor);
  }",Create a container with a null parent
"private boolean isNotCompound(String word) throws IOException {
    List<String> probablyCorrectWords = new ArrayList<>();
    List<String> testedTokens = new ArrayList<>(2);
    for (int i = 2; i < word.length(); i++) {
      // chop from left to right
      final String first = word.substring(0, i);
      final String second = word.substring(i, word.length());
      if (prefixes.contains(first.toLowerCase(conversionLocale))
              && !isMisspelled(speller1, second)
              && second.length() > first.length()) { // but not for short words such as ""premoc""
        // ignore this match, it's fine
        probablyCorrectWords.add(word); // FIXME: some strange words are being accepted, like prekupa
      } else {
        testedTokens.clear();
        testedTokens.add(first);
        testedTokens.add(second);
        List<AnalyzedTokenReadings> taggedToks =
                language.getTagger().tag(testedTokens);
        if (taggedToks.size() == 2
                // ""białozielony"", trzynastobitowy
                && (taggedToks.get(0).hasPosTag(""adja"")
                || (taggedToks.get(0).hasPosTag(""num:comp"")
                   && !taggedToks.get(0).hasPosTag(""adv"")))
                && taggedToks.get(1).hasPartialPosTag(""adj:"")) {
          probablyCorrectWords.add(word);
        }
      }
    }
    if (!probablyCorrectWords.isEmpty()) {
      addIgnoreTokens(probablyCorrectWords);
      return false;
    }
    return true;
  }",Checks if the word is a compound word.
"public final Calendar getCalendar() {
        Calendar calendar = calendarSelector.getCalendar();
        if (calendar == null) {
            calendar = entry.getCalendar();
        }

        return calendar;
    }",Gets the calendar.
"@Override
    public void audit(final LoggingEvent e) {
        try {
            logger.info(MarkerFactory.getMarker(AUDIT), serialize(e));
        } catch (Exception ex) {
            throw new RuntimeException(""unable to serialize event"", ex);
        }
    }",Audit event.
"private static <T> Stream<T> generateStream(T seed, Predicate<? super T> hasNext, UnaryOperator<T> next) {
        final Spliterator<T> spliterator = Spliterators.spliteratorUnknownSize(new Iterator<T>() {
            private T last = seed;

            @Override
            public boolean hasNext() {
                return hasNext.test(last);
            }

            @Override
            public T next() {
                final T current = last;
                last = next.apply(last);
                return current;
            }
        }, Spliterator.ORDERED);

        return StreamSupport.stream(spliterator, false);
    }",Generate a stream of tuples.
"@SuppressWarnings(""unchecked"")
	public <B, T extends B, D extends B> B resolveBeanWithDefaultClass(Class<T> typeToResolve, Class<D> defaultType) {

		// if type to resolve is null, do nothing, not even the default
		if(typeToResolve == null) {
			return null;
		}
		
		// get candidate resolve types
		Set<Bean<?>> candidates = this.manager.getBeans(typeToResolve);
		
		// if no candidates are available, resolve
		// using next class up
		if(!candidates.iterator().hasNext()) {
			this.logger.trace(""No candidates for: {}"", typeToResolve.getName());
			// try and resolve only the default type
			return resolveBeanWithDefaultClass(defaultType, null);
		} 
		
		this.logger.trace(""Requesting resolution on: {}"", typeToResolve.getName());
		
		// get candidate
		Bean<?> bean = candidates.iterator().next();
		CreationalContext<?> context = this.manager.createCreationalContext(bean);
		Type type = (Type) bean.getTypes().iterator().next();
	    B result = (B)this.manager.getReference(bean, type, context);
		
		this.logger.trace(""Resolved to: {}"", result.getClass().getName());
		
		return result;
	}",Resolves a bean with the specified type.
"public int read(char buff[], int off, int len) throws IOException
    {
        int b = read();
        if ( b == -1 )
            return -1;  // EOF, not zero read apparently
        else {
            buff[off]=(char)b;
            return 1;
        }
    }",read a single SEGMENT from the input stream.
"public Tuple2<ReadOnlyStyledDocument<PS, SEG, S>, ReadOnlyStyledDocument<PS, SEG, S>> split(int position) {
        return tree.locate(NAVIGATE, position).map(this::split);
    }",Split the document at the given position.
"private static <T> String getTableName(Class<T> clazz) {
		
		Table tableAnno = clazz.getAnnotation(Table.class);
		if(tableAnno != null){
			if(tableAnno.catalog() != null){
				return tableAnno.catalog() + ""."" + tableAnno.name();
			}
			return tableAnno.name();
		}
		//if Table annotation is null
		String className = clazz.getName();
		return IdUtils.toUnderscore(className.substring(className.lastIndexOf(""."")+1));
	}",Get the table name from the class.
"@Override
	public boolean eIsSet(int featureID) {
		switch (featureID) {
			case BpsimPackage.BP_SIM_DATA_TYPE__GROUP:
				return group != null && !group.isEmpty();
			case BpsimPackage.BP_SIM_DATA_TYPE__SCENARIO:
				return !getScenario().isEmpty();
		}
		return super.eIsSet(featureID);
	}",Override the eIsSet method to check if the feature is set.
"public <E extends Exception> boolean anyMatch(Try.BytePredicate<E> filter) throws E {
        return anyMatch(0, size(), filter);
    }",Returns true if this set contains at least one element that matches the given filter.
"public static long min( long[] values, final int start, final int length ) {
        long min = Long.MAX_VALUE;
        for (int index = start; index < length; index++ ) {
            if (values[index] < min) min = values[index];
        }
        return min;
    }",Get the minimum value of a set of log codes.
"public CMAAsset unPublish(CMAAsset asset) {
    assertNotNull(asset, ""asset"");

    final String assetId = getResourceIdOrThrow(asset, ""asset"");
    final String spaceId = getSpaceIdOrThrow(asset, ""asset"");
    final String environmentId = asset.getEnvironmentId();

    return service.unPublish(spaceId, environmentId, assetId).blockingFirst();
  }",Un - Publish an Asset.
"public String getFullName(TypeElement element) {
    element = typeUtil.getObjcClass(element);
    String fullName = fullNameCache.get(element);
    if (fullName == null) {
      fullName = getFullNameImpl(element);
      fullNameCache.put(element, fullName);
    }
    return fullName;
  }",Get the full name of a type element.
"private static Map<String, Object> convertLogicalMap(Group g, boolean binaryAsString)
  {
    /*
      // Map<String, Integer> (nullable map, non-null values)
      optional group my_map (MAP) {
        repeated group map {
          required binary str (UTF8);
          required int32 num;
        }
      }

      // Map<String, Integer> (nullable map, nullable values)
      optional group my_map (MAP_KEY_VALUE) {(
        repeated group map {
          required binary key (UTF8);
          optional int32 value;
        }
      }
     */
    assert isLogicalMapType(g.getType());
    int mapEntries = g.getFieldRepetitionCount(0);
    Map<String, Object> converted = new HashMap<>();
    for (int i = 0; i < mapEntries; i++) {
      Group mapEntry = g.getGroup(0, i);
      String key = convertPrimitiveField(mapEntry, 0, binaryAsString).toString();
      Object value = convertField(mapEntry, ""value"", binaryAsString);
      converted.put(key, value);
    }
    return converted;
  }",Convert a logical map of type Group to a map of type Map.
"@Pure
	public static Iterator<BusItineraryHalt> getBusHalts(BusLine busLine) {
		assert busLine != null;
		return new LineHaltIterator(busLine);
	}",Replies the bus itinerary halts.
"public TempStream copy()
  {
    TempStream newStream = new TempStream();

    TempBuffer ptr = _head;

    for (; ptr != null; ptr = ptr.next()) {
      TempBuffer newPtr = TempBuffer.create();
      
      if (newStream._tail != null)
        newStream._tail.next(newPtr);
      else
        newStream._head = newPtr;
      newStream._tail = newPtr;

      newPtr.write(ptr.buffer(), 0, ptr.length());
    }

    return newStream;
  }",Copy the content of this object to a TempStream.
"public SearchParameterMap setLoadSynchronousUpTo(Integer theLoadSynchronousUpTo) {
		myLoadSynchronousUpTo = theLoadSynchronousUpTo;
		if (myLoadSynchronousUpTo != null) {
			setLoadSynchronous(true);
		}
		return this;
	}",Sets the load synchronous up to time.
"protected Object afterInvocation(InterceptorStatusToken token, Object returnedObject) {
		if (token == null) {
			// public object
			return returnedObject;
		}

		finallyInvocation(token); // continue to clean in this method for passivity

		if (afterInvocationManager != null) {
			// Attempt after invocation handling
			try {
				returnedObject = afterInvocationManager.decide(token.getSecurityContext()
						.getAuthentication(), token.getSecureObject(), token
						.getAttributes(), returnedObject);
			}
			catch (AccessDeniedException accessDeniedException) {
				AuthorizationFailureEvent event = new AuthorizationFailureEvent(
						token.getSecureObject(), token.getAttributes(), token
								.getSecurityContext().getAuthentication(),
						accessDeniedException);
				publishEvent(event);

				throw accessDeniedException;
			}
		}

		return returnedObject;
	}",This method is called after an invocation of an interceptor.
"public Result next(CharSequence s, int sIndex, int sLimit) {
        if(sIndex>=sLimit) {
            // Empty input.
            return current();
        }
        int pos=pos_;
        if(pos<0) {
            return Result.NO_MATCH;
        }
        int length=remainingMatchLength_;  // Actual remaining match length minus 1.
        for(;;) {
            // Fetch the next input unit, if there is one.
            // Continue a linear-match node.
            char inUnit;
            for(;;) {
                if(sIndex==sLimit) {
                    remainingMatchLength_=length;
                    pos_=pos;
                    int node;
                    return (length<0 && (node=chars_.charAt(pos))>=kMinValueLead) ?
                            valueResults_[node>>15] : Result.NO_VALUE;
                }
                inUnit=s.charAt(sIndex++);
                if(length<0) {
                    remainingMatchLength_=length;
                    break;
                }
                if(inUnit!=chars_.charAt(pos)) {
                    stop();
                    return Result.NO_MATCH;
                }
                ++pos;
                --length;
            }
            int node=chars_.charAt(pos++);
            for(;;) {
                if(node<kMinLinearMatch) {
                    Result result=branchNext(pos, node, inUnit);
                    if(result==Result.NO_MATCH) {
                        return Result.NO_MATCH;
                    }
                    // Fetch the next input unit, if there is one.
                    if(sIndex==sLimit) {
                        return result;
                    }
                    if(result==Result.FINAL_VALUE) {
                        // No further matching units.
                        stop();
                        return Result.NO_MATCH;
                    }
                    inUnit=s.charAt(sIndex++);
                    pos=pos_;  // branchNext() advanced pos and wrote it to pos_ .
                    node=chars_.charAt(pos++);
                } else if(node<kMinValueLead) {
                    // Match length+1 units.
                    length=node-kMinLinearMatch;  // Actual match length minus 1.
                    if(inUnit!=chars_.charAt(pos)) {
                        stop();
                        return Result.NO_MATCH;
                    }
                    ++pos;
                    --length;
                    break;
                } else if((node&kValueIsFinal)!=0) {
                    // No further matching units.
                    stop();
                    return Result.NO_MATCH;
                } else {
                    // Skip intermediate value.
                    pos=skipNodeValue(pos, node);
                    node&=kNodeTypeMask;
                }
            }
        }
    }",This method returns the next Result from the input char sequence.
"@Override
	@SuppressWarnings({ ""unchecked"" })
	public synchronized Enumeration<Object> keys() {
		Enumeration<Object> keysEnum = super.keys();
		@SuppressWarnings(""rawtypes"")
		Vector keyList = new Vector<>();	// NOPMD - vector used on purpose here...
		while (keysEnum.hasMoreElements()) {
			keyList.add(keysEnum.nextElement());
		}

		Collections.sort(keyList);

		// reverse this list to have the newest items on top
		Collections.reverse(keyList);

		return keyList.elements();
	}",Returns an enumeration of the keys in this map.
"public Object extFunction(String ns, String funcName, Vector argVec,
        Object methodKey) throws javax.xml.transform.TransformerException {
        try {

            if ( funcName == null ) {
                String fmsg = XSLMessages.createXPATHMessage(
                    XPATHErrorResources.ER_ARG_CANNOT_BE_NULL,
                    new Object[] {""Function Name""} );
                throw new NullPointerException ( fmsg ); 
            }
            //Find the XPathFunction corresponding to namespace and funcName
            javax.xml.namespace.QName myQName = new QName( ns, funcName );

            // JAXP 1.3 spec says When XMLConstants.FEATURE_SECURE_PROCESSING 
            // feature is set then invocation of extension functions need to
            // throw XPathFunctionException
            if ( extensionInvocationDisabled ) {
                String fmsg = XSLMessages.createXPATHMessage(
                    XPATHErrorResources.ER_EXTENSION_FUNCTION_CANNOT_BE_INVOKED,
                    new Object[] { myQName.toString() } );
                throw new XPathFunctionException ( fmsg );
            }

            // Assuming user is passing all the needed parameters ( including
            // default values )
            int arity = argVec.size();

            javax.xml.xpath.XPathFunction xpathFunction = 
                resolver.resolveFunction ( myQName, arity );

            // not using methodKey
            ArrayList argList = new ArrayList( arity);
            for ( int i=0; i<arity; i++ ) {
                Object argument = argVec.elementAt( i );
                // XNodeSet object() returns NodeVector and not NodeList
                // Explicitly getting NodeList by using nodelist()
                if ( argument instanceof XNodeSet ) {
                    argList.add ( i, ((XNodeSet)argument).nodelist() );
                } else if ( argument instanceof XObject ) {
                    Object passedArgument = ((XObject)argument).object();
                    argList.add ( i, passedArgument );
                } else {
                    argList.add ( i, argument );
                }
            }

            return ( xpathFunction.evaluate ( argList ));
        } catch ( XPathFunctionException xfe ) {
            // If we get XPathFunctionException then we want to terminate
            // further execution by throwing WrappedRuntimeException 
            throw new org.apache.xml.utils.WrappedRuntimeException ( xfe );
        } catch ( Exception e ) {
            throw new javax.xml.transform.TransformerException ( e );
        }
    
    }",This method is called by the extension functions.
"public final ListFindingTypeStatsResponse listFindingTypeStats(ScanRunName parent) {

    ListFindingTypeStatsRequest request =
        ListFindingTypeStatsRequest.newBuilder()
            .setParent(parent == null ? null : parent.toString())
            .build();
    return listFindingTypeStats(request);
  }",List finding type stats for a scan run.
"private void saveXMLFile(final List<StepImplementationsDescriptor> classStepTags) {
        // got them all now serialize

        final String xml = serializer.toXML(classStepTags);

        writeOutputFile(xml, XMLSubstepsGlossarySerializer.XML_FILE_NAME);

    }",Serialize the result of a single class step.
"public java.util.List<ImportSnapshotTask> getImportSnapshotTasks() {
        if (importSnapshotTasks == null) {
            importSnapshotTasks = new com.amazonaws.internal.SdkInternalList<ImportSnapshotTask>();
        }
        return importSnapshotTasks;
    }",Gets the value of the importSnapshotTasks property.
"public static <E> Iterator<E> filter(Iterator<E> iterator, Predicate<E> predicate) {
        return new FilteringIterator<E>(iterator, predicate);
    }",Returns an iterator that returns the elements that match the given predicate.
"public boolean match(final String value) {
		if (pathMacros == null) {
			return this.value.equals(value);
		}
		return pathMacros.match(value) != -1;
	}",Checks if the given value matches this path.
"public List<JAXBElement<Object>> get_GenericApplicationPropertyOfOpening() {
        if (_GenericApplicationPropertyOfOpening == null) {
            _GenericApplicationPropertyOfOpening = new ArrayList<JAXBElement<Object>>();
        }
        return this._GenericApplicationPropertyOfOpening;
    }",Gets the value of the genericApplicationPropertyOfOpening property.
"public EmbedBuilder updateAllFields(Consumer<EditableEmbedField> updater) {
        delegate.updateFields(field -> true, updater);
        return this;
    }",Updates all fields of the embed.
"@Override
	public EClass getIfcStructuralMember() {
		if (ifcStructuralMemberEClass == null) {
			ifcStructuralMemberEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)
					.getEClassifiers().get(653);
		}
		return ifcStructuralMemberEClass;
	}",Get the IfcStructuralMemberEClass for the IIfc4Package.
"private ObjectCache getCachePerClass(Class objectClass, int methodCall)
    {
        ObjectCache cache = (ObjectCache) cachesByClass.get(objectClass.getName());
        if (cache == null && AbstractMetaCache.METHOD_CACHE == methodCall
                && !cachesByClass.containsKey(objectClass.getName()))
        {
            cache = new ObjectCacheDefaultImpl(null, null);
            setClassCache(objectClass.getName(), cache);
        }
        return cache;
    }",Gets the cache per class.
"public URLNormalizer addDomainTrailingSlash() {
        String urlRoot = HttpURL.getRoot(url);
        String path = toURL().getPath();
        if (StringUtils.isNotBlank(path)) {
            // there is a path so do nothing
            return this;
        }
        String urlRootAndPath = urlRoot + ""/"";
        url = StringUtils.replaceOnce(url, urlRoot, urlRootAndPath);
        return this;
    }",Add a trailing slash to the URL.
"public static int getFirstRow(RowSelection selection) {
		return (selection == null || selection.getFirstRow() == null) ? 0 : selection.getFirstRow();
	}",Get the first row of the row selection.
"public int getConnection(String connectionModel, String nodeType, int ordinal, String propertyName) {
    	int connectionModelIndex = modelHolder.getModelIndex(connectionModel);
        return getConnection(connectionModelIndex, nodeType, ordinal, propertyName);
    }",Get the connection index for the given connectionModel nodeType and ordinal.
"ExpandedPair retrieveNextPair(BitArray row, List<ExpandedPair> previousPairs, int rowNumber)
      throws NotFoundException {
    boolean isOddPattern  = previousPairs.size() % 2 == 0;
    if (startFromEven) {
      isOddPattern = !isOddPattern;
    }

    FinderPattern pattern;

    boolean keepFinding = true;
    int forcedOffset = -1;
    do {
      this.findNextPair(row, previousPairs, forcedOffset);
      pattern = parseFoundFinderPattern(row, rowNumber, isOddPattern);
      if (pattern == null) {
        forcedOffset = getNextSecondBar(row, this.startEnd[0]);
      } else {
        keepFinding = false;
      }
    } while (keepFinding);

    // When stacked symbol is split over multiple rows, there's no way to guess if this pair can be last or not.
    // boolean mayBeLast = checkPairSequence(previousPairs, pattern);

    DataCharacter leftChar  = this.decodeDataCharacter(row, pattern, isOddPattern, true);

    if (!previousPairs.isEmpty() && previousPairs.get(previousPairs.size() - 1).mustBeLast()) {
      throw NotFoundException.getNotFoundInstance();
    }

    DataCharacter rightChar;
    try {
      rightChar = this.decodeDataCharacter(row, pattern, isOddPattern, false);
    } catch (NotFoundException ignored) {
      rightChar = null;
    }
    return new ExpandedPair(leftChar, rightChar, pattern);
  }",Retrieve the next expansion pair from the given row.
"@Override
  public Collection<String> getCliqueFeatures(PaddedList<IN> cInfo, int loc, Clique clique) {
    Collection<String> features = new HashSet<String>();

    boolean doFE = cInfo.get(0).containsKey(DomainAnnotation.class);
    String domain = (doFE ? cInfo.get(0).get(DomainAnnotation.class) : null);

//    System.err.println(doFE+""\t""+domain);

    if (clique == cliqueC) {
      //200710: tried making this clique null; didn't improve performance (rafferty)
      Collection<String> c = featuresC(cInfo, loc);
      addAllInterningAndSuffixing(features, c, ""C"");
      if (doFE) {
        addAllInterningAndSuffixing(features, c, domain+""-C"");
      }
    } else if (clique == cliqueCpC) {
      Collection<String> c = featuresCpC(cInfo, loc);
      addAllInterningAndSuffixing(features, c, ""CpC"");
      if (doFE) {
        addAllInterningAndSuffixing(features, c, domain+""-CpC"");
      }

      c = featuresCnC(cInfo, loc-1);
      addAllInterningAndSuffixing(features, c, ""CnC"");
      if (doFE) {
        addAllInterningAndSuffixing(features, c, domain+""-CnC"");
      }
    } else if (clique == cliqueCp2C) {
      Collection<String> c = featuresCp2C(cInfo, loc);
      addAllInterningAndSuffixing(features, c, ""Cp2C"");
      if (doFE) {
        addAllInterningAndSuffixing(features, c, domain+""-Cp2C"");
      }
    } else if (clique == cliqueCp3C) {
      Collection<String> c = featuresCp3C(cInfo, loc);
      addAllInterningAndSuffixing(features, c, ""Cp3C"");
      if (doFE) {
        addAllInterningAndSuffixing(features, c, domain+""-Cp3C"");
      }
    } else if (clique == cliqueCp4C) {
      Collection<String> c = featuresCp4C(cInfo, loc);
      addAllInterningAndSuffixing(features, c, ""Cp4C"");
      if (doFE) {
        addAllInterningAndSuffixing(features, c, domain+""-Cp4C"");
      }
    } else if (clique == cliqueCp5C) {
      Collection<String> c = featuresCp5C(cInfo, loc);
      addAllInterningAndSuffixing(features, c, ""Cp5C"");
      if (doFE) {
        addAllInterningAndSuffixing(features, c, domain+""-Cp5C"");
      }
    } else if (clique == cliqueCpCp2C) {
      Collection<String> c = featuresCpCp2C(cInfo, loc);
      addAllInterningAndSuffixing(features, c, ""CpCp2C"");
      if (doFE) {
        addAllInterningAndSuffixing(features, c, domain+""-CpCp2C"");
      }

      c = featuresCpCnC(cInfo, loc-1);
      addAllInterningAndSuffixing(features, c, ""CpCnC"");
      if (doFE) {
        addAllInterningAndSuffixing(features, c, domain+""-CpCnC"");
      }
    } else if (clique == cliqueCpCp2Cp3C) {
      Collection<String> c = featuresCpCp2Cp3C(cInfo, loc);
      addAllInterningAndSuffixing(features, c, ""CpCp2Cp3C"");
      if (doFE) {
        addAllInterningAndSuffixing(features, c, domain+""-CpCp2Cp3C"");
      }
    } else if (clique == cliqueCpCp2Cp3Cp4C) {
      Collection<String> c = featuresCpCp2Cp3Cp4C(cInfo, loc);
      addAllInterningAndSuffixing(features, c, ""CpCp2Cp3Cp4C"");
      if (doFE) {
        addAllInterningAndSuffixing(features, c, domain+""-CpCp2Cp3Cp4C"");
      }
    }

    // System.err.println(StringUtils.join(features,""\n"")+""\n"");
    return features;
  }",Get the features of a single node in a clique.
"public BlockMeta moveBlockMeta(BlockMeta blockMeta, TempBlockMeta tempBlockMeta)
      throws BlockDoesNotExistException, WorkerOutOfSpaceException, BlockAlreadyExistsException {
    StorageDir srcDir = blockMeta.getParentDir();
    StorageDir dstDir = tempBlockMeta.getParentDir();
    srcDir.removeBlockMeta(blockMeta);
    BlockMeta newBlockMeta =
        new BlockMeta(blockMeta.getBlockId(), blockMeta.getBlockSize(), dstDir);
    dstDir.removeTempBlockMeta(tempBlockMeta);
    dstDir.addBlockMeta(newBlockMeta);
    return newBlockMeta;
  }",Move a block from one temp block to another.
"public static boolean addRuleFor(IndexedClass owlThing,
			ModifiableOntologyIndex index) {
		LOGGER_.trace(""{}: adding {}"", owlThing, NAME);
		return index.addContextInitRule(new OwlThingContextInitRule(owlThing));
	}",Adds a rule for the given owlThing.
"public static void format(final Source input, final Result output) {
        try {
            // Use an identity transformation to write the source to the result.
            final Transformer transformer = createTransformer(null);
            transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");

            transformer.transform(input, output);
        } catch (final Exception ex) {
            LOGGER.error(""Problem formatting DOM representation."", ex);
        }
    }",Format the source to the result.
"public static <T> List<T> innerJoin(List<List<T>> list, BiFunction<T, T, T> function) {
        if (list == null || function == null) {
            throw new NullPointerException(""list or function must not be null"");
        }
        if (list.isEmpty()) {
            return Collections.emptyList();
        }
        if (list.size() == 1) {
            return list.get(0);
        }

        List<List<T>> result = innerJoin(list.get(0), list.get(1), function);
        if (list.size() == 2) {
            return merge(result);
        } else {
            for (int i = 2; i < list.size(); i++) {
                List<T> l1 = list.get(i);
                List<List<T>> temp = new ArrayList<>();
                result.stream().forEach(l -> temp.addAll(innerJoin(l, l1, function)));
                result = temp;
            }
            return merge(result);
        }
    }",Inner join.
"public static ModelConstants getInstance() throws KbRuntimeException {
    try {
      if (instance == null) {
        instance = new ModelConstants();
      }
      return instance;
    } catch (KbException e) {
      throw new KbRuntimeException(
          ""Once of the private final fields in com.cyc.library.model.ModelConstants could not be instantiated, can not proceed further."",
          e);
    }
  }",Get the instance of the class.
"public static Object runMethod(Object object, String method, Object... args) throws JException
  {
    try
    {
      final Method m = object.getClass().getMethod(method);

      return m.invoke(object, args);
    }
    catch (Exception e)
    {
      throw new JException(e);
    }
  }",Run a method on an object.
"public static List<CommercePriceListAccountRel> toModels(
		CommercePriceListAccountRelSoap[] soapModels) {
		if (soapModels == null) {
			return null;
		}

		List<CommercePriceListAccountRel> models = new ArrayList<CommercePriceListAccountRel>(soapModels.length);

		for (CommercePriceListAccountRelSoap soapModel : soapModels) {
			models.add(toModel(soapModel));
		}

		return models;
	}",Converts the commerce price list account rels to the generic models.
"public static org.jfrog.hudson.ArtifactoryServer prepareArtifactoryServer(String artifactoryServerID,
                                                                              ArtifactoryServer pipelineServer) {

        if (artifactoryServerID == null && pipelineServer == null) {
            return null;
        }
        if (artifactoryServerID != null && pipelineServer != null) {
            return null;
        }
        if (pipelineServer != null) {
            CredentialsConfig credentials = pipelineServer.createCredentialsConfig();

            return new org.jfrog.hudson.ArtifactoryServer(null, pipelineServer.getUrl(), credentials,
                    credentials, pipelineServer.getConnection().getTimeout(), pipelineServer.isBypassProxy(), pipelineServer.getConnection().getRetry(), pipelineServer.getDeploymentThreads());
        }
        org.jfrog.hudson.ArtifactoryServer server = RepositoriesUtils.getArtifactoryServer(artifactoryServerID, RepositoriesUtils.getArtifactoryServers());
        if (server == null) {
            return null;
        }
        return server;
    }",Prepare artifactory server.
"public JsonWriter value(@NonNull Iterable<?> value) throws IOException {
      Preconditions.checkArgument(inArray() || writeStack.peek() == JsonTokenType.NAME,
                                  ""Expecting an array or a name, but found "" + writeStack.peek());
      popIf(JsonTokenType.NAME);
      beginArray();
      for (Object o : value) {
         value(o);
      }
      endArray();
      return this;
   }",Write an iterable of objects to the JSON writer.
"@Override
    public void action(final File backupFile)
            throws JsonParseException, JsonMappingException, IOException {
        backupManager.backup(backupFile);
    }",Action method for backup.
"public static Class<?> primitiveToWrapper(final Class<?> cls) {
        Class<?> convertedClass = cls;
        if (cls != null && cls.isPrimitive()) {
            convertedClass = primitiveWrapperMap.get(cls);
        }
        return convertedClass;
    }",Convert a class to a wrapper class.
"public KeyFactory reset() {
    setProjectId(pi);
    setNamespace(ns);
    kind = null;
    ancestors.clear();
    return this;
  }",Reset the key factory to its initial state.
"public static void ensureNotSingular( DMatrixSparseCSC A , Random rand ) {
//        if( A.numRows < A.numCols ) {
//            throw new IllegalArgumentException(""Fewer equations than variables"");
//        }

        int []s = UtilEjml.shuffled(A.numRows,rand);
        Arrays.sort(s);

        int N = Math.min(A.numCols,A.numRows);
        for (int col = 0; col < N; col++) {
            A.set(s[col],col,rand.nextDouble()+0.5);
        }
    }",Ensure that A is not singular.
"public void unregisterFhirProviders (FhirProviderBundle bundle, Map<String,Object> props) throws FhirConfigurationException {
		if (bundle != null) {
			Collection<Object> providers = bundle.getProviders();
			if (providers != null && !providers.isEmpty()) {
				try {
					registeredProviders.remove(providers);
					String serverName = (String)props.get(FhirServer.SVCPROP_SERVICE_NAME);
					String ourServerName = getServerName(serverName);
					FhirServer server = registeredServers.get(ourServerName);
					if (server != null) {
						
						server.unregisterOsgiProviders(providers);
						
						Collection<Collection<Object>> active = serverProviders.get(serverName);
						if (active != null) {
							active.remove(providers);
						}
					}
				} catch (BadServerException e) {
					throw new FhirConfigurationException(""Unable to register the OSGi FHIR Provider. Multiple Restful Servers exist. Specify the [""+FhirServer.SVCPROP_SERVICE_NAME+""] service-property"");
				}
			}
		}
	}",Unregister the OSGi FHIR Provider from the given bundle.
"long allocate() {
        if (elemSize == 0) {
            return toHandle(0);
        }

        if (numAvail == 0 || !doNotDestroy) {
            return -1;
        }

        final int bitmapIdx = getNextAvail();
        int q = bitmapIdx >>> 6;
        int r = bitmapIdx & 63;
        assert (bitmap[q] >>> r & 1) == 0;
        bitmap[q] |= 1L << r;

        if (-- numAvail == 0) {
            removeFromPool();
        }

        return toHandle(bitmapIdx);
    }",Allocate a new instance of a class from the pool.
"@Override
    public void handleNotification(Notification notification, Object handback) {
        String notificationType = notification.getType();
        if (notificationType.equals(JMXConnectionNotification.OPENED)) {
            managementContext.incrementManagementSessionCount();
        } else if (notificationType.equals(JMXConnectionNotification.CLOSED)) {
            managementContext.decrementManagementSessionCount();
        }
    }",Override this method to handle the notification.
"public Collection<L> upFromAnnotationToFields() {
		if (getKind() != Kind.ANNOTATION) return Collections.emptyList();
		L field = up();
		if (field == null || field.getKind() != Kind.FIELD) return Collections.emptyList();
		L type = field.up();
		if (type == null || type.getKind() != Kind.TYPE) return Collections.emptyList();
		
		List<L> fields = new ArrayList<L>();
		for (L potentialField : type.down()) {
			if (potentialField.getKind() != Kind.FIELD) continue;
			if (fieldContainsAnnotation(potentialField.get(), get())) fields.add(potentialField);
		}
		
		return fields;
	}",Returns all fields from an annotation to fields.
"public Map<String, Map<VMResource, Double[]>> getResourceStatus() throws IllegalStateException {
        if (usingSchedulingService) {
            throw new IllegalStateException(usingSchedSvcMesg);
        }
        return getResourceStatusIntl();
    }",Gets the status of the managed virtual machine resources.
"private void initComponents()
    {
        ClassLoader cl = this.getClass().getClassLoader();

        this.setLayout(new BoxLayout(this, BoxLayout.Y_AXIS));

        monthPanel = new JPanel();
        monthPanel.setName(""monthPanel"");
        monthPanel.setLayout (new BoxLayout(monthPanel, BoxLayout.X_AXIS));
        previousMonthButton = new JButton();
        previousMonthButton.setName(""previousMonthButton"");
        monthLabel = new JLabel();
        monthLabel.setName(""monthLabel"");
        try   {
            Icon icon  = new ImageIcon(cl.getResource(""org/jbundle/util/jcalendarbutton/images/buttons/"" + ""Back"" + "".gif""));
            previousMonthButton.setIcon(icon);
        } catch (Exception ex)  {
            previousMonthButton.setText(""<"");
        }
        previousMonthButton.setMargin(new Insets(2, 2, 2, 2));
        previousMonthButton.addActionListener(new ActionListener () {
            public void actionPerformed (ActionEvent evt) {
                prevMonthActionPerformed (evt);
            }
        }
        );
        monthPanel.add(previousMonthButton);
        monthPanel.add(Box.createHorizontalGlue());
        monthLabel.setText (""month"");
        monthLabel.setHorizontalAlignment (SwingConstants.CENTER);
        monthPanel.add (monthLabel);

        nextMonthButton = new JButton();
        nextMonthButton.setName(""nextMonthButton"");
        nextMonthButton.setAlignmentX (1.0F);
        try   {
            Icon icon  = new ImageIcon(cl.getResource(""org/jbundle/util/jcalendarbutton/images/buttons/"" + ""Forward"" + "".gif""));
            nextMonthButton.setIcon(icon);
        } catch (Exception ex)  {
            nextMonthButton.setText("">"");
        }
        nextMonthButton.setMargin (new Insets(2, 2, 2, 2));
        nextMonthButton.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent evt) {
                nextMonthActionPerformed (evt);
            }
        }
        );
        monthPanel.add(Box.createHorizontalGlue());
        monthPanel.add (nextMonthButton);
        add (monthPanel);

        yearPanel = new JPanel();
        yearPanel.setName(""yearPanel"");
        yearPanel.setLayout (new BoxLayout (yearPanel, BoxLayout.X_AXIS));
        previousYearButton = new JButton();
        previousYearButton.setName(""previousYearButton"");
        yearLabel = new JLabel();
        yearLabel.setName(""yearLabel"");
        try   {
            Icon icon  = new ImageIcon(cl.getResource(""org/jbundle/util/jcalendarbutton/images/buttons/"" + ""Back"" + "".gif""));
            previousYearButton.setIcon(icon);
        } catch (Exception ex)  {
            previousYearButton.setText(""<"");
        }
        previousYearButton.setMargin (new Insets(2, 2, 2, 2));
        previousYearButton.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent evt) {
                prevYearActionPerformed (evt);
            }
        }
        );
        yearPanel.add (previousYearButton);
        yearPanel.add(Box.createHorizontalGlue());
        yearLabel.setText (""Year"");
        yearLabel.setHorizontalAlignment (SwingConstants.CENTER);
        yearPanel.add (yearLabel);

        yearPanel.add(Box.createHorizontalGlue());
        nextYearButton = new JButton();
        nextYearButton.setName(""nextYearButton"");
        nextYearButton.setAlignmentX (1.0F);
        try   {
            Icon icon  = new ImageIcon(cl.getResource(""org/jbundle/util/jcalendarbutton/images/buttons/"" + ""Forward"" + "".gif""));
            nextYearButton.setIcon(icon);
        } catch (Exception ex)  {
            nextYearButton.setText("">"");
        }
        nextYearButton.setMargin (new Insets(2, 2, 2, 2));
        nextYearButton.addActionListener (new ActionListener () {
            public void actionPerformed (ActionEvent evt) {
                nextYearActionPerformed (evt);
            }
        }
        );
        yearPanel.add (nextYearButton);
        add (yearPanel);

        panelDays = new JPanel();
        panelDays.setName(""panelDays"");
        panelDays.setLayout (new GridLayout (7, 7));
        for (int i = 1; i <= 7; i++)
        {
            JLabel label = new JLabel();
            label.setText(Integer.toString(i));
            label.setHorizontalAlignment(SwingConstants.CENTER);
            panelDays.add(label);
        }

        for (int i = 1; i <= 7 * 6; i++)
        {
            JLabel label = new JLabel();
            label.setBorder(EMPTY_BORDER);
            label.setHorizontalAlignment(SwingConstants.CENTER);
            panelDays.add(label);
        }

        add (panelDays);
        
        this.setBorder(new EmptyBorder(2, 2, 2, 2));
    }",Initialize the components of the n - gram block.
"private long primeProduct(int[] ws, long[] ranks, boolean[] hydrogens) {
        long prod = 1;
        for (int w : ws) {
            if (!hydrogens[w]) {
                prod *= PRIMES[(int) ranks[w]];
            }
        }
        return prod;
    }",This method is used to calculate the product of a set of words.
"protected String embeddedIconsInConsole(String iconRef, String prefix) {
        if (iconRef == null) {
            return null;
        }

        if (iconRef.startsWith(""icons/"")) {
            iconRef = iconRef.substring(6);
        }

        // special for fabric8 as its in a different dir
        if (iconRef.contains(""META-INF/fabric8"")) {
            return ""img/fabric8_icon.svg"";
        }

        if (iconRef.contains(""activemq"")) {
            return prefix + ""activemq.svg"";
        } else if (iconRef.contains(""apiman"")) {
            return prefix + ""apiman.png"";
        } else if (iconRef.contains(""api-registry"")) {
            return prefix + ""api-registry.svg"";
        } else if (iconRef.contains(""brackets"")) {
            return prefix + ""brackets.svg"";
        } else if (iconRef.contains(""camel"")) {
            return prefix + ""camel.svg"";
        } else if (iconRef.contains(""chaos-monkey"")) {
            return prefix + ""chaos-monkey.png"";
        } else if (iconRef.contains(""docker-registry"")) {
            return prefix + ""docker-registry.png"";
        } else if (iconRef.contains(""elasticsearch"")) {
            return prefix + ""elasticsearch.png"";
        } else if (iconRef.contains(""fluentd"")) {
            return prefix + ""fluentd.png"";
        } else if (iconRef.contains(""forge"")) {
            return prefix + ""forge.svg"";
        } else if (iconRef.contains(""funktion"")) {
            return prefix + ""funktion.png"";
        } else if (iconRef.contains(""gerrit"")) {
            return prefix + ""gerrit.png"";
        } else if (iconRef.contains(""gitlab"")) {
            return prefix + ""gitlab.svg"";
        } else if (iconRef.contains(""gogs"")) {
            return prefix + ""gogs.png"";
        } else if (iconRef.contains(""grafana"")) {
            return prefix + ""grafana.png"";
        } else if (iconRef.contains(""hubot-irc"")) {
            return prefix + ""hubot-irc.png"";
        } else if (iconRef.contains(""hubot-letschat"")) {
            return prefix + ""hubot-letschat.png"";
        } else if (iconRef.contains(""hubot-notifier"")) {
            return prefix + ""hubot-notifier.png"";
        } else if (iconRef.contains(""hubot-slack"")) {
            return prefix + ""hubot-slack.png"";
        } else if (iconRef.contains(""image-linker"")) {
            return prefix + ""image-linker.svg"";
        } else if (iconRef.contains(""javascript"")) {
            return prefix + ""javascript.png"";
        } else if (iconRef.contains(""java"")) {
            return prefix + ""java.svg"";
        } else if (iconRef.contains(""jenkins"")) {
            return prefix + ""jenkins.svg"";
        } else if (iconRef.contains(""jetty"")) {
            return prefix + ""jetty.svg"";
        } else if (iconRef.contains(""karaf"")) {
            return prefix + ""karaf.svg"";
        } else if (iconRef.contains(""keycloak"")) {
            return prefix + ""keycloak.svg"";
        } else if (iconRef.contains(""kibana"")) {
            return prefix + ""kibana.svg"";
        } else if (iconRef.contains(""kiwiirc"")) {
            return prefix + ""kiwiirc.png"";
        } else if (iconRef.contains(""letschat"")) {
            return prefix + ""letschat.png"";
        } else if (iconRef.contains(""mule"")) {
            return prefix + ""mule.svg"";
        } else if (iconRef.contains(""nexus"")) {
            return prefix + ""nexus.png"";
        } else if (iconRef.contains(""node"")) {
            return prefix + ""node.svg"";
        } else if (iconRef.contains(""orion"")) {
            return prefix + ""orion.png"";
        } else if (iconRef.contains(""prometheus"")) {
            return prefix + ""prometheus.png"";
        } else if (iconRef.contains(""django"") || iconRef.contains(""python"")) {
            return prefix + ""python.png"";
        } else if (iconRef.contains(""spring-boot"")) {
            return prefix + ""spring-boot.svg"";
        } else if (iconRef.contains(""taiga"")) {
            return prefix + ""taiga.png"";
        } else if (iconRef.contains(""tomcat"")) {
            return prefix + ""tomcat.svg"";
        } else if (iconRef.contains(""tomee"")) {
            return prefix + ""tomee.svg"";
        } else if (iconRef.contains(""vertx"")) {
            return prefix + ""vertx.svg"";
        } else if (iconRef.contains(""wildfly"")) {
            return prefix + ""wildfly.svg"";
        } else if (iconRef.contains(""wildfly-swarm"")) {
            return prefix + ""wildfly-swarm.png"";
        } else if (iconRef.contains(""weld"")) {
            return prefix + ""weld.svg"";
        } else if (iconRef.contains(""zipkin"")) {
            return prefix + ""zipkin.png"";
        }

        return null;
    }",This method is used to get the image path of an embedded icon in the console.
"public static Node findNodeByName(Document doc, String pathExpression) {
        final StringTokenizer tok = new StringTokenizer(pathExpression, ""."");
        final int numToks = tok.countTokens();
        NodeList elements;
        if (numToks == 1) {
            elements = doc.getElementsByTagNameNS(""*"", pathExpression);
            return elements.item(0);
        }

        String element = pathExpression.substring(pathExpression.lastIndexOf('.')+1);
        elements = doc.getElementsByTagNameNS(""*"", element);

        String attributeName = null;
        if (elements.getLength() == 0) {
            //No element found, but maybe we are searching for an attribute
            attributeName = element;

            //cut off attributeName and set element to next token and continue
            Node found = findNodeByName(doc, pathExpression.substring(0, pathExpression.length() - attributeName.length() - 1));

            if (found != null) {
                return found.getAttributes().getNamedItem(attributeName);
            } else {
                return null;
            }
        }

        StringBuffer pathName;
        Node parent;
        for (int j=0; j<elements.getLength(); j++) {
            int cnt = numToks-1;
            pathName = new StringBuffer(element);
            parent = elements.item(j).getParentNode();
            do {
                if (parent != null) {
                    pathName.insert(0, '.');
                    pathName.insert(0, parent.getLocalName());//getNodeName());

                    parent = parent.getParentNode();
                }
            } while (parent != null && --cnt > 0);
            if (pathName.toString().equals(pathExpression)) {return elements.item(j);}
        }

        return null;
    }",Find Node by pathExpression.
"public Number getAndDecryptNumber(String name, String providerName) throws Exception {
        return (Number) getAndDecrypt(name, providerName);
    }",Get a Number from the name and provider name.
"public Object lookup(String type, String url)
        throws IOException
    {
        return new HessianRemote(type, url);
    }",Lookup a single Hessian class from the URL.
"private boolean move0(PoolChunk<T> chunk) {
        if (prevList == null) {
            // There is no previous PoolChunkList so return false which result in having the PoolChunk destroyed and
            // all memory associated with the PoolChunk will be released.
            assert chunk.usage() == 0;
            return false;
        }
        return prevList.move(chunk);
    }",Move the PoolChunk to the beginning of the list.
"public static final PaperSize getPaperSize(ULocale locale){
        UResourceBundle obj = measurementTypeBundleForLocale(locale, PAPER_SIZE);
        int[] size = obj.getIntVector();
        return new PaperSize(size[0], size[1]);
    }",Gets the paper size.
"Long getCharOctLenAct() {

        switch (type) {

            case Types.SQL_CHAR :
            case Types.SQL_NCHAR :
            case Types.SQL_VARCHAR :
            case Types.SQL_NVARCHAR :
                return ValuePool.getLong(2L * Integer.MAX_VALUE);

            case Types.SQL_CLOB :
            case Types.NCLOB :
                return ValuePool.getLong(Long.MAX_VALUE);

            default :
                return null;
        }
    }",getCharOctLenAct This method is used to get the value of the char in the SQL statement.
"public static Iterator<MutableLongTuple> lexicographicalIterator(
        LongTuple min, LongTuple max)
    {
        Utils.checkForEqualSize(min, max);
        LongTuple localMin = LongTuples.copy(min);
        LongTuple localMax = LongTuples.copy(max);
        return new LongTupleIterator(localMin, localMax, 
            LongTupleIncrementors.lexicographicalIncrementor());
    }",Returns an iterator over the tuples in lexicographical order.
"public static Object getFieldValue(Object obj, String name) {
        Class<?> clazz = obj.getClass();
        try {
            Field f = clazz.getDeclaredField(name);
            return f.get(obj);
        }
        catch (Exception e) {
            return null;
        }
    }",Gets the value of a single field from an object.
"@Override
    public void endElement(String uri, String local, String raw) {
        if (NS_ATOMTYPE.equals(uri)) {
            endAtomTypeElement(local);
        } // ignore other namespaces
        currentChars = """";
    }",End an XML element.
"private boolean walkInvalidList(String className, String name, String[][] list) {
        boolean isInvalidCombination = false;

        for (int i = 0; i != list.length; i++) {
            if (className.equalsIgnoreCase(list[i][0])) {
                if (name.equalsIgnoreCase(list[i][1])) {
                    isInvalidCombination = true;
                    break;
                }
            }
        }
        return isInvalidCombination;
    }",Walk invalid list.
"public static String hashPassword(String clearPswd) {
        if (StringUtils.isNotEmpty(clearPswd)) {
            SimpleDigest digest = new SimpleDigest();
            String hashedPswd = digest.digestBase64(clearPswd);

            return hashedPswd + PASSWORD_SEP + digest.getBase64Salt();
        } else {
            return null;
        }
    }",Hash password.
"public String getName() {
    ResourceServices services = getServices();
    return (services != null) ? services.getResourceName() : null;
  }",Gets the name of the resource.
"public /*@Nullable*/Downloader startGetFile(final String path, /*@Nullable*/String rev)
            throws DbxException
    {
        DbxPathV1.checkArgNonRoot(""path"", path);
        String apiPath = ""1/files/auto"" + path;
        /*@Nullable*/String[] params = {
            ""rev"", rev
        };
        return startGetSomething(apiPath, params);
    }",Download a file from the server.
"public static Resource child(@NotNull Resource parentResource, @NotNull String name, @NotNull String resourceType,
      @NotNull ValueMap valueMap) {
    Resource child = new GraniteUiSyntheticResource(parentResource.getResourceResolver(),
        parentResource.getPath() + ""/"" + name,
        resourceType,
        valueMap,
        ImmutableList.<Resource>of());
    if (parentResource instanceof GraniteUiSyntheticResource) {
      ((GraniteUiSyntheticResource)parentResource).addChild(child);
    }
    else {
      throw new IllegalArgumentException(""Resource is not a GraniteUiSyntheticResource."");
    }
    return child;
  }",Create a child resource from a parent resource.
"@SuppressWarnings({""WeakerAccess"", ""unused"", ""unchecked""})
    @Internal
    @UsedByGeneratedCode
    protected Object postConstruct(BeanResolutionContext resolutionContext, BeanContext context, Object bean) {
        DefaultBeanContext defaultContext = (DefaultBeanContext) context;
        Collection<BeanRegistration<BeanInitializedEventListener>> beanInitializedEventListeners = ((DefaultBeanContext) context).beanInitializedEventListeners;
        if (CollectionUtils.isNotEmpty(beanInitializedEventListeners)) {
            for (BeanRegistration<BeanInitializedEventListener> registration : beanInitializedEventListeners) {
                BeanDefinition<BeanInitializedEventListener> definition = registration.getBeanDefinition();
                List<Argument<?>> typeArguments = definition.getTypeArguments(BeanInitializedEventListener.class);
                if (CollectionUtils.isEmpty(typeArguments) || typeArguments.get(0).getType().isAssignableFrom(getBeanType())) {
                    BeanInitializedEventListener listener = registration.getBean();
                    bean = listener.onInitialized(new BeanInitializingEvent(context, this, bean));
                    if (bean == null) {
                        throw new BeanInstantiationException(resolutionContext, ""Listener ["" + listener + ""] returned null from onInitialized event"");
                    }
                }
            }
        }

        for (int i = 0; i < methodInjectionPoints.size(); i++) {
            MethodInjectionPoint methodInjectionPoint = methodInjectionPoints.get(i);
            if (methodInjectionPoint.isPostConstructMethod() && methodInjectionPoint.requiresReflection()) {
                injectBeanMethod(resolutionContext, defaultContext, i, bean);
            }
        }
        if (bean instanceof LifeCycle) {
            bean = ((LifeCycle) bean).start();
        }
        return bean;
    }",PostConstruct method.
"@Override
   public boolean isWrapperFor(Class<?> iface) throws SQLException
   {
      if (iface.isInstance(this)) {
         return true;
      }

      HikariPool p = pool;
      if (p != null) {
         final DataSource unwrappedDataSource = p.getUnwrappedDataSource();
         if (iface.isInstance(unwrappedDataSource)) {
            return true;
         }

         if (unwrappedDataSource != null) {
            return unwrappedDataSource.isWrapperFor(iface);
         }
      }

      return false;
   }",isWrapperFor Method.
"@Override
    public void trainOnInstanceImpl(Instance instance) {

        if (m_weights == null) {
            int length;
             if (instance.classAttribute().isNominal()) {
                 length = instance.numClasses();
             } else {
                 length = 1;
             }
            m_weights = new DoubleVector[length];
            m_bias = new double[length];
            for (int i = 0; i < m_weights.length; i++){
                m_weights[i] = new DoubleVector(); 
                m_bias[i] = 0.0;
            }
        }
        for (int i = 0; i < m_weights.length; i++){
                this.trainOnInstanceImpl(instance, i); 
            }
        m_t++;
    }",trainOnInstanceImpl This method is called to train the class.
"@Nullable
	public static KeyedStateHandle chooseTheBestStateHandleForInitial(
		@Nonnull Collection<KeyedStateHandle> restoreStateHandles,
		@Nonnull KeyGroupRange targetKeyGroupRange) {

		KeyedStateHandle bestStateHandle = null;
		double bestScore = 0;
		for (KeyedStateHandle rawStateHandle : restoreStateHandles) {
			double handleScore = STATE_HANDLE_EVALUATOR.apply(rawStateHandle, targetKeyGroupRange);
			if (handleScore > bestScore) {
				bestStateHandle = rawStateHandle;
				bestScore = handleScore;
			}
		}

		return bestStateHandle;
	}",Returns the best state handle for the initial state.
"private static String joinAndGetValueForInsert(List<Field> fields, String sep, String fieldPrefix,
			List<Object> values, Object obj, boolean isWithNullValue) {
		if(values == null || obj == null) {
			throw new InvalidParameterException(""joinAndGetValueForInsert require values and obj"");
		}
		
        fieldPrefix = fieldPrefix == null ? """" : fieldPrefix.trim();

    	StringBuilder sb = new StringBuilder();
    	for(Field field : fields) {
    		Column column = field.getAnnotation(Column.class);
    		if(!(column.computed().trim().isEmpty())) {
    			continue; // insert不加入computed字段
    		}

			Object value = DOInfoReader.getValue(field, obj);
			if(value != null && column.isJSON()) {
				value = JSON.toJson(value);
			}
			if(isWithNullValue) {
				values.add(value);
			} else {
				if(value == null) {
					continue; // 不加入该column
				} else {
					values.add(value);
				}
			}
    		
        	sb.append(fieldPrefix).append(getColumnName(column)).append(sep);
    	}
    	int len = sb.length();
    	return len == 0 ? """" : sb.toString().substring(0, len - 1);
	}",Join get value for insert.
"@Trivial
    private static MessageDigest getMessageDigest() throws NoSuchAlgorithmException {
        // If we've never been asked for a MessageDigest, create the parent of
        // our clones. This is not thread safe, but it does not really need to
        // be, since we're just establishing the parent. If we incur the cost
        // of creating two clones the first time through, that's really not
        // worth synchronizing this whole method.
        if (CLONEABLE_MESSAGE_DIGEST == null) {
            CLONEABLE_MESSAGE_DIGEST = MessageDigest.getInstance(MESSAGE_DIGEST_ALGORITHM);
        }

        // Try to clone the parent. If we can't, then we'll FFDC and create a
        // new instance. If the clone fails, which is REALLY unlikely, as we
        // know the SHA MessageDigest is cloneable on IBM and Sun JDKs, we'll
        // get FFDCs.
        try {
            return (MessageDigest) CLONEABLE_MESSAGE_DIGEST.clone();
        } catch (CloneNotSupportedException cnse) {
            if (tc.isDebugEnabled()) {
                Tr.debug(tc, ""CloneNotSupportedException caught while trying to clone MessageDigest with algorithm "" + MESSAGE_DIGEST_ALGORITHM
                             + "". This is pretty unlikely, and we need to get details about the JDK which is in use."", cnse);
            }
            return MessageDigest.getInstance(MESSAGE_DIGEST_ALGORITHM);
        }
    }",Get the MessageDigest object that is used by the caller.
"public void compileScript(String url, String text) {
        DimIProxy action = new DimIProxy(this, IPROXY_COMPILE_SCRIPT);
        action.url = url;
        action.text = text;
        action.withContext();
    }",Compile a script.
"protected CompensatingTransactionHolderSupport getNewHolder() {
        DirContext newCtx = getContextSource().getReadWriteContext();
        return new DirContextHolder(
                new DefaultCompensatingTransactionOperationManager(
                        new LdapCompensatingTransactionOperationFactory(
                                renamingStrategy)), newCtx);
    }",Get a new instance of CompensatingTransactionHolderSupport.
"public void free()
    {
        if (m_mapTasks != null)
        {
            while (m_mapTasks.size() > 0)
            {
                for (Task task : m_mapTasks.keySet())
                {
                    if (task != null)
                    {
                    	int iCount = 0;
                        while (task.isRunning())  // This will also remove this from the list
                        {
                        	if (iCount++ == 10)
                        	{
                                Util.getLogger().warning(""Shutting down a running task"");   // Ignore and continue
                        		break;
                        	}
                        	try {
								Thread.sleep(100);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
                        }
                        this.removeTask(task);	// Make sure this doesn't free me (if all tasks are freed, app will be freed)
                        task.setApplication(null);
                        task.stopTask();
                    }
                    else
                    {
                        try {
                            RemoteTask remoteTask = m_mapTasks.remove(task);
                            if (remoteTask != null)
                                remoteTask.freeRemoteSession();
                        } catch (RemoteException ex)    {
                            ex.printStackTrace();
                        }
                    }
                    break;  // YES, This only loops through the FIRST one, because it is removed and I would get a concurrent mod error
                }
            }
        }
        m_mapTasks = null;
        if (m_PhysicalDatabaseParent instanceof Freeable)
        {
            ((Freeable)m_PhysicalDatabaseParent).free();
            m_PhysicalDatabaseParent = null;
        }
    }",Free the database.
"@Override
    public Message newMessage(final String message) {
        final ReusableSimpleMessage result = getSimple();
        result.set(message);
        return result;
    }",Create a new message.
"public List<DomainObjectType> getDomainObjectTypes() {
		List<DomainObjectType> resultList = new ArrayList<DomainObjectType>();
		GrNode infoNode = loadDomainInfoNode();
		GrProperty prop = infoNode.getProperty(DomainInfoLabel2ClassProperty);
		if (prop != null) {
			@SuppressWarnings(""unchecked"")
			List<String> val = (List<String>) prop.getValue();
			for (String str : val) {
				String[] c2l = str.split(""="");
				resultList.add(new DomainObjectType(c2l[1], c2l[0]));
			}
		}
		return resultList;
	}",Returns a list of DomainObjectType objects that are contained in the domain info node.
"public void applyAndJournal(Supplier<JournalContext> context, UpdateInodeEntry entry) {
    try {
      applyUpdateInode(entry);
      context.get().append(JournalEntry.newBuilder().setUpdateInode(entry).build());
    } catch (Throwable t) {
      ProcessUtils.fatalError(LOG, t, ""Failed to apply %s"", entry);
      throw t; // fatalError will usually system.exit
    }
  }",Apply an update inode entry to the inode and journal the entry.
"@CodingStyleguideUnaware
  public static <T extends Iterable <?>> T notEmpty (final T aValue, @Nonnull final Supplier <? extends String> aName)
  {
    notNull (aValue, aName);
    if (isEnabled ())
      if (!aValue.iterator ().hasNext ())
        throw new IllegalArgumentException (""The value of the iterable '"" + aName.get () + ""' may not be empty!"");
    return aValue;
  }",Check if the passed iterable is not empty.
"public static <T extends Comparable<T>> int compareArrays(T[] first, T[] second) {
    List<T> firstAsList = Arrays.asList(first);
    List<T> secondAsList = Arrays.asList(second);
    return CollectionUtils.compareLists(firstAsList, secondAsList);
  }",Compares two arrays of type T.
"@Override
    public synchronized void timeoutTransaction(boolean initial) {
        final boolean traceOn = TraceComponent.isAnyTracingEnabled();

        if (traceOn && tc.isEntryEnabled())
            Tr.entry(tc, ""timeoutTransaction"", initial);

        if (traceOn && tc.isEventEnabled())
            Tr.event(tc, ""(SPI) Transaction TIMEOUT occurred for TX: "" + getLocalTID());

        _timedOut = true; // mark

        if (initial) // initial timeout
        {
            _rollbackOnly = true;

            abortTransactionParticipants();

            // inactivity timeout may have happened ... check status
            if (_status.getState() == TransactionState.STATE_ACTIVE) {
                // If there is no txn timeout, or we are into completion phase the timeout setting may be zero
                if (_timeout == 0)
                    _timeout = 10;
                EmbeddableTimeoutManager.setTimeout(this, EmbeddableTimeoutManager.REPEAT_TIMEOUT, _timeout);

                // d369039 only rollback if still in ACTIVE state
                if (_activeAssociations <= 0) {
                    rollbackResources();
                }
            }
        } else if (_activeAssociations <= 0) // off server ... do the rollback
        {
            final EmbeddableTranManagerSet tranManager = (EmbeddableTranManagerSet) TransactionManagerFactory.getTransactionManager();

            boolean resumed = false;
            try {
                tranManager.resume(this);
                resumed = true;
            } catch (Throwable t) {
                FFDCFilter.processException(t, ""com.ibm.ws.tx.jta.TransactionImpl.timeoutTransaction"", ""1311"", this);
                if (traceOn && tc.isDebugEnabled())
                    Tr.debug(tc, ""timeoutTransaction resume threw exception"", t);
                // swallow this exception
            }

            if (resumed) {
                boolean rolledback = false;
                try {
                    tranManager.rollback();
                    rolledback = true;
                } catch (Throwable t) {
                    FFDCFilter.processException(t, ""com.ibm.ws.tx.jta.TransactionImpl.timeoutTransaction"", ""1326"", this);
                    if (traceOn && tc.isDebugEnabled())
                        Tr.debug(tc, ""timeoutTransaction rollback threw exception"", t);
                    // swallow this exception
                } finally {
                    if (!rolledback) {
                        tranManager.suspend();
                    }
                }
            }
        } else // on server ... just re-schedule timeout
        {
            _rollbackOnly = true; // for the case of server quiesce?
            // inactivity timeout may have happened ... check status
            if (_status.getState() == TransactionState.STATE_ACTIVE) {
                // If there is no txn timeout, or we are into completion phase the timeout setting may be zero
                if (_timeout == 0)
                    _timeout = 10;
                EmbeddableTimeoutManager.setTimeout(this, EmbeddableTimeoutManager.REPEAT_TIMEOUT, _timeout);
            }
        }

        if (traceOn && tc.isEntryEnabled())
            Tr.exit(tc, ""timeoutTransaction"");
    }",Called by the SPI to signal that a timeout occurs on a transaction.
"public void filter(ClientRequestContext request) throws IOException
    {
        if(!request.getHeaders().containsKey(""X-Query-Key""))
            request.getHeaders().add(""X-Query-Key"", this.querykey);
    }",Add the query key to the request.
"public static CustomSerializer getCustomSerializer(CommandCode code) {
        if (!commandCustomSerializer.isEmpty()) {
            return commandCustomSerializer.get(code);
        }
        return null;
    }",Get the CustomSerializer for a command code.
"public Diff decode()
		throws UnsupportedEncodingException, DecodingException
	{

		int header = r.read(3);
		if (DiffAction.parse(header) != DiffAction.DECODER_DATA) {

			throw new DecodingException(""Invalid codecData code: "" + header);
		}

		int blockSize_C = 3;
		int blockSize_S = r.read(5);
		int blockSize_E = r.read(5);
		int blockSize_B = r.read(5);
		int blockSize_L = r.read(5);
		r.read(1);

		if (blockSize_S < 0 || blockSize_S > 31) {
			throw new DecodingException(""blockSize_S out of range: ""
					+ blockSize_S);
		}
		if (blockSize_E < 0 || blockSize_E > 31) {
			throw new DecodingException(""blockSize_E out of range: ""
					+ blockSize_E);
		}
		if (blockSize_B < 0 || blockSize_B > 31) {
			throw new DecodingException(""blockSize_B out of range: ""
					+ blockSize_B);
		}
		if (blockSize_L < 0 || blockSize_L > 31) {
			throw new DecodingException(""blockSize_L out of range: ""
					+ blockSize_L);
		}

		return decode(blockSize_C, blockSize_S, blockSize_E, blockSize_B,
				blockSize_L);
	}",Decodes the diff from the codecData.
"private void setAddInfoMaps() {

        m_addInfoEditable = new TreeMap<String, Object>();
        m_addInfoReadOnly = new TreeMap<String, Object>();
        Iterator<Entry<String, Object>> itEntries = m_user.getAdditionalInfo().entrySet().iterator();
        while (itEntries.hasNext()) {
            Entry<String, Object> entry = itEntries.next();
            String key = entry.getKey().toString();
            if ((entry.getValue() == null) || CmsStringUtil.isEmptyOrWhitespaceOnly(entry.getValue().toString())) {
                // skip empty entries
                continue;
            }
            if (!entry.getValue().getClass().equals(String.class)) {
                // only show type different to string
                key += ""@"" + entry.getValue().getClass().getName();
            }
            if (CmsDataTypeUtil.isParseable(entry.getValue().getClass())) {
                m_addInfoEditable.put(key, entry.getValue());
            } else {
                String value = entry.getValue().toString();
                if (value.length() > (75 - key.length())) {
                    if ((75 - key.length()) > 5) {
                        value = value.substring(0, (75 - key.length())) + "" ..."";
                    } else {
                        value = ""..."";
                    }
                }
                m_addInfoReadOnly.put(key, value);
            }
        }
    }",Sets the add info maps.
"public boolean canValidate(Document doc) {
        XsdSchema schema = schemaMappingStrategy.getSchema(schemas, doc);
        return schema != null;
    }",Check if the document can be validated.
"public static <T> T[] notEmpty(final T[] array, final String message, final Object... values) {
        return INSTANCE.notEmpty(array, message, values);
    }",Check that an array is not empty.
"@Override
    public InputStream getLicenseInformation() {
        try {
            if (liEntry != null)
                return liEntry.getInputStream();
        } catch (IOException e) {
        }
        return null;
    }",Get the license information.
"public static String underscoreToCamelCase(final String undescoredString) {

        // Split the string for each underscore
        final String[] parts = undescoredString.split(CASE_SEPARATOR);
        final StringBuilder camelCaseString = new StringBuilder(undescoredString.length());
        camelCaseString.append(parts[0].toLowerCase(Locale.getDefault()));

        // Skip the first part already added
        for (int i = 1; i < parts.length; i++) {
            // First letter to upper case
            camelCaseString.append(parts[i].substring(0, 1).toUpperCase(Locale.getDefault()));
            // Others to lower case
            camelCaseString.append(parts[i].substring(1).toLowerCase(Locale.getDefault()));
        }
        return camelCaseString.toString();

    }",Convert an underscored string to a camel cased string.
"@TargetApi(Build.VERSION_CODES.GINGERBREAD)
    public void apply() {
        if (editing == null) {
            return;
        }
        try {
            editing.apply();
        } catch (Exception ex) {
            editing.commit(); // Fallback in case low api lever.
        }
        editing = null;
    }",Apply the CRS to the CRS.
"@Override
  public Set<C> columnKeySet() {
    Set<C> result = columnKeySet;
    return (result == null) ? columnKeySet = new ColumnKeySet() : result;
  }",Override this method to return the column key set.
"private CmsResource handleSecureResource(
        CmsObject cms,
        HttpServletRequest req,
        HttpServletResponse res,
        CmsResource resource,
        String resourceName)
    throws CmsException, CmsVfsResourceNotFoundException {

        // check online project
        if (cms.getRequestContext().getCurrentProject().isOnlineProject() && (res != null)) {
            boolean secure = false;
            try {
                // check if resource is secure
                secure = Boolean.valueOf(
                    cms.readPropertyObject(
                        cms.getSitePath(resource),
                        CmsPropertyDefinition.PROPERTY_SECURE,
                        true).getValue()).booleanValue();
            } catch (CmsVfsResourceNotFoundException e) {
                LOG.warn(e.getLocalizedMessage(), e);
            } catch (CmsException e) {
                LOG.error(e.getLocalizedMessage(), e);
            }
            if (secure) {
                CmsResource resource1 = resource;
                // resource is secure, check site config
                CmsSite site = OpenCms.getSiteManager().getCurrentSite(cms);
                // check the secure url
                String secureUrl = null;
                try {
                    secureUrl = site.getSecureUrl();
                } catch (Exception e) {
                    LOG.error(
                        Messages.get().getBundle().key(Messages.ERR_SECURE_SITE_NOT_CONFIGURED_1, resourceName),
                        e);
                    throw new CmsException(
                        Messages.get().container(Messages.ERR_SECURE_SITE_NOT_CONFIGURED_1, resourceName),
                        e);
                }
                boolean usingSec = true;
                if (req != null) {
                    usingSec = req.getRequestURL().toString().toUpperCase().startsWith(secureUrl.toUpperCase());
                }
                if (site.isExclusiveUrl() && !usingSec) {
                    resource1 = null;
                    // secure resource without secure protocol, check error config
                    if (site.isExclusiveError()) {
                        // trigger 404 error
                        throw new CmsVfsResourceNotFoundException(
                            Messages.get().container(Messages.ERR_REQUEST_SECURE_RESOURCE_0));
                    } else {
                        // redirect
                        String target = OpenCms.getLinkManager().getOnlineLink(cms, resourceName);
                        if (!target.toLowerCase().startsWith(secureUrl.toLowerCase())) {
                            Optional<String> targetWithReplacedHost = CmsStringUtil.replacePrefix(
                                target,
                                site.getSiteMatcher().getUrl(),
                                secureUrl,
                                true);
                            if (targetWithReplacedHost.isPresent()) {
                                target = targetWithReplacedHost.get();
                            }
                            if (!target.toLowerCase().startsWith(secureUrl.toLowerCase())) {
                                LOG.warn(""Failed to generate secure URL for "" + target + "", site = "" + site);
                            }
                        }

                        try {
                            if (site.usesPermanentRedirects()) {
                                res.setStatus(HttpServletResponse.SC_MOVED_PERMANENTLY);
                                res.setHeader(""Location"", target);
                            } else {
                                res.sendRedirect(target);
                            }
                        } catch (Exception e) {
                            // ignore, but should never happen
                            LOG.error(""Error sending secure resource redirect."", e);
                        }
                    }
                }
                resource = resource1;
            }

        }
        return resource;
    }",Handle secure resource.
"static String[] getRemoteTypeIds(Class<?> remoteInterface) {
        ArrayList<String> remoteTypes = new ArrayList<String>();
        remoteTypes.add(getRemoteTypeId(remoteInterface));

        Class<?>[] interfaces = remoteInterface.getInterfaces();
        for (Class<?> remote : interfaces) {
            if (remote != Remote.class) {
                remoteTypes.add(getRemoteTypeId(remote));
            }
        }

        return remoteTypes.toArray(new String[remoteTypes.size()]);
    }",Get the remote type ids of the given interface.
"private void onIdAttribute(final MetaModelBuilder builder, EntityMetadata entityMetadata, final Class clazz, Field f)
    {
        EntityType entity = (EntityType) builder.getManagedTypes().get(clazz);

        Attribute attrib = entity.getAttribute(f.getName());
        if (!attrib.isCollection() && ((SingularAttribute) attrib).isId())
        {
            entityMetadata.setIdAttribute((SingularAttribute) attrib);
            populateIdAccessorMethods(entityMetadata, clazz, f);
        }
    }",On id attribute.
"@Override
    public void acknowledge(SQSMessage message) throws JMSException {
        session.checkClosed();
        amazonSQSClient.deleteMessage(new DeleteMessageRequest(
                message.getQueueUrl(), message.getReceiptHandle()));
        unAckMessages.remove(message.getReceiptHandle());
    }",Acknowledges a message.
"private static byte[] digest(final byte[] input, final String algorithm, final byte[] salt, final int iterations) {
		try {
			MessageDigest digest = MessageDigest.getInstance(algorithm);

			if (salt != null) {
				digest.update(salt);
			}

			byte[] result = digest.digest(input);

			for (int i = 1; i < iterations; i++) {
				digest.reset();
				result = digest.digest(result);
			}
			return result;
		} catch (NoSuchAlgorithmException e) {
			throw new ImpossibleException(e);
		}
	}",Digest a byte array using the specified algorithm salt and iterations.
"private static void addPartyData(final DataSeries dataSeries, final SimpleDateFormat simpleDateFormat,
			final List<ViewRiksdagenVoteDataBallotPartySummaryDaily> list, final Function<ViewRiksdagenVoteDataBallotPartySummaryDaily, Object> t) {
		dataSeries.newSeries();
		for (final ViewRiksdagenVoteDataBallotPartySummaryDaily viewRiksdagenVoteDataBallotPartySummaryDaily : list) {
			if (viewRiksdagenVoteDataBallotPartySummaryDaily != null) {
				dataSeries.add(
						simpleDateFormat
								.format(viewRiksdagenVoteDataBallotPartySummaryDaily.getEmbeddedId().getVoteDate()),
						t.apply(viewRiksdagenVoteDataBallotPartySummaryDaily));
			}
		}
	}",Add party data to a data series
"private void createAreas(final BufferedImage IMAGE) {
        final Point2D AREA_OFFSET = new Point2D.Double(0, 0);

        if (bImage != null && !getAreas().isEmpty()) {
            double stopAngle = 0;
            double startAngle = 0;

            final double OUTER_RADIUS = bImage.getWidth() *  0.3411214953f;
            final double RADIUS;
            if (isSectionsVisible()) {
                RADIUS = isExpandedSectionsEnabled() ? OUTER_RADIUS - bImage.getWidth() * 0.12f : OUTER_RADIUS - bImage.getWidth() * 0.023364486f;
            } else {
                RADIUS = OUTER_RADIUS;
            }

            final double FREE_AREA = bImage.getWidth() / 2.0 - RADIUS;
            final Rectangle2D AREA_FRAME = new Rectangle2D.Double(bImage.getMinX() + FREE_AREA * 0.9 + AREA_OFFSET.getX(), bImage.getMinY() + FREE_AREA * 0.9 + AREA_OFFSET.getY(), 4 * RADIUS, 4 * RADIUS);

            for (Section tmpArea : getAreas()) {
                switch (getOrientation()) {
                    case NORTH_EAST:
                        if (!isLogScale()) {
                            stopAngle = 90 - Math.toDegrees((getMaxValue() - tmpArea.getStop() - getMinValue()) * getAngleStep());
                            startAngle = 90 - Math.toDegrees((getMaxValue() - tmpArea.getStart() - getMinValue()) * getAngleStep());
                        } else {
                            stopAngle = 90 - Math.toDegrees(UTIL.logOfBase(BASE, getMaxValue() - tmpArea.getStop() - getMinValue()) * getLogAngleStep());
                            startAngle = 90 - Math.toDegrees(UTIL.logOfBase(BASE, getMaxValue() - tmpArea.getStart() - getMinValue()) * getLogAngleStep());
                        }
                        AREA_OFFSET.setLocation(-bImage.getWidth() * 0.45, bImage.getWidth() * 0.195);
                        break;

                    case SOUTH_EAST:
                        if (!isLogScale()) {
                            stopAngle = 0 - Math.toDegrees((getMaxValue() - tmpArea.getStop() - getMinValue()) * getAngleStep());
                            startAngle = 0 - Math.toDegrees((getMaxValue() - tmpArea.getStart() - getMinValue()) * getAngleStep());
                        } else {
                            stopAngle = 0 - Math.toDegrees(UTIL.logOfBase(BASE, getMaxValue() - tmpArea.getStop() - getMinValue()) * getLogAngleStep());
                            startAngle = 0 - Math.toDegrees(UTIL.logOfBase(BASE, getMaxValue() - tmpArea.getStart() - getMinValue()) * getLogAngleStep());
                        }
                        AREA_OFFSET.setLocation(-bImage.getWidth() * 0.45, -bImage.getWidth() * 0.45);
                        break;

                    case SOUTH_WEST:
                        if (!isLogScale()) {
                            stopAngle = 270 - Math.toDegrees((tmpArea.getStop() - getMinValue()) * getAngleStep());
                            startAngle = 270 - Math.toDegrees((tmpArea.getStart() - getMinValue()) * getAngleStep());
                        } else {
                            stopAngle = 270 - Math.toDegrees(UTIL.logOfBase(BASE, tmpArea.getStop() - getMinValue()) * getLogAngleStep());
                            startAngle = 270 - Math.toDegrees(UTIL.logOfBase(BASE, tmpArea.getStart() - getMinValue()) * getLogAngleStep());
                        }
                        AREA_OFFSET.setLocation(bImage.getWidth() * 0.195, -bImage.getWidth() * 0.45);
                        break;

                    case NORTH_WEST:

                    default:
                        if (!isLogScale()) {
                            stopAngle = 180 - Math.toDegrees((tmpArea.getStop() - getMinValue()) * getAngleStep());
                            startAngle = 180 - Math.toDegrees((tmpArea.getStart() - getMinValue()) * getAngleStep());
                        } else {
                            if (!isLogScale()) {
                            stopAngle = 180 - Math.toDegrees(UTIL.logOfBase(BASE, tmpArea.getStop() - getMinValue()) * getLogAngleStep());
                            startAngle = 180 - Math.toDegrees(UTIL.logOfBase(BASE, tmpArea.getStart() - getMinValue()) * getLogAngleStep());
                        }
                        }
                        if (isSectionsVisible()) {
                            AREA_OFFSET.setLocation(bImage.getWidth() * 0.195, bImage.getWidth() * 0.195);
                        } else {
                            AREA_OFFSET.setLocation(bImage.getWidth() * 0.148271028, bImage.getWidth() * 0.148271028);
                        }

                        break;
                }
                final java.awt.geom.Arc2D ARC = new java.awt.geom.Arc2D.Double(AREA_FRAME, 0 - (tmpArea.getStart() * getAngleStep()), -(tmpArea.getStop() - tmpArea.getStart()) * getAngleStep(), java.awt.geom.Arc2D.PIE);
                ARC.setFrame(AREA_OFFSET.getX(), AREA_OFFSET.getY(), 4 * RADIUS, 4 * RADIUS);
                ARC.setAngleStart(startAngle);
                ARC.setAngleExtent(stopAngle - startAngle);
                tmpArea.setFilledArea(ARC);
            }

            // Draw the area
            if (isAreasVisible() && IMAGE != null) {
                final Graphics2D G2 = IMAGE.createGraphics();
                G2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
                for (Section area : getAreas()) {
                    G2.setColor(isTransparentAreasEnabled() ? area.getTransparentColor() : area.getColor());
                    G2.fill(area.getFilledArea());
                }
                G2.dispose();
            }
        }
    }",Create the areas.
"public String toStringByValue() {
	IntArrayList theKeys = new IntArrayList();
	keysSortedByValue(theKeys);

	StringBuffer buf = new StringBuffer();
	buf.append(""["");
	int maxIndex = theKeys.size() - 1;
	for (int i = 0; i <= maxIndex; i++) {
		int key = theKeys.get(i);
	    buf.append(String.valueOf(key));
		buf.append(""->"");
	    buf.append(String.valueOf(get(key)));
		if (i < maxIndex) buf.append("", "");
	}
	buf.append(""]"");
	return buf.toString();
}",Returns a String representation of this object.
"public static void scaleFit(Bitmap src, Bitmap dest, int clearColor) {
        float ratio = Math.min(dest.getWidth() / (float) src.getWidth(), dest.getHeight() / (float) src.getHeight());
        int newW = (int) (src.getWidth() * ratio);
        int newH = (int) (src.getHeight() * ratio);
        int paddingTop = (dest.getHeight() - (int) (src.getHeight() * ratio)) / 2;
        int paddingLeft = (dest.getWidth() - (int) (src.getWidth() * ratio)) / 2;

        scale(src, dest, clearColor, 0, 0, src.getWidth(), src.getHeight(), paddingLeft, paddingTop,
                newW + paddingLeft,
                newH + paddingTop);
    }",Scales the image to fit into the destination bitmap.
"protected void addSortedInserts(List<DbOperation> flush) {
    for (Entry<Class<?>, SortedSet<DbEntityOperation>> operationsForType : inserts.entrySet()) {

      // add inserts to flush
      if(HasDbReferences.class.isAssignableFrom(operationsForType.getKey())) {
        // if this type has self references, we need to resolve the reference order
        flush.addAll(sortByReferences(operationsForType.getValue()));
      } else {
        flush.addAll(operationsForType.getValue());
      }
    }
  }",Add the inserts to the flush list.
"@ReturnsMutableCopy
  @Nonnull
  public ICommonsMap <String, IVATItem> getAllVATItemsForCountry (@Nonnull final Locale aCountry)
  {
    ValueEnforcer.notNull (aCountry, ""Country"");

    final ICommonsMap <String, IVATItem> ret = new CommonsHashMap <> ();

    // first get locale specific VAT types
    final VATCountryData aVATCountryData = getVATCountryData (aCountry);
    if (aVATCountryData != null)
    {
      if (aVATCountryData.isZeroVATAllowed ())
        ret.put (VATTYPE_NONE.getID (), VATTYPE_NONE);
      ret.putAll (aVATCountryData.getAllItems ());
    }
    return ret;
  }",Get all VAT items for the passed country.
"public void setRefEdge(Integer newRefEdge) {
		Integer oldRefEdge = refEdge;
		refEdge = newRefEdge;
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, AfplibPackage.FINISHING_OPERATION__REF_EDGE, oldRefEdge, refEdge));
	}",Sets the reference edge of the operation.
"void cleanup() {
        State s;
        State nexts;
        int n;

    /* clear out unreachable or dead-end states */
    /* use pre to mark reachable, then post to mark can-reach-post */
        markreachable(pre, null, pre);
        markcanreach(post, pre, post);
        for (s = states; s != null; s = nexts) {
            nexts = s.next;
            if (s.tmp != post && 0 == s.flag) {
                dropstate(s);
            }
        }
        assert post.nins == 0 || post.tmp == post;

        cleartraverse(pre);

        assert post.nins == 0 || post.tmp == null;
    /* the nins==0 (final unreachable) case will be caught later */

    /* renumber surviving states */
        n = 0;
        for (s = states; s != null; s = s.next) {
            s.no = n++;
        }
        nstates = n;
    }",Cleanup the exception.
"boolean validateIssuer(String consumerConfigId, String issuers, String tokenIssuer) throws InvalidClaimException {
		boolean isIssuer = false;
		if (issuers == null || issuers.isEmpty()) {
			String msg = Tr.formatMessage(tc, ""JWT_TRUSTED_ISSUERS_NULL"",
					new Object[] { tokenIssuer, consumerConfigId });
			throw new InvalidClaimException(msg);
		}

		StringTokenizer st = new StringTokenizer(issuers, "","");
		while (st.hasMoreTokens()) {
			String iss = st.nextToken().trim();
			if (tc.isDebugEnabled()) {
				Tr.debug(tc, ""Trusted issuer: "" + iss);
			}
			if (Constants.ALL_ISSUERS.equals(iss) || (tokenIssuer != null && tokenIssuer.equals(iss))) {
				isIssuer = true;
				break;
			}
		}

		if (!isIssuer) {
			String msg = Tr.formatMessage(tc, ""JWT_ISSUER_NOT_TRUSTED"",
					new Object[] { tokenIssuer, consumerConfigId, issuers });
			throw new InvalidClaimException(msg);
		}
		return isIssuer;
	}",Validate issuer.
"public PagedResult<UpdateRequest> listUpdateRequests(long sheetId, PaginationParameters paging) throws SmartsheetException {
        String path = ""sheets/"" + sheetId + ""/updaterequests"";

        HashMap<String, Object> parameters = new HashMap<String, Object>();
        if (paging != null) {
            parameters = paging.toHashMap();
        }
        path += QueryUtil.generateUrl(null, parameters);

        return this.listResourcesWithWrapper(path, UpdateRequest.class);
    }",List all update requests for a single sheet.
"private void applyDefaultValues(Map<String, Object> parameterValues) {
    for (Parameter<?> parameter : allParameters) {
      parameterValues.put(parameter.getName(), getParameterDefaultValue(parameter));
    }
  }",Apply default values to all parameters.
"private String wrapMessage(final String message) {
		// Note that the original cowsay wraps lines mid-word.
		// This version differs in that it wraps between words if possible.
		int wrap = getWordwrap();
		if (wrap <= 0) {
			return message;
		}
		final List<String> result = new ArrayList<String>();
		String newLine = System.getProperty(""line.separator"");
		String[] lines = message.split(newLine);
		for (String line : lines) {
			result.add(WordUtils.wrap(line, wrap, null, true));
		}
		return StringUtils.join(result, newLine);
	}",Wrap a message in words if necessary.
"private void initStoreDefinitions(Version storesXmlVersion) {
        if(this.storeDefinitionsStorageEngine == null) {
            throw new VoldemortException(""The store definitions directory is empty"");
        }

        String allStoreDefinitions = ""<stores>"";
        Version finalStoresXmlVersion = null;
        if(storesXmlVersion != null) {
            finalStoresXmlVersion = storesXmlVersion;
        }
        this.storeNames.clear();

        ClosableIterator<Pair<String, Versioned<String>>> storesIterator = this.storeDefinitionsStorageEngine.entries();

        // Some test setups may result in duplicate entries for 'store' element.
        // Do the de-dup here
        Map<String, Versioned<String>> storeNameToDefMap = new HashMap<String, Versioned<String>>();
        Version maxVersion = null;
        while(storesIterator.hasNext()) {
            Pair<String, Versioned<String>> storeDetail = storesIterator.next();
            String storeName = storeDetail.getFirst();
            Versioned<String> versionedStoreDef = storeDetail.getSecond();
            storeNameToDefMap.put(storeName, versionedStoreDef);
            Version curVersion = versionedStoreDef.getVersion();

            // Get the highest version from all the store entries
            if(maxVersion == null) {
                maxVersion = curVersion;
            } else if(maxVersion.compare(curVersion) == Occurred.BEFORE) {
                maxVersion = curVersion;
            }
        }

        // If the specified version is null, assign highest Version to
        // 'stores.xml' key
        if(finalStoresXmlVersion == null) {
            finalStoresXmlVersion = maxVersion;
        }

        // Go through all the individual stores and update metadata
        for(Entry<String, Versioned<String>> storeEntry: storeNameToDefMap.entrySet()) {
            String storeName = storeEntry.getKey();
            Versioned<String> versionedStoreDef = storeEntry.getValue();

            // Add all the store names to the list of storeNames
            this.storeNames.add(storeName);

            this.metadataCache.put(storeName, new Versioned<Object>(versionedStoreDef.getValue(),
                                                                    versionedStoreDef.getVersion()));
        }

        Collections.sort(this.storeNames);
        for(String storeName: this.storeNames) {
            Versioned<String> versionedStoreDef = storeNameToDefMap.get(storeName);
            // Stitch together to form the complete store definition list.
            allStoreDefinitions += versionedStoreDef.getValue();

        }

        allStoreDefinitions += ""</stores>"";

        // Update cache with the composite store definition list.
        metadataCache.put(STORES_KEY,
                          convertStringToObject(STORES_KEY,
                                                new Versioned<String>(allStoreDefinitions,
                                                                      finalStoresXmlVersion)));
    }",Initialize the store definitions.
"private Vector getDistinctSortedY(Vector distinctY, Vector piecesEachY, ArrayList<TextPiece> wordsOfAPage, 
    TableCandidate tc) {
    	int pieceNumThisPage = wordsOfAPage.size();
    	float x_columnToGetYs = m_docInfo.getMinX();
    	float endX_columnToGetYs = m_docInfo.getMiddleX();
    	if ( (tc.isWideTable()==false) && (tc.getCaptionX()>=m_docInfo.getMiddleX())){
    		x_columnToGetYs = m_docInfo.getMiddleX();
    		endX_columnToGetYs = m_docInfo.getMaxX();
    	}
    	float[] sortY = new float[pieceNumThisPage];		
    	for (int bb=0; bb<pieceNumThisPage; bb++) {
    		if ( (wordsOfAPage.get(bb).getX()>=x_columnToGetYs) && (wordsOfAPage.get(bb).getEndX()<=endX_columnToGetYs) ) {
    			sortY[bb]=wordsOfAPage.get(bb).getY();
    		}
    	}
    	Arrays.sort(sortY);
	
    	int bb=0; float lastY = 0.0f; 
    	while (bb<pieceNumThisPage)  {
    		if (distinctY.size()>0) 	lastY =((Float)distinctY.lastElement()).floatValue();
    		if ( (sortY[bb]-lastY)>=m_docInfo.getAverageLineGap()/2.0) 
    			distinctY.addElement(new Float(sortY[bb]));
    		bb++;
    	}
    	return distinctY;
    }",Get the distinct Y vector sorted by X
"public static vrid6[] get_filtered(nitro_service service, String filter) throws Exception{
		vrid6 obj = new vrid6();
		options option = new options();
		option.set_filter(filter);
		vrid6[] response = (vrid6[]) obj.getfiltered(service, option);
		return response;
	}",Use this API to fetch filtered set of vrid6 resources. set the filter parameter values in filter parameter value.
"public List<FunctionDescriptor> buildListing() {
        List<FunctionDescriptor> listing = new ArrayList<>();

        for (Map.Entry<String, Method> entry : m_functions.entrySet()) {
            FunctionDescriptor descriptor = new FunctionDescriptor(entry.getKey().toUpperCase());
            listing.add(descriptor);
        }

        Collections.sort(listing, new Comparator<FunctionDescriptor>() {
            @Override
            public int compare(FunctionDescriptor f1, FunctionDescriptor f2) {
                return f1.m_name.compareTo(f2.m_name);
            }
        });

        return listing;
    }",Build a listing of all the function descriptors.
"@PUT
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    public @Nullable KeyValue update(SetValue setValue) throws Exception {
        if (!setValue.hasNewValue() && !setValue.hasExpectedValue()) {
            throw new IllegalArgumentException(String.format(""key:%s - bad request: expectedValue and newValue not set"", key));
        }

        if (setValue.hasExpectedValue()) {
            return compareAndSet(setValue);
        } else {
            return set(setValue);
        }
    }",Updates the value of a Crafter Namenode namespace.
"@Override
  public void handleBitfieldAvailability(SharingPeer peer,
                                         BitSet availablePieces) {
    // Determine if the peer is interesting for us or not, and notify it.
    BitSet interesting = (BitSet) availablePieces.clone();
    synchronized (this) {
      interesting.andNot(this.completedPieces);
      interesting.andNot(this.requestedPieces);
    }
    // Record the peer has all the pieces it told us it had.
    for (int i = availablePieces.nextSetBit(0); i >= 0;
         i = availablePieces.nextSetBit(i + 1)) {
      this.pieces[i].seenAt(peer);
    }

    if (interesting.cardinality() == 0) {
      peer.notInteresting();
    } else {
      peer.interesting();
    }

    logger.debug(""Peer {} contributes {} piece(s), total pieces count: {}."",
            new Object[]{
                    peer,
                    availablePieces.cardinality(),
                    myTorrentMetadata.getPiecesCount()
            });
  }",Handle bitfield availability event.
"StringBuilder subBuf(int start, int end) {
		if (start > end) {
			return null;
		}
		StringBuilder ret = new StringBuilder(end - start + 1);
		for (int i=start; i<=end; i++) {
			ret.append(buf[i]);
		}
		return ret;
	}",Returns a sub - buffer of this buffer.
"private void initStandardTagsLowercase() {
        Iterator<String> it = standardTags.iterator();
        while (it.hasNext()) {
            standardTagsLowercase.add(StringUtils.toLowerCase(it.next()));
        }
    }",Initialize the standard tags lower case.
"public static no.bekk.bekkopen.person.Fodselsnummer getFodselsnummer(String fodselsnummer) throws IllegalArgumentException {
		validateSyntax(fodselsnummer);
		validateIndividnummer(fodselsnummer);
		validateDate(fodselsnummer);
		validateChecksums(fodselsnummer);
		return new no.bekk.bekkopen.person.Fodselsnummer(fodselsnummer);
	}",Returns an instance of the Fodselsnummer class.
"@Deprecated
    public void setPattern(Pattern pattern) {
        patterns = new ArrayList<Pattern>(1);
        patterns.add(pattern);
    }",Sets the pattern.
"private void writeJsonForArchivedJob(PrintWriter wrt, RecentJobEvent jobEvent) {
		
		try {
		
			wrt.write(""["");
		
			ManagementGraph jobManagementGraph = jobmanager.getManagementGraph(jobEvent.getJobID());
			
			//Serialize job to json
			wrt.write(""{"");
			wrt.write(""\""jobid\"": \"""" + jobEvent.getJobID() + ""\"","");
			wrt.write(""\""jobname\"": \"""" + jobEvent.getJobName()+""\"","");
			wrt.write(""\""status\"": \""""+ jobEvent.getJobStatus() + ""\"","");
			wrt.write(""\""SCHEDULED\"": ""+ jobmanager.getArchive().getJobTime(jobEvent.getJobID(), JobStatus.SCHEDULED) + "","");
			wrt.write(""\""RUNNING\"": ""+ jobmanager.getArchive().getJobTime(jobEvent.getJobID(), JobStatus.RUNNING) + "","");
			wrt.write(""\""FINISHED\"": ""+ jobmanager.getArchive().getJobTime(jobEvent.getJobID(), JobStatus.FINISHED) + "","");
			wrt.write(""\""FAILED\"": ""+ jobmanager.getArchive().getJobTime(jobEvent.getJobID(), JobStatus.FAILED) + "","");
			wrt.write(""\""CANCELED\"": ""+ jobmanager.getArchive().getJobTime(jobEvent.getJobID(), JobStatus.CANCELED) + "","");
			wrt.write(""\""CREATED\"": "" + jobmanager.getArchive().getJobTime(jobEvent.getJobID(), JobStatus.CREATED)+"","");

			if (jobEvent.getJobStatus() == JobStatus.FAILED) {
			ManagementGraphIterator managementGraphIterator =  new ManagementGraphIterator(jobManagementGraph,true);
			wrt.write(""\""failednodes\"": ["");
			HashSet<String> map = new HashSet<String>();
			boolean first = true;
			while (managementGraphIterator.hasNext()) {
				ManagementVertex managementVertex = managementGraphIterator.next();
				String instanceName = managementVertex.getInstanceName();
				if (managementVertex.getExecutionState() == ExecutionState.FAILED && !map.contains(instanceName)) {
					if (first) {
						first = false;
					} else {
						wrt.write("","");
					}
					wrt.write(""{"");
					wrt.write(""\""node\"": \"""" + instanceName + ""\"","");
					wrt.write(""\""message\"": \"""" + StringUtils.escapeHtml(managementVertex.getOptMessage()) + ""\"""");
					wrt.write(""}"");
					map.add(instanceName);
				}
			}
			wrt.write(""],"");
			}

			// Serialize ManagementGraph to json
			wrt.write(""\""groupvertices\"": ["");
			boolean first = true;
			for(ManagementGroupVertex groupVertex : jobManagementGraph.getGroupVerticesInTopologicalOrder()) {
				//Write seperator between json objects
				if(first) {
					first = false;
				} else {
					wrt.write("",""); }
				
				wrt.write(groupVertex.toJson());
				
			}
			wrt.write(""],"");
			
			// write accumulators
			AccumulatorEvent accumulators = jobmanager.getAccumulatorResults(jobEvent.getJobID());
			Map<String, Object> accMap = AccumulatorHelper.toResultMap(accumulators.getAccumulators());
			
			wrt.write(""\n\""accumulators\"": ["");
			int i = 0;
			for( Entry<String, Object> accumulator : accMap.entrySet()) {
				wrt.write(""{ \""name\"": \""""+accumulator.getKey()+"" ("" + accumulator.getValue().getClass().getName()+"")\"",""
						+ "" \""value\"": \""""+accumulator.getValue().toString()+""\""}\n"");
				if(++i < accMap.size()) {
					wrt.write("","");
				}
			}
			wrt.write(""],\n"");
			
			wrt.write(""\""groupverticetimes\"": {"");
			first = true;
			for(ManagementGroupVertex groupVertex : jobManagementGraph.getGroupVerticesInTopologicalOrder()) {
				
				if(first) {
					first = false;
				} else {
					wrt.write("",""); }
				
				// Calculate start and end time for groupvertex
				long started = Long.MAX_VALUE;
				long ended = 0;
				
				// Take earliest running state and latest endstate of groupmembers
				for(int j = 0; j < groupVertex.getNumberOfGroupMembers(); j++) {
					ManagementVertex vertex = groupVertex.getGroupMember(j);
					
					long running = jobmanager.getArchive().getVertexTime(jobEvent.getJobID(), vertex.getID(), ExecutionState.RUNNING);
					if(running != 0 && running < started) {
						started = running;
					}
					
					long finished = jobmanager.getArchive().getVertexTime(jobEvent.getJobID(), vertex.getID(), ExecutionState.FINISHED);
					long canceled = jobmanager.getArchive().getVertexTime(jobEvent.getJobID(), vertex.getID(), ExecutionState.CANCELED);
					long failed = jobmanager.getArchive().getVertexTime(jobEvent.getJobID(), vertex.getID(), ExecutionState.FAILED);
					
					if(finished != 0 && finished > ended) {
						ended = finished;
					}
					
					if(canceled != 0 && canceled > ended) {
						ended = canceled;
					}
					
					if(failed != 0 && failed > ended) {
						ended = failed;
					}

				}
				
				wrt.write(""\""""+groupVertex.getID()+""\"": {"");
				wrt.write(""\""groupvertexid\"": \"""" + groupVertex.getID() + ""\"","");
				wrt.write(""\""groupvertexname\"": \"""" + groupVertex + ""\"","");
				wrt.write(""\""STARTED\"": ""+ started + "","");
				wrt.write(""\""ENDED\"": ""+ ended);
				wrt.write(""}"");
				
			}

			wrt.write(""}"");
			
			wrt.write(""}"");
			
			
		wrt.write(""]"");
		
		} catch (EofException eof) { // Connection closed by client
			LOG.info(""Info server for jobmanager: Connection closed by client, EofException"");
		} catch (IOException ioe) { // Connection closed by client	
			LOG.info(""Info server for jobmanager: Connection closed by client, IOException"");
		} 
		
	}",Write the JSON for an archived job.
"@Override
  public void setSchemeTerritory(String schemeTerritory) {
    XSString st = null;
    if (schemeTerritory != null) {
      st = (new XSStringBuilder()).buildObject(this.getElementQName().getNamespaceURI(), SCHEME_TERRITORY_LOCAL_NAME,
        this.getElementQName().getPrefix());
      st.setValue(schemeTerritory);
    }
    this.setSchemeTerritory(st);
  }",Set the scheme territory.
"@Override
    public synchronized SnapshotContentItem read()
        throws Exception, UnexpectedInputException, ParseException, NonTransientResourceException {

        if (this.items == null) {
            this.items =
                new StreamingIterator<>(new JpaIteratorSource<SnapshotContentItemRepo, SnapshotContentItem>(repo) {
                    @Override
                    protected Page<SnapshotContentItem> getNextPage(Pageable pageable, SnapshotContentItemRepo repo) {
                        return repo.findBySnapshotName(snapshotName, pageable);
                    }
                });
            skipLinesAlreadyRead(this.items);
        }
        return this.items.hasNext() ? this.items.next() : null;
    }",read method.
"public Filters withKeyTypes(KeyAlgorithm... keyTypes) {
        java.util.ArrayList<String> keyTypesCopy = new java.util.ArrayList<String>(keyTypes.length);
        for (KeyAlgorithm value : keyTypes) {
            keyTypesCopy.add(value.toString());
        }
        if (getKeyTypes() == null) {
            setKeyTypes(keyTypesCopy);
        } else {
            getKeyTypes().addAll(keyTypesCopy);
        }
        return this;
    }",Sets the keyTypes property.
"@Override
    public DescribeIdentityUsageResult describeIdentityUsage(DescribeIdentityUsageRequest request) {
        request = beforeClientExecution(request);
        return executeDescribeIdentityUsage(request);
    }",Retrieves the usage of an identity group.
"public void register(ICalComponentScribe<? extends ICalComponent> scribe) {
		experimentalCompByName.put(scribe.getComponentName().toUpperCase(), scribe);
		experimentalCompByClass.put(scribe.getComponentClass(), scribe);
	}",Registers a ICalComponentScribe with the experimental registry.
"public List<Relationship> getLinkListRelationships() {
        final List<Relationship> linkListRelationships = new LinkedList<Relationship>();
        for (final Relationship r : relationships) {
            if (r.getType() == RelationshipType.LINKLIST) {
                linkListRelationships.add(r);
            }
        }
        return linkListRelationships;
    }",Gets the list of link list relationships.
"private void writeEvaluatorsJsonOutput(final HttpServletResponse response) throws IOException {
    LOG.log(Level.INFO, ""HttpServerReefEventHandler writeEvaluatorsJsonOutput is called"");
    try {
      final EvaluatorListSerializer serializer =
          Tang.Factory.getTang().newInjector().getInstance(EvaluatorListSerializer.class);
      final AvroEvaluatorList evaluatorList = serializer.toAvro(
          this.reefStateManager.getEvaluators(), this.reefStateManager.getEvaluators().size(),
          this.reefStateManager.getStartTime());
      writeResponse(response, serializer.toString(evaluatorList));
    } catch (final InjectionException e) {
      LOG.log(Level.SEVERE, ""Error in injecting EvaluatorListSerializer."", e);
      writeResponse(response, ""Error in injecting EvaluatorListSerializer: "" + e);
    }
  }",Write the evaluators list to the response.
"public static Map<String, String> getAzkabanTags(Configuration conf) {
    Map<String, String> tagMap = Maps.newHashMap();

    for (Map.Entry<String, String> entry : PROPERTIES_TO_TAGS_MAP.entrySet()) {
      if (StringUtils.isNotBlank(conf.get(entry.getKey()))) {
        tagMap.put(entry.getValue(), conf.get(entry.getKey()));
      } else {
        log.warn(String.format(""No config value found for config %s. Metrics will not have tag %s"", entry.getKey(),
            entry.getValue()));
      }
    }
    return tagMap;
  }",Get a map of tags from a configuration.
"private String createOrUpdateGraph(String version) {
        String oldVersion = null;
        Connection conn = this.sqlgGraph.tx().getConnection();
        try {
            DatabaseMetaData metadata = conn.getMetaData();
            String[] types = new String[]{""TABLE""};
            //load the vertices
            try (ResultSet vertexRs = metadata.getTables(null, Schema.SQLG_SCHEMA, Topology.VERTEX_PREFIX + Topology.GRAPH, types)) {
                if (!vertexRs.next()) {
                    try (Statement statement = conn.createStatement()) {
                        String sql = this.sqlDialect.sqlgCreateTopologyGraph();
                        statement.execute(sql);
                        TopologyManager.addGraph(this.sqlgGraph, version);
                        oldVersion = version;
                    }
                } else {
                    //Need to check if dbVersion has been added
                    try (ResultSet columnRs = metadata.getColumns(null, Schema.SQLG_SCHEMA, Topology.VERTEX_PREFIX + Topology.GRAPH, Topology.SQLG_SCHEMA_GRAPH_DB_VERSION)) {
                        if (!columnRs.next()) {
                            try (Statement statement = conn.createStatement()) {
                                statement.execute(sqlDialect.addDbVersionToGraph(metadata));
                            }
                        }
                    }
                    GraphTraversalSource traversalSource = sqlgGraph.topology();
                    List<Vertex> graphVertices = traversalSource.V().hasLabel(SQLG_SCHEMA + ""."" + Topology.SQLG_SCHEMA_GRAPH).toList();
                    if (graphVertices.isEmpty()) {
                        TopologyManager.addGraph(this.sqlgGraph, version);
                        oldVersion = version;
                    } else {
                        oldVersion = TopologyManager.updateGraph(this.sqlgGraph, version);
                    }
                }
                return oldVersion;
            }
        } catch (SQLException e) {
            throw new RuntimeException(e);
        }
    }",create or update the graph
"public static Object deserialize(byte[] bytes) {
		
		Object result = null;
		
		if (isEmpty(bytes)) {
			return null;
		}

		try {
			ByteArrayInputStream byteStream = new ByteArrayInputStream(bytes);
			try {
				ObjectInputStream objectInputStream = new ObjectInputStream(byteStream);
				try {
					result = objectInputStream.readObject();
				}
				catch (ClassNotFoundException ex) {
					throw new Exception(""Failed to deserialize object type"", ex);
				}
			}
			catch (Throwable ex) {
				throw new Exception(""Failed to deserialize"", ex);
			}
		} catch (Exception e) {
			logger.error(""Failed to deserialize"",e);
		}
		return result;
	}",Deserializes the bytes to an object.
"public void setHost( String host )
    {
        _host = null;
        if ( host != null && host.length() > 0 )
        {
            //
            // Here's some very minimal support for IPv6 addresses.
            // If the literal IPv6 address is not enclosed in square brackets
            // then add them.
            //
            boolean needBrackets = ( ( host.indexOf( ':' ) >= 0 )
                    && !host.startsWith( ""["" )
                    && !host.endsWith( ""]"" ) );

            if ( needBrackets )
            {
                _host = '[' + host + ']';
            }
            else
            {
                _host = host;
            }

            _opaque = false;
            setSchemeSpecificPart( null );
        }

        if ( _host == null )
        {
            setUserInfo( null );
            setPort( UNDEFINED_PORT );
        }
    }",Sets the host.
"private Iterator<Outcome> mapKeyValuesToOutcomes(Iterator<KeyValue> iterator) {
    final Outcome outcome = new Outcome(null, 0.0);
    final VariableNumMap vars = getVars();

    return Iterators.transform(iterator, new Function<KeyValue, Outcome>() {
      @Override
      public Outcome apply(KeyValue keyValue) {
        outcome.setAssignment(vars.intArrayToAssignment(keyValue.getKey()));
        outcome.setProbability(keyValue.getValue());
        return outcome;
      }
    });
  }",Maps the key values to outcomes.
"public IndexRecord getIndexInformation(String mapId, int reduce,
      Path fileName) throws IOException {

    IndexInformation info = cache.get(mapId);

    if (info == null) {
      info = readIndexFileToCache(fileName, mapId);
    } else {
      synchronized (info) {
        while (null == info.mapSpillRecord) {
          try {
            info.wait();
          } catch (InterruptedException e) {
            throw new IOException(""Interrupted waiting for construction"", e);
          }
        }
      }
      LOG.debug(""IndexCache HIT: MapId "" + mapId + "" found"");
    }

    if (info.mapSpillRecord.size() == 0 ||
        info.mapSpillRecord.size() < reduce) {
      throw new IOException(""Invalid request "" +
        "" Map Id = "" + mapId + "" Reducer = "" + reduce +
        "" Index Info Length = "" + info.mapSpillRecord.size());
    }
    return info.mapSpillRecord.getIndex(reduce);
  }",Get the index information from the cache.
"public static MozuUrl updatePackageUrl(String packageId, String responseFields, String returnId)
	{
		UrlFormatter formatter = new UrlFormatter(""/api/commerce/returns/{returnId}/packages/{packageId}?responseFields={responseFields}"");
		formatter.formatUrl(""packageId"", packageId);
		formatter.formatUrl(""responseFields"", responseFields);
		formatter.formatUrl(""returnId"", returnId);
		return new MozuUrl(formatter.getResourceUrl(), MozuUrl.UrlLocation.TENANT_POD) ;
	}",Get Resource Url for UpdatePackage
"public boolean isModified()
    {
        gatekeeper.signIn();
        try
        {
            for (ChangeStack<String> stack : properties.values())
            {
                if (stack.isModified())
                {
                    return true;
                }
            }

            return false;
        }
        finally
        {
            gatekeeper.signOut();
        }
    }",Check if the CRA is modified.
"@Override
    public GetIPSetResult getIPSet(GetIPSetRequest request) {
        request = beforeClientExecution(request);
        return executeGetIPSet(request);
    }",Returns the IPSet specified by the ID.
"public Term parse( TokenStream tokens ) {
        CheckArg.isNotNull(tokens, ""tokens"");
        List<Term> terms = new ArrayList<Term>();
        do {
            Term term = parseDisjunctedTerms(tokens);
            if (term == null) break;
            terms.add(term);
        } while (tokens.canConsume(""OR""));
        if (terms.isEmpty()) return null;
        return terms.size() > 1 ? new Disjunction(terms) : terms.iterator().next();
    }",Parse a single term from the token stream.
"public void marshall(IssueCertificateRequest issueCertificateRequest, ProtocolMarshaller protocolMarshaller) {

        if (issueCertificateRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(issueCertificateRequest.getCertificateAuthorityArn(), CERTIFICATEAUTHORITYARN_BINDING);
            protocolMarshaller.marshall(issueCertificateRequest.getCsr(), CSR_BINDING);
            protocolMarshaller.marshall(issueCertificateRequest.getSigningAlgorithm(), SIGNINGALGORITHM_BINDING);
            protocolMarshaller.marshall(issueCertificateRequest.getValidity(), VALIDITY_BINDING);
            protocolMarshaller.marshall(issueCertificateRequest.getIdempotencyToken(), IDEMPOTENCYTOKEN_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given issueCertificateRequest to the given protocolMarshaller.
"private Node createTemplateNode() {
    // The Node type choice is arbitrary.
    Node templateNode = new Node(Token.SCRIPT);
    templateNode.setStaticSourceFile(sourceFile);
    return templateNode;
  }",Create a template node.
"@BetaApi
  public final Operation insertTargetHttpProxy(
      ProjectName project, TargetHttpProxy targetHttpProxyResource) {

    InsertTargetHttpProxyHttpRequest request =
        InsertTargetHttpProxyHttpRequest.newBuilder()
            .setProject(project == null ? null : project.toString())
            .setTargetHttpProxyResource(targetHttpProxyResource)
            .build();
    return insertTargetHttpProxy(request);
  }",Creates a InsertTargetHttpProxyHttpRequest in the specified project and target HttpProxy resource.
"public void performRecovery(ObjectManagerState objectManagerState)
                    throws ObjectManagerException
    {
        if (Tracing.isAnyTracingEnabled() && trace.isEntryEnabled())
            trace.entry(this,
                        cclass,
                        ""performRecovery"",
                        objectManagerState);

        // Recover the ObjectManagerState from its serialized bytes.
        ObjectManagerState recoveredObjectManagerState = (ObjectManagerState) ManagedObject.restoreFromSerializedBytes(objectManagerStateBytes,
                                                                                                                       objectManagerState);
        if (Tracing.isAnyTracingEnabled() && trace.isDebugEnabled())
            trace.debug(this, cclass
                        , ""recoveredObjectManagerState="" + recoveredObjectManagerState + ""(ObjectManagerState)""
                            );

        // Make ObjectManagerState the recovered version.
        objectManagerStateToken.setManagedObject(recoveredObjectManagerState);

        if (Tracing.isAnyTracingEnabled() && trace.isEntryEnabled())
            trace.exit(this,
                       cclass,
                       ""performRecovery"");
    }",Perform a recovery of the ObjectManagerState.
"private Map<String, JsonObject> findCertificateAuthorities() throws NetworkConfigurationException {
        Map<String, JsonObject> ret = new HashMap<>();

        JsonObject jsonCertificateAuthorities = getJsonObject(jsonConfig, ""certificateAuthorities"");
        if (null != jsonCertificateAuthorities) {

            for (Entry<String, JsonValue> entry : jsonCertificateAuthorities.entrySet()) {
                String name = entry.getKey();

                JsonObject jsonCA = getJsonValueAsObject(entry.getValue());
                if (jsonCA == null) {
                    throw new NetworkConfigurationException(format(""Error loading config. Invalid CA entry: %s"", name));
                }
                ret.put(name, jsonCA);
            }
        }

        return ret;

    }",Find certificateAuthorities map.
"private static final boolean checkShort(String s)
    {
        try {
            short val = Short.parseShort(s);
            if(DebugValueChecking) {
                DAPNode.log.debug(""Attribute.checkShort() - string: '"" + s + ""'   value: "" + val);
            }
            return true;
        } catch (NumberFormatException e) {
            return false;
        }
    }",checkShort Method.
"public void pingLoop() {
        if ( ! isStopped() ) {
            Log.Info(this, ""----------- START MULTI RESPONSE REQUEST ------------"");
            mediator.askSubscribers(self(), ""defaultTopic"", ""Hello from "" + myName,
                (reply, error) -> {
                    if (Actors.isComplete(error)) {
                        Log.Info(this,""----------- ALL RESULTS RECEIVED ------------"");
                        delayed(5000, () -> pingLoop());
                    } else {
                        Log.Info(this,""=>"" + reply);
                    }
                });
        }
    }",This method is called by the server to start the loop of the server.
"public void marshall(DestinationSchema destinationSchema, ProtocolMarshaller protocolMarshaller) {

        if (destinationSchema == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(destinationSchema.getRecordFormatType(), RECORDFORMATTYPE_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given destinationSchema to the JSON - compatible parameter object.
"public static Document createDocument(InputStream input) throws IOException
    {
        Check.notNull(input);

        try
        {
            return getDocumentFactory().parse(input);
        }
        catch (final SAXException exception)
        {
            throw new IOException(exception);
        }
    }",Create a DOM Document from an input stream.
"public void marshall(BatchMeterUsageRequest batchMeterUsageRequest, ProtocolMarshaller protocolMarshaller) {

        if (batchMeterUsageRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(batchMeterUsageRequest.getUsageRecords(), USAGERECORDS_BINDING);
            protocolMarshaller.marshall(batchMeterUsageRequest.getProductCode(), PRODUCTCODE_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given BatchMeterUsageRequest to the given protocolMarshaller.
"public void readToken(String parentFieldName, JsonToken expectedToken)
    throws IOException {
    JsonToken currentToken = jsonParser.nextToken();
    if (currentToken != expectedToken) {
      throw new IOException(""Expected a "" + expectedToken.toString() +
        "" token when reading the value of the field: "" +
        parentFieldName +
        "" but found a "" +
        currentToken.toString() + "" token"");
    }
  }",Read a token from the JSON parser.
"public static void setSunNamespacePrefixMapper (@Nonnull final Marshaller aMarshaller,
                                                  @Nonnull final JAXBNamespacePrefixMapper aNamespacePrefixMapper)
  {
    final String sPropertyName = SUN_PREFIX_MAPPER;
    _setProperty (aMarshaller, sPropertyName, aNamespacePrefixMapper);
  }",Set the namespace prefix mapper.
"public static CanCache of(MethodDescription.InDefinedShape methodDescription) {
        if (methodDescription.isTypeInitializer()) {
            return CanCacheIllegal.INSTANCE;
        } else if (methodDescription.isConstructor()) {
            return new ForConstructor(methodDescription);
        } else {
            return new ForMethod(methodDescription);
        }
    }",Gets the CanCache instance for the given method description.
"void cancelFeedback(String feedbackId) {
    // Find the event and remove it from the queue
    FeedbackEvent feedbackEvent = (FeedbackEvent) findQueuedTelemetryEvent(feedbackId);
    queuedFeedbackEvents.remove(feedbackEvent);
  }",Cancel a feedback.
"@com.fasterxml.jackson.annotation.JsonProperty(""status"")
    public void setStatus(String status) {
        this.status = status;
    }",Sets the status of the resource.
"@Override
    public DetachInstancesFromLoadBalancerResult detachInstancesFromLoadBalancer(DetachInstancesFromLoadBalancerRequest request) {
        request = beforeClientExecution(request);
        return executeDetachInstancesFromLoadBalancer(request);
    }",Detaches the instances from an load balancer.
"public static String updateSetColumns(Class<?> entityClass, String entityName, boolean notNull, boolean notEmpty) {
        StringBuilder sql = new StringBuilder();
        sql.append(""<set>"");
        //获取全部列
        Set<EntityColumn> columnSet = EntityHelper.getColumns(entityClass);
        //对乐观锁的支持
        EntityColumn versionColumn = null;
        // 逻辑删除列
        EntityColumn logicDeleteColumn = null;
        //当某个列有主键策略时，不需要考虑他的属性是否为空，因为如果为空，一定会根据主键策略给他生成一个值
        for (EntityColumn column : columnSet) {
            if (column.getEntityField().isAnnotationPresent(Version.class)) {
                if (versionColumn != null) {
                    throw new VersionException(entityClass.getCanonicalName() + "" 中包含多个带有 @Version 注解的字段，一个类中只能存在一个带有 @Version 注解的字段!"");
                }
                versionColumn = column;
            }
            if (column.getEntityField().isAnnotationPresent(LogicDelete.class)) {
                if (logicDeleteColumn != null) {
                    throw new LogicDeleteException(entityClass.getCanonicalName() + "" 中包含多个带有 @LogicDelete 注解的字段，一个类中只能存在一个带有 @LogicDelete 注解的字段!"");
                }
                logicDeleteColumn = column;
            }
            if (!column.isId() && column.isUpdatable()) {
                if (column == versionColumn) {
                    Version version = versionColumn.getEntityField().getAnnotation(Version.class);
                    String versionClass = version.nextVersion().getCanonicalName();
                    sql.append(""<bind name=\"""").append(column.getProperty()).append(""Version\"" value=\"""");
                    //version = ${@tk.mybatis.mapper.version@nextVersionClass(""versionClass"", version)}
                    sql.append(""@tk.mybatis.mapper.version.VersionUtil@nextVersion("")
                        .append(""@"").append(versionClass).append(""@class, "");
                    if (StringUtil.isNotEmpty(entityName)) {
                        sql.append(entityName).append(""."");
                    }
                    sql.append(column.getProperty()).append("")\""/>"");
                    sql.append(column.getColumn()).append("" = #{"").append(column.getProperty()).append(""Version},"");
                } else if (column == logicDeleteColumn) {
                    sql.append(logicDeleteColumnEqualsValue(column, false)).append("","");
                } else if (notNull) {
                    sql.append(SqlHelper.getIfNotNull(entityName, column, column.getColumnEqualsHolder(entityName) + "","", notEmpty));
                } else {
                    sql.append(column.getColumnEqualsHolder(entityName) + "","");
                }
            }
        }
        sql.append(""</set>"");
        return sql.toString();
    }",Update set columns.
"protected int findGTE(int[] list, int start, int len, int value)
  {

    int low = start;
    int high = start + (len - 1);
    int end = high;

    while (low <= high)
    {
      int mid = (low + high) / 2;
      int c = list[mid];

      if (c > value)
        high = mid - 1;
      else if (c < value)
        low = mid + 1;
      else
        return mid;
    }

    return (low <= end && list[low] > value) ? low : -1;
  }",Find the first index of the value in the list that is greater than or equal to the given value.
"@XmlElementDecl(namespace = ""http://www.immoxml.de"", name = ""wohnflaeche"")
    @XmlJavaTypeAdapter(Adapter7 .class)
    public JAXBElement<BigDecimal> createWohnflaeche(BigDecimal value) {
        return new JAXBElement<BigDecimal>(_Wohnflaeche_QNAME, BigDecimal.class, null, value);
    }",Create an instance of a Wohnflaeche type.
"public void acceptPrompt() {
        String action = ""Clicking 'OK' on a prompt"";
        String expected = ""Prompt is present to be clicked"";
        if (isNotPrompt(action, expected, ""click"")) {
            return;
        }
        accept(action, expected, ""prompt"");
    }",Accept a prompt.
"public void marshall(DisassociateMembersRequest disassociateMembersRequest, ProtocolMarshaller protocolMarshaller) {

        if (disassociateMembersRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(disassociateMembersRequest.getAccountIds(), ACCOUNTIDS_BINDING);
            protocolMarshaller.marshall(disassociateMembersRequest.getDetectorId(), DETECTORID_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given request to the JSON object.
"public Quaterniond premul(double qx, double qy, double qz, double qw) {
        return premul(qx, qy, qz, qw, this);
    }",Premultiplies this quaternion by another quaternion.
"private void addPostParams(final Request request) {
        if (attributes != null) {
            request.addPostParam(""Attributes"", attributes);
        }

        if (dateCreated != null) {
            request.addPostParam(""DateCreated"", dateCreated.toString());
        }

        if (dateUpdated != null) {
            request.addPostParam(""DateUpdated"", dateUpdated.toString());
        }
    }",Add Post Params.
"@Override
    public void configureContentNegotiation(ContentNegotiationConfigurer configurer) {
        configurer.favorParameter(false);
        configurer.favorPathExtension(false);
    }",Override this method to configure the content negotiation.
"@Override
    protected void setLinkProperty(final UUID _linkTypeUUID,
                                   final long _toId,
                                   final UUID _toTypeUUID,
                                   final String _toName)
        throws EFapsException
    {
        if (_linkTypeUUID.equals(CIAdminUserInterface.LinkIcon.uuid)) {
            this.icon = _toName;
        }
        super.setLinkProperty(_linkTypeUUID, _toId, _toTypeUUID, _toName);
    }",Set the link property.
"@Override
    public boolean process(final Set<? extends TypeElement> annotations, final RoundEnvironment roundEnv) {

        final Map<String, VariableElement> fields = new ConcurrentHashMap<>();

        final Map<String, ExecutableElement> methods = new ConcurrentHashMap<>();

        for (final Element element : roundEnv.getElementsAnnotatedWith(Bean.class)) {

            if (element.getKind() == ElementKind.CLASS) {

                final Bean bean = element.getAnnotation(Bean.class);

                final Class beanDef = new Class();

                final TypeElement classElement = (TypeElement) element;
                final PackageElement packageElement = (PackageElement) classElement.getEnclosingElement();

                this.processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, ""annotated class: "" + classElement.getQualifiedName(), element);

                // fqClassName = classElement.getQualifiedName().toString();
                beanDef.name(bean.value());
                beanDef._package(org.jrebirth.af.tooling.codegen.bean.Package.create().qualifiedName(packageElement.getQualifiedName().toString()));

                final Class td = new Class();
                td.qualifiedName(classElement.getQualifiedName().toString());

                beanDef.setSuperType(td);

                for (final Element child : classElement.getEnclosedElements()) {

                    if (child.getKind() == ElementKind.METHOD) {

                        final ExecutableElement method = (ExecutableElement) child;

                        final Property propertyDef = new Property();
                        propertyDef.type(Class.of(method.getReturnType().toString()));
                        propertyDef.name(method.getSimpleName().toString());
                        beanDef.properties().add(propertyDef);

                    } else if (child.getKind().isField()) {

                        final VariableElement field = (VariableElement) child;

                        final Property propertyDef = new Property();
                        propertyDef.type(Class.of(getClassName(field)));
                        propertyDef.name(field.getSimpleName().toString());
                        beanDef.properties().add(propertyDef);

                    }
                }

                // } else if (e.getKind() == ElementKind.FIELD) {
                //
                // final VariableElement varElement = (VariableElement) e;
                //
                // processingEnv.getMessager().printMessage(
                // Diagnostic.Kind.NOTE,
                // ""annotated field: "" + varElement.getSimpleName(), e);
                //
                // fields.put(varElement.getSimpleName().toString(), varElement);

                try {
                    final String formattedSource = Generators.beanGenerator.generate(beanDef, Roaster.create(JavaClassSource.class));

                    final JavaFileObject jfo = this.processingEnv.getFiler().createSourceFile(beanDef.qualifiedName());
                    this.processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, ""creating source file: "" + jfo.toUri());

                    final Writer writer = jfo.openWriter();
                    writer.write(formattedSource);
                    writer.close();

                } catch (final Exception e) {
                    e.printStackTrace();
                    throw new RuntimeException(e);
                }

            } else if (element.getKind() == ElementKind.METHOD) {

                final ExecutableElement exeElement = (ExecutableElement) element;

                this.processingEnv.getMessager().printMessage(
                                                              Diagnostic.Kind.NOTE,
                                                              ""annotated method: "" + exeElement.getSimpleName(), element);

                methods.put(exeElement.getSimpleName().toString(), exeElement);
            }

        }

        return true;
    }",Process the annotations of the CDI - AFF - AFF - B.
"public AuthParams newAuthParams(String name, long expires) {
        AuthParams set = new AuthParams();
        set.name(name);
        set.expires(expires);
        auth.add(set);
        return set;
    }",Create a new instance of the class.
"protected Postcard build(Uri uri) {
        if (null == uri || TextUtils.isEmpty(uri.toString())) {
            throw new HandlerException(Consts.TAG + ""Parameter invalid!"");
        } else {
            PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);
            if (null != pService) {
                uri = pService.forUri(uri);
            }
            return new Postcard(uri.getPath(), extractGroup(uri.getPath()), uri, null);
        }
    }",Build a postcard from the given URI.
"public boolean isInState(JComponent c) {
        if (c instanceof JButton && c.getParent() != null && c.getParent() instanceof JTextComponent) {
            c = (JComponent) c.getParent();
        } else if (!(c instanceof JTextComponent)) {
            return false;
        }

        if (!""search"".equals(c.getClientProperty(""JTextField.variant""))) {
            return false;
        }

        Object o = c.getClientProperty(""JTextField.Search.FindPopup"");

        return (o != null && o instanceof JPopupMenu);
    }",Is this component in the state of the component?
"public void marshall(CloudWatchLogsConfiguration cloudWatchLogsConfiguration, ProtocolMarshaller protocolMarshaller) {

        if (cloudWatchLogsConfiguration == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(cloudWatchLogsConfiguration.getEnabled(), ENABLED_BINDING);
            protocolMarshaller.marshall(cloudWatchLogsConfiguration.getLogStreams(), LOGSTREAMS_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the CloudWatchLogsConfiguration to the JSON object.
"private boolean pathExists(T u, T v, boolean includeAdjacent) {
        if (!nodes.contains(u) || !nodes.contains(v)) {
            return false;
        }
        if (includeAdjacent && isAdjacent(u, v)) {
            return true;
        }
        Deque<T> stack = new LinkedList<>();
        Set<T> visited = new HashSet<>();
        stack.push(u);
        while (!stack.isEmpty()) {
            T node = stack.pop();
            if (node.equals(v)) {
                return true;
            }
            if (!visited.contains(node)) {
                visited.add(node);
                edges.get(node).stream()
                     .filter(e -> includeAdjacent || !node.equals(u) || !e.equals(v))
                     .forEach(stack::push);
            }
        }
        assert !visited.contains(v);
        return false;
    }",Check if the path exists.
"public static String escapeLink(String source) {

        if (source == null) {
            return null;
        }
        StringBuffer result = new StringBuffer(source.length() * 2);
        int terminatorIndex;
        for (int i = 0; i < source.length(); ++i) {
            char ch = source.charAt(i);
            switch (ch) {
                case '&':
                    // don't escape already escaped &amps;
                    terminatorIndex = source.indexOf(';', i);
                    if (terminatorIndex > 0) {
                        String substr = source.substring(i + 1, terminatorIndex);
                        if (""amp"".equals(substr)) {
                            result.append(ch);
                        } else {
                            result.append(""&amp;"");
                        }
                    } else {
                        result.append(""&amp;"");
                    }
                    break;
                default:
                    result.append(ch);
            }
        }
        return new String(result);
    }",Escape a string for use in a URL.
"public static <E extends Enum<E>> List<E> computeEnum(List<EnumItem<E>> roleTagList, TransformMatrixDictionary<E> transformMatrixDictionary)
    {
        int length = roleTagList.size() - 1;
        List<E> tagList = new ArrayList<E>(roleTagList.size());
        double[][] cost = new double[2][];  // 滚动数组
        Iterator<EnumItem<E>> iterator = roleTagList.iterator();
        EnumItem<E> start = iterator.next();
        E pre = start.labelMap.entrySet().iterator().next().getKey();
        // 第一个是确定的
        tagList.add(pre);
        // 第二个也可以简单地算出来
        Set<E> preTagSet;
        {
            EnumItem<E> item = iterator.next();
            cost[0] = new double[item.labelMap.size()];
            int j = 0;
            for (E cur : item.labelMap.keySet())
            {
                cost[0][j] = transformMatrixDictionary.transititon_probability[pre.ordinal()][cur.ordinal()] - Math.log((item.getFrequency(cur) + 1e-8) / transformMatrixDictionary.getTotalFrequency(cur));
                ++j;
            }
            preTagSet = item.labelMap.keySet();
        }
        // 第三个开始复杂一些
        for (int i = 1; i < length; ++i)
        {
            int index_i = i & 1;
            int index_i_1 = 1 - index_i;
            EnumItem<E> item = iterator.next();
            cost[index_i] = new double[item.labelMap.size()];
            double perfect_cost_line = Double.MAX_VALUE;
            int k = 0;
            Set<E> curTagSet = item.labelMap.keySet();
            for (E cur : curTagSet)
            {
                cost[index_i][k] = Double.MAX_VALUE;
                int j = 0;
                for (E p : preTagSet)
                {
                    double now = cost[index_i_1][j] + transformMatrixDictionary.transititon_probability[p.ordinal()][cur.ordinal()] - Math.log((item.getFrequency(cur) + 1e-8) / transformMatrixDictionary.getTotalFrequency(cur));
                    if (now < cost[index_i][k])
                    {
                        cost[index_i][k] = now;
                        if (now < perfect_cost_line)
                        {
                            perfect_cost_line = now;
                            pre = p;
                        }
                    }
                    ++j;
                }
                ++k;
            }
            tagList.add(pre);
            preTagSet = curTagSet;
        }
        tagList.add(tagList.get(0));    // 对于最后一个##末##
        return tagList;
    }",Compute the enumeration of the class.
"public LaunchNowOption param(String key, Object value) {
        if (key == null) {
            throw new IllegalArgumentException(""The argument 'key' should not be null."");
        }
        if (parameterMap == null) {
            parameterMap = new LinkedHashMap<String, Object>();
        }
        parameterMap.put(key, value);
        return this;
    }",Add a parameter to the launch now option.
"public MethodMetaArgs createGetMethod(HandlerMetaDef handlerMetaDef, Object keyValue) {

		String p_methodName = handlerMetaDef.getFindMethod();
		if (p_methodName == null) {
			Debug.logError(""[JdonFramework] not configure the findMethod parameter: <getMethod name=XXXXX /> "", module);
		}
		if (keyValue == null) {
			Debug.logError(""[JdonFramework] not found model's key value:"" + handlerMetaDef.getModelMapping().getKeyName()
					+ ""=? in request parameters"", module);
		}
		return createCRUDMethodMetaArgs(p_methodName, keyValue);
	}",create get method meta args
"public String getTimeline() {
    StringBuilder builder = new StringBuilder();
    for (Event event : events) {
      builder.append(event.name()).append("":"").append(event.timestamp()).append("";"");
    }
    return builder.toString();
  }",Get the timestamp of the events.
"public void setColSize3(Integer newColSize3) {
		Integer oldColSize3 = colSize3;
		colSize3 = newColSize3;
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, AfplibPackage.COLOR_SPECIFICATION__COL_SIZE3, oldColSize3, colSize3));
	}",Sets the colSize3 value.
"public static Object getSessionValue(HttpServletRequest request, String key) {

        HttpSession session = request.getSession(true);
        return session.getAttribute(key);
    }",Gets the value of the specified key from the session.
"public void write(DataOutput out) throws IOException {
    out.writeInt(getLayoutVersion());
    out.writeInt(getNamespaceID());
    out.writeLong(getCTime());
    out.writeLong(mostRecentCheckpointTxId);
    out.writeLong(curSegmentTxId);
    imageDigest.write(out);
  }",Write the block to the output stream.
"public File getFile(String hash)
   {
      // work with digest
      return new File(channel.rootDir, channel.makeFilePath(hash, 0));
   }",Get a file from the given hash.
"public static Calendar next(Calendar self) {
        Calendar result = (Calendar) self.clone();
        result.add(Calendar.DATE, 1);
        return result;
    }",Get the next calendar in a calendar.
"@Override
  public Filter adapt(FilterAdapterContext context, TimestampsFilter filter) {
    InterleaveFilter interleave = FILTERS.interleave();
    for (long timestamp : filter.getTimestamps()) {
      interleave.filter(TimestampFilterUtil.hbaseToTimestampRangeFilter(timestamp, timestamp + 1));
    }
    return interleave;
  }",Override to add filters to the interleave filter.
"private void bindAuthenticationProviders(
            Collection<Class<AuthenticationProvider>> authProviders,
            Set<String> tolerateFailures) {

        // Bind each authentication provider within extension
        for (Class<AuthenticationProvider> authenticationProvider : authProviders)
            bindAuthenticationProvider(authenticationProvider, tolerateFailures);

    }

    /**
     * Returns a list of all currently-bound AuthenticationProvider instances.
     *
     * @return
     *     A List of all currently-bound AuthenticationProvider. The List is
     *     not modifiable.
     */
    @Provides
    public List<AuthenticationProvider> getAuthenticationProviders() {
        return Collections.unmodifiableList(boundAuthenticationProviders);
    }

    /**
     * Binds the given provider class such that a listener is bound for each
     * listener interface implemented by the provider and such that all bound
     * listener instances can be obtained via injection.
     *
     * @param providerClass
     *     The listener class to bind.
     */
    private void bindListener(Class<?> providerClass) {

        logger.debug(""[{}] Binding listener \""{}\""."",
                boundListeners.size(), providerClass.getName());
        boundListeners.addAll(ListenerFactory.createListeners(providerClass));

    }

    /**
     * Binds each of the the given Listener classes such that any
     * service requiring access to the Listener can obtain it via
     * injection.
     *
     * @param listeners
     *     The Listener classes to bind.
     */
    private void bindListeners(Collection<Class<?>> listeners) {

        // Bind each listener within extension
        for (Class<?> listener : listeners)
            bindListener(listener);
    }

    /**
     * Returns a list of all currently-bound Listener instances.
     *
     * @return
     *     A List of all currently-bound Listener instances. The List is
     *     not modifiable.
     */
    @Provides
    public List<Listener> getListeners() {
        return Collections.unmodifiableList(boundListeners);
    }

    /**
     * Serves each of the given resources as a language resource. Language
     * resources are served from within the ""/translations"" directory as JSON
     * files, where the name of each JSON file is the language key.
     *
     * @param resources
     *     A map of all language resources to serve, where the key of each
     *     entry in the language key from which the name of the JSON file will
     *     be derived.
     */
    private void serveLanguageResources(Map<String, Resource> resources) {

        // Add all resources to language resource service
        for (Map.Entry<String, Resource> translationResource : resources.entrySet()) {

            // Get path and resource from path/resource pair
            String path = translationResource.getKey();
            Resource resource = translationResource.getValue();

            // Derive key from path
            String languageKey = languageResourceService.getLanguageKey(path);
            if (languageKey == null) {
                logger.warn(""Invalid language file name: \""{}\"""", path);
                continue;
            }

            // Add language resource
            languageResourceService.addLanguageResource(languageKey, resource);

        }

    }

    /**
     * Serves each of the given resources under the given prefix. The path of
     * each resource relative to the prefix is the key of its entry within the
     * map.
     *
     * @param prefix
     *     The prefix under which each resource should be served.
     *
     * @param resources
     *     A map of all resources to serve, where the key of each entry in the
     *     map is the desired path of that resource relative to the prefix.
     */
    private void serveStaticResources(String prefix, Map<String, Resource> resources) {

        // Add all resources under given prefix
        for (Map.Entry<String, Resource> staticResource : resources.entrySet()) {

            // Get path and resource from path/resource pair
            String path = staticResource.getKey();
            Resource resource = staticResource.getValue();

            // Serve within namespace-derived path
            serve(prefix + path).with(new ResourceServlet(resource));

        }

    }",Binds the given authentication providers to the appropriate authentication providers.
"public Matrix3x2d translate(double x, double y, Matrix3x2d dest) {
        double rm20 = x;
        double rm21 = y;
        dest.m20 = m00 * rm20 + m10 * rm21 + m20;
        dest.m21 = m01 * rm20 + m11 * rm21 + m21;
        dest.m00 = m00;
        dest.m01 = m01;
        dest.m10 = m10;
        dest.m11 = m11;
        return dest;
    }",Translates this matrix to the specified matrix.
"public static Gaussian fromBinomial(final double probability,
    final long totalPopulation) {
    if (0. >= totalPopulation) {
      throw new IllegalArgumentException();
    }
    if (0. >= probability) {
      throw new IllegalArgumentException();
    }
    if (1. <= probability) {
      throw new IllegalArgumentException();
    }
    if (Double.isNaN(probability)) {
      throw new IllegalArgumentException();
    }
    if (Double.isInfinite(probability)) {
      throw new IllegalArgumentException();
    }
    return new Gaussian(
      probability * totalPopulation,
      Math.sqrt(totalPopulation * probability * (1 - probability)));
  }",Create a Gaussian from a binomial distribution.
"void formatTimeZone_v(StringBuilder b, ZonedDateTime d, int width) {
    if (width != 1 && width != 4) {
      return;
    }
    
    ZoneId zone = d.getZone();
    Name variants = getTimeZoneName(zone.getId(), d, width == 4);
    String name = variants == null ? null : variants.generic();

    if (name != null) {
      b.append(name);
    } else {
      // Falls back to 'O' or 'OOOO'.
      formatTimeZone_O(b, d, width);
    }
  }",Format a time zone.
"public static PrioritizationStrategy getPrioritizationStrategy(String attributeValue, Long processInstanceId) throws StrategyException {
        Package packageVO = processInstanceId == null ? null : getPackage(processInstanceId);
        TaskInstanceStrategyFactory factory = getInstance();
        String className = factory.getStrategyClassName(attributeValue, StrategyType.PrioritizationStrategy);
        PrioritizationStrategy strategy = (PrioritizationStrategy) factory.getStrategyInstance(PrioritizationStrategy.class, className, packageVO);
        return strategy;
    }",Get a PrioritizationStrategy instance from an attribute value.
"public Observable<Page<RecommendationInner>> listAsync() {
        return listWithServiceResponseAsync()
            .map(new Func1<ServiceResponse<Page<RecommendationInner>>, Page<RecommendationInner>>() {
                @Override
                public Page<RecommendationInner> call(ServiceResponse<Page<RecommendationInner>> response) {
                    return response.body();
                }
            });
    }",List a list of CDNA recommendation.
"public static double[] randomDoubleArray(int len, Random r) {
    final double[] ret = new double[len];
    for(int i = 0; i < len; i++) {
      ret[i] = r.nextDouble();
    }
    return ret;
  }",Random double array.
"public static String stringArrayToString(final String[] stringArray, final String delim) {
        String ret = """";
        for (final String element : stringArray) {
            if (ret.length() > 0) {
                ret = ret + delim + element;
            } else {
                ret = element;
            }
        }
        return ret;
    }",stringArrayToString Method.
"public UpdateEndpointGroupRequest withEndpointConfigurations(EndpointConfiguration... endpointConfigurations) {
        if (this.endpointConfigurations == null) {
            setEndpointConfigurations(new java.util.ArrayList<EndpointConfiguration>(endpointConfigurations.length));
        }
        for (EndpointConfiguration ele : endpointConfigurations) {
            this.endpointConfigurations.add(ele);
        }
        return this;
    }",A list of endpoint configurations to be updated.
"public void downloadFile(String bucketName, String srcFilename, Path destFilePath)
      throws IOException {
    // [START storage_download_file]
    // The name of the bucket to access
    // String bucketName = ""my-bucket"";

    // The name of the remote file to download
    // String srcFilename = ""file.txt"";

    // The path to which the file should be downloaded
    // Path destFilePath = Paths.get(""/local/path/to/file.txt"");

    // Instantiate a Google Cloud Storage client
    Storage storage = StorageOptions.getDefaultInstance().getService();

    // Get specific file from specified bucket
    Blob blob = storage.get(BlobId.of(bucketName, srcFilename));

    // Download file to specified path
    blob.downloadTo(destFilePath);
    // [END storage_download_file]
  }",Download a file from a specified bucket.
"public void writeUTF8(ByteArrayBuffer bb, String value)
  {
    bb.clear();

    for (int i = 0; i < value.length(); i++) {
      int ch = value.charAt(i);

      if (ch > 0 && ch < 0x80)
        bb.append(ch);
      else if (ch < 0x800) {
        bb.append(0xc0 + (ch >> 6));
        bb.append(0x80 + (ch & 0x3f));
      }
      else {
        bb.append(0xe0 + (ch >> 12));
        bb.append(0x80 + ((ch >> 6) & 0x3f));
        bb.append(0x80 + ((ch) & 0x3f));
      }
    }
  }",Write UTF - 8 string to a ByteArrayBuffer.
"public void render(OutputStream target, Graph graph) throws IOException {
		
		BufferedImage bi = 
			new BufferedImage(graph.width, graph.height, 
					GraphConfiguration.imageType);
		Graphics2D g2d = bi.createGraphics();
		graph.draw(g2d);
	    ImageIO.write(bi, ""png"", target);
	}",Renders the given graph to the specified output stream.
"@Override
    public GetLoadBalancerResult getLoadBalancer(GetLoadBalancerRequest request) {
        request = beforeClientExecution(request);
        return executeGetLoadBalancer(request);
    }",Returns information about a load balancer.
"private static List<ConnectionNotation> getAllSelfCycleConnections(List<ConnectionNotation> connections) {
    List<ConnectionNotation> listSelfCycle = new ArrayList<ConnectionNotation>();
    for (ConnectionNotation connection : connections) {
      if ((connection.getTargetId().getId().equals(connection.getSourceId().getId()))) {
        listSelfCycle.add(connection);
      }
    }
    return listSelfCycle;
  }",method to get all self cycle connections
"public static Object provideContext(Class<?> type,
	                                    String defaultValue,
	                                    RoutingContext context) throws ContextException {

		// vert.x context
		if (type.isAssignableFrom(HttpServerResponse.class)) {
			return context.response();
		}

		if (type.isAssignableFrom(HttpServerRequest.class)) {
			return context.request();
		}

		if (type.isAssignableFrom(RoutingContext.class)) {
			return context;
		}

		// provide vertx via @Context
		if (type.isAssignableFrom(Vertx.class)) {
			return context.vertx();
		}

		// provide event bus via @Context
		if (type.isAssignableFrom(EventBus.class)) {
			return context.vertx().eventBus();
		}

		if (type.isAssignableFrom(User.class)) {
			return context.user();
		}

		// internal context / reflection of route definition
		if (type.isAssignableFrom(RouteDefinition.class)) {
			return new RouteDefinition(context);
		}

		// browse through context storage
		if (context.data() != null && context.data().size() > 0) {

			Object item = context.data().get(getContextKey(type));
			if (item != null) { // found in storage ... return
				return item;
			}
		}

		if (defaultValue != null) {
			// check if type has constructor that can be used with defaultValue ...
			// and create Context type on the fly constructed with defaultValue
			try {
				return ClassFactory.constructType(type, defaultValue);
			}
			catch (ClassFactoryException e) {
				throw new ContextException(""Can't provide @Context of type: "" + type + "". "" + e.getMessage());
			}
		}

		throw new ContextException(""Can't provide @Context of type: "" + type);
	}",Provides a context object for the given type.
"public void translate(double dx, double dy) {
		this.m02 = this.m00 * dx + this.m01 * dy + this.m02;
		this.m12 = this.m10 * dx + this.m11 * dy + this.m12;
	}",Translate this matrix by the given translation.
"public static CommercePriceList findByCompanyId_First(long companyId,
		OrderByComparator<CommercePriceList> orderByComparator)
		throws com.liferay.commerce.price.list.exception.NoSuchPriceListException {
		return getPersistence()
				   .findByCompanyId_First(companyId, orderByComparator);
	}",Returns the first commerce price list in the ordered set where company = &#63 ;.
"public static StringBuffer insert(StringBuffer target, int offset16, int char32) {
        String str = valueOf(char32);
        if (offset16 != target.length() && bounds(target, offset16) == TRAIL_SURROGATE_BOUNDARY) {
            offset16++;
        }
        target.insert(offset16, str);
        return target;
    }",Insert a char32 into a StringBuffer.
"public static RawMessage toRawMessage(final short sendingNodeId, final ByteBuffer buffer) {
    buffer.flip();

    final RawMessage message = new RawMessage(buffer.limit());

    message.put(buffer, false);

    buffer.clear();

    final RawMessageHeader header = new RawMessageHeader(sendingNodeId, (short) 0, (short) message.length());

    message.header(header);

    return message;
  }",Converts a ByteBuffer to a raw message.
"private InvAccess getImageAccess(InvDataset invDataset, ucar.nc2.util.CancelTask task, Result result) {

    List<InvAccess> accessList = new ArrayList<>(invDataset.getAccess()); // a list of all the accesses
    while (accessList.size() > 0) {
      InvAccess access = chooseImageAccess(accessList);
      if (access != null) return access;

// next choice is resolver type.
      access = invDataset.getAccess(ServiceType.RESOLVER);

// no valid access
      if (access == null) {
        result.errLog.format(""No access that could be used for Image Type %s %n"", invDataset);
        return null;
      }

      // deal with RESOLVER type
      String datasetLocation = access.getStandardUrlName();
      InvDatasetImpl rds = openResolver(datasetLocation, task, result);
      if (rds == null)
        return null;

// use the access list from the resolved dataset
      accessList = new ArrayList<>(invDataset.getAccess());
    } // loop over accesses

    return null;
  }",Get the image access.
"public ProjectCalendar getBaselineCalendar()
   {
      //
      // Attempt to locate the calendar normally used by baselines
      // If this isn't present, fall back to using the default
      // project calendar.
      //
      ProjectCalendar result = getCalendarByName(""Used for Microsoft Project 98 Baseline Calendar"");
      if (result == null)
      {
         result = getDefaultCalendar();
      }
      return result;
   }",Get the calendar used by baselines.
"@Override
    public void handle(RequestContext context, AuthenticationException e) throws SecurityProviderException,
            IOException {
        String targetUrl = getTargetUrl();
        if (StringUtils.isNotEmpty(targetUrl)) {
            RedirectUtils.redirect(context.getRequest(), context.getResponse(), targetUrl);
        } else {
            sendError(e, context);
        }
    }",Override handle to redirect to the target URL.
"@Override
	public boolean eIsSet(int featureID) {
		switch (featureID) {
			case AfplibPackage.TILE_TOCRG__XOFFSET:
				return XOFFSET_EDEFAULT == null ? xoffset != null : !XOFFSET_EDEFAULT.equals(xoffset);
			case AfplibPackage.TILE_TOCRG__YOFFSET:
				return YOFFSET_EDEFAULT == null ? yoffset != null : !YOFFSET_EDEFAULT.equals(yoffset);
			case AfplibPackage.TILE_TOCRG__THSIZE:
				return THSIZE_EDEFAULT == null ? thsize != null : !THSIZE_EDEFAULT.equals(thsize);
			case AfplibPackage.TILE_TOCRG__TVSIZE:
				return TVSIZE_EDEFAULT == null ? tvsize != null : !TVSIZE_EDEFAULT.equals(tvsize);
			case AfplibPackage.TILE_TOCRG__RELRES:
				return RELRES_EDEFAULT == null ? relres != null : !RELRES_EDEFAULT.equals(relres);
			case AfplibPackage.TILE_TOCRG__COMPR:
				return COMPR_EDEFAULT == null ? compr != null : !COMPR_EDEFAULT.equals(compr);
			case AfplibPackage.TILE_TOCRG__DATAPOS:
				return DATAPOS_EDEFAULT == null ? datapos != null : !DATAPOS_EDEFAULT.equals(datapos);
		}
		return super.eIsSet(featureID);
	}",Override the eIsSet method for the feature ID
"public String getResourcePath()
    {
        switch (resourceType)
        {
            case ANDROID_ASSETS: return assetPath;

            case ANDROID_RESOURCE: return resourceFilePath;

            case LINUX_FILESYSTEM: return filePath;

            case NETWORK: return url.getPath();

            case INPUT_STREAM: return inputStreamName;

            default: return null;
        }
    }",Get the path of the resource.
"public void marshall(EmbeddedPlusScte20DestinationSettings embeddedPlusScte20DestinationSettings, ProtocolMarshaller protocolMarshaller) {

        if (embeddedPlusScte20DestinationSettings == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",Creates a protocolMarshaller instance for the ACSCTe20DestinationSettings object.
"public static GenericObjectPool<Integer> createConnectionPool(int maxConnections) {
        GenericObjectPool<Integer> connectionPool = new GenericObjectPool<Integer>(new ConnectionPoolObjectFactory());
        connectionPool.setMaxActive(maxConnections);
        connectionPool.setWhenExhaustedAction(GenericObjectPool.WHEN_EXHAUSTED_BLOCK);
        return connectionPool;
    }",Create a connection pool.
"protected <T> Optional<T> getUserData(Optional<? extends Node> node, WaveItem<T> waveItem) {
        if (node.isPresent()) {
            final Node n = node.get();
            return getValue(n, n::getUserData, waveItem);
        }
        return Optional.empty();
    }",Get user data.
"@Override
    public ListIterator<E> listIterator(final int index) {
        Object[] elements = getArray();
        int len = elements.length;
        if (index < 0 || index > len)
            throw new IndexOutOfBoundsException(""Index: "" + index);

        return new COWIterator<E>(elements, index);
    }",Gets a list iterator.
"public static Double extractToDouble(final DeviceAttribute deviceAttributeRead)
	    throws DevFailed {
	final Object value = AttributeHelper.extract(deviceAttributeRead);
	Double argout = null;
	if (value instanceof Short) {
	    argout = Double.valueOf(((Short) value).doubleValue());
	} else if (value instanceof String) {
	    try {
		argout = Double.valueOf((String) value);
	    } catch (final Exception e) {
		Except.throw_exception(""TANGO_WRONG_DATA_ERROR"", ""output type "" + value
			+ "" is not a numerical"",
			""AttributeHelper.extractToFloat(deviceAttributeWritten)"");
	    }
	} else if (value instanceof Integer) {
	    argout = Double.valueOf(((Integer) value).doubleValue());
	} else if (value instanceof Long) {
	    argout = Double.valueOf(((Long) value).doubleValue());
	} else if (value instanceof Float) {
	    argout = Double.valueOf(((Float) value).doubleValue());
	} else if (value instanceof Boolean) {
	    if (((Boolean) value).booleanValue()) {
		argout = Double.valueOf(1);
	    } else {
		argout = Double.valueOf(0);
	    }
	} else if (value instanceof Double) {
	    argout = (Double) value;
	} else if (value instanceof DevState) {
	    argout = Double.valueOf(Integer.valueOf(((DevState) value).value()).doubleValue());
	} else {
	    Except.throw_exception(""TANGO_WRONG_DATA_ERROR"", ""output type "" + value.getClass()
		    + "" not supported"",
		    ""AttributeHelper.extractToFloat(Object value,deviceAttributeWritten)"");
	}

	return argout;
    }",Extract data from DeviceAttribute to a Double
"@Override
    public T handleResponse(final HttpResponse response) throws IOException {

        InputStream content = null;
        final T addresses;

        try {
            final StatusLine status = response.getStatusLine();
            if (status.getStatusCode() >= HttpStatus.SC_BAD_REQUEST) {
                throw new IOException(String.format(""HTTP error: %s %s"", status.getStatusCode(), status.getReasonPhrase()));
            }
            content = response.getEntity().getContent();
            addresses = gsonInstance
                    .fromJson(new InputStreamReader(content, ""utf-8""), responseType);
        } finally {
            if (null != content) {
                content.close();
            }
            response.getEntity().consumeContent();
        }

        return addresses;
    }",Handle response.
"public URL generatePresignedUrl(String bucketName, String key, int expirationInSeconds) {
        return this.generatePresignedUrl(bucketName, key, expirationInSeconds, HttpMethodName.GET);
    }",Generate a URL for a single key in a bucket.
"public List<Point2D_F64> convert(@Nullable List<Point2D_F64> storage , boolean copy ) {
		if( storage == null )
			storage = new ArrayList<>();
		else
			storage.clear();

		if( copy ) {
			for (int i = 0; i < 4; i++) {
				storage.add( get(i).copy() );
			}
		} else {
			for (int i = 0; i < 4; i++) {
				storage.add( get(i) );
			}
		}
		return storage;
	}",Converts the image into a list of 2D_F64 objects.
"@Override
	public int lastIndexOf(long elem) {
		for (int i = size-1; i >= 0; i--)
			if (elem==elementData[i])
				return i;
		return -1;
	}",Returns the index of the last occurrence of the specified element.
"private GBSNode leftMostChild(
                                 DeleteStack    stack)
    {
        GBSNode       p;
        p = _index.root();             /* Root of tree                          */
        GBSNode lastl = null;          /* Will point to left-most child         */
        if (p != null)                 /* Root is not null, we have a tree      */
        {
            /* Remember father of root               */
            stack.start(_index.dummyTopNode(), ""GBSIterator.leftMostChild"");
            lastl = leftMostChild(stack, p);
        }

        return lastl;
    }",Get the left - most child of the tree
"public void subscribe (DObjectManager omgr)
    {
        if (_active) {
            log.warning(""Active safesub asked to resubscribe "" + this + ""."", new Exception());
            return;
        }

        // note that we are now again in the ""wishing to be subscribed"" state
        _active = true;

        // make sure we dont have an object reference (which should be
        // logically impossible)
        if (_object != null) {
            log.warning(""Incroyable! A safesub has an object and was "" +
                        ""non-active!? "" + this + ""."", new Exception());
            // make do in the face of insanity
            _subscriber.objectAvailable(_object);
            return;
        }

        if (_pending) {
            // we were previously asked to subscribe, then they asked to
            // unsubscribe and now they've asked to subscribe again, all
            // before the original subscription even completed; we need do
            // nothing here except as the original subscription request
            // will eventually come through and all will be well
            return;
        }

        // we're not pending and we just became active, that means we need
        // to request to subscribe to our object
        _pending = true;
        omgr.subscribeToObject(_oid, this);
    }",Subscribes to the object.
"public void updateDistanceWith(RouteProgress routeProgress) {
    if (routeProgress != null && !isRerouting) {
      InstructionModel model = new InstructionModel(distanceFormatter, routeProgress);
      updateDataFromInstruction(model);
    }
  }",Update the distance with the given route progress.
"@Override
    public String visit(final JmesPathProjection jmesPathProjection,
                        final Void aVoid) throws InvalidTypeException {
        return ""new JmesPathProjection( "" + jmesPathProjection.getLhsExpr()
                .accept(this, aVoid) + "", "" + jmesPathProjection.getProjectionExpr()
                .accept(this, aVoid) + "")"";
    }",Generates the code for a new CRAID SEGMENT.
"public ServiceFuture<String> replaceContentAsync(String resourceGroupName, String automationAccountName, String runbookName, String runbookContent, final ServiceCallback<String> serviceCallback) {
        return ServiceFuture.fromHeaderResponse(replaceContentWithServiceResponseAsync(resourceGroupName, automationAccountName, runbookName, runbookContent), serviceCallback);
    }",Replaces the content of a runbook.
"@Override
    public List<JobExecution> getJobExecutions(JobInstance instance) throws NoSuchJobInstanceException, JobSecurityException {

        if (authService != null) {
            authService.authorizedInstanceRead(instance.getInstanceId());
        }

        return new ArrayList<JobExecution>(getPersistenceManagerService().getJobExecutionsFromJobInstanceId(instance.getInstanceId()));
    }",Get the list of executions for a given job instance.
"public void setMatchETagNone(String etag) throws InvalidArgumentException {
    if (etag == null) {
      throw new InvalidArgumentException(""ETag cannot be empty"");
    }
    copyConditions.put(""x-amz-copy-source-if-none-match"", etag);
  }",Set the ETag to be ignored.
"public static void compress(String srcFilePath, String destFilePath) throws Exception {
		File src = new File(srcFilePath);
		if (!src.exists()) {
			throw new RuntimeException(srcFilePath + ""不存在"");
		}
		File zipFile = new File(destFilePath);
		ZipOutputStream zos=null;
		try {
			FileOutputStream fos = new FileOutputStream(zipFile);
			CheckedOutputStream cos = new CheckedOutputStream(fos, new CRC32());
			zos = new ZipOutputStream(cos);
			String baseDir = """";
			compressbyType(src, zos, baseDir);
		}finally {
			if(zos!=null)
			{
				zos.close();
			}
		}
	}",Compress a file from srcFilePath to destFilePath
"@XmlElementDecl(namespace = ""http://www.opengis.net/gml"", name = ""_ContinuousCoverage"", substitutionHeadNamespace = ""http://www.opengis.net/gml"", substitutionHeadName = ""_Coverage"")
    public JAXBElement<AbstractContinuousCoverageType> create_ContinuousCoverage(AbstractContinuousCoverageType value) {
        return new JAXBElement<AbstractContinuousCoverageType>(__ContinuousCoverage_QNAME, AbstractContinuousCoverageType.class, null, value);
    }",Create an instance of the _ContinuousCoverage property.
"@Deprecated
    public static RequestAsyncTask executePlacesSearchRequestAsync(Session session, Location location,
            int radiusInMeters, int resultsLimit, String searchText, GraphPlaceListCallback callback) {
        return newPlacesSearchRequest(session, location, radiusInMeters, resultsLimit, searchText, callback)
                .executeAsync();
    }",Execute a place search request asynchronously.
"public void ensureNamespace(String schema)
    {
        try {
            // If the table schema is not ""default"" and the namespace does not exist, create it
            if (!schema.equals(DEFAULT) && !connector.namespaceOperations().exists(schema)) {
                connector.namespaceOperations().create(schema);
            }
        }
        catch (AccumuloException | AccumuloSecurityException e) {
            throw new PrestoException(UNEXPECTED_ACCUMULO_ERROR, ""Failed to check for existence or create Accumulo namespace"", e);
        }
        catch (NamespaceExistsException e) {
            // Suppress race condition between test for existence and creation
            LOG.warn(""NamespaceExistsException suppressed when creating "" + schema);
        }
    }",Ensure the Accumulo namespace for the given table schema.
"@Override
    public ResourceSet<Day> read(final TwilioRestClient client) {
        return new ResourceSet<>(this, client, firstPage(client));
    }",Example of reading the calendar calendar.
"private void parse(String namedSql, Map<String, Object> paramMap) {
		int len = namedSql.length();

		final StrBuilder name = StrUtil.strBuilder();
		final StrBuilder sqlBuilder = StrUtil.strBuilder();
		char c;
		Character nameStartChar = null;
		for (int i = 0; i < len; i++) {
			c = namedSql.charAt(i);
			if (c == ':' || c == '@' || c == '?') {
				nameStartChar = c;
			} else if (null != nameStartChar) {
				// 变量状态
				if (isGenerateChar(c)) {
					// 变量名
					name.append(c);
				} else {
					// 变量结束
					String nameStr = name.toString();
					if(paramMap.containsKey(nameStr)) {
						// 有变量对应值（值可以为null），替换占位符
						final Object paramValue = paramMap.get(nameStr);
						sqlBuilder.append('?');
						this.params.add(paramValue);
					} else {
						// 无变量对应值，原样输出
						sqlBuilder.append(nameStartChar).append(name);
					}
					nameStartChar = null;
					name.clear();
					sqlBuilder.append(c);
				}
			} else {
				sqlBuilder.append(c);
			}
		}

		if (false == name.isEmpty()) {
			// SQL结束依旧有变量名存在，说明变量位于末尾
			final Object paramValue = paramMap.get(name.toString());
			if (null != paramValue) {
				// 有变量对应值，替换占位符
				sqlBuilder.append('?');
				this.params.add(paramValue);
			} else {
				// 无变量对应值，原样输出
				sqlBuilder.append(nameStartChar).append(name);
			}
			nameStartChar = null;
			name.clear();
		}

		this.sql = sqlBuilder.toString();
	}",Parses the named SQL string and creates a list of parameters.
"private List<GempakStation> getStationList() {
    Key slat = findKey(GempakStation.SLAT);
    if (slat == null) {
      return null;
    }
    List<int[]> toCheck;
    if (slat.type.equals(ROW)) {
      toCheck = headers.rowHeaders;
    } else {
      toCheck = headers.colHeaders;
    }
    List<GempakStation> fileStations = new ArrayList<>();
    int i = 0;
    for (int[] header : toCheck) {
      if (header[0] != IMISSD) {
        GempakStation station = makeStation(header);
        if (station != null) {
          station.setIndex(i + 1);
          fileStations.add(station);
        }
      }
      i++;
    }
    return fileStations;
  }",Get the list of station objects from the header list.
"public static List<Writable> toArrowWritablesSingle(List<FieldVector> fieldVectors,Schema schema) {
        return toArrowWritables(fieldVectors,schema).get(0);
    }",Converts a list of field vectors to a single arrow writables list.
"public Future<Boolean> isDataInCache(Class<?> clazz, final Object cacheKey, long cacheExpiryDuration) throws CacheCreationException {
        return executeCommand(new IsDataInCacheCommand(this, clazz, cacheKey, cacheExpiryDuration));
    }",Checks if the data in cache is present in the cache.
"public static void setProperty(Object obj, String prop, Object value) throws PageException {
	boolean done = false;
	try {
	    if (setField(obj, prop, value)) done = true;
	}
	catch (Throwable t) {
	    ExceptionUtil.rethrowIfNecessary(t);
	}
	if (!done) callSetter(obj, prop, value);
    }",set a property on a object
"public int count(T obj, int count) {
        if (count < 1)
            throw new IllegalArgumentException(""Count must be positive: "" + count);
        int objIndex = (allowNewIndices) 
            ? objectIndices.index(obj)
            : objectIndices.find(obj);
        if (objIndex < 0)
            return 0;
        int curCount = indexToCount.get(objIndex);
        indexToCount.put(objIndex, curCount + count);
        sum += count;
        return curCount + count;
    }",Count a single exception of type T.
"public void setValue(int n, ValueType value) {
        if (VERIFY_INTEGRITY && value == null) {
            throw new IllegalArgumentException();
        }
        if (!isValid()) {
            throw new IllegalStateException(""accessing top or bottom frame"");
        }
        slotList.set(n, value);
    }",Sets the value of a particular attribute in the class file.
"private Status executeSwitch(Stmt.Switch stmt, CallStack frame, EnclosingScope scope) {
		Tuple<Stmt.Case> cases = stmt.getCases();
		//
		Object value = executeExpression(ANY_T, stmt.getCondition(), frame);
		for (int i = 0; i != cases.size(); ++i) {
			Stmt.Case c = cases.get(i);
			Stmt.Block body = c.getBlock();
			if (c.isDefault()) {
				return executeBlock(body, frame, scope);
			} else {
				// FIXME: this is a temporary hack until a proper notion of
				// ConstantExpr is introduced.
				RValue[] values = executeExpressions(c.getConditions(), frame);
				for (RValue v : values) {
					if (v.equals(value)) {
						return executeBlock(body, frame, scope);
					}
				}
			}
		}
		return Status.NEXT;
	}",Execute a switch statement.
"public double d(int[] x, int[] y) {
        if (x.length != y.length)
            throw new IllegalArgumentException(String.format(""Arrays have different length: x[%d], y[%d]"", x.length, y.length));

        double dist = 0.0;

        if (weight == null) {
            for (int i = 0; i < x.length; i++) {
                double d = Math.abs(x[i] - y[i]);
                dist += Math.pow(d, p);
            }
        } else {
            if (x.length != weight.length)
                throw new IllegalArgumentException(String.format(""Input vectors and weight vector have different length: %d, %d"", x.length, weight.length));

            for (int i = 0; i < x.length; i++) {
                double d = Math.abs(x[i] - y[i]);
                dist += weight[i] * Math.pow(d, p);
            }
        }

        return Math.pow(dist, 1.0/p);
    }",Compute the distance between two sets of integers.
"public static BooleanIsLessThan isLessThan(BooleanExpression left, Object constant) {

        if (!(constant instanceof Boolean))
            throw new IllegalArgumentException(""constant is not a Boolean"");

        return new BooleanIsLessThan(left, constant((Boolean)constant));
    }",Create an BooleanIsLessThan expression from the given expression and constant.
"public final WSConnectionEvent recycle(int eid, Exception ex, Object handle) 
    {
        id = eid;
        exception = ex;
        setConnectionHandle(handle);

        return this;
    }",Recycle this WSConnectionEvent.
"@Override
    public byte[] fromEndpoint(Endpoint endpoint, long lastTimeStarted, long lastTimeStopped)
        throws ServiceLocatorException {
        return serialize(createEndpointData(endpoint, lastTimeStarted,  lastTimeStopped));
    }",Serialize an endpoint into a byte array.
"protected void processContent(Content file) {
        // Handle metadata/special cases
        String lowerCaseFileName = file.name.toLowerCase();
        if (lowerCaseFileName.endsWith(""pom.properties"")) {
            // handle pom properties files
            InputStream is = new ByteArrayInputStream(file.bytes);
            Metadata md = Metadata.fromPomProperties(is);
            putMetadata(file.name, md);
        }

        // This is separate as we may or may not want to fingerprint
        // all files.
        if (RECURSIVE) {
            Artifact record = Processor.process(file.bytes, file.name, true);
            addContent(record, file.name);
        }
    }",Process the content of a CRAA file.
"public static long getLong(String pStr) {
        if (isEmpty(pStr)) {
            return 0;
        }
        long value = 0;
        try {
            value = Long.parseLong(pStr);
        } catch (NumberFormatException nm) {
        }
        return value;
    }",Get the Long value from a String.
"public static boolean isFraction(final String text, final int start, final int len){
        if(len < 3){
            return false;
        }
        int index = -1;
        for(int i=start; i<start+len; i++){
            char c = text.charAt(i);
            if(c=='.' || c=='/' || c=='／' || c=='．' || c=='·'){
                index = i;
                break;
            }
        }
        if(index == -1 || index == start || index == start+len-1){
            return false;
        }
        int beforeLen = index-start;
        return isNumber(text, start, beforeLen) && isNumber(text, index+1, len-(beforeLen+1));
    }",Check if a string is a fraction of a sequence of characters.
"public void addDefaultPool(String alias, int minSize, int maxSize) {
    if (alias == null) {
      throw new NullPointerException(""Pool alias cannot be null"");
    }
    if (defaultAlias == null) {
      addPool(alias, minSize, maxSize);
      defaultAlias = alias;
    } else {
      throw new IllegalArgumentException(""'"" + defaultAlias + ""' is already configured as the default pool"");
    }
  }",Add a default pool to the list of pools.
"@InternalApi
  public MutateRowsRequest toBulkProto(RequestContext requestContext) {
    String tableName =
        NameUtil.formatTableName(
            requestContext.getProjectId(), requestContext.getInstanceId(), tableId);

    return MutateRowsRequest.newBuilder()
        .setAppProfileId(requestContext.getAppProfileId())
        .setTableName(tableName)
        .addEntries(
            Entry.newBuilder().setRowKey(key).addAllMutations(mutation.getMutations()).build())
        .build();
  }",Converts the request to a bulk proto.
"private ColumnPair doToModel(DataColumnPairDO dataColumnPairDo) {

        Column sourceColumn = dataColumnPairDo.getSourceColumnName() == null ? null : new Column(
                                                                                                 dataColumnPairDo.getSourceColumnName());
        Column targetColumn = dataColumnPairDo.getTargetColumnName() == null ? null : new Column(
                                                                                                 dataColumnPairDo.getTargetColumnName());
        ColumnPair columnPair = new ColumnPair(sourceColumn, targetColumn);
        columnPair.setId(dataColumnPairDo.getId());
        columnPair.setDataMediaPairId(dataColumnPairDo.getDataMediaPairId());
        columnPair.setGmtCreate(dataColumnPairDo.getGmtCreate());
        columnPair.setGmtModified(dataColumnPairDo.getGmtModified());

        return columnPair;
    }",Method to convert a DataColumnPairDO to a Model ColumnPair.
"public boolean parse(final boolean fragment) throws FrameworkException {

		init();

		if (StringUtils.isNotBlank(code)) {

			if (!isDeployment) {
				logger.info(""##### Start parsing code for page {} #####"", new Object[]{name});
			} else {

				// a trailing slash to all void/self-closing tags so the XML parser can parse it correctly
				code = code.replaceAll(""<(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)([^>]*)>"", ""<$1$2/>"");
			}

			if (fragment) {

				if (isDeployment) {

					final List<Node> nodeList = Parser.parseXmlFragment(code, """");
					parsedDocument            = Document.createShell("""");
					final Element body        = parsedDocument.body();
					final Node[] nodes        = nodeList.toArray(new Node[nodeList.size()]);

					for (int i = nodes.length - 1; i > 0; i--) {
					    nodes[i].remove();
					}

					for (Node node : nodes) {
					    body.appendChild(node);
					}

				} else {

					parsedDocument = Jsoup.parseBodyFragment(code);
				}

			} else {

				if (isDeployment) {

					parsedDocument = Jsoup.parse(code, """", Parser.xmlParser());

				} else {

					parsedDocument = Jsoup.parse(code);
				}

			}

		} else {

			if (!isDeployment) {
				logger.info(""##### Start fetching {} for page {} #####"", new Object[]{address, name});
			}

			code = HttpHelper.get(address);
			parsedDocument = Jsoup.parse(code);

		}

		return true;

	}",Parses the XML code and returns true if the code is valid.
"private void writeConnection(Definition def, Writer out, int indent) throws IOException
   {
      writeWithIndent(out, indent, ""/**\n"");
      writeWithIndent(out, indent, "" * Gets a connection to an EIS instance. \n"");
      writeWithIndent(out, indent, "" *\n"");
      writeWithIndent(out, indent, "" * @return Connection instance the EIS instance.\n"");
      writeWithIndent(out, indent, "" * @throws ResourceException Failed to get a connection to\n"");
      writeWithIndent(out, indent, "" */\n"");

      writeWithIndent(out, indent, ""@Override\n"");
      writeWithIndent(out, indent, ""public Connection getConnection() throws ResourceException"");
      writeLeftCurlyBracket(out, indent);

      writeWithIndent(out, indent + 1,
            ""return new "" + def.getMcfDefs().get(getNumOfMcf()).getCciConnClass() + ""(new "" + def.getMcfDefs()
                  .get(getNumOfMcf()).getConnSpecClass() + ""());"");
      writeRightCurlyBracket(out, indent);
      writeEol(out);

      writeWithIndent(out, indent, ""/**\n"");
      writeWithIndent(out, indent, "" * Gets a connection to an EIS instance. \n"");
      writeWithIndent(out, indent, "" *\n"");
      writeWithIndent(out, indent, "" * @param connSpec Connection parameters and security information specified as ""
            + ""ConnectionSpec instance\n"");
      writeWithIndent(out, indent, "" * @return Connection instance the EIS instance.\n"");
      writeWithIndent(out, indent, "" * @throws ResourceException Failed to get a connection to\n"");
      writeWithIndent(out, indent, "" */\n"");

      writeWithIndent(out, indent, ""@Override\n"");
      writeWithIndent(out, indent, ""public Connection getConnection(ConnectionSpec connSpec) throws ResourceException"");
      writeLeftCurlyBracket(out, indent);

      writeWithIndent(out, indent + 1,
            ""return new "" + def.getMcfDefs().get(getNumOfMcf()).getCciConnClass() + ""(connSpec);"");
      writeRightCurlyBracket(out, indent);
      writeEol(out);
   }",Output Connection method
"public static <T> T convertToObject(Class<T> clazz, InputStream inputStream, Charset charset) {
		return convertToObject(clazz, new InputStreamReader(inputStream, charset));
	}",Converts an input stream to an object of the specified class using the specified charset.
"private void addValue(OUT reuse) throws SQLException {
		for (int pos = 0; pos < columnTypes.length; pos++) {
			switch (columnTypes[pos]) {
				case java.sql.Types.NULL:
					reuse.setField(NullValue.getInstance(), pos);
					break;
				case java.sql.Types.BOOLEAN:
					reuse.setField(resultSet.getBoolean(pos + 1), pos);
					break;
				case java.sql.Types.BIT:
					reuse.setField(resultSet.getBoolean(pos + 1), pos);
					break;
				case java.sql.Types.CHAR:
					reuse.setField(resultSet.getString(pos + 1), pos);
					break;
				case java.sql.Types.NCHAR:
					reuse.setField(resultSet.getString(pos + 1), pos);
					break;
				case java.sql.Types.VARCHAR:
					reuse.setField(resultSet.getString(pos + 1), pos);
					break;
				case java.sql.Types.LONGVARCHAR:
					reuse.setField(resultSet.getString(pos + 1), pos);
					break;
				case java.sql.Types.LONGNVARCHAR:
					reuse.setField(resultSet.getString(pos + 1), pos);
					break;
				case java.sql.Types.TINYINT:
					reuse.setField(resultSet.getShort(pos + 1), pos);
					break;
				case java.sql.Types.SMALLINT:
					reuse.setField(resultSet.getShort(pos + 1), pos);
					break;
				case java.sql.Types.BIGINT:
					reuse.setField(resultSet.getLong(pos + 1), pos);
					break;
				case java.sql.Types.INTEGER:
					reuse.setField(resultSet.getInt(pos + 1), pos);
					break;
				case java.sql.Types.FLOAT:
					reuse.setField(resultSet.getDouble(pos + 1), pos);
					break;
				case java.sql.Types.REAL:
					reuse.setField(resultSet.getFloat(pos + 1), pos);
					break;
				case java.sql.Types.DOUBLE:
					reuse.setField(resultSet.getDouble(pos + 1), pos);
					break;
				case java.sql.Types.DECIMAL:
					reuse.setField(resultSet.getBigDecimal(pos + 1).doubleValue(), pos);
					break;
				case java.sql.Types.NUMERIC:
					reuse.setField(resultSet.getBigDecimal(pos + 1).doubleValue(), pos);
					break;
				case java.sql.Types.DATE:
					reuse.setField(resultSet.getDate(pos + 1).toString(), pos);
					break;
				case java.sql.Types.TIME:
					reuse.setField(resultSet.getTime(pos + 1).getTime(), pos);
					break;
				case java.sql.Types.TIMESTAMP:
					reuse.setField(resultSet.getTimestamp(pos + 1).toString(), pos);
					break;
				case java.sql.Types.SQLXML:
					reuse.setField(resultSet.getSQLXML(pos + 1).toString(), pos);
					break;
				default:
					throw new SQLException(""Unsupported sql-type ["" + columnTypes[pos] + ""] on column ["" + pos + ""]"");

				// case java.sql.Types.BINARY:
				// case java.sql.Types.VARBINARY:
				// case java.sql.Types.LONGVARBINARY:
				// case java.sql.Types.ARRAY:
				// case java.sql.Types.JAVA_OBJECT:
				// case java.sql.Types.BLOB:
				// case java.sql.Types.CLOB:
				// case java.sql.Types.NCLOB:
				// case java.sql.Types.DATALINK:
				// case java.sql.Types.DISTINCT:
				// case java.sql.Types.OTHER:
				// case java.sql.Types.REF:
				// case java.sql.Types.ROWID:
				// case java.sql.Types.STRUCT:
			}
		}
	}",Method addValue.
"public static void attach(
      final Registry registry,
      final ThreadPoolExecutor threadPool,
      final String threadPoolName) {

    Preconditions.checkNotNull(registry, ""registry"");
    Preconditions.checkNotNull(threadPool, ""threadPool"");

    final String idValue;
    if (threadPoolName == null || threadPoolName.isEmpty()) {
      idValue = DEFAULT_ID;
    } else {
      idValue = threadPoolName;
    }

    final Tag idTag = new BasicTag(ID_TAG_NAME, idValue);

    PolledMeter.using(registry)
        .withName(TASK_COUNT)
        .withTag(idTag)
        .monitorMonotonicCounter(threadPool, ThreadPoolExecutor::getTaskCount);
    PolledMeter.using(registry)
        .withName(COMPLETED_TASK_COUNT)
        .withTag(idTag)
        .monitorMonotonicCounter(threadPool, ThreadPoolExecutor::getCompletedTaskCount);
    PolledMeter.using(registry)
        .withName(CURRENT_THREADS_BUSY)
        .withTag(idTag)
        .monitorValue(threadPool, ThreadPoolExecutor::getActiveCount);
    PolledMeter.using(registry)
        .withName(MAX_THREADS)
        .withTag(idTag)
        .monitorValue(threadPool, ThreadPoolExecutor::getMaximumPoolSize);
    PolledMeter.using(registry)
        .withName(POOL_SIZE)
        .withTag(idTag)
        .monitorValue(threadPool, ThreadPoolExecutor::getPoolSize);
    PolledMeter.using(registry)
        .withName(CORE_POOL_SIZE)
        .withTag(idTag)
        .monitorValue(threadPool, ThreadPoolExecutor::getCorePoolSize);
    PolledMeter.using(registry)
        .withName(QUEUE_SIZE)
        .withTag(idTag)
        .monitorValue(threadPool, tp -> tp.getQueue().size());

    // Handler is not allowed to be null, checked internally to thread pool
    Counter rejected = registry.counter(registry.createId(REJECTED_TASK_COUNT).withTag(idTag));
    RejectedExecutionHandler handler = threadPool.getRejectedExecutionHandler();
    RejectedExecutionHandler monitoredHandler = (Runnable r, ThreadPoolExecutor exec) -> {
      rejected.increment();
      handler.rejectedExecution(r, exec);
    };
    threadPool.setRejectedExecutionHandler(monitoredHandler);
  }",Attaches the specified thread pool to the specified registry.
"private void setTitleOfLayoutHeader() {
        titleOfArtifactDetails.setValue(HawkbitCommonUtil.getArtifactoryDetailsLabelId("""", i18n));
        titleOfArtifactDetails.setContentMode(ContentMode.HTML);
    }",Set the title of artifact details layout header.
"@Override
  public String[] prepareArguments(final CCTask task, final String outputDir, final String outputFile,
      final String[] sourceFiles, final CommandLineLinkerConfiguration config) {
    //
    // need to suppress sources that correspond to
    // library set entries since they are already
    // in the argument list
    final String[] libnames = config.getLibraryNames();
    if (libnames == null || libnames.length == 0) {
      return super.prepareArguments(task, outputDir, outputFile, sourceFiles, config);
    }
    //
    //
    // null out any sources that correspond to library names
    //
    final String[] localSources = sourceFiles.clone();
    int extra = 0;
    for (final String libname : libnames) {
      for (int j = 0; j < localSources.length; j++) {
        if (localSources[j] != null && localSources[j].indexOf(libname) > 0 && localSources[j].indexOf(""lib"") > 0) {
          final String filename = new File(localSources[j]).getName();
          if (filename.startsWith(""lib"") && filename.substring(3).startsWith(libname)) {
            final String extension = filename.substring(libname.length() + 3);
            if (extension.equals("".a"") || extension.equals("".so"") || extension.equals("".sl"")) {
              localSources[j] = null;
              extra++;
            }
          }
        }
      }
    }
    if (extra == 0) {
      return super.prepareArguments(task, outputDir, outputFile, sourceFiles, config);
    }
    final String[] finalSources = new String[localSources.length - extra];
    int index = 0;
    for (final String localSource : localSources) {
      if (localSource != null) {
        finalSources[index++] = localSource;
      }
    }
    return super.prepareArguments(task, outputDir, outputFile, finalSources, config);
  }",Override prepareArguments to suppress any libraries that are not in the library set.
"private <T> T deserialize(Response response, TypeRef returnType) throws ApiException {
    String contentType = null;
    List<Object> contentTypes = response.getHeaders().get(""Content-Type"");
    if (contentTypes != null && !contentTypes.isEmpty()) {
      contentType = (String)contentTypes.get(0);
    }

    if (contentType == null) {
      throw new ApiException(500, ""missing Content-Type in response"");
    }

    if (contentType.startsWith(""application/json"")) {
      String body;
      if (response.hasEntity()) {
        body = response.readEntity(String.class);
      } else {
        body = """";
      }
      if (body.length() > 0) {
        return json.deserialize(body, returnType);
      }
      return null;
    } if (contentType.startsWith(""image"")) {
      return (T) response.readEntity(InputStream.class);
    } else {
      throw new ApiException(500, ""can not deserialize Content-Type: "" + contentType);
    }
  }",Deserialize a response.
"public static String getHostName(InetAddress inetAddress) {
		String hostName;
		String fqdnHostName = getFqdnHostName(inetAddress);

		if (fqdnHostName.equals(inetAddress.getHostAddress())) {
			// this happens when the name lookup fails, either due to an exception,
			// or because no hostname can be found for the address
			// take IP textual representation
			hostName = fqdnHostName;
			LOG.warn(""No hostname could be resolved for the IP address {}, using IP address as host name. ""
				+ ""Local input split assignment (such as for HDFS files) may be impacted."", inetAddress.getHostAddress());
		} else {
			hostName = NetUtils.getHostnameFromFQDN(fqdnHostName);
		}

		return hostName;
	}",Get the hostname of the IP address
"public static boolean operate(PageContext pc, String[] varNames) {
	int scope = VariableInterpreter.scopeString2Int(pc.ignoreScopes(), varNames[0]);
	return _operate(pc, scope, KeyImpl.toKeyArray(varNames), scope == Scope.SCOPE_UNDEFINED ? 0 : 1);
    }",operate on a list of variable names
"public URI toURI() {
        String scheme = getScheme();
        String authority = getAuthority(scheme);
        String queryString = getQueryString();
        String uri = scheme + ""://"" + authority;

        if (!queryString.isEmpty()) {
            uri += ""?"" + queryString;
        }

        return URI.create(uri);
    }",Returns a URI for this request.
"public static void saveProperties(
        CmsObject cms,
        Element parentElement,
        Map<String, String> properties,
        Map<String, CmsXmlContentProperty> propertiesConf) {

        // remove old entries
        for (Object propElement : parentElement.elements(CmsXmlContentProperty.XmlNode.Properties.name())) {
            parentElement.remove((Element)propElement);
        }

        // use a sorted map to force a defined order
        SortedMap<String, String> props = new TreeMap<String, String>(properties);

        // create new entries
        for (Map.Entry<String, String> property : props.entrySet()) {
            String propName = property.getKey();
            String propValue = property.getValue();
            if ((propValue == null) || (propValue.length() == 0)) {
                continue;
            }
            // only if the property is configured in the schema we will save it
            Element propElement = parentElement.addElement(CmsXmlContentProperty.XmlNode.Properties.name());

            // the property name
            propElement.addElement(CmsXmlContentProperty.XmlNode.Name.name()).addCDATA(propName);
            Element valueElement = propElement.addElement(CmsXmlContentProperty.XmlNode.Value.name());
            boolean isVfs = false;
            CmsXmlContentProperty propDef = propertiesConf.get(propName);
            if (propDef != null) {
                isVfs = CmsXmlContentProperty.PropType.isVfsList(propDef.getType());
            }
            if (!isVfs) {
                // string value
                valueElement.addElement(CmsXmlContentProperty.XmlNode.String.name()).addCDATA(propValue);
            } else {
                addFileListPropertyValue(cms, valueElement, propValue);
            }
        }
    }",Saves the properties of a single class.
"public SerDe getSerDe() throws IOException {
    if (!this.serDe.isPresent()) {
      try {
        this.serDe = Optional.of(SerDe.class.cast(Class.forName(this.serDeClassName).newInstance()));
      } catch (Throwable t) {
        throw new IOException(""Failed to instantiate SerDe "" + this.serDeClassName, t);
      }
    }
    return this.serDe.get();
  }",Get the SerDe object.
"public void validateFields() throws IllegalStateException {
		for (String rf : requiredFields)
			if (textFields.get(rf).getText().trim().isEmpty()) {
				textFields.get(rf).requestFocusInWindow();
				throw new IllegalStateException(Constant.messages.getString(
						""authentication.method.script.dialog.error.text.required"", rf));
			}
	}",Validate fields.
"private void updateTime(long tolerance) {
        long now = System.currentTimeMillis();
        // check for exact match
        if (now == this.lastTimeCheck) {
            return;
        }
        // check for a ""range"" match
        if (0L != tolerance) {
            long range = (-1 == tolerance) ? DEFAULT_TOLERANCE : tolerance;
            if ((now - this.lastTimeCheck) <= range) {
                return;
            }
        }
        // otherwise need to format the current time
        this.myDate.setTime(now);
        this.myBuffer.setLength(0);
        this.myBuffer = this.myFormat.format(this.myDate, this.myBuffer, new FieldPosition(0));
//        int len = this.myBuffer.length();
//
//        // extract the char[] of the time and save the byte[] equivalent
//        if (this.caTime.length != len) {
//            // both arrays will always have the same length
//            this.caTime = new char[len];
//            this.baTime = new byte[len];
//        }
//        this.myBuffer.getChars(0, len, this.caTime, 0);
//        for (int i = 0; i < len; i++) {
//            this.baTime[i] = (byte) this.caTime[i];
//        }
        // delay the string creation until it's actually needed
        this.sTime = null;

        this.lastTimeCheck = now;
    }",Update the time field of the exception.
"public void setResources(com.google.api.ads.admanager.axis.v201808.ProposalLink[] resources) {
        this.resources = resources;
    }",Sets the resources value for this Proposal.
"@Override
	public CommerceWarehouse findByG_A_C_First(long groupId, boolean active,
		long commerceCountryId,
		OrderByComparator<CommerceWarehouse> orderByComparator)
		throws NoSuchWarehouseException {
		CommerceWarehouse commerceWarehouse = fetchByG_A_C_First(groupId,
				active, commerceCountryId, orderByComparator);

		if (commerceWarehouse != null) {
			return commerceWarehouse;
		}

		StringBundler msg = new StringBundler(8);

		msg.append(_NO_SUCH_ENTITY_WITH_KEY);

		msg.append(""groupId="");
		msg.append(groupId);

		msg.append("", active="");
		msg.append(active);

		msg.append("", commerceCountryId="");
		msg.append(commerceCountryId);

		msg.append(""}"");

		throw new NoSuchWarehouseException(msg.toString());
	}",Returns the commerce warehouse in the ordered set where groupId = &#63 ; and active = &#63 ; and commerceCountryId = &#63 ;.
"private void addError(int code, String key) {

        errorCodes = (int[]) ArrayUtil.resizeArray(errorCodes,
                errorCodes.length + 1);
        errorKeys = (String[]) ArrayUtil.resizeArray(errorKeys,
                errorKeys.length + 1);
        errorCodes[errorCodes.length - 1] = code;
        errorKeys[errorKeys.length - 1]   = key;
    }",Add an error to the errorCodes and errorKeys array.
"public void build(final String... args) {
        if (args != null) {
            final CmdLineParser parser = new CmdLineParser(this, ParserProperties.defaults().withUsageWidth(80));

            try {
                parser.parseArgument(args);
            } catch (final CmdLineException e) {
                throw new ClusterRunnerException(""Failed to parse args: "" + Strings.arrayToDelimitedString(args, "" ""));
            }
        }

        if (basePath == null) {
            try {
                basePath = Files.createTempDirectory(""es-cluster"").toAbsolutePath().toString();
            } catch (final IOException e) {
                throw new ClusterRunnerException(""Could not create $ES_HOME."", e);
            }
        }

        final Path esBasePath = Paths.get(basePath);
        createDir(esBasePath);

        final String[] types = moduleTypes == null ? MODULE_TYPES : moduleTypes.split("","");
        for (final String moduleType : types) {
            Class<? extends Plugin> clazz;
            try {
                clazz = Class.forName(moduleType).asSubclass(Plugin.class);
                pluginList.add(clazz);
            } catch (final ClassNotFoundException e) {
                logger.debug(moduleType + "" is not found."", e);
            }
        }
        if (pluginTypes != null) {
            for (final String value : pluginTypes.split("","")) {
                final String pluginType = value.trim();
                if (pluginType.length() > 0) {
                    Class<? extends Plugin> clazz;
                    try {
                        clazz = Class.forName(pluginType).asSubclass(Plugin.class);
                        pluginList.add(clazz);
                    } catch (final ClassNotFoundException e) {
                        throw new ClusterRunnerException(pluginType + "" is not found."", e);
                    }
                }
            }
        }

        print(""Cluster Name: "" + clusterName);
        print(""Base Path:    "" + basePath);
        print(""Num Of Node:  "" + numOfNode);

        for (int i = 0; i < numOfNode; i++) {
            execute(i + 1);
        }
    }",Build the cluster.
"public void setHomeAsUpIndicator(Drawable indicator) {
        if(!deviceSupportMultiPane()) {
            pulsante.setHomeAsUpIndicator(indicator);
        }
        else {
            actionBar.setHomeAsUpIndicator(indicator);
        }
    }",Set the Home As Up indicator.
"public SignatureAttr getSignatureAttr() {
        for (int i = mAttributes.size(); --i >= 0; ) {
            Attribute attr = mAttributes.get(i);
            if (attr instanceof SignatureAttr) {
                return (SignatureAttr) attr;
            }
        }
        return null;
    }",Get the SignatureAttr object.
"public Xid[] recover(int flag) throws XAException
    {
        if (tc.isEntryEnabled()) Tr.entry(tc, ""recover"", Util.printFlag(flag));

		final Xid[] result = TxExecutionContextHandler.recover(flag);
			
		if (tc.isEntryEnabled()) Tr.exit(tc, ""recover"", result);
		return result;
    }",This method is called by the XAResource when an exception occurs during recovery.
"private Es6SyntacticScopeCreator createScopeCreator() {
    if (validityCheck) {
      return new Es6SyntacticScopeCreator(compiler);
    } else {
      dupHandler = new RedeclarationCheckHandler();
      return new Es6SyntacticScopeCreator(compiler, dupHandler);
    }
  }",Create a syntactic scope creator.
"public com.google.privacy.dlp.v2.RedactConfig getRedactConfig() {
    if (transformationCase_ == 2) {
      return (com.google.privacy.dlp.v2.RedactConfig) transformation_;
    }
    return com.google.privacy.dlp.v2.RedactConfig.getDefaultInstance();
  }",Gets the value of the redactConfig property.
"void resetCacheFlags(boolean resetChilds) {
		if (isTraceable(TraceLevel.FINEST)) {
			finestEnabled = true;
			finerEnabled = true;
			fineEnabled = true;
			configEnabled = true;
			infoEnabled = true;
			warningEnabled = true;
			severeEnabled = true;
		}
		else {
			finestEnabled = false;
			if (isTraceable(TraceLevel.FINER)) {
				finerEnabled = true;
				fineEnabled = true;
				configEnabled = true;
				infoEnabled = true;
				warningEnabled = true;
				severeEnabled = true;
			}
			else {
				finerEnabled = false;
				if (isTraceable(TraceLevel.FINE)) {
					fineEnabled = true;
					configEnabled = true;
					infoEnabled = true;
					warningEnabled = true;
					severeEnabled = true;
				}
				else {
					fineEnabled = false;
					if (isTraceable(TraceLevel.CONFIG)) {
						configEnabled = true;
						infoEnabled = true;
						warningEnabled = true;
						severeEnabled = true;
					}
					else {
						if (isTraceable(TraceLevel.INFO)) {
							infoEnabled = true;
							warningEnabled = true;
							severeEnabled = true;
						}
						else {
							infoEnabled = false;
							if (isTraceable(TraceLevel.WARNING)) {
								warningEnabled = true;
								severeEnabled = true;
							}
							else {
								warningEnabled = false;
								if (isTraceable(TraceLevel.SEVERE)) {
									severeEnabled = true;
								}
								else {
									severeEnabled = false;
								}
							}
						}
					}
				}
			}
		}
		if (resetChilds) {
			// implicit change of level demands that we update reset flags on childs without level
			for(TracerImpl child : childs) {
				if (child.level == null) {
					child.resetCacheFlags(true);
				}				
			}
		}
	}",Resets the flags of the cache.
"public ServiceFuture<NetworkInterfaceIPConfigurationInner> getAsync(String resourceGroupName, String networkInterfaceName, String ipConfigurationName, final ServiceCallback<NetworkInterfaceIPConfigurationInner> serviceCallback) {
        return ServiceFuture.fromResponse(getWithServiceResponseAsync(resourceGroupName, networkInterfaceName, ipConfigurationName), serviceCallback);
    }",Gets an IP configuration.
"public long insert(final InsertQuery query) {
        return runner.run(new TransactionWrapper<Long>() {
            public Long perform(QueryRunner queryRunner) {
                return queryRunner.insert(query);
            }
        });
    }",Insert a record in the database.
"private void copy() {
        if (elems.nonEmpty()) {
            List<A> orig = elems;

            elems = last = List.of(orig.head);

            while ((orig = orig.tail).nonEmpty()) {
                last.tail = List.of(orig.head);
                last = last.tail;
            }
        }
    }",Copy the list of A to the list of a single page.
"public static <F extends ConfigurationComponent<F>> F mergeComponent(final F localValue, final F defaultValue) {
        return Optional.ofNullable(localValue).map(v -> v.merge(defaultValue)).orElse(defaultValue);
    }",Merge a configuration component.
"@XmlElementDecl(namespace = ""http://www.opengis.net/gml"", name = ""name"")
    public JAXBElement<CodeType> createName(CodeType value) {
        return new JAXBElement<CodeType>(_Name_QNAME, CodeType.class, null, value);
    }",Create an instance of a name specification.
"public static StrokeInfo createStroke(String color, int width, float opacity, String dashArray) {
		StrokeInfo strokeInfo = new StrokeInfo();
		if (color != null) {
			strokeInfo.getCssParameterList().add(createCssParameter(""stroke"", color));
		}
		strokeInfo.getCssParameterList().add(createCssParameter(""stroke-width"", width));
		if (dashArray != null) {
			strokeInfo.getCssParameterList().add(createCssParameter(""stroke-dasharray"", dashArray));
		}
		strokeInfo.getCssParameterList().add(createCssParameter(""stroke-opacity"", opacity));
		return strokeInfo;
	}",Create a stroke with the specified parameters.
"@SuppressWarnings(""PMD.UseVarargs"")
    public void disableBundle(final Class<? extends GuiceyBundle>[] bundles) {
        for (Class<? extends GuiceyBundle> bundle : bundles) {
            registerDisable(ConfigItem.Bundle, bundle);
        }
    }",Disable all bundles.
"public static void delete(String url, HttpConsumer<HttpExchange> endpoint, MediaTypes... mediaTypes) {
        addResource(Methods.DELETE, url, endpoint, mediaTypes);
    }",Add a DELETE resource.
"private static void appendExtrude(ExtrudeMode extrude, StringBuilder sb) {
        if (extrude.equals(ExtrudeMode.TRUE)) {
            sb.append(""<extrude>"").append(1).append(""</extrude>"");
        } else if (extrude.equals(ExtrudeMode.FALSE)) {
            sb.append(""<extrude>"").append(0).append(""</extrude>"");
        }
    }",Append Extrude mode.
"public static ConstraintViolationImpl<Object> instantiate(
      final SerializationStreamReader streamReader) throws SerializationException {

    final String messageTemplate = null;
    final String interpolatedMessage = streamReader.readString();
    final Class<Object> rootBeanClass = null;
    final Object rootBean = null;
    final Object leafBeanInstance = null;
    final Object value = null;
    final Path propertyPath = (Path) streamReader.readObject();
    final ConstraintDescriptor<?> constraintDescriptor = null;
    final ElementType elementType = null;
    final Map<String, Object> messageParameters = new HashMap<>();
    final Map<String, Object> expressionVariables = new HashMap<>();
    return (ConstraintViolationImpl<Object>) ConstraintViolationImpl.forBeanValidation(
        messageTemplate, messageParameters, expressionVariables, interpolatedMessage, rootBeanClass,
        rootBean, leafBeanInstance, value, propertyPath, constraintDescriptor, elementType, null);
  }",Instantiates a ConstraintViolationImpl object from the passed in SerializationStreamReader.
"public Optional<Application> show(long applicationId)
    {
        return HTTP.GET(String.format(""/v2/applications/%d.json"", applicationId), APPLICATION);
    }",Returns the application with the given id.
"@JsonIgnore
	public <T> T getAsTypeWithDefault(Class<T> type, T defaultValue) {
		return TypeConverter.toTypeWithDefault(type, _value, defaultValue);
	}",Converts object value into a value with default value if conversion is not possible.
"private static String calibrate(String context) {
        while(context.startsWith(""/"")) context = context.substring(1);
        return context.replace('/', ':');
    }",Calrate a context string.
"public Object execute(final Map<Object, Object> iArgs) {
    if (clazz == null)
      throw new OCommandExecutionException(""Cannot execute the command because it has not been parsed yet"");

    ODatabaseRecord database = getDatabase();
    if (!(database instanceof OGraphDatabase))
      database = new OGraphDatabase((ODatabaseRecordTx) database);

    final ORecordId fromId = new ORecordId(from);
    final ORecordId toId = new ORecordId(to);

    final ODocument edge = ((OGraphDatabase) database).createEdge(fromId, toId, clazz.getName());

    OSQLHelper.bindParameters(edge, fields, new OCommandParameters(iArgs));

    edge.save(clusterName);

    return edge;
  }","Executes the
    command."
"void afterHtmlUpdate() {

        if (m_overlayTimer != null) {
            m_overlayTimer.cancel();
            m_overlayTimer = null;
        }
        m_runningUpdate = false;
        List<Element> elements = CmsEntityBackend.getInstance().getAttributeElements(
            m_parentEntity,
            m_attributeHandler.getAttributeName(),
            m_formParent.getElement());
        if (m_popupClosed) {
            // the form popup has already been closed, reinitialize the editing widgets for updated HTML
            CmsInlineEditOverlay.updateCurrentOverlayPosition();
            if (m_requireShowPopup) {
                if (elements.size() > m_attributeIndex) {
                    m_referenceElement = elements.get(m_attributeIndex);
                }
                showEditPopup(null);
                m_hasChanges = true;
            } else {
                CmsInlineEditOverlay.getRootOverlay().clearButtonPanel();
                m_htmlUpdateHandler.reinitWidgets(m_formParent);
            }

        } else {
            if (m_referenceElement != null) {
                CmsInlineEditOverlay.removeLastOverlay();
            }
            if (elements.size() > m_attributeIndex) {
                m_referenceElement = elements.get(m_attributeIndex);
                CmsInlineEditOverlay.addOverlayForElement(m_referenceElement);
            } else {
                m_referenceElement = m_formParent.getElement();
                CmsInlineEditOverlay.addOverlayForElement(m_referenceElement);
            }
        }
        // schedule to update the ovelay position
        m_overlayTimer = new Timer() {

            /** Timer run counter. */
            private int m_timerRuns;

            /**
             * @see com.google.gwt.user.client.Timer#run()
             */
            @Override
            public void run() {

                CmsInlineEditOverlay.updateCurrentOverlayPosition();
                if (m_timerRuns > 3) {
                    cancel();
                }
                m_timerRuns++;
            }
        };
        m_overlayTimer.scheduleRepeating(100);
    }",Called after HTML update.
"public void waitForCompletion(long timeout) throws AsyncTimeoutException, InterruptedException {
        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
            Tr.debug(tc, ""waitForCompletion: "" + timeout);
        }

        // First do a non-sync test, to see if we can return quickly
        if (this.fullyCompleted) {
            return;
        }

        synchronized (this.completedSemaphore) {
            if (this.completed) {
                return;
            }
            // not completed, so we must wait to be notified of completion.
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""waiting for completion notification for future: "" + this);
            }
            this.completedSemaphore.wait(timeout);
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""done waiting for completion notification for future: "" + this);
            }
        } // end-sync

        // we either woke up because the operation completed, or timed out.
        // For performance reasons, first do a lazy check to see if we are done.
        // If we are not then grab the semaphore, and throw a timed out
        // exception.
        if (this.fullyCompleted) {
            return;
        }

        synchronized (this.completedSemaphore) {
            if (!this.completed) {
                this.completed = true;
                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                    Tr.debug(tc, ""Sync operation timed out"");
                }
                throw new AsyncTimeoutException();
            }
        } // end-sync
    }",Wait for completion of the current thread.
"public void truncateRecording(final long recordingId, final long position)
    {
        lock.lock();
        try
        {
            ensureOpen();

            final long correlationId = aeron.nextCorrelationId();

            if (!archiveProxy.truncateRecording(recordingId, position, correlationId, controlSessionId))
            {
                throw new ArchiveException(""failed to send truncate recording request"");
            }

            pollForResponse(correlationId);
        }
        finally
        {
            lock.unlock();
        }
    }",Truncate a recording.
"public EList<FNPRG> getRg() {
		if (rg == null) {
			rg = new EObjectContainmentEList.Resolving<FNPRG>(FNPRG.class, this, AfplibPackage.FNP__RG);
		}
		return rg;
	}",Replies the list of the RG elements.
"public RootMethodRunResult getRunResultByRootMethod(TestMethod rootMethod) {
        if (rootMethod == null) {
            throw new NullPointerException();
        }
        return getRunResultByRootMethodKey(rootMethod.getKey());
    }",Gets the RunResult for a given root method.
"@Path(""/users"")
	@Post
	@Public
	public void add(@Valid @LoginAvailable User user) {
        validator.onErrorUsePageOf(HomeController.class).login();
        
		userDao.add(user);

		// you can add objects to result even in redirects. Added objects will
		// survive one more request when redirecting.
		result.include(""notice"", ""User "" + user.getName() + "" successfully added"");
		result.redirectTo(HomeController.class).login();
	}",Add a user to the result
"@Override
    public void start()
    {
        try {
            m_leaderCache = new LeaderCache(m_zk, ""MpTerm-iv2masters"", VoltZK.iv2masters, m_leadersChangeHandler);
            m_leaderCache.start(true);
        }
        catch (ExecutionException ee) {
            VoltDB.crashLocalVoltDB(""Unable to create babysitter starting term."", true, ee);
        } catch (InterruptedException e) {
            VoltDB.crashLocalVoltDB(""Unable to create babysitter starting term."", true, e);
        }
    }",Start the babysitter.
"public double[][] buildBondMatrix() {
        int i, j, k, m;
        for (i = 0; i < nodeNumber; i++) {
            for (j = 1; j <= layerNumber; j++) {
                bondMatrix[i][j - 1] = 0.0;
                for (k = 0; k < nodeNumber; k++) {
                    if (j == 1) {
                        if (apspMatrix[i][k] == j) {
                            bondMatrix[i][j - 1] += adjaMatrix[i][k];
                        }
                    } else {
                        if (apspMatrix[i][k] == j) {
                            for (m = 0; m < nodeNumber; m++) {
                                if (apspMatrix[i][m] == (j - 1)) {
                                    bondMatrix[i][j - 1] += adjaMatrix[k][m];
                                }
                            }
                        }
                    }
                }
            }
        }
        return bondMatrix;
    }",Build bond matrix.
"public ReadOnlyStyledDocumentBuilder<PS, SEG, S> addParagraph(List<StyledSegment<SEG, S>> styledSegments) {
        return addParagraph(styledSegments, null);
    }",Add a paragraph to the document.
"@Reference(authors = ""Erich Schubert, Arthur Zimek, Hans-Peter Kriegel"", //
      title = ""Geodetic Distance Queries on R-Trees for Indexing Geographic Data"", //
      booktitle = ""Int. Symp. Advances in Spatial and Temporal Databases (SSTD'2013)"", //
      url = ""https://doi.org/10.1007/978-3-642-40235-7_9"", //
      bibkey = ""DBLP:conf/ssd/SchubertZK13"")
  public static double latlngMinDistRadFull(double plat, double plng, double rminlat, double rminlng, double rmaxlat, double rmaxlng) {
    // FIXME: add support for rectangles crossing the +-180 deg boundary!

    // Degenerate rectangles:
    if((rminlat >= rmaxlat) && (rminlng >= rmaxlng)) {
      return haversineFormulaRad(rminlat, rminlng, plat, plng);
    }

    // The simplest case is when the query point is in the same ""slice"":
    if(rminlng <= plng && plng <= rmaxlng) {
      return (rminlat <= plat && plat <= rmaxlat) ? 0 // Inside
          : (plat < rminlat) ? rminlat - plat : plat - rmaxlat; // S, N
    }

    // Determine whether going east or west is shorter.
    double lngE = rminlng - plng;
    lngE = lngE >= 0 ? lngE : lngE + TWOPI;
    double lngW = plng - rmaxlng; // we keep this negative!
    lngW = lngW >= 0 ? lngW : lngW + TWOPI;

    // Compute sine and cosine values we will certainly need below:
    final DoubleWrapper tmp = new DoubleWrapper(); // To return cosine
    final double slatQ = sinAndCos(plat, tmp), clatQ = tmp.value;
    final double slatN = sinAndCos(rmaxlat, tmp), clatN = tmp.value;
    final double slatS = sinAndCos(rminlat, tmp), clatS = tmp.value;

    // Head east, to min edge:
    if(lngE <= lngW) {
      final double slngD = sinAndCos(lngE, tmp), clngD = tmp.value;

      // Bearing to south
      // atan2(slngD * clatS, clatQ * slatS - slatQ * clatS * clngD);
      // Bearing from south
      final double bs = atan2(slngD * clatQ, clatS * slatQ - slatS * clatQ * clngD);
      // Bearing to north
      // atan2(slngD * clatN, clatQ * slatN - slatQ * clatN * clngD);
      // Bearing from north
      final double bn = atan2(slngD * clatQ, clatN * slatQ - slatN * clatQ * clngD);
      if(bs < HALFPI && bn > HALFPI) {
        // Radians from south pole = abs(ATD)
        final double radFromS = -HALFPI - plat;

        // Cross-track-distance to longitude line.
        return asin(sin(radFromS) * -slngD);
      }
      if(bs - HALFPI < HALFPI - bn) {
        // Haversine to north corner.
        final double slatN2 = sin((plat - rmaxlat) * .5);
        final double slon = sin(lngE * .5);
        final double aN = slatN2 * slatN2 + slon * slon * clatQ * clatN;
        return 2 * atan2(sqrt(aN), sqrt(1 - aN));
      }
      else {
        // Haversine to south corner.
        final double slatS2 = sin((plat - rminlat) * .5);
        final double slon = sin(lngE * .5);
        final double aS = slatS2 * slatS2 + slon * slon * clatQ * clatS;
        return 2 * atan2(sqrt(aS), sqrt(1 - aS));
      }
    }
    else { // Head west, to max edge
      final double slngD = -sinAndCos(lngW, tmp), clngD = tmp.value;

      // Bearing to south
      // atan2(slngD * clatS, clatQ * slatS - slatQ * clatS * clngD);
      // Bearing from south
      final double bs = atan2(slngD * clatQ, clatS * slatQ - slatS * clatQ * clngD);
      // Bearing to north
      // atan2(slngD * clatN, clatQ * slatN - slatQ * clatN * clngD);
      // Bearing from north
      final double bn = atan2(slngD * clatQ, clatN * slatQ - slatN * clatQ * clngD);
      if(bs > -HALFPI && bn < -HALFPI) {
        // Radians from south = abs(ATD) = distance from pole
        final double radFromS = -HALFPI - plat;
        // Cross-track-distance to longitude line.
        return asin(sin(radFromS) * slngD);
      }
      if(-HALFPI - bs < bn + HALFPI) {
        // Haversine to north corner.
        final double slatN2 = sin((plat - rmaxlat) * .5);
        final double slon = sin(lngW * .5);
        final double aN = slatN2 * slatN2 + slon * slon * clatQ * clatN;
        return 2 * atan2(sqrt(aN), sqrt(1 - aN));
      }
      else {
        // Haversine to south corner.
        final double slatS2 = sin((plat - rminlat) * .5);
        final double slon = sin(lngW * .5);
        final double aS = slatS2 * slatS2 + slon * slon * clatQ * clatS;
        return 2 * atan2(sqrt(aS), sqrt(1 - aS));
      }
    }
  }",Get Lat Long Min Distance Rad Full
"public static DelegatingErrorHandlingRunnable decorateTaskWithErrorHandler(Runnable task,
            ErrorHandler errorHandler, boolean isRepeatingTask) {
        if (task instanceof DelegatingErrorHandlingRunnable) {
            return (DelegatingErrorHandlingRunnable) task;
        }
        ErrorHandler eh = errorHandler != null ? errorHandler : getDefaultErrorHandler(isRepeatingTask);
        return new DelegatingErrorHandlingRunnable(task, eh);
    }",Decorate a task with an error handler.
"public float getTangentY(int vertex) {
        if (!hasTangentsAndBitangents()) {
            throw new IllegalStateException(""mesh has no bitangents"");
        }
        
        checkVertexIndexBounds(vertex);
        
        return m_tangents.getFloat((vertex * 3 + 1) * SIZEOF_FLOAT);
    }",Get the y - coordinate of a vertex s tangent.
"public void showPageOverlay() {

        if (m_overlay == null) {
            m_overlay = new SimplePanel();
            m_overlay.setStyleName(I_CmsLayoutBundle.INSTANCE.dialogCss().popupOverlay());
            Style style = m_overlay.getElement().getStyle();
            style.setWidth(100, Unit.PCT);
            style.setHeight(100, Unit.PCT);
            style.setPosition(Position.FIXED);
        }
        RootPanel.get().add(m_overlay);
    }",Show page overlay.
"String getTemplateString() {
		String templateString = null;

		Template template = getSelectedTemplate();
		if (template != null) {
			TemplateContextType contextType = GlassmakerUIPlugin.getDefault().getTemplateContextRegistry().getContextType(CardContextType.CONTEXT_TYPE);
			IDocument document = new Document();
			TemplateContext context = new DocumentTemplateContext(contextType, document, 0, 0);
			try {
				TemplateBuffer buffer = context.evaluate(template);
				templateString = buffer.getString();
			}
			catch (Exception e) {
				GlassmakerUIPlugin.logError(""Could not create template for new html"", e); 
			}
		}

		return templateString;
	}",Returns the string of the selected template.
"public List<Double> getNonNegativeDoubleList(final String param) {
    return getList(param, new StringToDouble(),
        new IsNonNegative<Double>(), ""non-negative double"");
  }",Gets the non - negative double list.
"private ImageIcon createIcon(String resourcePath) {
		if (getView() == null) {
			return null;
		}
		return new ImageIcon(ExtensionScript.class.getResource(resourcePath));
	}",Create an image icon for the resource.
"public FutureData<ManagedSourceList> get(ManagedDataSourceType type, int page, int perPage) {
        FutureData<ManagedSourceList> future = new FutureData<>();
        ParamBuilder b = newParams();
        if (type != null) {
            b.put(""source_type"", type.value());
        }
        if (page > 0) {
            b.put(""page"", page);
        }
        if (perPage > 0) {
            b.put(""per_page"", perPage);
        }
        URI uri = b.forURL(config.newAPIEndpointURI(GET));
        Request request = config.http().
                GET(uri, new PageReader(newRequestCallback(future, new ManagedSourceList(), config)));
        performRequest(future, request);
        return future;
    }",Get all the managed sources of the specified type.
"public PlainTime minus(
        long amount,
        ClockUnit unit
    ) {

        return this.plus(Math.negateExact(amount), unit);

    }",Returns a PlainTime representing the specified number of nanoseconds minus the specified unit.
"void ensureTriangleOrder(List<Point2D_I32> contour ) {
		Element<Corner> e = list.getHead();
		Corner a = e.object;e=e.next;
		Corner b = e.object;e=e.next;
		Corner c = e.object;

		int distB = CircularIndex.distanceP(a.index,b.index,contour.size());
		int distC = CircularIndex.distanceP(a.index,c.index,contour.size());

		if( distB > distC ) {
			list.reset();
			list.pushTail(a);
			list.pushTail(c);
			list.pushTail(b);
		}
	}",Ensure that the triangle order of the contour is correct.
"public static Iterable<VcfRecord> records(final InputStream inputStream) throws IOException {
        checkNotNull(inputStream);
        try (BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream))) {
            return records(reader);
        }
    }",Read VCF records from the specified input stream.
"private void tfJavaFieldTypeFocusLost(java.awt.event.FocusEvent evt)//GEN-FIRST:event_tfJavaFieldTypeFocusLost
    {//GEN-HEADEREND:event_tfJavaFieldTypeFocusLost
        // Commit on lost focus
        this.aRelation.setFieldType(tfJavaFieldType.getText());
    }",This method is called when the user sets the field type of a TfJava class field to a different value.
"public Observable<Void> beginValidateMoveResourcesAsync(String sourceResourceGroupName, ResourcesMoveInfo parameters) {
        return beginValidateMoveResourcesWithServiceResponseAsync(sourceResourceGroupName, parameters).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }",Validate move resources. Validate move resources.
"public static String getRelativeName(String fullDn, Context baseCtx)
			throws NamingException {

		String baseDn = baseCtx.getNameInNamespace();

		if (baseDn.length() == 0) {
			return fullDn;
		}

		DistinguishedName base = new DistinguishedName(baseDn);
		DistinguishedName full = new DistinguishedName(fullDn);

		if (base.equals(full)) {
			return """";
		}

		Assert.isTrue(full.startsWith(base), ""Full DN does not start with base DN"");

		full.removeFirst(base);

		return full.toString();
	}",Get the relative name of a DN.
"protected Content getPackage(PackageElement pkg, ModuleElement mdle) {
        Content packageLinkContent;
        Content pkgLabel;
        if (!pkg.isUnnamed()) {
            pkgLabel = getPackageLabel(utils.getPackageName(pkg));
            packageLinkContent = getHyperLink(pathString(pkg,
                     DocPaths.PACKAGE_FRAME), pkgLabel, """",
                    ""packageFrame"");
        } else {
            pkgLabel = new StringContent(""<unnamed package>"");
            packageLinkContent = getHyperLink(DocPaths.PACKAGE_FRAME,
                    pkgLabel, """", ""packageFrame"");
        }
        Content li = HtmlTree.LI(packageLinkContent);
        return li;
    }",Get Package link.
"public Transaction get( Transaction transaction ) {
    return RestfulUtils.show( TransactionService.PATH, transaction, Transaction.class, super.httpClient );
  }",Get a transaction
"public <P, D> Translator<P, D> getTranslator(final TypeKey<P> tk, final CreateContext ctx, final Path path) {
		return factory.getTranslators().get(tk, ctx, path);
	}",Gets translator.
"public static DockerCredentialHelperAuth get(final String credsStore, final String registry)
      throws IOException {
    return credentialHelperDelegate.get(credsStore, registry);
  }",Get a credential from the credsStore and registry.
"public Tile getAboveLeft() {
        int y = tileY - 1;
        int x = tileX - 1;
        if (y < 0) {
            y = getMaxTileNumber(this.zoomLevel);
        }
        if (x < 0) {
            x = getMaxTileNumber(this.zoomLevel);
        }
        return new Tile(x, y, this.zoomLevel, this.tileSize);
    }",Get the tile behind left.
"public INDArray compress(INDArray array, String algorithm) {
        algorithm = algorithm.toUpperCase();
        if (!codecs.containsKey(algorithm))
            throw new RuntimeException(""Non-existent compression algorithm requested: ["" + algorithm + ""]"");

        return codecs.get(algorithm).compress(array);
    }",Compress an ndarray using the specified algorithm
"void parse(QEntityFactory entityFactory, EntityType<?> metadata, SessionFactoryImplementor sessionFactory)
	{
		this.metamodelEntity = metadata;
		this.name = metadata.getName();

		for (Attribute<?, ?> attribute : metadata.getAttributes())
		{
			parseFields(entityFactory, sessionFactory, null, attribute);
		}

		// Parse top-level properties

		// Add identifier property
		{
			if (!metadata.hasSingleIdAttribute())
				throw new IllegalArgumentException(""@IdClass Entity not supported! "" + metadata.getJavaType());

			Type idType = metadata.getIdType();

			switch (idType.getPersistenceType())
			{
				case BASIC:
					break; // No action necessary, will be processed like a normal field
				case EMBEDDABLE:
				{
					EmbeddableType<?> emb = (EmbeddableType<?>) idType;

					parseEmbeddable(entityFactory, sessionFactory, ""id"", emb);
					break;
				}
				default:
					throw new IllegalArgumentException(""Cannot handle id type: "" + idType.getPersistenceType() + "": "" + idType);
			}
		}

		// Add links to descendants
		{
			final List<QEntity> descendants = entityFactory.getSubclasses(clazz);

			if (!descendants.isEmpty())
				this.descendants = descendants;
		}


		// Figure out the id method/field
		final String idPropertyName = getIdPropertyName();

		if (idPropertyName != null)
			this.idProperty = new PropertyWrapper(clazz, idPropertyName);
	}",Parses the entity.
"public static PageUpdateResult pageUpdate(String accessToken,
                                              PageUpdate pageUpdate) {
        return pageUpdate(accessToken, JsonUtil.toJSONString(pageUpdate));
    }",Perform a page update with the specified access token.
"public static <T> Collection<T> dropWhile(Iterable<T> self, @ClosureParams(FirstParam.FirstGenericType.class) Closure<?> condition) {
        Collection<T> selfCol = self instanceof Collection ? (Collection<T>) self : toList(self);
        Collection<T> result = createSimilarCollection(selfCol);
        addAll(result, dropWhile(self.iterator(), condition));
        return result;
    }",Drops elements from the iterable while condition returns true.
"public String deleteByPrimaryKey(MappedStatement ms) {
        final Class<?> entityClass = getEntityClass(ms);
        StringBuilder sql = new StringBuilder();
        if (SqlHelper.hasLogicDeleteColumn(entityClass)) {
            sql.append(SqlHelper.updateTable(entityClass, tableName(entityClass)));
            sql.append(""<set>"");
            sql.append(SqlHelper.logicDeleteColumnEqualsValue(entityClass, true));
            sql.append(""</set>"");
            MetaObjectUtil.forObject(ms).setValue(""sqlCommandType"", SqlCommandType.UPDATE);
        } else {
            sql.append(SqlHelper.deleteFromTable(entityClass, tableName(entityClass)));
        }
        sql.append(SqlHelper.wherePKColumns(entityClass));
        return sql.toString();
    }",Delete by primary key.
"public void marshall(InstanceFleetModifyConfig instanceFleetModifyConfig, ProtocolMarshaller protocolMarshaller) {

        if (instanceFleetModifyConfig == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(instanceFleetModifyConfig.getInstanceFleetId(), INSTANCEFLEETID_BINDING);
            protocolMarshaller.marshall(instanceFleetModifyConfig.getTargetOnDemandCapacity(), TARGETONDEMANDCAPACITY_BINDING);
            protocolMarshaller.marshall(instanceFleetModifyConfig.getTargetSpotCapacity(), TARGETSPOTCAPACITY_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given instanceFleetModifyConfig to the JSON object.
"public static MessageDigest createMessageDigest(String algorithm) {
		final Provider provider = GlobalBouncyCastleProvider.INSTANCE.getProvider();

		MessageDigest messageDigest;
		try {
			messageDigest = (null == provider) ? MessageDigest.getInstance(algorithm) : MessageDigest.getInstance(algorithm, provider);
		} catch (NoSuchAlgorithmException e) {
			throw new CryptoException(e);
		}

		return messageDigest;
	}",Creates a MessageDigest object based on the algorithm name.
"@Override
    protected final void unserialize(ByteBuffer bytes)
    {
        int indexDataLength = m_dataOffset_ + m_dataLength_;
        m_index_ = ICUBinary.getChars(bytes, indexDataLength, 0);
        m_data_           = m_index_;
        m_initialValue_   = m_data_[m_dataOffset_];
    }",Unserialize the data in the underlying data structure.
"public void marshall(InstancePatchStateFilter instancePatchStateFilter, ProtocolMarshaller protocolMarshaller) {

        if (instancePatchStateFilter == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(instancePatchStateFilter.getKey(), KEY_BINDING);
            protocolMarshaller.marshall(instancePatchStateFilter.getValues(), VALUES_BINDING);
            protocolMarshaller.marshall(instancePatchStateFilter.getType(), TYPE_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given instancePatchStateFilter to the JSON - compatible parameter object.
"public Matrix3x2d view(double left, double right, double bottom, double top, Matrix3x2d dest) {
        double rm00 = 2.0 / (right - left);
        double rm11 = 2.0 / (top - bottom);
        double rm20 = (left + right) / (left - right);
        double rm21 = (bottom + top) / (bottom - top);
        dest.m20 = m00 * rm20 + m10 * rm21 + m20;
        dest.m21 = m01 * rm20 + m11 * rm21 + m21;
        dest.m00 = m00 * rm00;
        dest.m01 = m01 * rm00;
        dest.m10 = m10 * rm11;
        dest.m11 = m11 * rm11;
        return dest;
    }",This method is used to compute the view of the matrix.
"protected long getItemId(final int index) {
        long id = -1;
        if (index < getDataCount() && index >= 0 && mAdapter != null) {
            id =  mAdapter.getItemId(index);
        }
        return id;
    }",Gets the item id.
"@Override
  public String getQueryBaseRoute() {
    final String[] split = explodePath();
    if (split.length < 1) {
      return """";
    }
    if (!split[0].toLowerCase().equals(""api"")) {
      return split[0].toLowerCase();
    }
    // set the default api_version so the API call is handled by a serializer if
    // an exception is thrown
    this.api_version = MAX_API_VERSION;
    if (split.length < 2) {
      return ""api"";
    }
    if (split[1].toLowerCase().startsWith(""v"") && split[1].length() > 1 &&
        Character.isDigit(split[1].charAt(1))) {
      try {
        final int version = Integer.parseInt(split[1].substring(1));
        if (version > MAX_API_VERSION) {
          throw new BadRequestException(HttpResponseStatus.NOT_IMPLEMENTED,
              ""Requested API version is greater than the max implemented"",
              ""API version ["" + version + ""] is greater than the max ["" +
              MAX_API_VERSION + ""]"");
        }
        this.api_version = version;
      } catch (NumberFormatException nfe) {
        throw new BadRequestException(HttpResponseStatus.BAD_REQUEST,
            ""Invalid API version format supplied"",
            ""API version ["" + split[1].substring(1) +
            ""] cannot be parsed to an integer"");
      }
    } else {
      return ""api/"" + split[1].toLowerCase();
    }
    if (split.length < 3){
      return ""api"";
    }
    return ""api/"" + split[2].toLowerCase();
  }",Get the query base route.
"public static boolean isWildcardType(final MediaType mediaType) {
		requireNonNull(mediaType,MEDIA_TYPE_CANNOT_BE_NULL);
		return WILDCARD_TYPE.equals(mediaType.type());
	}",Checks if the given media type is a wildcard type.
"private BlockingQueue<V> retrieveSharedQueue(String key) {
		BlockingQueue<V> queue = mediations.get(key);
		if (queue == null) {
			queue = new ArrayBlockingQueue<V>(1);
			BlockingQueue<V> commonQueue = mediations.putIfAbsent(key, queue);
			return commonQueue != null ? commonQueue : queue;
		} else {
			return queue;
		}
	}",Retrieve a shared queue.
"protected URI doPostCreateMultipart(String path, FormDataMultiPart formDataMultiPart) throws ClientException {
        this.readLock.lock();
        try {
            ClientResponse response = getResourceWrapper()
                    .rewritten(path, HttpMethod.POST)
                    .type(Boundary.addBoundary(MediaType.MULTIPART_FORM_DATA_TYPE))
                    .accept(MediaType.TEXT_PLAIN)
                    .post(ClientResponse.class, formDataMultiPart);
            errorIfStatusNotEqualTo(response, ClientResponse.Status.OK, ClientResponse.Status.CREATED);
            try {
                return response.getLocation();
            } finally {
                response.close();
            }
        } catch (ClientHandlerException ex) {
            throw new ClientException(ClientResponse.Status.INTERNAL_SERVER_ERROR, ex.getMessage());
        } finally {
            this.readLock.unlock();
        }
    }",This method is used to create a new multipart resource.
"public TupleCombinerBuilder include( Stream<String> varNamePatterns)
    {
    varNamePatterns.forEach( varNamePattern -> tupleCombiner_.addIncludedVar( varNamePattern));
    return this;
    }",Add all the variables in the given var name patterns to the combiner.
"public static void debug(Class<?> clazz, String message, String... values) {
        getLogger(clazz).debug(formatString(message, values));
    }",Log a debug message.
"private void complete(final InstallationManager.InstallationModification modification, final FinalizeCallback callback) {
        final List<File> processed = new ArrayList<File>();
        List<File> reenabled = Collections.emptyList();
        List<File> disabled = Collections.emptyList();
        try {
            try {
                // Update the state to invalidate and process module resources
                if (stateUpdater.compareAndSet(this, State.PREPARED, State.INVALIDATE)) {
                    if (mode == PatchingTaskContext.Mode.APPLY) {
                        // Only invalidate modules when applying patches; on rollback files are immediately restored
                        for (final File invalidation : moduleInvalidations) {
                            processed.add(invalidation);
                            PatchModuleInvalidationUtils.processFile(this, invalidation, mode);
                        }
                        if (!modulesToReenable.isEmpty()) {
                            reenabled = new ArrayList<File>(modulesToReenable.size());
                            for (final File path : modulesToReenable) {
                                reenabled.add(path);
                                PatchModuleInvalidationUtils.processFile(this, path, PatchingTaskContext.Mode.ROLLBACK);
                            }
                        }
                    } else if(mode == PatchingTaskContext.Mode.ROLLBACK) {
                        if (!modulesToDisable.isEmpty()) {
                            disabled = new ArrayList<File>(modulesToDisable.size());
                            for (final File path : modulesToDisable) {
                                disabled.add(path);
                                PatchModuleInvalidationUtils.processFile(this, path, PatchingTaskContext.Mode.APPLY);
                            }
                        }
                    }

                }
                modification.complete();
                callback.completed(this);
                state = State.COMPLETED;
            } catch (Exception e) {
                this.moduleInvalidations.clear();
                this.moduleInvalidations.addAll(processed);
                this.modulesToReenable.clear();
                this.modulesToReenable.addAll(reenabled);
                this.modulesToDisable.clear();
                this.moduleInvalidations.addAll(disabled);
                throw new RuntimeException(e);
            }
        } finally {
            if (state != State.COMPLETED) {
                try {
                    modification.cancel();
                } finally {
                    try {
                        undoChanges();
                    } finally {
                        callback.operationCancelled(this);
                    }
                }
            } else  {
                try {
                    if (checkForGarbageOnRestart) {
                        final File cleanupMarker = new File(installedImage.getInstallationMetadata(), ""cleanup-patching-dirs"");
                        cleanupMarker.createNewFile();
                    }
                    storeFailedRenaming();
                } catch (IOException e) {
                    PatchLogger.ROOT_LOGGER.debugf(e, ""failed to create cleanup marker"");
                }
            }
        }
    }",Complete the installation.
"public int decide(final LoggingEvent event) {
    boolean matchOccured = loggerToMatch.equals(event.getLoggerName());
    if (matchOccured) {
      if (this.acceptOnMatch) {
        return Filter.ACCEPT;
      } else {
        return Filter.DENY;
      }
    } else {
      return Filter.NEUTRAL;
    }
  }",Determine if the event is a match of this filter.
"public ClientConfig getClientConfig() {

    ClientConfig rescuConfig = new ClientConfig(); // create default rescu config

    // set per exchange connection- and read-timeout (if they have been set in the
    // ExchangeSpecification)
    int customHttpConnTimeout = exchange.getExchangeSpecification().getHttpConnTimeout();
    if (customHttpConnTimeout > 0) {
      rescuConfig.setHttpConnTimeout(customHttpConnTimeout);
    }
    int customHttpReadTimeout = exchange.getExchangeSpecification().getHttpReadTimeout();
    if (customHttpReadTimeout > 0) {
      rescuConfig.setHttpReadTimeout(customHttpReadTimeout);
    }
    if (exchange.getExchangeSpecification().getProxyHost() != null) {
      rescuConfig.setProxyHost(exchange.getExchangeSpecification().getProxyHost());
    }
    if (exchange.getExchangeSpecification().getProxyPort() != null) {
      rescuConfig.setProxyPort(exchange.getExchangeSpecification().getProxyPort());
    }
    return rescuConfig;
  }",Get the client config
"public JSONArray element( Collection value, JsonConfig jsonConfig ) {
      if( value instanceof JSONArray ){
         elements.add( value );
         return this;
      }else{
         return element( _fromCollection( value, jsonConfig ) );
      }
   }",Add a collection of JSONArray to this JSONArray.
"public static void notEmpty(Object[] arr, String name) {
    notNull(arr, name);

    if (arr.length == 0) {
      throw new IllegalArgumentException(name + ""must not be empty"");
    }
  }",Check that the array is not empty
"public void load(final Runnable afterLoad) {

        CmsRpcAction<CmsAliasInitialFetchResult> action = new CmsRpcAction<CmsAliasInitialFetchResult>() {

            /**
             * @see org.opencms.gwt.client.rpc.CmsRpcAction#execute()
             */
            @Override
            public void execute() {

                getService().getAliasTable(this);
                start(0, true);
            }

            /**
             * @see org.opencms.gwt.client.rpc.CmsRpcAction#onResponse(java.lang.Object)
             */
            @Override
            public void onResponse(CmsAliasInitialFetchResult aliasTable) {

                stop(false);

                String lockOwner = aliasTable.getAliasTableLockOwner();
                if (lockOwner != null) {

                    String errorMessage = CmsAliasMessages.messageAliasTableLocked(lockOwner);
                    String title = CmsAliasMessages.messageAliasTableLockedTitle();
                    CmsAlertDialog alert = new CmsAlertDialog(title, errorMessage);
                    alert.center();
                } else {

                    m_downloadUrl = aliasTable.getDownloadUrl();
                    m_initialData = aliasTable.getRows();
                    m_siteRoot = CmsCoreProvider.get().getSiteRoot();
                    List<CmsAliasTableRow> copiedData = copyData(m_initialData);
                    List<CmsRewriteAliasTableRow> rewriteData = aliasTable.getRewriteAliases();
                    m_view.setData(copiedData, rewriteData);
                    if (afterLoad != null) {
                        afterLoad.run();
                    }
                }
            }
        };
        action.execute();
    }",Loads the alias table.
"@Invalidate
    public void stop() throws InterruptedException {
        unregisterQuietly(vertxRegistration);
        unregisterQuietly(busRegistration);
        CountDownLatch latch = new CountDownLatch(1);
        vertx.close(v -> latch.countDown());
        latch.await();
        vertx = null;
    }",Stop the service.
"public static sdxtools_image[] get_filtered(nitro_service service, filtervalue[] filter) throws Exception
	{
		sdxtools_image obj = new sdxtools_image();
		options option = new options();
		option.set_filter(filter);
		sdxtools_image[] response = (sdxtools_image[]) obj.getfiltered(service, option);
		return response;
	}",Use this API to fetch filtered set of sdxtools_image resources. set the filter parameter values in filtervalue object.
"@SuppressWarnings(""unchecked"")
   public static <T> T enhance(Class<T> type, ForgeProxy handler)
   {
      Assert.notNull(type, ""Class type to proxy must not be null"");
      Assert.notNull(handler, ""ForgeProxy handler must not be null"");

      Object result = null;

      Class<?> proxyType = getCachedProxyType(type.getClassLoader(), type);
      if (proxyType == null)
      {
         Class<?>[] hierarchy = null;
         Class<?> superclass = null;

         if (type.isInterface() && !ForgeProxy.class.isAssignableFrom(type))
            hierarchy = new Class<?>[] { type, ForgeProxy.class };
         else if (type.isInterface())
            hierarchy = new Class<?>[] { type };
         else
         {
            if (Proxies.isProxyType(type))
               superclass = unwrapProxyTypes(type);
            else
            {
               superclass = type;
               hierarchy = new Class<?>[] { ForgeProxy.class };
            }
         }

         ProxyFactory f = new ProxyFactory();

         f.setFilter(filter);
         f.setInterfaces(hierarchy);
         f.setSuperclass(superclass);

         proxyType = f.createClass();
         setCachedProxyType(type.getClassLoader(), type, proxyType);
      }

      try
      {
         result = proxyType.newInstance();
      }
      catch (InstantiationException e)
      {
         throw new IllegalStateException(
                  ""Could not instantiate proxy for type ["" + type
                           + ""]. For optimal proxy compatibility, ensure "" +
                           ""that this type is an interface, or a class with a default constructor."",
                  e);
      }
      catch (IllegalAccessException e)
      {
         throw new IllegalStateException(e);
      }

      if (result instanceof Proxy)
         ((Proxy) result).setHandler(handler);
      else if (result instanceof ProxyObject)
         ((ProxyObject) result).setHandler(handler);
      else
         throw new IllegalStateException(""Could not set proxy handler ["" + handler + ""] for proxy object [""
                  + result + ""] for proxy of type ["" + type + ""]"");

      return (T) result;
   }",Enhances a class type with a ForgeProxy handler.
"public String getError() {
    StringBuilder strBuilder = new StringBuilder();
    for (int i = 0; i < errors.size(); i++) {
      strBuilder.append(getError(i) + "" "");
    }
    return strBuilder.toString();
  }",Get the error string.
"public static Map<String, String[]> mapUrlEncodedParameters(byte[] dataArray) throws Exception {
        Map<String, String[]> mapPostParameters = new HashMap<String, String[]>();

        try {
            ByteArrayOutputStream byteout = new ByteArrayOutputStream();
            for (int x = 0; x < dataArray.length; x++) {
                // split the data up by & to get the parts
                if (dataArray[x] == '&' || x == (dataArray.length - 1)) {
                    if (x == (dataArray.length - 1)) {
                        byteout.write(dataArray[x]);
                    }
                    // find '=' and split the data up into key value pairs
                    int equalsPos = -1;
                    ByteArrayOutputStream key = new ByteArrayOutputStream();
                    ByteArrayOutputStream value = new ByteArrayOutputStream();
                    byte[] byteArray = byteout.toByteArray();
                    for (int xx = 0; xx < byteArray.length; xx++) {
                        if (byteArray[xx] == '=') {
                            equalsPos = xx;
                        } else {
                            if (equalsPos == -1) {
                                key.write(byteArray[xx]);
                            } else {
                                value.write(byteArray[xx]);
                            }
                        }
                    }

                    ArrayList<String> values = new ArrayList<String>();

                    if (mapPostParameters.containsKey(key.toString())) {
                        values = new ArrayList<String>(Arrays.asList(mapPostParameters.get(key.toString())));
                        mapPostParameters.remove(key.toString());
                    }

                    values.add(value.toString());
                    /**
                     * If equalsPos is not -1, then there was a '=' for the key
                     * If value.size is 0, then there is no value so want to add in the '='
                     * Since it will not be added later like params with keys and valued
                     */
                    if (equalsPos != -1 && value.size() == 0) {
                        key.write((byte) '=');
                    }

                    mapPostParameters.put(key.toString(), values.toArray(new String[values.size()]));

                    byteout = new ByteArrayOutputStream();
                } else {
                    byteout.write(dataArray[x]);
                }
            }
        } catch (Exception e) {
            throw new Exception(""Could not parse request data: "" + e.getMessage());
        }

        return mapPostParameters;
    }",mapUrlEncodedParameters This method converts a byte array to a Map of String values.
"public static void insert (final CharSequence aSeq, final int nIndex, @Nonnull final Codepoint aCodepoint)
  {
    insert (aSeq, nIndex, aCodepoint.getValue ());
  }",Insert a code point into the sequence at the specified index.
"@Override
  public T next() {
    final Object value = iterator.next();
    final T entity = mapper.fromReadValue(value);
    return entity;
  }",Returns the next entity in the iterator.
"public void write(byte[] wBuf, int wOffset, int numToWrite) throws IOException {
        if ((this.currBytes + numToWrite) > this.currSize) {
            throw new IOException(""request to write '"" + numToWrite
                                  + ""' bytes exceeds size in header of '""
                                  + this.currSize + ""' bytes for entry '""
                                  + currName + ""'"");

            //
            // We have to deal with assembly!!!
            // The programmer can be writing little 32 byte chunks for all
            // we know, and we must assemble complete records for writing.
            // REVIEW Maybe this should be in TarBuffer? Could that help to
            // eliminate some of the buffer copying.
            //
        }

        if (this.assemLen > 0) {
            if ((this.assemLen + numToWrite) >= this.recordBuf.length) {
                int aLen = this.recordBuf.length - this.assemLen;

                System.arraycopy(this.assemBuf, 0, this.recordBuf, 0,
                                 this.assemLen);
                System.arraycopy(wBuf, wOffset, this.recordBuf,
                                 this.assemLen, aLen);
                this.buffer.writeRecord(this.recordBuf);

                this.currBytes += this.recordBuf.length;
                wOffset += aLen;
                numToWrite -= aLen;
                this.assemLen = 0;
            } else {
                System.arraycopy(wBuf, wOffset, this.assemBuf, this.assemLen,
                                 numToWrite);

                wOffset += numToWrite;
                this.assemLen += numToWrite;
                numToWrite = 0;
            }
        }

        //
        // When we get here we have EITHER:
        // o An empty ""assemble"" buffer.
        // o No bytes to write (numToWrite == 0)
        //
        while (numToWrite > 0) {
            if (numToWrite < this.recordBuf.length) {
                System.arraycopy(wBuf, wOffset, this.assemBuf, this.assemLen,
                                 numToWrite);

                this.assemLen += numToWrite;

                break;
            }

            this.buffer.writeRecord(wBuf, wOffset);

            int num = this.recordBuf.length;

            this.currBytes += num;
            numToWrite -= num;
            wOffset += num;
        }
    }",Write a single entry to the output stream.
"public Future<int[]> batch(final InputHandler[] inputHandlers) throws SQLException {
        return executorService.submit(new Callable<int[]>() {

            /**
             * {@inheritDoc}
             */
            public int[] call() throws Exception {
                return queryRunner.batch(inputHandlers);
            }

        });
    }",Batch the result set of a CRUD operation.
"@NotNull public static <T> Observable<Response<T>> from(@NotNull final ApolloQueryWatcher<T> watcher,
      @NotNull Emitter.BackpressureMode backpressureMode) {
    checkNotNull(backpressureMode, ""backpressureMode == null"");
    checkNotNull(watcher, ""watcher == null"");
    return Observable.create(new Action1<Emitter<Response<T>>>() {
      @Override public void call(final Emitter<Response<T>> emitter) {
        final AtomicBoolean canceled = new AtomicBoolean();
        emitter.setCancellation(new Cancellable() {
          @Override public void cancel() throws Exception {
            canceled.set(true);
            watcher.cancel();
          }
        });
        watcher.enqueueAndWatch(new ApolloCall.Callback<T>() {
          @Override public void onResponse(@NotNull Response<T> response) {
            if (!canceled.get()) {
              emitter.onNext(response);
            }
          }

          @Override public void onFailure(@NotNull ApolloException e) {
            Exceptions.throwIfFatal(e);
            if (!canceled.get()) {
              emitter.onError(e);
            }
          }
        });
      }
    }, backpressureMode);
  }",Creates an observable from an ApolloQueryWatcher.
"public void shutDown() {
    logger.info(""Shutting down RPC server."");
    channel.close().addListener(new GenericFutureListener<Future<Void>>() {

      @Override
      public void operationComplete(Future<Void> future) throws Exception {
        parentGroup.shutdownGracefully();
        childGroup.shutdownGracefully();
      }
    }).awaitUninterruptibly();
  }",Shuts down the server.
"@Override
    public Object invoke(Object[] vals) throws InvocationTargetException {
        try {
            return constr.newInstance(vals);
        } catch (InvocationTargetException | IllegalArgumentException e) {
            throw e;
        } catch (IllegalAccessException e) {
            // runtime exception, isValid should prevent this case
            throw new RuntimeException(""can't access constructor"");
        } catch (InstantiationException e) {
            // runtime excpetion, because the constructor of constructor
            // has to prevent this situation.
            throw new RuntimeException(""can't instantiate"");
        }
    }",Override the default implementation to create a new instance of the class.
"private boolean parseRequest()
    throws IOException
  {
    try {
      ReadStream is = connTcp().readStream();
      
      if (! readRequest(is)) {
        clearRequest();

        return false;
      }
      
      _sequence = connHttp().nextSequenceRead();

      if (log.isLoggable(Level.FINE)) {
        log.fine(_method + "" ""
                 + new String(_uri, 0, _uriLength) + "" "" + _protocol
                 + "" ("" + dbgId() + "")"");
        log.fine(""Remote-IP: "" + connTcp().addressRemote()
                 + "":"" + connTcp().portRemote() + "" ("" + dbgId() + "")"");
      }

      parseHeaders(is);

      return true;
    } catch (ClientDisconnectException e) {
      throw e;
    } catch (SocketTimeoutException e) {
      log.log(Level.FINER, e.toString(), e);
      
      return false;
    } catch (ArrayIndexOutOfBoundsException e) {
      log.log(Level.FINEST, e.toString(), e);
      
      throw new BadRequestException(L.l(""Invalid request: URL or headers are too long""), e);
    } catch (Throwable e) {
      log.log(Level.FINEST, e.toString(), e);
      
      throw new BadRequestException(String.valueOf(e), e);
    }
  }",Parses a single request.
"public void marshall(HierarchyStructure hierarchyStructure, ProtocolMarshaller protocolMarshaller) {

        if (hierarchyStructure == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(hierarchyStructure.getLevelOne(), LEVELONE_BINDING);
            protocolMarshaller.marshall(hierarchyStructure.getLevelTwo(), LEVELTWO_BINDING);
            protocolMarshaller.marshall(hierarchyStructure.getLevelThree(), LEVELTHREE_BINDING);
            protocolMarshaller.marshall(hierarchyStructure.getLevelFour(), LEVELFOUR_BINDING);
            protocolMarshaller.marshall(hierarchyStructure.getLevelFive(), LEVELFIVE_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given hierarchyStructure to the given protocolMarshaller.
"public static SsdpResponse parse(DatagramPacket packet) {

    Map<String, String> headers = new HashMap<String, String>();
    byte[] body = null;
    SsdpResponse.Type type = null;

    byte[] data = packet.getData();
    // Find position of the last header data
    int endOfHeaders = findEndOfHeaders(data);
    if (endOfHeaders == -1) {
      endOfHeaders = packet.getLength();
    }
    // Retrieve all header lines
    String[] headerLines = new String(Arrays.copyOfRange(data, 0, endOfHeaders)).split(""\r\n"");

    // Determine type of message
    if (SEARCH_REQUEST_LINE_PATTERN.matcher(headerLines[0]).matches()) {
      type = SsdpResponse.Type.DISCOVERY_RESPONSE;
    } else if (SERVICE_ANNOUNCEMENT_LINE_PATTERN.matcher(headerLines[0]).matches()) {
      type = SsdpResponse.Type.PRESENCE_ANNOUNCEMENT;
    }

    // If type was not found, this is not a valid SSDP message. get out of here
    if (type == null) {
      return null;
    }

    // Let's parse our headers.
    for (int i = 1; i < headerLines.length; i++) {
      String line = headerLines[i];
      Matcher matcher = HEADER_PATTERN.matcher(line);
      if (matcher.matches()) {
        headers.put(matcher.group(1).toUpperCase().trim(), matcher.group(2).trim());
      }
    }
    // Determine expiry depending on the presence of cache-control or expires headers.
    long expiry = parseCacheHeader(headers);

    // Let's see if we have a body. If we do, let's copy the byte array and put it into the response for the user to get.
    int endOfBody = packet.getLength();
    if (endOfBody > endOfHeaders + 4) {
      body = Arrays.copyOfRange(data, endOfHeaders + 4, endOfBody);
    }

    return new SsdpResponse(type, headers, body, expiry, packet.getAddress());
  }",Parses a SSDP response from a datagram packet.
"@PublicEvolving
	public static <T> DynamicProcessingTimeSessionWindows<T> withDynamicGap(SessionWindowTimeGapExtractor<T> sessionWindowTimeGapExtractor) {
		return new DynamicProcessingTimeSessionWindows<>(sessionWindowTimeGapExtractor);
	}",Creates a new dynamic processing time session windows.
"@GET
    @Produces(MediaType.TEXT_PLAIN)
    @Description(""Does not do anything. Is only supported for backwards compatibility."")
    @Path(""/logout"")
    public Response logout(@Context HttpServletRequest req) {
        return Response.ok(""You have logged out."").build();
    }",Logout the user.
"public Vector2f positiveX(Vector2f dir) {
        float s = m00 * m11 - m01 * m10;
        s = 1.0f / s;
        dir.x =  m11 * s;
        dir.y = -m01 * s;
        return dir.normalize(dir);
    }",Compute the positive X direction of the vector.
"public void setSendCollectionType(boolean isSendType) {
        if (_collectionSerializer == null)
            _collectionSerializer = new CollectionSerializer();

        _collectionSerializer.setSendJavaType(isSendType);

        if (_mapSerializer == null)
            _mapSerializer = new MapSerializer();

        _mapSerializer.setSendJavaType(isSendType);
    }",Sets the sendCollectionType property.
"@SuppressWarnings(""unchecked"")
    public static <K, V> List<Tuple<K, V>> pick(final Map<K, V> object, final K ... keys) {
        return without(map(newArrayList(object.entrySet()), new Function<Map.Entry<K, V>, Tuple<K, V>>() {
            @Override
            public Tuple<K, V> apply(Map.Entry<K, V> entry) {
                if (Arrays.asList(keys).contains(entry.getKey())) {
                    return Tuple.create(entry.getKey(), entry.getValue());
                } else {
                    return null;
                }
            }
        }), (Tuple<K, V>) null);
    }",Picks the elements of the given map from the given keys.
"static Codec<NamingMessage> createFullCodec(final IdentifierFactory factory) {
    final Map<Class<? extends NamingMessage>, Codec<? extends NamingMessage>> clazzToCodecMap
        = new HashMap<>();
    clazzToCodecMap.put(NamingLookupRequest.class, new NamingLookupRequestCodec(factory));
    clazzToCodecMap.put(NamingLookupResponse.class, new NamingLookupResponseCodec(factory));
    clazzToCodecMap.put(NamingRegisterRequest.class, new NamingRegisterRequestCodec(factory));
    clazzToCodecMap.put(NamingRegisterResponse.class,
        new NamingRegisterResponseCodec(new NamingRegisterRequestCodec(factory)));
    clazzToCodecMap.put(NamingUnregisterRequest.class, new NamingUnregisterRequestCodec(factory));
    final Codec<NamingMessage> codec = new MultiCodec<>(clazzToCodecMap);
    return codec;
  }",Create a full codec.
"public void addInterceptor(Interceptor interceptor) {
    if (interceptor == null) {
      throw new NullPointerException(""interceptor can't be null"");
    }
    if (interceptorChain == null) {
      interceptorChain = new InterceptorChain();
    }
    interceptorChain.addInterceptor(interceptor);
  }",Add an interceptor to the interceptor chain.
"public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case METRIC_ID:
      return is_set_metricId();
    case TS:
      return is_set_ts();
    case METRIC_TYPE:
      return is_set_metricType();
    case LONG_VALUE:
      return is_set_longValue();
    case DOUBLE_VALUE:
      return is_set_doubleValue();
    case M1:
      return is_set_m1();
    case M5:
      return is_set_m5();
    case M15:
      return is_set_m15();
    case MEAN:
      return is_set_mean();
    case MIN:
      return is_set_min();
    case MAX:
      return is_set_max();
    case P50:
      return is_set_p50();
    case P75:
      return is_set_p75();
    case P95:
      return is_set_p95();
    case P98:
      return is_set_p98();
    case P99:
      return is_set_p99();
    case P999:
      return is_set_p999();
    case STDDEV:
      return is_set_stddev();
    case POINTS:
      return is_set_points();
    case POINT_SIZE:
      return is_set_pointSize();
    }
    throw new IllegalStateException();
  }",Checks if the specified field is set.
"Pipeline createPipeline(Language lang, Language motherTongue, TextChecker.QueryParams params, UserConfig userConfig)
    throws Exception { // package-private for mocking
    Pipeline lt = new Pipeline(lang, params.altLanguages, motherTongue, cache, userConfig);
    lt.setMaxErrorsPerWordRate(config.getMaxErrorsPerWordRate());
    if (config.getLanguageModelDir() != null) {
      lt.activateLanguageModelRules(config.getLanguageModelDir());
    }
    if (config.getWord2VecModelDir () != null) {
      lt.activateWord2VecModelRules(config.getWord2VecModelDir());
    }
    if (config.getRulesConfigFile() != null) {
      configureFromRulesFile(lt, lang);
    } else {
      configureFromGUI(lt, lang);
    }
    if (params.useQuerySettings) {
      Tools.selectRules(lt, new HashSet<>(params.disabledCategories), new HashSet<>(params.enabledCategories),
        new HashSet<>(params.disabledRules), new HashSet<>(params.enabledRules), params.useEnabledOnly);
    }
    if (pool != null) {
      lt.setupFinished();
    }
    return lt;
  }",Create a pipeline from the input parameters
"public void addAttribute(String attribute)
    {
        if(this.attributes == null)
            this.attributes = new ArrayList<String>();
        this.attributes.add(attribute);
    }",Add an attribute to the attribute list.
"@Override
  public int cipherBits()
  {
    if (! (_s instanceof SSLSocket))
      return super.cipherBits();
    
    SSLSocket sslSocket = (SSLSocket) _s;
    
    SSLSession sslSession = sslSocket.getSession();
    
    if (sslSession != null)
      return _sslKeySizes.get(sslSession.getCipherSuite());
    else
      return 0;
  }",Returns the cipher bits of this socket.
"@Deprecated
    public void setTicketKeys(byte[] keys) {
        if (keys.length % SessionTicketKey.TICKET_KEY_SIZE != 0) {
            throw new IllegalArgumentException(""keys.length % "" + SessionTicketKey.TICKET_KEY_SIZE  + "" != 0"");
        }
        SessionTicketKey[] tickets = new SessionTicketKey[keys.length / SessionTicketKey.TICKET_KEY_SIZE];
        for (int i = 0, a = 0; i < tickets.length; i++) {
            byte[] name = Arrays.copyOfRange(keys, a, SessionTicketKey.NAME_SIZE);
            a += SessionTicketKey.NAME_SIZE;
            byte[] hmacKey = Arrays.copyOfRange(keys, a, SessionTicketKey.HMAC_KEY_SIZE);
            i += SessionTicketKey.HMAC_KEY_SIZE;
            byte[] aesKey = Arrays.copyOfRange(keys, a, SessionTicketKey.AES_KEY_SIZE);
            a += SessionTicketKey.AES_KEY_SIZE;
            tickets[i] = new SessionTicketKey(name, hmacKey, aesKey);
        }
        Lock writerLock = context.ctxLock.writeLock();
        writerLock.lock();
        try {
            SSLContext.clearOptions(context.ctx, SSL.SSL_OP_NO_TICKET);
            SSLContext.setSessionTicketKeys(context.ctx, tickets);
        } finally {
            writerLock.unlock();
        }
    }",Set the ticket keys.
"@Override
    public void write(byte[] b) throws IOException {
        if (b.length == 0)
            return;
        fos().write(b);
        currFileBytesWritten += b.length;
        totalBytesWritten += b.length;
    }",Write a byte array to the underlying file.
"public synchronized void resumeControlPoint(final String entryPoint) {
        for (ControlPoint ep : entryPoints.values()) {
            if (ep.getEntryPoint().equals(entryPoint)) {
                ep.resume();
            }
        }
    }",Resume a control point.
"public static WaybackRequest createCaptureQueryRequet(String url, String replay, String start, String end) {
		WaybackRequest r = new WaybackRequest();
		r.setCaptureQueryRequest();
		r.setRequestUrl(url);
		r.setReplayTimestamp(replay);
		r.setStartTimestamp(start);
		r.setEndTimestamp(end);
		return r;
	}",Creates a WaybackRequest with the specified parameters.
"private static void registerH2GISFunctions(Connection connection, String packagePrepend) throws SQLException {
        Statement st = connection.createStatement();
        for (Function function : getBuiltInsFunctions()) {
            try {
                registerFunction(st, function, packagePrepend);
            } catch (SQLException ex) {
                // Catch to register other functions
                ex.printStackTrace(System.err);
            }
        }
    }",Register H2GIS functions.
"static String getMethodSpecificName(Method m) {

        return m == null ? null
                         : m.getDeclaringClass().getName() + '.'
                           + getSignature(m);
    }",Get the name of the method that is specific to a class.
"public static void logError(BundleContext pBundleContext, String pMessage, Throwable pThrowable) {

        final ServiceReference lRef = pBundleContext.getServiceReference(LogService.class.getName());
        if (lRef != null) {
            try {
                final LogService logService = (LogService) pBundleContext.getService(lRef);
                if (logService != null) {
                    logService.log(LogService.LOG_ERROR, pMessage, pThrowable);
                    return;
                }
            } finally {
                pBundleContext.ungetService(lRef);
            }
        }
        System.err.println(""Jolokia-Error: "" + pMessage + "" : "" + pThrowable.getMessage());
    }",Log an error message and exception.
"public List<CmsJspNavElement> getNavigationForFolder(String folder) {

        return getNavigationForFolder(folder, Visibility.navigation, CmsResourceFilter.DEFAULT);
    }",Returns the navigation elements for the given folder.
"public static boolean isUnderDirectory(File child, File parent) {
        if (child == null || parent == null)
            return false;

        URI childUri = child.toURI();
        URI relativeUri = parent.toURI().relativize(childUri);
        return relativeUri.equals(childUri) ? false : true;

    }",Checks if the child file is under the parent file.
"public static int geoContextToFlickrContextId(JinxConstants.GeoContext geoContext) {
        if (geoContext == null) {
            return -1;
        }
        int ret;
        switch (geoContext) {
            case not_defined:
                ret = 0;
                break;
            case indoors:
                ret = 1;
                break;
            case outdoors:
                ret = 2;
                break;
            default:
                ret = -1;
                break;
        }
        return ret;
    }",Convert a JinxConstants. GeoContext object to a Flickr context ID.
"public synchronized void stopLocalForwarding(String bindAddress,
			int bindPort, boolean killActiveTunnels) throws SshException {
		String key = generateKey(bindAddress, bindPort);
		stopLocalForwarding(key, killActiveTunnels);
	}",Stop listening to the local host.
"public void flush() throws IOException {
        if (exception != null)
            throw exception;

        if (finished)
            throw new XZIOException(""Stream finished or closed"");

        try {
            if (blockEncoder != null) {
                if (filtersSupportFlushing) {
                    // This will eventually call out.flush() so
                    // no need to do it here again.
                    blockEncoder.flush();
                } else {
                    endBlock();
                    out.flush();
                }
            } else {
                out.flush();
            }
        } catch (IOException e) {
            exception = e;
            throw e;
        }
    }",Flush the underlying stream.
"public static boolean inside(Point point, Polygon polygon) {
    // This API needs to get better
    List<List<Point>> coordinates = polygon.coordinates();
    List<List<List<Point>>> multiCoordinates = new ArrayList<>();
    multiCoordinates.add(coordinates);
    return inside(point, MultiPolygon.fromLngLats(multiCoordinates));
  }",Checks if the point is inside the polygon
"public static CharTrie indexWords(Collection<String> documents, int maxLevels, int minWeight) {
    return create(documents, maxLevels, minWeight, true);
  }",Index words.
"public static JMenu leftShift(JMenu self, Action action) {
        self.add(action);
        return self;
    }",Overloads the left shift operator to provide an easy way to add an action to a menu.
"public static void rcvResetBrowse(CommsByteBuffer request, Conversation conversation,
                                     int requestNumber, boolean allocatedFromBufferPool,
                                     boolean partOfExchange)
   {
      if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(tc, ""rcvResetBrowse"",
                                           new Object[]
                                           {
                                              request,
                                              conversation,
                                              """"+requestNumber,
                                              """"+allocatedFromBufferPool
                                            });

      // Strip information from reset request.
      short connectionObjectId = request.getShort();                 // Connection Id
      short browserSessionId = request.getShort();                   // Id of browser session.

      if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(tc, ""rcvResetBrowse> connectionObjectId = ""+connectionObjectId+
                                               ""\nrcvResetBrowse> browserSessionId   = ""+browserSessionId);

      BrowserSession browserSession = null;
      ConversationState convState = null;

      try
      {
         // Locate browser session from conversation state.
         convState = (ConversationState)conversation.getAttachment();
         CATMainConsumer mainConsumer = (CATMainConsumer)convState.getObject(browserSessionId);
         browserSession = mainConsumer.getBrowserSession();

         if (browserSession == null)
         {
            // The browser session from the main consumer should not be null here
            SIErrorException e = new SIErrorException(
               nls.getFormattedMessage(""BROWSER_SESSION_NULL_SICO20"", null, null)
            );

            FFDCFilter.processException(e, CLASS_NAME + "".rcvResetBrowse"",
                                        CommsConstants.STATICCATBROWSER_RCVRESETBROWSERSESS_04);

            throw e;
         }
      }
      catch(NullPointerException npe)
      {
         FFDCFilter.processException(npe, CLASS_NAME + "".rcvResetBrowse"",
                                     CommsConstants.STATICCATBROWSER_RCVRESETBROWSERSESS_01);

         if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(tc, ""Browser session was null!"", npe);

         // This is an internal error, so inform the client
         StaticCATHelper.sendExceptionToClient(npe,
                                               CommsConstants.STATICCATBROWSER_RCVRESETBROWSERSESS_01,   // d186970
                                               conversation, requestNumber);
      }

      if (browserSession != null)
      {
         try
         {
            browserSession.reset();
         }
         catch (SIException e)
         {
            //No FFDC code needed
            //Only FFDC if we haven't received a meTerminated event.
            if(!convState.hasMETerminated())
            {
               FFDCFilter.processException(e, CLASS_NAME + "".rcvResetBrowse"",
                                           CommsConstants.STATICCATBROWSER_RCVRESETBROWSERSESS_02);
            }

            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) SibTr.debug(tc, e.getMessage(), e);

            // Send error to client.
            StaticCATHelper.sendExceptionToClient(e,
                                                  CommsConstants.STATICCATBROWSER_RCVRESETBROWSERSESS_02,   // d186970
                                                  conversation, requestNumber);
         }
      }

      // Send response.
      CommsByteBuffer reply = poolManager.allocate();
      try
      {
         conversation.send(reply,
                           JFapChannelConstants.SEG_RESET_BROWSE_R,
                           requestNumber,
                           JFapChannelConstants.PRIORITY_MEDIUM,
                           true,
                           ThrottlingPolicy.BLOCK_THREAD,
                           null);
      }
      catch (SIException e)
      {
         FFDCFilter.processException(e, CLASS_NAME + "".rcvResetBrowse"",
                                     CommsConstants.STATICCATBROWSER_RCVRESETBROWSERSESS_03);

         SibTr.error(tc, ""COMMUNICATION_ERROR_SICO2020"", e);

         // Can't really do much as a communications exception implies that
         // we have lost contact with the client anyway.
      }

      request.release(allocatedFromBufferPool);

      if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(tc, ""rcvResetBrowse"");
   }",This method is called by the client to reset the browse page.
"private void recurse(Stream bounds, String arg) {
    // Refuse if we've reached our recursion limit.
    streamIndex++;
    if (streamIndex == streams.length) {
      return;
    }

    // Trim the '{' and '}' bounding characters.
    bounds.pos++;
    bounds.end--;

    // Set the bounds of the tag, allocating a new stream on the stack if necessary.
    if (streams[streamIndex] == null) {
      streams[streamIndex] = bounds.copy();
    } else {
      streams[streamIndex].setFrom(bounds);
    }

    // Execute the formatter recursively on the current bounds, then
    // pop the stack.
    format(streams[streamIndex], arg);
    streamIndex--;
  }",Recursive method to perform the formatting on the bounds of the tag.
"public void storeBundle(String bundleName, StringBuffer bundledResources) {

		JoinableResourceBundleContent bundleResourcesContent = new JoinableResourceBundleContent(bundledResources);
		storeBundle(bundleName, bundleResourcesContent);
	}",Store a bundle in the cache.
"public ResponseBuilder getTimeGateBuilder(final SortedSet<Instant> mementos, final TrellisRequest req,
            final String baseUrl) {
        final String identifier = fromUri(baseUrl).path(req.getPath()).build().toString();
        return status(FOUND)
            .location(fromUri(identifier + ""?version="" + req.getDatetime().getInstant().getEpochSecond()).build())
            .link(identifier, ORIGINAL + "" "" + TIMEGATE)
            .links(getMementoLinks(identifier, mementos).map(this::filterLinkParams).toArray(Link[]::new))
            .header(VARY, ACCEPT_DATETIME);
    }",Gets a response builder for a TIMEGATE response.
"@Override
    public void initialize() throws Exception {
        log.debug(""Initialize the observer."");

        configFileEntry = new FileEntry(configFile);
        configFileEntry.refresh(configFile);

        prepareSassAndCssPaths();
        sassWatchable = new WatchableDirectory(sassPath, new SassFileFilter());
        sassWatchable.initialize();
    }",Initialize the observer.
"public EventServiceSegment getSegment(String service, boolean forceCreate) {
        EventServiceSegment segment = segments.get(service);
        if (segment == null && forceCreate) {
            // we can't make use of the ConcurrentUtil; we need to register the segment to the metricsRegistry in case of creation
            EventServiceSegment newSegment = new EventServiceSegment(service, nodeEngine.getService(service));
            EventServiceSegment existingSegment = segments.putIfAbsent(service, newSegment);
            if (existingSegment == null) {
                segment = newSegment;
                nodeEngine.getMetricsRegistry().scanAndRegister(newSegment, ""event.["" + service + ""]"");
            } else {
                segment = existingSegment;
            }
        }
        return segment;
    }",Get the segment for the given service.
"public static LinkedBuffer encode(final byte[] input, int inOffset, int inLen,
            final WriteSession session, final OutputStream out, 
            final LinkedBuffer lb) throws IOException
    {
        int outputSize = ((inLen+2)/3)*4;
        session.size += outputSize;
        
        final int available = lb.buffer.length - lb.offset;
        if(outputSize > available)
        {
            final int bufSize = lb.buffer.length - lb.start;
            if(outputSize > bufSize)
            {
                // still larger than buffer size.
                int chunks = available/4;
                if(chunks == 0)
                {
                    // available size is less than 4
                    // flush and reset
                    out.write(lb.buffer, lb.start, lb.offset-lb.start);
                    lb.offset = lb.start;
                    
                    final int loops = bufSize/4, inProcessLen = loops*3, outProcessLen = loops*4;
                    do
                    {
                        inOffset = encodeExplicit(input, inOffset, 0, lb.buffer, 
                                lb.offset, loops);
                        
                        out.write(lb.buffer, lb.offset, outProcessLen);
                        inLen -= inProcessLen;
                        outputSize -= outProcessLen;
                    }
                    while(inLen > inProcessLen);
                    
                    // write remaining
                    encode(input, inOffset, inLen, lb.buffer, lb.offset);
                    lb.offset += outputSize;
                    
                    return lb;
                }
                
                int inBefore = inOffset;
                byte[] buffer = lb.buffer;
                int offset = lb.offset;
                byte b0, b1, b2;
                
                // process available
                while(chunks-->0)
                {
                    b0=input[inOffset++];
                    b1=input[inOffset++];
                    b2=input[inOffset++];
                    buffer[offset++]=nibble2code[(b0>>>2)&0x3f];
                    buffer[offset++]=nibble2code[(b0<<4)&0x3f|(b1>>>4)&0x0f];
                    buffer[offset++]=nibble2code[(b1<<2)&0x3f|(b2>>>6)&0x03];
                    buffer[offset++]=nibble2code[b2&077];
                }
                
                inLen -= (inOffset - inBefore);
                
                outputSize -= (offset - lb.offset);
                
                // flush available
                out.write(buffer, lb.start, offset-lb.start);
                // reset
                lb.offset = lb.start;
                
                if(outputSize > bufSize)
                {
                    // still larger than buffer size.
                    final int loops = bufSize/4, inProcessLen = loops*3, outProcessLen = loops*4;
                    do
                    {
                        inOffset = encodeExplicit(input, inOffset, 0, lb.buffer, 
                                lb.offset, loops);
                        
                        out.write(lb.buffer, lb.offset, outProcessLen);
                        inLen -= inProcessLen;
                        outputSize -= outProcessLen;
                    }
                    while(inLen > inProcessLen);
                    
                    // write remaining
                    encode(input, inOffset, inLen, lb.buffer, lb.offset);
                    lb.offset += outputSize;
                    
                    return lb;
                }
                
                encode(input, inOffset, inLen, lb.buffer, lb.offset);
                lb.offset += outputSize;

                return lb;
            }
            
            // flush and reset
            out.write(lb.buffer, lb.start, lb.offset-lb.start);
            lb.offset = lb.start;
        }
        
        encode(input, inOffset, inLen, lb.buffer, lb.offset);
        lb.offset += outputSize;

        return lb;
    }",Encodes a byte array into a single LinkedBuffer.
"@SuppressWarnings(""unchecked"")
   public List<Failure> validate(Validate vo, ResourceBundle rb)
   {
      if (vo != null && Key.CONNECTION_FACTORY == vo.getKey())
      {
         if (vo.getClazz() == null)
         {
            ValidateClass vc = (ValidateClass)vo;

            List<Failure> failures = new ArrayList<Failure>(1);
            Failure failure = null;

            String code = null;
            if (vc.getClassName() != null)
            {
               code = vc.getClassName().equals("""") ? ""<empty>"" : vc.getClassName() +
                  "" ("" + vc.getClassLoader().toString() + "")"";
            }

            if (code != null)
            {
               failure = new Failure(Severity.ERROR,
                                     SECTION,
                                     rb.getString(""cf.CFNull""),
                                     code);
            }
            else
            {
               failure = new Failure(Severity.ERROR,
                                     SECTION,
                                     rb.getString(""cf.CFNull""));
            }

            failures.add(failure);

            return failures;
         }
      }

      return null;
   }",Validate method for a single object
"@Override
  public SoyData get(int index) {
    try {
      return list.get(index);
    } catch (IndexOutOfBoundsException ioobe) {
      return null;
    }
  }",Returns the data at the given index.
"public <V> double[] getConfidenceInterval(final double alpha, final Map<V, Double> baselineMetricPerDimension, final Map<V, Double> testMetricPerDimension, final boolean pairedSamples) {
        if (pairedSamples) {
            Set<V> overlap = new HashSet<V>(baselineMetricPerDimension.keySet());
            overlap.retainAll(testMetricPerDimension.keySet());

            // paired or matched samples --> analyse distribution of difference scores
            SummaryStatistics differences = new SummaryStatistics();
            for (V key : overlap) {
                double diff = Math.abs(testMetricPerDimension.get(key) - baselineMetricPerDimension.get(key));
                differences.addValue(diff);
            }
            return getConfidenceInterval(alpha / 2, (int) differences.getN() - 1, (int) differences.getN(), differences.getStandardDeviation(), differences.getMean());
        } else {
            // independent samples --> analyse distribution of differences between means
            SummaryStatistics statsBaseline = new SummaryStatistics();
            for (double d : baselineMetricPerDimension.values()) {
                statsBaseline.addValue(d);
            }
            SummaryStatistics statsTest = new SummaryStatistics();
            for (double d : testMetricPerDimension.values()) {
                statsTest.addValue(d);
            }
            long dfT = statsBaseline.getN() + statsTest.getN() - 2;
            double sDif = Math.sqrt((1.0 / statsBaseline.getN() + 1.0 / statsTest.getN())
                    * (statsBaseline.getVariance()
                    * (statsBaseline.getN() - 1) + statsTest.getVariance()
                    * (statsTest.getN() - 1)));
            double mDif = Math.abs(statsTest.getMean() - statsBaseline.getMean());
            return getConfidenceInterval(alpha, (int) dfT, (int) dfT, sDif, mDif);
        }
    }",Get confidence interval.
"private static PBXObjectRef createPBXFrameworksBuildPhase(final int buildActionMask, final List files,
      final boolean runOnly) {
    final Map map = new HashMap();
    map.put(""isa"", ""PBXFrameworksBuildPhase"");
    map.put(""buildActionMask"", NumberFormat.getIntegerInstance(Locale.US).format(buildActionMask));
    map.put(""files"", files);
    map.put(""runOnlyForDeploymentPostprocessing"", toString(runOnly));
    return new PBXObjectRef(map);
  }",Create PBXFrameworksBuildPhase.
"public Set<GraphObject> run()
	{
		// result set of neighborhood query
		Set<GraphObject> queryResult = new HashSet<GraphObject>();

		// if upstream is selected
		if (direction == Direction.UPSTREAM || direction == Direction.BOTHSTREAM)
		{
			// run BFS in upstream direction
			BFS bfsBackward = new BFS(sourceNodes, null, Direction.UPSTREAM, this.limit);

			/*
	  Maps to hold forward and backward BFS results
	 */
			Map<GraphObject, Integer> mapBackward = bfsBackward.run();

			// add result of BFS to result Set
			queryResult.addAll(mapBackward.keySet());
		}

		// if downstream is selected
		if (direction == Direction.DOWNSTREAM || direction == Direction.BOTHSTREAM)
		{
			// run BFS in downstream direction
			BFS bfsForward = new BFS(sourceNodes, null, Direction.DOWNSTREAM, this.limit);

			Map<GraphObject, Integer> mapForward = bfsForward.run();

			// add result of BFS to result Set
			queryResult.addAll(mapForward.keySet());
		}
		
		// return the result of query
		return queryResult;
	}",Executes the BFS query and returns the result set of neighborhoods.
"@Override
    public UpdateByteMatchSetResult updateByteMatchSet(UpdateByteMatchSetRequest request) {
        request = beforeClientExecution(request);
        return executeUpdateByteMatchSet(request);
    }",Updates an existing CDN file or directory in a byte - set.
"public JSONObject toJSONObject(JSONArray names) throws JSONException {
        JSONObject result = new JSONObject();
        int length = Math.min(names.length(), values.size());
        if (length == 0) {
            return null;
        }
        for (int i = 0; i < length; i++) {
            String name = JSON.toString(names.opt(i));
            result.put(name, opt(i));
        }
        return result;
    }",Convert a JSONArray of attributes to a JSONObject.
"protected AppendResponse checkGlobalIndex(AppendRequest request) {
    // If the globalIndex has changed and is not present in the local log, truncate the log.
    // This ensures that if major compaction progressed on any server beyond the entries in this
    // server's log that this server receives all entries after compaction.
    // If the current global index is 0 then do not perform the index check. This ensures that
    // servers don't truncate their logs at startup.
    // Ensure that the globalIndex is updated here to prevent endlessly truncating the log
    // if the AppendRequest is rejected.
    long currentGlobalIndex = context.getGlobalIndex();
    long nextGlobalIndex = request.globalIndex();
    if (currentGlobalIndex > 0 && nextGlobalIndex > currentGlobalIndex && nextGlobalIndex > context.getLog().lastIndex()) {
      context.setGlobalIndex(nextGlobalIndex);
      context.reset();
    }

    // If an entry was provided, check the entry against the local log.
    if (request.logIndex() != 0) {
      return checkPreviousEntry(request);
    } else {
      return appendEntries(request);
    }
  }",Check the global index of the AppendRequest.
"public boolean updateAttributes(Collection<Attribute> attributes)
      throws IllegalStateException {
    if (this.terminated) {
      throw new IllegalStateException(
          ""Cannot send solutions to the World Model once the connection has been destroyed."");
    }

    if (this.canSend) {
      return this.wmi.updateAttributes(attributes);
    }
    for (Attribute a : attributes) {
      if (!this.attributeBuffer.offer(a)) {
        return false;
      }
    }

    return true;
  }",Update the attributes of the World Model.
"public DateRangeQuery end(Date end) {
        this.end = SearchUtils.toFtsUtcString(end);
        this.inclusiveEnd = null;
        return this;
    }",Sets the end date.
"protected void afterSend(RpcInternalContext context, InvokeContext invokeContext, SofaRequest request) {
        currentRequests.decrementAndGet();
        if (RpcInternalContext.isAttachmentEnable()) {
            putToContextIfNotNull(invokeContext, InvokeContext.CLIENT_CONN_CREATETIME, context,
                RpcConstants.INTERNAL_KEY_CONN_CREATE_TIME);
        }
        if (EventBus.isEnable(ClientAfterSendEvent.class)) {
            EventBus.post(new ClientAfterSendEvent(request));
        }
    }",Called after send.
"public void beginImport()
        {
        try
            {
            if (m_writer == null)
                {
                m_writer = m_writerFactory.create();
                }
            CsvPreference preferences =
                    new CsvPreference.Builder(m_quoteChar, m_delimiterChar, m_endOfLineSymbols).build();
            m_csvWriter = new CsvMapWriter(m_writer, preferences);
            m_csvWriter.writeHeader(m_propertyNames);
            }
        catch (IOException e)
            {
            throw new RuntimeException(e);
            }
        }",Begin import.
"public void shutdown() {
        LOGGER.entering();
        if (launcher == null) {
            return;
        }

        if (!isRunning()) {
            return;
        }

        try {
            launcher.shutdown();
        } catch (Exception e) { // NOSONAR
            LOGGER.log(Level.SEVERE, e.getMessage(), e);
        }
        LOGGER.exiting();
    }",Shutdown the application.
"public static <T> ConnectableObservable<T> create(ObservableSource<T> source,
            final int bufferSize) {
        if (bufferSize == Integer.MAX_VALUE) {
            return createFrom(source);
        }
        return create(source, new ReplayBufferSupplier<T>(bufferSize));
    }",Create an observable from an observable source.
"@SuppressWarnings(""unchecked"")
    @InternalFunction(operator="">"", precedence=10)
    public Boolean gt(Object value, Object value2)
    {
        if (value2 != null && value2 instanceof Comparable)
        {
            @SuppressWarnings(""rawtypes"")
			final int ret = ((Comparable)value2).compareTo(value);
            return (ret > 0); 
        }
        return null;
    }",Gets the result of a GT operation.
"public static SortedSet<String> metadata ( final Map<MetaKey, String> metadata, String namespace, String key )
    {
        final SortedSet<String> result = new TreeSet<> ();

        if ( namespace.isEmpty () )
        {
            namespace = null;
        }

        if ( key.isEmpty () )
        {
            key = null;
        }

        for ( final Map.Entry<MetaKey, String> entry : metadata.entrySet () )
        {
            if ( namespace != null && !namespace.equals ( entry.getKey ().getNamespace () ) )
            {
                continue;
            }

            if ( key != null && !key.equals ( entry.getKey ().getKey () ) )
            {
                continue;
            }

            result.add ( entry.getValue () );
        }

        return result;
    }",Get the metadata.
"private void addRelevantBaseTypes(ClassDescriptorDef curType, ArrayList baseTypes)
    {
        ClassDescriptorDef baseDef;

        for (Iterator it = curType.getDirectBaseTypes(); it.hasNext();)
        {
            baseDef = (ClassDescriptorDef)it.next();
            if (!baseDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_INCLUDE_INHERITED, true))
            {
                // the base type has include-inherited set to false which means that
                // it does not include base features
                // since we do want these base features, we have to traverse its base types
                addRelevantBaseTypes(baseDef, baseTypes);
            }
            baseTypes.add(baseDef);
        }
    }",Add the relevant base types to the ArrayList.
"public List<Message> getFilteredList( EMessageType messageType, Long fromTsMillis, Long toTsMillis, long limit )
            throws Exception {
        String tableName = TABLE_MESSAGES;
        String sql = ""select "" + getQueryFieldsString() + "" from "" + tableName;

        List<String> wheresList = new ArrayList<>();
        if (messageType != null && messageType != EMessageType.ALL) {
            String where = type_NAME + ""="" + messageType.getCode();
            wheresList.add(where);
        }
        if (fromTsMillis != null) {
            String where = TimeStamp_NAME + "">"" + fromTsMillis;
            wheresList.add(where);
        }
        if (toTsMillis != null) {
            String where = TimeStamp_NAME + ""<"" + toTsMillis;
            wheresList.add(where);
        }

        if (wheresList.size() > 0) {
            sql += "" WHERE "";
            for( int i = 0; i < wheresList.size(); i++ ) {
                if (i > 0) {
                    sql += "" AND "";
                }
                sql += wheresList.get(i);
            }
        }

        sql += "" order by "" + ID_NAME + "" desc"";
        if (limit > 0) {
            sql += "" limit "" + limit;
        }

        String _sql = sql;
        List<Message> messages = new ArrayList<Message>();
        logDb.execOnConnection(connection -> {
            try (IHMStatement stmt = connection.createStatement(); IHMResultSet rs = stmt.executeQuery(_sql);) {
                while( rs.next() ) {
                    Message event = resultSetToItem(rs);
                    messages.add(event);
                }
            }
            return null;
        });
        return messages;
    }",Gets filtered list of messages.
"public static MutableIntTuple add(
        IntTuple t0, int value, MutableIntTuple result)
    {
        return IntTupleFunctions.apply(
            t0, (a)->(a+value), result);
    }",Add the given value to the given tuple.
"@Nonnull
	public static <T, R> LObjBoolFunction<T, R> objBoolFunctionFrom(Consumer<LObjBoolFunctionBuilder<T, R>> buildingFunction) {
		LObjBoolFunctionBuilder builder = new LObjBoolFunctionBuilder();
		buildingFunction.accept(builder);
		return builder.build();
	}",Create a LObjBoolFunction from a Consumer.
"private void recordSize(MixinMetric mixinMetric, RpcClientLookoutModel model) {

        Long requestSize = model.getRequestSize();
        Long responseSize = model.getResponseSize();

        if (requestSize != null) {
            DistributionSummary requestSizeDS = mixinMetric.distributionSummary(""request_size"");
            requestSizeDS.record(model.getRequestSize());
        }

        if (responseSize != null) {
            DistributionSummary responseSizeDS = mixinMetric.distributionSummary(""response_size"");
            responseSizeDS.record(model.getResponseSize());
        }
    }",Record size of the exception.
"public JsJmsObjectMessage createJmsObjectMessage() throws MessageCreateFailedException {
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.entry(tc, ""createJmsObjectMessage"");
    JsJmsObjectMessage msg = null;
    try {
      msg = new JsJmsObjectMessageImpl(MfpConstants.CONSTRUCTOR_NO_OP);
    }
    catch (MessageDecodeFailedException e) {
      /* No need to FFDC this as JsMsgObject will already have done so */
      // No FFDC code needed
      throw new MessageCreateFailedException(e);
    }
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) SibTr.exit(tc, ""createJmsObjectMessage"");
    return msg;
  }",Create a new empty HSID message
"public static void replaceDefaultHandler(Handler handler) {
    Logger rootlogger = LogManager.getLogManager().getLogger("""");
    for(Handler h : rootlogger.getHandlers()) {
      if(h instanceof CLISmartHandler) {
        rootlogger.removeHandler(h);
      }
    }
    addHandler(handler);
  }",Replace the default handler.
"static void injectResourceBundle(Object target, ResourceBundle resourceBundle) {
		final List<Field> fieldsWithAnnotation = ReflectionUtils
				.getFieldsWithAnnotation(target, InjectResourceBundle.class);
		
		final boolean notAssignableFieldPresent = fieldsWithAnnotation.stream()
				.anyMatch(field -> !field.getType().isAssignableFrom(ResourceBundle.class));
		
		if (notAssignableFieldPresent) {
			throw new IllegalStateException(
					""The class [""
							+ target
							+ ""] has at least one field with the annotation @InjectResourceBundle but the field is not of type ResourceBundle."");
		}
		
		// check whether the user has provided any resourceBundle or not
		if (resourceBundle == null || resourceBundle.equals(EMPTY_RESOURCE_BUNDLE)) {
			
			if (!fieldsWithAnnotation.isEmpty()) {
				
				final boolean nonOptionalFieldsPresent = fieldsWithAnnotation.stream()
						.flatMap(field -> Arrays.stream(field.getAnnotationsByType(InjectResourceBundle.class)))
						.anyMatch(annotation -> !annotation.optional());
				
				// if all annotated fields are marked as ""optional"", no exception has to be thrown.
				if (nonOptionalFieldsPresent) {
					throw new IllegalStateException(
							""The class [""
									+ target
									+ ""] expects a ResourceBundle to be injected but no ResourceBundle was defined while loading."");
				}
			}
		} else {
			fieldsWithAnnotation
					.forEach(field -> {
						if (field.getType().isAssignableFrom(ResourceBundle.class)) {
							ReflectionUtils.setField(field, target, resourceBundle);
						} else {
							throw new IllegalStateException(
									""The class [""
											+ target
											+ ""] has a field with the @InjectResourceBundle annotation but the type of the field doesn't match ResourceBundle"");
						}
					});
		}
	}",Inject a ResourceBundle to the target object.
"public static Callable getNameFunctionAndThis(String name,
                                                  Context cx,
                                                  Scriptable scope)
    {
        Scriptable parent = scope.getParentScope();
        if (parent == null) {
            Object result = topScopeName(cx, scope, name);
            if (!(result instanceof Callable)) {
                if (result == Scriptable.NOT_FOUND) {
                    throw notFoundError(scope, name);
                }
                throw notFunctionError(result, name);
            }
            // Top scope is not NativeWith or NativeCall => thisObj == scope
            Scriptable thisObj = scope;
            storeScriptable(cx, thisObj);
            return (Callable)result;
        }

        // name will call storeScriptable(cx, thisObj);
        return (Callable)nameOrFunction(cx, scope, parent, name, true);
    }",Get name function and this.
"private void parseFile()
    {

        try {
            try (
                BufferedReader fp = new BufferedReader(new InputStreamReader(new FileInputStream(iniFile), Charset.forName(""UTF-8"")));
            ) {
                boolean done = false;
                while(!done) {
                    String thisLine = fp.readLine();
		            if(thisLine != null && thisLine.trim().length() == 0)
			            thisLine = null;
                    if(thisLine != null) {
                        if(Debug) System.out.println(""Read: \"""" + thisLine + ""\"""");

                        if(thisLine.startsWith("";"") || thisLine.equalsIgnoreCase("""")) {
                            // Do nothing, it's a comment
                            if(Debug) System.out.println(""Ignoring comment or blank line..."");
                        } else {
                            int cindx = thisLine.indexOf("";"");

                            if(cindx > 0)
                                thisLine = thisLine.substring(0, cindx).trim();

                            if(Debug) System.out.println(""Comments removed: \"""" + thisLine + ""\"""");


                            if(thisLine.startsWith(""["") && thisLine.endsWith(""]"")) {

                                String sname = thisLine.substring(1, thisLine.length() - 1).trim();

                                if(Debug) System.out.println(""Found Section Name: "" + sname);

                                if(sectionNames == null)
                                    sectionNames = new Vector();

                                sectionNames.add(sname);

                                if(sectionProperties == null)
                                    sectionProperties = new Vector();

                                sectionProperties.add(new Vector());


                            } else if(sectionNames != null && sectionProperties != null) {
                                int eqidx = thisLine.indexOf(""="");

                                if(eqidx != -1) {
                                    String pair[] = new String[2];
                                    pair[0] = thisLine.substring(0, eqidx).trim();
                                    pair[1] = thisLine.substring(eqidx + 1, thisLine.length()).trim();

                                    if(Debug)
                                        System.out.println(""pair[0]: \"""" + pair[0] + ""\""   pair[1]: \"""" + pair[1] + ""\"""");

                                    // Add the pair to the current property list, which is the
                                    // last element in the sectionProperties vector.
                                    ((Vector) sectionProperties.lastElement()).add(pair);
                                }
                            }
                        }
                    } else {
                        done = true;
                    }
                }
            }
        } catch (FileNotFoundException e) {
            System.err.println(""Could Not Find ini File: \"""" + iniFile + ""\"""");
        } catch (IOException e) {
            System.err.println(""Could Not Read ini File: \"""" + iniFile + ""\"""");
        }
    }",Parse the INI file for a single SECTYPE.
"public static int checkElementIndex(
        int index,
        int size,
        final Eid eid,
        final String messageFormat,
        final Object... parameters
    ) {
        if (isSizeIllegal(size)) {
            throw new EidIllegalArgumentException(
                ensureEid(eid).message(messageFormat, parameters)
            );
        }
        if (isIndexAndSizeIllegal(index, size)) {
            throw new EidIndexOutOfBoundsException(
                ensureEid(eid).message(messageFormat, parameters)
            );
        }
        return index;
    }",Check if the element index is illegal.
"public void open(ucar.unidata.io.RandomAccessFile raf, ucar.nc2.NetcdfFile ncfile,
                   ucar.nc2.util.CancelTask cancelTask) throws IOException {

    super.open(raf, ncfile, cancelTask);

    headerParser = new FysatHeader();
    headerParser.read(raf, ncfile);

    ncfile.finish();
  }",This method is called by the FysatTask to open the file.
"private void fillGrid() {

		if (jbounds!=null && !ibounds.overlaps(jbounds, cutoff)) {
			//System.out.print(""-"");
			noOverlap = true;
			return;
		}

		findFullGridIntBounds();

		cells = new GridCell[1+(bounds[3]-bounds[0])/cellSize]
		                    [1+(bounds[4]-bounds[1])/cellSize]
		                    [1+(bounds[5]-bounds[2])/cellSize];

		int i = 0;
		for (Point3d atom:iAtoms) {

			int xind = xintgrid2xgridindex(getFloor(atom.x));
			int yind = yintgrid2ygridindex(getFloor(atom.y));
			int zind = zintgrid2zgridindex(getFloor(atom.z));
			if (cells[xind][yind][zind]==null) {
				cells[xind][yind][zind] = new GridCell(this);
			}
			cells[xind][yind][zind].addIindex(i);
			i++;
		}

		if (jAtoms==null) return;

		int j = 0;
		for (Point3d atom:jAtoms) {

			int xind = xintgrid2xgridindex(getFloor(atom.x));
			int yind = yintgrid2ygridindex(getFloor(atom.y));
			int zind = zintgrid2zgridindex(getFloor(atom.z));
			if (cells[xind][yind][zind]==null) {
				cells[xind][yind][zind] = new GridCell(this);
			}
			cells[xind][yind][zind].addJindex(j);
			j++;
		}

	}",Fill the grid with the data from the input data.
"public static Geldbetrag ofMinor(CurrencyUnit currency, long amountMinor) {
        return ofMinor(currency, amountMinor, currency.getDefaultFractionDigits());
    }",Create a Geldbetrag with the given currency and amount minor.
"public static ObjectMapperClientFeatureModule with(
      Class<? extends Annotation> clientBindingAnnotation) {
    BindingAnnotations.checkIsBindingAnnotation(clientBindingAnnotation);

    return new ObjectMapperClientFeatureModule(clientBindingAnnotation);
  }",Create a new ObjectMapperClientFeatureModule with the specified clientBinding annotation.
"protected final int getNextNamespaceNode2(int baseID) {
        int type;
        while ((type = _type2(++baseID)) == DTM.ATTRIBUTE_NODE);

        if (type == DTM.NAMESPACE_NODE)
            return baseID;
        else
            return NULL;
    }",Get the next namespace node.
"private void onUploadFinished() {
        if (artifactUploadState.areAllUploadsFinished() && artifactUploadState.isStatusPopupMinimized()) {
            if (artifactUploadState.getFilesInFailedState().isEmpty()) {
                cleanupStates();
                closeWindow();
            } else {
                maximizeWindow();
            }
        }
    }",On upload finished.
"public Boolean tickets_ticketId_canBeScored_GET(Long ticketId) throws IOException {
		String qPath = ""/support/tickets/{ticketId}/canBeScored"";
		StringBuilder sb = path(qPath, ticketId);
		String resp = exec(qPath, ""GET"", sb.toString(), null);
		return convertTo(resp, Boolean.class);
	}",Check if a ticket can be scored
"public static int cuGraphAddEmptyNode(CUgraphNode phGraphNode, CUgraph hGraph, CUgraphNode dependencies[], long numDependencies) 
    {
        return checkResult(cuGraphAddEmptyNodeNative(phGraphNode, hGraph, dependencies, numDependencies));
    }",Adds an empty node to the graph.
"public double[] project(double[] xyz) {
        double[] coord = new double[3];

        coord[0] = cosTheta * xyz[1] - sinTheta * xyz[0];
        coord[1] = cosPhi * xyz[2] - sinPhi * cosTheta * xyz[0] - sinPhi * sinTheta * xyz[1];
        coord[2] = cosPhi * sinTheta * xyz[1] + sinPhi * xyz[2] + cosPhi * cosTheta * xyz[0];

        return coord;
    }",Project a 2 - dimensional double array to a 2 - dimensional double array.
"@Override
	public boolean isTableType(ContentsDataType type, String table) {
		return isTableType(type.getName(), table);
	}",Checks if the contents data type is a table type.
"public double[] xyzell(double a, double b, double[] xstat) {


    double[] xstell = new double[3];
    double e2, s, rlam, zps, h, phi, n, hp, phip;
    int i, niter;

    e2 = (a * a - b * b) / (a * a);
    s = Math.sqrt(xstat[0] * xstat[0] + xstat[1] * xstat[1]);
    rlam = Math.atan2(xstat[1], xstat[0]);
    zps = xstat[2] / s;
    h = Math.sqrt(xstat[0] * xstat[0] + xstat[1] * xstat[1]
            + xstat[2] * xstat[2]) - a;
    phi = Math.atan(zps / (1.0 - e2 * a / (a + h)));

    niter = 0;
    for (i = 1; i <= 10000000; i++) {
      n = a / Math.sqrt(1.0 - e2 * Math.sin(phi) * Math.sin(phi));
      hp = h;
      phip = phi;
      h = s / Math.cos(phi) - n;
      phi = Math.atan(zps / (1.0 - e2 * n / (n + h)));
      niter = niter + 1;
      if ((Math.abs(phip - phi) <= 1.e-11)
              && (Math.abs(hp - h) <= 1.e-5)) {
        break;
      }
      if (niter >= 10) {
        phi = -999.0;
        rlam = -999.0;
        h = -999.0;
        break;
      }

    }

    xstell[0] = phi * 180 / 3.1415926;
    xstell[1] = rlam * 180 / 3.1415926;
    xstell[2] = h;

    return xstell;

  }",Returns the xyzell of two vectors.
"private void setItem(int index, Timepoint time) {
        time = roundToValidTime(time, index);
        mCurrentTime = time;
        reselectSelector(time, false, index);
    }",Set the item in the calendar.
"private static String formatEnvironmentContext(Environment environment) {
    String environmentName = environment.getName();

    if (environmentName == null || environmentName.isEmpty()) {
      return """";
    } else {
      return environmentName.endsWith(""_"") ? environmentName : environmentName + ""_"";
    }
  }",Format the environment context.
"private int determineCharge(IAtomContainer mol, IAtom atom) {
        Integer q = atom.getFormalCharge();
        if (q == null)
            q = 0;
        switch (q) {
            case -3: return 7;
            case -2: return 6;
            case -1: return 5;
            case 0:
                if (mol.getConnectedSingleElectronsCount(atom) == 1)
                    return 4;
                return 0;
            case +1:  return 3;
            case +2:  return 2;
            case +3:  return 1;
        }
        return 0;
    }",Determine the charge of a given atom.
"@Override
    public void setTransition(Transition transition) {
        if (anchor == null) {
            if (transition != null) {
                setUrl(""#"");
            } else {
                return;
            }
        }
        if (anchor != null) JQMCommon.setTransition(anchor, transition);
    }",Set the transition for this tag.
"@Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);

        Fragment fragment = getSupportFragmentManager().findFragmentById(android.R.id.content);
        if (fragment == null) {
            fragment = MainFragment.newInstance(getIntent().getExtras());
            getSupportFragmentManager()
                    .beginTransaction()
                    .replace(android.R.id.content, fragment, """")
                    .commit();
        } else {
            getSupportFragmentManager()
                    .beginTransaction()
                    .attach(fragment)
                    .commit();
        }
    }",Override onCreate to create the content view and attach it to the activity
"public DockerRuleBuilder keepContainer(boolean keepContainer) {
        if (keepContainer) {
            this.stopOptions.setOptions(StopOption.KEEP);
        } else {
            this.stopOptions.setOptions(StopOption.REMOVE);
        }
        return this;
    }",Keep container.
"public Address createAddress(String sipAddress)
			throws ServletParseException {
		try {
			if (logger.isDebugEnabled()) {
				logger.debug(""Creating Address from ["" + sipAddress + ""]"");
			}

			AddressImpl retval = new AddressImpl();
			retval.setValue(sipAddress);
			return retval;
		} catch (IllegalArgumentException e) {
			throw new ServletParseException(e);
		}
	}",Create an Address from a sip address.
"@Override
    public Request<AcceptVpcEndpointConnectionsRequest> getDryRunRequest() {
        Request<AcceptVpcEndpointConnectionsRequest> request = new AcceptVpcEndpointConnectionsRequestMarshaller().marshall(this);
        request.addParameter(""DryRun"", Boolean.toString(true));
        return request;
    }",Gets the request that will be used to delete the vpc endpoint from the cache.
"public final DetectLanguageResponse detectLanguage(String parent, String model, String mimeType) {
    if (!parent.isEmpty()) {
      LOCATION_PATH_TEMPLATE.validate(parent, ""detectLanguage"");
    }
    DetectLanguageRequest request =
        DetectLanguageRequest.newBuilder()
            .setParent(parent)
            .setModel(model)
            .setMimeType(mimeType)
            .build();
    return detectLanguage(request);
  }",Detect language.
"public static <T> Class<T> loadClass(String className, ClassLoader classloader) {
        if(className == null) {
            throw new IllegalArgumentException(""className cannot be null"");
        }

        if(classloader == null) {
            throw new IllegalArgumentException(""classloader cannot be null"");
        }

        try {
            return (Class<T>) Class.forName(className, false, classloader);
        } catch (ClassNotFoundException e) {
            throw new RuntimeException(e);
        }
    }",Load a class from a String.
"@Override
    public synchronized void post(byte[] data, int offset, int len) {
        // Log.w(TAG, ""post"");
        if (isClosed) {
            return;
        }
        try {
            sendProtoPackage(data, offset, len);
        } catch (IOException e) {
            Log.e(TAG, e);
            close();
        }
    }",Post a message to the Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban s Azkaban.
"@SuppressWarnings(""PMD.AvoidCatchingThrowable"")
  private static String newString(char[] buf) {
    if (STRING_CONSTRUCTOR != null) {
      try {
        return (String) STRING_CONSTRUCTOR.invokeExact(buf, true);
      } catch (Throwable t) {
        // Note: `invokeExact` explicitly throws Throwable to propagate any exception of the
        // method unchanged. For our purposes we just fallback to the string constructor.
        return new String(buf);
      }
    } else {
      return new String(buf);
    }
  }",This method is used to create a String from a char array.
"public String getName()
   {
      try
      {
         return locationFactory.createJCRName(nodeTypeData.getName()).getAsString();
      }
      catch (RepositoryException e)
      {
         throw new RuntimeException(""Wrong name in nodeTypeData "" + e, e);
      }
   }","Returns the name of the
inant object."
"public void addWithLeftMargin(E tabContent, String tabName) {

        tabContent.addStyleName(I_CmsLayoutBundle.INSTANCE.generalCss().cornerAll());
        m_tabPanel.add(tabContent, CmsDomUtil.stripHtml(tabName));

        int tabIndex = m_tabPanel.getWidgetIndex(tabContent);
        Element tabElement = getTabElement(tabIndex);
        if (tabElement != null) {
            tabElement.addClassName(I_CmsLayoutBundle.INSTANCE.tabbedPanelCss().tabLeftMargin());
            if (!m_panelStyle.equals(CmsTabbedPanelStyle.classicTabs)) {
                tabElement.addClassName(I_CmsLayoutBundle.INSTANCE.generalCss().buttonCornerAll());
                tabElement.addClassName(I_CmsLayoutBundle.INSTANCE.tabbedPanelCss().borderAll());
            }
        }
        m_tabPanel.checkTabOverflow();
    }",Add a tab with left margin.
"public E insert(E element) {
        E evicted = null;
        if (size() >= capacity) {
            if (evictPolicy == EvictPolicy.REJECT_NEW) {
                // reject the new element
                return element;
            }
            // Evict first, so we do not need to resize
            evicted = evict();
        }
        deque.offerLast(element);
        return evicted;
    }",Inserts the specified element into the deque.
"public void clear() {
        weightParams.clear();
        biasParams.clear();
        paramsList = null;
        weightParamsList = null;
        biasParamsList = null;
    }",Clear all the data structures.
"public void topicSpaceCreatedEvent(DestinationHandler destination) throws SIResourceException
  {
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.entry(tc, ""topicSpaceCreatedEvent"", destination);
    
    try
    {
      _lockManager.lockExclusive();
      
      _neighbours.topicSpaceCreated(destination);
    }
    finally
    {
      _lockManager.unlockExclusive();
    }

    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.exit(tc, ""topicSpaceCreatedEvent"");
  }",topicSpaceCreatedEvent is called by the Neighbour to indicate that a topic space has been created.
"public Option getSelectedItem() {
        for (Entry<OptionElement, Option> entry : itemMap.entrySet()) {
            Option opt = entry.getValue();
            if (opt.isSelected())
                return opt;
        }
        return null;
    }",Get the selected item.
"public final BaseDescr equalityExpression() throws RecognitionException {
		BaseDescr result = null;


		Token op=null;
		BaseDescr left =null;
		BaseDescr right =null;

		try {
			// src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:286:3: (left= instanceOfExpression ( (op= EQUALS |op= NOT_EQUALS ) right= instanceOfExpression )* )
			// src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:286:5: left= instanceOfExpression ( (op= EQUALS |op= NOT_EQUALS ) right= instanceOfExpression )*
			{
			pushFollow(FOLLOW_instanceOfExpression_in_equalityExpression1395);
			left=instanceOfExpression();
			state._fsp--;
			if (state.failed) return result;
			if ( state.backtracking==0 ) { if( buildDescr  ) { result = left; } }
			// src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:287:3: ( (op= EQUALS |op= NOT_EQUALS ) right= instanceOfExpression )*
			loop32:
			while (true) {
				int alt32=2;
				int LA32_0 = input.LA(1);
				if ( (LA32_0==EQUALS||LA32_0==NOT_EQUALS) ) {
					alt32=1;
				}

				switch (alt32) {
				case 1 :
					// src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:287:5: (op= EQUALS |op= NOT_EQUALS ) right= instanceOfExpression
					{
					// src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:287:5: (op= EQUALS |op= NOT_EQUALS )
					int alt31=2;
					int LA31_0 = input.LA(1);
					if ( (LA31_0==EQUALS) ) {
						alt31=1;
					}
					else if ( (LA31_0==NOT_EQUALS) ) {
						alt31=2;
					}

					else {
						if (state.backtracking>0) {state.failed=true; return result;}
						NoViableAltException nvae =
							new NoViableAltException("""", 31, 0, input);
						throw nvae;
					}

					switch (alt31) {
						case 1 :
							// src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:287:7: op= EQUALS
							{
							op=(Token)match(input,EQUALS,FOLLOW_EQUALS_in_equalityExpression1407); if (state.failed) return result;
							}
							break;
						case 2 :
							// src/main/resources/org/drools/compiler/lang/DRL5Expressions.g:287:19: op= NOT_EQUALS
							{
							op=(Token)match(input,NOT_EQUALS,FOLLOW_NOT_EQUALS_in_equalityExpression1413); if (state.failed) return result;
							}
							break;

					}

					if ( state.backtracking==0 ) {  helper.setHasOperator( true );
					       if( input.LA( 1 ) != DRL5Lexer.EOF ) helper.emit( Location.LOCATION_LHS_INSIDE_CONDITION_ARGUMENT ); }
					pushFollow(FOLLOW_instanceOfExpression_in_equalityExpression1429);
					right=instanceOfExpression();
					state._fsp--;
					if (state.failed) return result;
					if ( state.backtracking==0 ) { if( buildDescr  ) {
					               result = new RelationalExprDescr( (op!=null?op.getText():null), false, null, left, right );
					           }
					         }
					}
					break;

				default :
					break loop32;
				}
			}

			}

		}

		catch (RecognitionException re) {
		    throw re;
		}

		finally {
			// do for sure before leaving
		}
		return result;
	}",Generates a equalityExpression
"protected static Method findTargetMethod(final Method sourceMethod, Class<?> target) throws NoSuchElementException {
        return Iterables.find(Arrays.asList(target.getMethods()), new Predicate<Method>() {
            @Override
            public boolean apply(Method element) {
                if (!sourceMethod.getName().equals(element.getName())) {
                    return false;
                }
                if (sourceMethod.getParameterTypes().length != element.getParameterTypes().length) {
                    return false;
                }
                return true;
            }
        });
    }",Find the target method.
"private void addSwitchCase(Node switchBlock, Node caseExpression,
                               Node statements)
    {
        if (switchBlock.getType() != Token.BLOCK) throw Kit.codeBug();
        Jump switchNode = (Jump)switchBlock.getFirstChild();
        if (switchNode.getType() != Token.SWITCH) throw Kit.codeBug();

        Node gotoTarget = Node.newTarget();
        if (caseExpression != null) {
            Jump caseNode = new Jump(Token.CASE, caseExpression);
            caseNode.target = gotoTarget;
            switchNode.addChildToBack(caseNode);
        } else {
            switchNode.setDefault(gotoTarget);
        }
        switchBlock.addChildToBack(gotoTarget);
        switchBlock.addChildToBack(statements);
    }",Add a switch case.
"public static br_configurealert configurealert(nitro_service client, br_configurealert resource) throws Exception
	{
		return ((br_configurealert[]) resource.perform_operation(client, ""configurealert""))[0];
	}",Use this operation to configure alert.
"@Override
    public DescribeFpgaImageAttributeResult describeFpgaImageAttribute(DescribeFpgaImageAttributeRequest request) {
        request = beforeClientExecution(request);
        return executeDescribeFpgaImageAttribute(request);
    }",Retrieves the description of an FPGA image attribute.
"public static final Assignment fromSortedArrays(int[] vars, Object[] values) {
    // Verify that the assignment is sorted and contains no duplicate values.
    for (int i = 1; i < vars.length; i++) {
      Preconditions.checkArgument(vars[i - 1] < vars[i], ""Illegal assignment variable nums: %s %s"",
          vars[i - 1], vars[i]);
    }
    return new Assignment(vars, values);
  }",Create an assignment from a sorted array of variable numbers and a set of values.
"private static void addLocaleField(TypeSpec.Builder type, String name, LocaleID locale) {
    FieldSpec.Builder field = FieldSpec.builder(CLDR_LOCALE_IF, name, PUBLIC, STATIC, FINAL)
        .initializer(""new $T($S, $S, $S, $S)"",
            META_LOCALE,
            strOrNull(locale.language), 
            strOrNull(locale.script),
            strOrNull(locale.territory),
            strOrNull(locale.variant));
    type.addField(field.build());
  }",Add a locale field to the type.
"ImmutableMap<ExecutableElement, TypeMirror> methodReturnTypes(
      Set<ExecutableElement> methods, DeclaredType in) {
    ImmutableMap.Builder<ExecutableElement, TypeMirror> map = ImmutableMap.builder();
    Map<Name, ExecutableElement> noArgMethods = null;
    for (ExecutableElement method : methods) {
      TypeMirror returnType = null;
      try {
        TypeMirror methodMirror = typeUtils.asMemberOf(in, method);
        returnType = MoreTypes.asExecutable(methodMirror).getReturnType();
      } catch (IllegalArgumentException e) {
        if (method.getParameters().isEmpty()) {
          if (noArgMethods == null) {
            noArgMethods = noArgMethodsIn(in);
          }
          returnType = noArgMethods.get(method.getSimpleName()).getReturnType();
        }
      }
      if (returnType == null) {
        returnType = method.getReturnType();
      }
      map.put(method, returnType);
    }
    return map.build();
  }",Method return types.
"public static final double addLongitude(double longitude, double delta)
    {
        double gha = longitudeToGHA(longitude);
        gha -= delta;
        return ghaToLongitude(normalizeAngle(gha));
    }",Add the delta to a longitude.
"@Override
  public void setupValueChangedListeners() {
    super.setupValueChangedListeners();
    editableSpinner.focusedProperty().addListener(
        (observable, oldValue, newValue) -> toggleTooltip(editableSpinner)
    );
  }",Setup the listeners that are attached to the editable spinner.
"public String logName()
    {
        if (tc.isEntryEnabled())
            Tr.entry(tc, ""logName"", this);
        if (tc.isEntryEnabled())
            Tr.exit(tc, ""logName"", _logName);
        return _logName;
    }",This method is called by the application to get the name of the log file.
"public static DevState[] extractToDevStateArray(final DeviceData deviceDataArgout)
	    throws DevFailed {
	final Object[] values = CommandHelper.extractArray(deviceDataArgout);
	if (values == null) {
	    Except.throw_exception(""TANGO_WRONG_DATA_ERROR"", ""output is empty "",
		    ""CommandHelper.extractToFloatArray(deviceDataArgin)"");
	}
	final DevState[] argout = new DevState[values.length];

	if (values.length > 0) {
	    if (values[0] instanceof Short) {
		for (int i = 0; i < values.length; i++) {
		    try {
			argout[i] = DevState.from_int(((Short) values[i]).intValue());
		    } catch (final Exception e) {
			argout[i] = DevState.UNKNOWN;
		    }
		}
	    } else if (values[0] instanceof String) {
		for (int i = 0; i < values.length; i++) {
		    argout[i] = StateUtilities.getStateForName((String) values[i]);
		}
	    } else if (values[0] instanceof Integer) {
		for (int i = 0; i < values.length; i++) {
		    try {
			argout[i] = DevState.from_int(((Integer) values[i]).intValue());
		    } catch (final Exception e) {
			argout[i] = DevState.UNKNOWN;
		    }
		}
	    } else if (values[0] instanceof Long) {
		for (int i = 0; i < values.length; i++) {
		    try {
			argout[i] = DevState.from_int(((Long) values[i]).intValue());
		    } catch (final Exception e) {
			argout[i] = DevState.UNKNOWN;
		    }
		}
	    } else if (values[0] instanceof Float) {
		for (int i = 0; i < values.length; i++) {
		    try {
			argout[i] = DevState.from_int(((Float) values[i]).intValue());
		    } catch (final Exception e) {
			argout[i] = DevState.UNKNOWN;
		    }
		}
	    } else if (values[0] instanceof Boolean) {
		for (int i = 0; i < values.length; i++) {
		    try {
			if (((Boolean) values[i]).booleanValue()) {
			    argout[i] = DevState.from_int(1);
			} else {
			    argout[i] = DevState.from_int(0);
			}
		    } catch (final Exception e) {
			argout[i] = DevState.UNKNOWN;
		    }
		}
	    } else if (values[0] instanceof Double) {
		for (int i = 0; i < values.length; i++) {
		    try {
			argout[i] = DevState.from_int(((Double) values[i]).intValue());
		    } catch (final Exception e) {
			argout[i] = DevState.UNKNOWN;
		    }
		}
	    } else if (values[0] instanceof Byte) {
		for (int i = 0; i < values.length; i++) {
		    try {
			argout[i] = DevState.from_int(((Byte) values[i]).intValue());
		    } catch (final Exception e) {
			argout[i] = DevState.UNKNOWN;
		    }
		}
	    } else if (values[0] instanceof DevState) {
		for (int i = 0; i < values.length; i++) {
		    argout[i] = (DevState) values[i];
		}
	    } else {
		Except.throw_exception(""TANGO_WRONG_DATA_ERROR"", ""output type ""
			+ values[0].getClass() + "" not supported"",
			""CommandHelper.extractToFloatArray(Object value,deviceDataArgin)"");
	    }
	}
	return argout;
    }",Extract data to DevState array.
"private static <T> T coalesce(T... values) {
    for (T value : values) {
      if (value != null) {
        return value;
      }
    }
    return null;
  }",Coalesce the given values into a single value.
"protected void setStartParameters(MouseDownEvent event) {

        m_oldheight = Double.parseDouble(getElement().getStyle().getHeight().replace(""px"", """"));
        m_clientY = event.getClientY();
    }",Set the start parameters.
"public static MimeType parseMimeType(String mimeType) {
        if (!StringUtils.hasLength(mimeType)) {
            throw new InvalidMimeTypeException(mimeType, ""'mimeType' must not be empty"");
        }
        String[] parts = StringUtils.tokenizeToStringArray(mimeType, "";"");

        String fullType = parts[0].trim();
        // java.net.HttpURLConnection returns a *; q=.2 Accept header
        if (MimeType.WILDCARD_TYPE.equals(fullType)) {
            fullType = ""*/*"";
        }
        int subIndex = fullType.indexOf('/');
        if (subIndex == -1) {
            throw new InvalidMimeTypeException(mimeType, ""does not contain '/'"");
        }
        if (subIndex == fullType.length() - 1) {
            throw new InvalidMimeTypeException(mimeType, ""does not contain subtype after '/'"");
        }
        String type = fullType.substring(0, subIndex);
        String subtype = fullType.substring(subIndex + 1, fullType.length());
        if (MimeType.WILDCARD_TYPE.equals(type) && !MimeType.WILDCARD_TYPE.equals(subtype)) {
            throw new InvalidMimeTypeException(mimeType, ""wildcard type is legal only in '*/*' (all mime types)"");
        }

        Map<String, String> parameters = null;
        if (parts.length > 1) {
            parameters = new LinkedHashMap<String, String>(parts.length - 1);
            for (int i = 1; i < parts.length; i++) {
                String parameter = parts[i];
                int eqIndex = parameter.indexOf('=');
                if (eqIndex != -1) {
                    String attribute = parameter.substring(0, eqIndex);
                    String value = parameter.substring(eqIndex + 1, parameter.length());
                    parameters.put(attribute, value);
                }
            }
        }

        try {
            return new MimeType(type, subtype, parameters);
        } catch (UnsupportedCharsetException ex) {
            throw new InvalidMimeTypeException(mimeType, ""unsupported charset '"" + ex.getCharsetName() + ""'"");
        } catch (IllegalArgumentException ex) {
            throw new InvalidMimeTypeException(mimeType, ex.getMessage());
        }
    }",Parses a string of mime types into a MimeType object.
"public static void symmRankNMinus_L(int blockLength ,
                                        DSubmatrixD1 A , DSubmatrixD1 B )
    {
        int widthB = B.col1-B.col0;
        if( widthB > blockLength )
            throw new IllegalArgumentException(""Width of B cannot be greater than the block length"");

        int N = B.row1-B.row0;

        if( A.col1-A.col0 != N )
            throw new IllegalArgumentException(""A does not have the expected number of columns based on B's height"");
        if( A.row1-A.row0 != N )
            throw new IllegalArgumentException(""A does not have the expected number of rows based on B's height"");

        for( int i = B.row0; i < B.row1; i += blockLength ) {


            int heightB_i = Math.min(blockLength,B.row1-i);
            int indexB_i = i*B.original.numCols + heightB_i*B.col0;

            int rowA = i-B.row0+A.row0;
            int heightA = Math.min( blockLength , A.row1 - rowA);

            for( int j = B.row0; j <= i; j += blockLength ) {
                
                int widthB_j = Math.min(blockLength,B.row1-j);

                int indexA = rowA * A.original.numCols + (j-B.row0+A.col0)*heightA;
                int indexB_j = j*B.original.numCols + widthB_j*B.col0;

                if( i == j ) {
                    multTransBBlockMinus_L( B.original.data,A.original.data,
                            indexB_i,indexB_j,indexA,widthB,heightB_i,widthB_j);
                } else {
                    multTransBBlockMinus( B.original.data,A.original.data,
                            indexB_i,indexB_j,indexA,widthB,heightB_i,widthB_j);
                }
            }
        }
    }",Method symmRankNMinus_L.
"public static synchronized void mockStaticPartialStrict(Class<?> clazz, String... methodNames) {
        mockStaticStrict(clazz, Whitebox.getMethods(clazz, methodNames));
    }",Mock a static method with a strict mode.
"public static int[] getMatrixMultiplyShape(int[] left, int[] right) {
        if(Shape.shapeIsScalar(left)) {
            return right;
        }

        if(Shape.shapeIsScalar(right)) {
            return left;
        }

        if (left.length != 2 && right.length != 2) {
            throw new IllegalArgumentException(""Illegal shapes for matrix multiply. Must be of length 2. Left shape: ""
                    + Arrays.toString(left) + "", right shape: "" + Arrays.toString(right));
        }

        for(int i = 0; i < left.length; i++) {
            if(left[i] < 1)
                throw new ND4JIllegalStateException(""Left shape contained value < 0 at index "" + i + "" - left shape "" + Arrays.toString(left));
        }



        for(int i = 0; i < right.length; i++) {
            if(right[i] < 1)
                throw new ND4JIllegalStateException(""Right shape contained value < 0 at index "" + i + "" - right shape "" + Arrays.toString(right));
        }


        if (left.length > 1 && left[1] != right[0])
            throw new IllegalArgumentException(""Columns of left not equal to rows of right: left shape "" + Arrays.toString(left)
                    + "", right shape "" + Arrays.toString(right));

        if(left.length < right.length) {
            if(left[0] == right[0]) {
                return new int[] {1, right[1]};
            }
        }

        int[] shape = {left[0], right[1]};
        return shape;
    }",Get matrix multiply shape.
"public void setName(String name) {
        String oldname = this.name;
        this.name = name;
        //TODO Reset the main map
        save(oldname);
    }",Sets the name of the class.
"private double getMolecularWeight(IAtomContainer atomContainer) throws CDKException {
        double mw = 0.0;
        try {
            final IsotopeFactory isotopeFactory = Isotopes.getInstance();

            for (IAtom atom : atomContainer.atoms()) {
                if (!atom.getSymbol().equals(""H"")) {
                    final IIsotope majorIsotope = isotopeFactory.getMajorIsotope(atom.getSymbol());

                    if (majorIsotope != null && majorIsotope.getExactMass() != null) {
                        mw += majorIsotope.getExactMass().doubleValue();
                    }
                }
            }
        } catch (IOException e) {
            throw new CDKException(e.getMessage(), e);
        }
        return mw;
    }",Gets the molecular weight of the molecule.
"public static LottieTask<LottieComposition> fromJsonInputStream(final InputStream stream, @Nullable final String cacheKey) {
    return cache(cacheKey, new Callable<LottieResult<LottieComposition>>() {
      @Override public LottieResult<LottieComposition> call() {
        return fromJsonInputStreamSync(stream, cacheKey);
      }
    });
  }",Creates a new task that will read the content of the given input stream and cache it.
"public Optional<Filters.Filter> adaptFilter(FilterAdapterContext context, Filter filter)
      throws IOException {
    SingleFilterAdapter<?> adapter = getAdapterForFilterOrThrow(filter);
    return Optional.fromNullable(adapter.adapt(context, filter));
  }",Adapts a single filter to a CRX Filter.
"public static <K, V> Function<K, V> forMap(Map<K, V> map) {
		return key -> {
			if (map.containsKey(key)) {
				return map.get(key);
			} else {
				throw new IllegalArgumentException(""Key '"" + key + ""' not present in map"");
			}
		};
	}",For Map Function.
"public ElemTemplate getOwnerXSLTemplate()
  {
  	ElemTemplateElement el = this;
  	int type = el.getXSLToken();
  	while((null != el) && (type != Constants.ELEMNAME_TEMPLATE))
  	{
    	el = el.getParentElem();
    	if(null != el)
  			type = el.getXSLToken();
  	}
  	return (ElemTemplate)el;
  }",Gets the owner XSLT template.
"public static LinkedHashMap<String, ProteinSequence> readFastaProteinSequence(
			File file) throws IOException {
		FileInputStream inStream = new FileInputStream(file);
		LinkedHashMap<String, ProteinSequence> proteinSequences = readFastaProteinSequence(inStream);
		inStream.close();
		return proteinSequences;
	}",Read a FASTA protein sequence file.
"@Override
  public void sendLocationInformationRequest(JLocationInfoRequest request)
      throws InternalException, IllegalDiameterStateException, RouteException, OverloadException {
    send(Event.Type.SEND_MESSAGE, request, null);
  }","Method to send a
 request to the device."
"@Override
    public void config(String msg) {
        if (isLoggable(Level.CONFIG)) {
            log(Level.CONFIG, msg);
        }
    }",Logs a CONFIG message.
"public List<CmsPublishResource> getBrokenResources(List<CmsResource> pubResources) {

        List<CmsPublishResource> resources = new ArrayList<CmsPublishResource>();
        CmsPublishManager publishManager = OpenCms.getPublishManager();

        CmsPublishList publishList;
        try {
            publishList = OpenCms.getPublishManager().getPublishListAll(
                m_cms,
                pubResources,
                m_options.isIncludeSiblings(),
                true);
            if (m_options.isIncludeRelated()) {
                CmsPublishList related = publishManager.getRelatedResourcesToPublish(m_cms, publishList);
                publishList = publishManager.mergePublishLists(m_cms, publishList, related);
            }

        } catch (CmsException e) {
            // should never happen
            LOG.error(e.getLocalizedMessage(), e);
            return resources;
        }

        CmsRelationPublishValidator validator = new CmsRelationPublishValidator(m_cms, publishList);
        m_relationValidator = validator;
        for (String resourceName : validator.keySet()) {
            CmsRelationValidatorInfoEntry infoEntry = validator.getInfoEntry(resourceName);
            try {
                CmsResource resource = m_cms.readResource(
                    m_cms.getRequestContext().removeSiteRoot(resourceName),
                    CmsResourceFilter.ALL);
                if (resource.getState().isDeleted()) {
                    for (CmsRelation relation : infoEntry.getRelations()) {
                        try {
                            CmsResource theResource = relation.getSource(m_cms, CmsResourceFilter.ALL);
                            CmsPublishResourceInfo info = new CmsPublishResourceInfo(
                                Messages.get().getBundle(m_workplaceLocale).key(Messages.GUI_BROKEN_LINK_ONLINE_0),
                                CmsPublishResourceInfo.Type.BROKENLINK);
                            // HACK: GWT serialization does not like unmodifiable collections :(
                            // Collections.singletonList(resourceToBean(resource, info, false, null)));
                            ArrayList<CmsPublishResource> relatedList = new ArrayList<CmsPublishResource>();
                            relatedList.add(resourceToBean(resource, info, false, null));
                            CmsPublishResource pubRes = resourceToBean(theResource, null, false, relatedList);
                            resources.add(pubRes);
                        } catch (CmsException e) {
                            // should never happen
                            LOG.error(e.getLocalizedMessage(), e);
                        }
                    }
                } else {
                    try {
                        List<CmsPublishResource> related = new ArrayList<CmsPublishResource>();
                        for (CmsRelation relation : infoEntry.getRelations()) {
                            try {
                                CmsResource theResource = relation.getTarget(m_cms, CmsResourceFilter.ALL);
                                CmsPublishResource pubRes = resourceToBean(theResource, null, false, null);
                                related.add(pubRes);
                            } catch (CmsException e) {
                                CmsPublishResource pubRes = relationToBean(relation);
                                related.add(pubRes);
                                LOG.warn(e.getLocalizedMessage(), e);
                            }
                        }
                        CmsPublishResourceInfo info = new CmsPublishResourceInfo(
                            Messages.get().getBundle(m_workplaceLocale).key(Messages.GUI_RESOURCE_MISSING_ONLINE_0),
                            CmsPublishResourceInfo.Type.MISSING);
                        CmsPublishResource pubRes = resourceToBean(resource, info, false, related);
                        resources.add(pubRes);
                    } catch (Exception e) {
                        // should never happen
                        LOG.error(e.getLocalizedMessage(), e);
                    }
                }
            } catch (CmsException e) {
                // should never happen
                LOG.error(e.getLocalizedMessage(), e);
            }
        }

        return resources;
    }",Returns all broken resources.
"public void setElementId(int v) {
    if (DocumentElement_Type.featOkTst && ((DocumentElement_Type)jcasType).casFeat_ElementId == null)
      jcasType.jcas.throwFeatMissing(""ElementId"", ""ch.epfl.bbp.uima.types.DocumentElement"");
    jcasType.ll_cas.ll_setIntValue(addr, ((DocumentElement_Type)jcasType).casFeatCode_ElementId, v);}",setter for ElementId - sets
"public void setLinedata(String newLinedata) {
		String oldLinedata = linedata;
		linedata = newLinedata;
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, AfplibPackage.LINE_DATA__LINEDATA, oldLinedata, linedata));
	}",Sets the linedata value.
"public boolean lockerWaitingOn(Locker locker, Locker target)
    {
        //-------------------------------------------------------------
        // Locker can be waiting on at most one lock. If that lock
        // is held by target or if any of the holders of that lock
        // is waiting on the target then locker is waiting on target.
        //-------------------------------------------------------------

        Lock waitingOn = (Lock) waitTable.get(locker);

        if (waitingOn == null) {
            return false;
        }

        Enumeration holders = waitingOn.getHolders();
        while (holders.hasMoreElements()) {
            Locker next = (Locker) holders.nextElement();
            if (next == target) {
                return true;
            }
            if (lockerWaitingOn(next, target)) {
                return true;
            }
        }
        return false;
    }",Checks if a lock is waiting on a target.
"public com.google.api.ads.adwords.axis.v201809.cm.Image getHeaderImage() {
        return headerImage;
    }",Gets the headerImage value for this CdnImage.
"private static void addShutdownHook(final Logger log, final Process process, final File command) {
        Runtime.getRuntime().addShutdownHook(new Thread(command.getName()) {
            @Override
            public void run() {
                if (process != null) {
                    // Trying to determine if the process is alive
                    boolean alive = false;
                    try {
                        process.exitValue();
                    } catch (IllegalThreadStateException e) {
                        alive = true;
                    }

                    if (alive) {
                        log.info(""Terminating process %s"", command);
                        try {
                            process.destroy();
                        } catch (Exception e) {
                            log.error(""Failed to terminate process %s"", command);
                        }
                        /* Only available in Java 8: So disabled for now until we switch to Java 8
                        try {
                            if (process != null && process.isAlive()) {
                                process.destroyForcibly();
                            }
                        } catch (Exception e) {
                            log.error(""Failed to forcibly terminate process %s"", command);
                        }
                        */
                    }
                }
            }
        });
    }",Add a shutdown hook to the JVM.
"public Vector<Object> runReference(Vector<Object> referenceParams, String locale)
	{
		return serviceDelegator.runReference(referenceParams, locale);
	}",Run a reference.
"private <T> T read(final Class<T> rootType) throws Exception {
        StartElement start = advanceToStartElement();
        if (start.getName().equals(BEAN_QNAME) == false) {
            throw new IllegalArgumentException(""Expected root element 'bean' but found '"" + start.getName() + ""'"");
        }
        Attribute attr = start.getAttributeByName(TYPE_QNAME);
        if (attr == null && rootType == Bean.class) {
            throw new IllegalArgumentException(""Root element attribute must specify '"" + TYPE + ""'"");
        }
        Class<?> effectiveType = rootType;
        if (attr != null) {
            String typeStr = attr.getValue();
            effectiveType = SerTypeMapper.decodeType(typeStr, settings, null, knownTypes);
            if (rootType.isAssignableFrom(effectiveType) == false) {
                throw new IllegalArgumentException(""Specified root type is incompatible with XML root type: "" + rootType.getName() + "" and "" + effectiveType.getName());
            }
        }
        if (Bean.class.isAssignableFrom(effectiveType) == false) {
            throw new IllegalArgumentException(""Root type is not a Joda-Bean: "" + effectiveType.getName());
        }
        basePackage = effectiveType.getPackage().getName() + ""."";
        Object parsed = parseBean(effectiveType);
        return rootType.cast(parsed);
    }",Read a single instance of the specified type from the XML.
"private static void renewCCTokenAsync(final Jwt jwt) {
        // Not expired yet, try to renew async but let requests use the old token.
        logger.trace(""In renew window but token is not expired yet."");
        if(!jwt.isRenewing() || System.currentTimeMillis() > jwt.getEarlyRetryTimeout()) {
            jwt.setRenewing(true);
            jwt.setEarlyRetryTimeout(System.currentTimeMillis() + jwt.getEarlyRefreshRetryDelay());
            logger.trace(""Retrieve token async is called while token is not expired yet"");

            ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();

            executor.schedule(() -> {
                Result<Jwt> result = getCCTokenRemotely(jwt);
                if(result.isFailure()) {
                    // swallow the exception here as it is on a best effort basis.
                    logger.error(""Async retrieve token error with status: {}"", result.getError().toString());
                }
                //set renewing flag to false after response, doesn't matter if it's success or fail.
                jwt.setRenewing(false);
            }, 50, TimeUnit.MILLISECONDS);
            executor.shutdown();
        }
    }",Renew the CCToken asynchronously.
"private JsonObject affToJsonObject() {
        JsonObjectBuilder ob = Json.createObjectBuilder();
        if (client.getCAName() != null) {
            ob.add(HFCAClient.FABRIC_CA_REQPROP, client.getCAName());
        }
        if (this.updateName != null) {
            ob.add(""name"", updateName);
            this.updateName = null;
        } else {
            ob.add(""name"", name);
        }

        return ob.build();
    }",AFF to JsonObject.
"protected Session getWriteSession() throws CpoException {
    Session session;

    try {
      session = getWriteDataSource().getSession();
    } catch (Throwable t) {
      String msg = ""getWriteConnection(): failed"";
      logger.error(msg, t);
      throw new CpoException(msg, t);
    }

    return session;
  }",Get the write session
"private static void rangeCheck(int length, int fromIndex, int toIndex) {
        if (fromIndex > toIndex) {
            throw new IllegalArgumentException(""fromIndex("" + fromIndex + "") > toIndex("" + toIndex + "")"");
        }
        if (fromIndex < 0) {
            throw new ArrayIndexOutOfBoundsException(fromIndex);
        }
        if (toIndex > length) {
            throw new ArrayIndexOutOfBoundsException(toIndex);
        }
    }",rangeCheck This method checks if the fromIndex and toIndex are valid.
"@Override
    public final void onApplicationEvent(ApplicationLepProcessingEvent event) {
        LepProcessingEvent lepProcessingEvent = event.getLepProcessingEvent();
        if (lepProcessingEvent instanceof BeforeProcessingEvent) {
            onBeforeProcessingEvent(BeforeProcessingEvent.class.cast(lepProcessingEvent));
        } else if (lepProcessingEvent instanceof BeforeExecutionEvent) {
            onBeforeExecutionEvent(BeforeExecutionEvent.class.cast(lepProcessingEvent));
        } else if (lepProcessingEvent instanceof AfterExecutionEvent) {
            onAfterExecutionEvent(AfterExecutionEvent.class.cast(lepProcessingEvent));
        } else if (lepProcessingEvent instanceof AfterProcessingEvent) {
            onAfterProcessingEvent(AfterProcessingEvent.class.cast(lepProcessingEvent));
        } else {
            onOtherEvent(lepProcessingEvent);
        }
    }",Method called to handle application event.
"@Override
    public final void postInvoke(int id, EJSDeployedSupport s)
                    throws RemoteException
    {
        if (state == DESTROYED) {
            return;
        }
        ContainerTx tx = null;
        if (null == ivContainerTx) { //d170394
            tx = ivContainerTx;
        } else {
            tx = container.getCurrentTx(false);
        }

        //167937 - discard bean if BMT was started and is still active.

        if (tx != null && tx.isBmtActive(s.methodInfo))
        {
            // BMT is still active.  Discard bean and let the BeanManaged.postInvoke
            // do the rollback and throwing of the exception.
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
                Tr.debug(tc,
                         ""Stateless SB method is not allowed to leave a BMT active. "" +
                                         ""Discarding bean."");
            discard();
        }

        ivContainerTx = null;//d170394
    }",d170394 - d170394
"public static String[] getLibraryPaths() {
        String libraryPathString = System.getProperty(""java.library.path"");
        String pathSeparator = System.getProperty(""path.separator"");
        return libraryPathString.split(pathSeparator);
    }",Get the list of library paths.
"public static ContentSpec transform(final ContentSpecWrapper spec, final DataProviderFactory providerFactory,
            final boolean includeChecksum) {
        // local variables that are used to map transformed content
        Map<Integer, Node> nodes = new HashMap<Integer, Node>();
        Map<String, SpecTopic> topicTargets = new HashMap<String, SpecTopic>();
        List<CSNodeWrapper> relationshipFromNodes = new ArrayList<CSNodeWrapper>();
        List<Process> processes = new ArrayList<Process>();

        // Start the transformation
        final ContentSpec contentSpec = new ContentSpec();

        contentSpec.setId(spec.getId());
        transformGlobalOptions(spec, contentSpec);

        // Add all the levels/topics
        boolean localeFound = false;
        if (spec.getChildren() != null) {
            final List<CSNodeWrapper> childNodes = spec.getChildren().getItems();
            final HashMap<CSNodeWrapper, Node> levelNodes = new HashMap<CSNodeWrapper, Node>();
            for (final CSNodeWrapper childNode : childNodes) {
                if (childNode.getNodeType() == CommonConstants.CS_NODE_TOPIC) {
                    final SpecTopic topic = transformSpecTopic(childNode, nodes, topicTargets, relationshipFromNodes);
                    levelNodes.put(childNode, topic);
                } else if (childNode.getNodeType() == CommonConstants.CS_NODE_COMMENT) {
                    final Comment comment = transformComment(childNode);
                    levelNodes.put(childNode, comment);
                } else if (childNode.getNodeType() == CommonConstants.CS_NODE_COMMON_CONTENT) {
                    final CommonContent commonContent = transformCommonContent(childNode);
                    levelNodes.put(childNode, commonContent);
                } else if (childNode.getNodeType() == CommonConstants.CS_NODE_META_DATA || childNode.getNodeType() == CommonConstants
                        .CS_NODE_META_DATA_TOPIC) {
                    if (!IGNORE_META_DATA.contains(childNode.getTitle().toLowerCase())) {
                        final KeyValueNode<?> metaDataNode = transformMetaData(childNode, nodes, topicTargets, relationshipFromNodes);
                        levelNodes.put(childNode, metaDataNode);
                    }
                    if (CommonConstants.CS_LOCALE_TITLE.equalsIgnoreCase(childNode.getTitle())) {
                        localeFound = true;
                    }
                } else {
                    final Level level = transformLevel(childNode, nodes, topicTargets, relationshipFromNodes, processes);
                    levelNodes.put(childNode, level);
                }
            }

            // Sort the level nodes so that they are in the right order based on next/prev values.
            final LinkedHashMap<CSNodeWrapper, Node> sortedMap = CSNodeSorter.sortMap(levelNodes);

            // Add the child nodes to the content spec now that they are in the right order.
            boolean addToBaseLevel = false;
            final Iterator<Map.Entry<CSNodeWrapper, Node>> iter = sortedMap.entrySet().iterator();
            while (iter.hasNext()) {
                final Map.Entry<CSNodeWrapper, Node> entry = iter.next();

                // If a level or spec topic is found then start adding to the base level instead of the content spec
                if ((entry.getValue() instanceof Level || entry.getValue() instanceof SpecTopic) && !addToBaseLevel) {
                    addToBaseLevel = true;

                    // Add the locale if it wasn't specified
                    if (!localeFound) {
                        contentSpec.setLocale(spec.getLocale() == null ? null : spec.getLocale().getValue());
                    }

                    // Add a space between the base metadata and optional metadata
                    contentSpec.appendChild(new TextNode(""\n""));
                }

                // Add the node to the right component.
                if (addToBaseLevel) {
                    contentSpec.getBaseLevel().appendChild(entry.getValue());
                    // Add a new line to separate chapters/parts
                    if (isNodeASeparatorLevel(entry.getValue()) && iter.hasNext()) {
                        contentSpec.getBaseLevel().appendChild(new TextNode(""\n""));
                    }
                } else {
                    contentSpec.appendChild(entry.getValue());
                }
            }
        }

        // Apply the relationships to the nodes
        applyRelationships(contentSpec, nodes, topicTargets, relationshipFromNodes, processes, providerFactory);

        // Set the line numbers
        setLineNumbers(contentSpec, includeChecksum ? 2 : 1);

        return contentSpec;
    }",Transform a Content Spec object into a Content Spec object.
"public static Builder addValuesToAnnotationArgument(
      AnnotationTree annotation,
      String parameterName,
      Collection<String> newValues,
      VisitorState state) {
    if (annotation.getArguments().isEmpty()) {
      String parameterPrefix = parameterName.equals(""value"") ? """" : (parameterName + "" = "");
      return SuggestedFix.builder()
          .replace(
              annotation,
              annotation
                  .toString()
                  .replaceFirst(""\\(\\)"", ""("" + parameterPrefix + newArgument(newValues) + "")""));
    }
    Optional<ExpressionTree> maybeExistingArgument = findArgument(annotation, parameterName);
    if (!maybeExistingArgument.isPresent()) {
      return SuggestedFix.builder()
          .prefixWith(
              annotation.getArguments().get(0),
              parameterName + "" = "" + newArgument(newValues) + "", "");
    }

    ExpressionTree existingArgument = maybeExistingArgument.get();
    if (!existingArgument.getKind().equals(NEW_ARRAY)) {
      return SuggestedFix.builder()
          .replace(
              existingArgument, newArgument(state.getSourceForNode(existingArgument), newValues));
    }

    NewArrayTree newArray = (NewArrayTree) existingArgument;
    if (newArray.getInitializers().isEmpty()) {
      return SuggestedFix.builder().replace(newArray, newArgument(newValues));
    } else {
      return SuggestedFix.builder()
          .postfixWith(getLast(newArray.getInitializers()), "", "" + Joiner.on("", "").join(newValues));
    }
  }",Add values to an annotation argument.
"public void createPublishJob(CmsDbContext dbc, CmsPublishJobInfoBean publishJob) throws CmsException {

        getProjectDriver(dbc).createPublishJob(dbc, publishJob);
    }",Creates a publish job.
"public static Scsn cs_lu(Scs A, Scss S, float tol) {
        Scs L, U;
        Scsn N;
        float pivot, Lx[], Ux[], x[], a, t;
        int Lp[], Li[], Up[], Ui[], pinv[], xi[], q[], n, ipiv, k, top, p, i, col, lnz, unz;
        if (!Scs_util.CS_CSC(A) || S == null)
            return (null); /* check inputs */
        n = A.n;
        q = S.q;
        lnz = S.lnz;
        unz = S.unz;
        x = new float[n]; /* get float workspace */
        xi = new int[2 * n]; /* get int workspace */
        N = new Scsn(); /* allocate result */
        N.L = L = Scs_util.cs_spalloc(n, n, lnz, true, false); /* allocate result L */
        N.U = U = Scs_util.cs_spalloc(n, n, unz, true, false); /* allocate result U */
        N.pinv = pinv = new int[n]; /* allocate result pinv */
        Lp = L.p;
        Up = U.p;
        for (i = 0; i < n; i++)
            x[i] = 0; /* clear workspace */
        for (i = 0; i < n; i++)
            pinv[i] = -1; /* no rows pivotal yet */
        for (k = 0; k <= n; k++)
            Lp[k] = 0; /* no cols of L yet */
        lnz = unz = 0;
        for (k = 0; k < n; k++) /* compute L(:,k) and U(:,k) */
        {
            /* --- Triangular solve --------------------------------------------- */
            Lp[k] = lnz; /* L(:,k) starts here */
            Up[k] = unz; /* U(:,k) starts here */
            if (lnz + n > L.nzmax) {
                Scs_util.cs_sprealloc(L, 2 * L.nzmax + n);
            }
            if (unz + n > U.nzmax) {
                Scs_util.cs_sprealloc(U, 2 * U.nzmax + n);
            }
            Li = L.i;
            Lx = L.x;
            Ui = U.i;
            Ux = U.x;
            col = q != null ? (q[k]) : k;
            top = Scs_spsolve.cs_spsolve(L, A, col, xi, x, pinv, true); /* x = L\A(:,col) */
            /* --- Find pivot --------------------------------------------------- */
            ipiv = -1;
            a = -1;
            for (p = top; p < n; p++) {
                i = xi[p]; /* x(i) is nonzero */
                if (pinv[i] < 0) /* row i is not yet pivotal */
                {
                    if ((t = Math.abs(x[i])) > a) {
                        a = t; /* largest pivot candidate so far */
                        ipiv = i;
                    }
                } else /* x(i) is the entry U(pinv[i],k) */
                {
                    Ui[unz] = pinv[i];
                    Ux[unz++] = x[i];
                }
            }
            if (ipiv == -1 || a <= 0)
                return (null);
            if (pinv[col] < 0 && Math.abs(x[col]) >= a * tol)
                ipiv = col;
            /* --- Sivide by pivot ---------------------------------------------- */
            pivot = x[ipiv]; /* the chosen pivot */
            Ui[unz] = k; /* last entry in U(:,k) is U(k,k) */
            Ux[unz++] = pivot;
            pinv[ipiv] = k; /* ipiv is the kth pivot row */
            Li[lnz] = ipiv; /* first entry in L(:,k) is L(k,k) = 1 */
            Lx[lnz++] = 1;
            for (p = top; p < n; p++) /* L(k+1:n,k) = x / pivot */
            {
                i = xi[p];
                if (pinv[i] < 0) /* x(i) is an entry in L(:,k) */
                {
                    Li[lnz] = i; /* save unpermuted row in L */
                    Lx[lnz++] = x[i] / pivot; /* scale pivot column */
                }
                x[i] = 0; /* x [0.f.n-1] = 0 for next k */
            }
        }
        /* --- Finalize L and U ------------------------------------------------- */
        Lp[n] = lnz;
        Up[n] = unz;
        Li = L.i; /* fix row indices of L for final pinv */
        for (p = 0; p < lnz; p++)
            Li[p] = pinv[Li[p]];
        Scs_util.cs_sprealloc(L, 0); /* remove extra space from L and U */
        Scs_util.cs_sprealloc(U, 0);
        return N;
    }",Returns a copy of the specified Scsn object with the most likely error - prone problem.
"@Override
    public DeleteApplicationOutputResult deleteApplicationOutput(DeleteApplicationOutputRequest request) {
        request = beforeClientExecution(request);
        return executeDeleteApplicationOutput(request);
    }",Deletes an application s output.
"public static String doGet(String url, Map<String, String> params) throws IOException {
        return doGet(url, params, DEFAULT_CHARSET);
    }",Perform a HTTP GET request.
"public Connection connect(String url, Properties prop) throws SQLException {
		try {
			// assumes no port specified
			String host = url.replace(""jdbc:vanilladb://"", """");
			Registry reg = LocateRegistry.getRegistry(host);
			RemoteDriver rdvr = (RemoteDriver) reg.lookup(JdbcStartUp.RMI_REG_NAME);
			RemoteConnection rconn = rdvr.connect();
			return new JdbcConnection(rconn);
		} catch (Exception e) {
			throw new SQLException(e);
		}
	}",Creates a new Connection object.
"public XElement childElement(String name) {
        for (XElement e : children) {
            if (e.name.equals(name)) {
                return e;
            }
        }
        return null;
    }",Get the child element with the given name.
"public List<String> getFieldNames() {
		List<String> ret = new ArrayList<String>();
		DOType typ = this;
		while(typ != null) {
			ret.addAll(typ.getDeclaredFieldNames());
			typ = typ.getSuperType();
		}
		return ret;
	}",Returns a list of all field names declared in this type.
"@SuppressWarnings({ ""rawtypes"", ""unchecked"" })
    public void runThread(Object objJobDef)
    {
        if (objJobDef instanceof Task)
        {
            Task task = (Task)objJobDef;
            if (task.getApplication() == null)  // init()ed yet?
                task.initTask(this.getApplication(), null);     // No, Initialize it
            task.run();
        }
        else if ((objJobDef instanceof String) || (objJobDef instanceof Properties))
        {
            String strJobDef = null;
            Map<String,Object> properties = null;
            if (objJobDef instanceof String)
            {
                strJobDef = (String)objJobDef;
                properties = new Hashtable<String,Object>();
                Util.parseArgs(properties, strJobDef);
            }
            if (objJobDef instanceof Properties)
                properties = (Map)objJobDef;
            if (properties.get(""webStartPropertiesFile"") != null)
                properties = this.addPropertiesFile(properties);
            String strClass = (String)properties.get(Param.TASK);
            if (strClass == null)
                strClass = (String)properties.get(Param.APPLET); // Applets are also run as tasks
            Object job = ClassServiceUtility.getClassService().makeObjectFromClassName(strClass);
            if (job instanceof Task)
            {
                ((Task)job).initTask(this.getApplication(), properties);
                ((Task)job).run();
            }
            else if (job instanceof Applet)
            { // An applet
                //new JBaseFrame(""Applet"", (Applet)job);
            	System.out.println(""********** Applet task type needs to be fixed *********"");
            }
            else if (job instanceof Runnable)
            { // A thread (Is this okay?? I already have my own thread)
//x                         new Thread((Runnable)job).start();  // No, don't start another thread
                ((Runnable)job).run();  // This should be okay, as I already have my own thread
            }
            else
                Util.getLogger().warning(""Illegal job type passed to TaskScheduler: "" + job);
        }
        else if (objJobDef instanceof Runnable)
            ((Runnable)objJobDef).run();
        else
            Util.getLogger().warning(""Error: Illegal job type"");
    }",Run the thread.
"public T initInstance(T instance, ColumnList<String> columns) {
        for (com.netflix.astyanax.model.Column<String> column : columns) {
            Field field = fields.get(column.getName());
            if (field != null) { // otherwise it may be a column that was
                                 // removed, etc.
                Coercions.setFieldFromColumn(instance, field, column);
            }
        }
        return instance;
    }",Initialize the instance.
"private Criteria buildPrefetchCriteria(Collection ids, String[] fkCols, String[] itemFkCols,
            FieldDescriptor[] itemPkFields)
    {
        if (fkCols.length == 1 && itemFkCols.length == 1)
        {
            return buildPrefetchCriteriaSingleKey(ids, fkCols[0], itemFkCols[0], itemPkFields[0]);
        }
        else
        {
            return buildPrefetchCriteriaMultipleKeys(ids, fkCols, itemFkCols, itemPkFields);
        }

    }","Build a Criteria object for a
   ."
"public ServiceFactory getServiceFactory(AppContextWrapper sc) {
		ContainerWrapper containerWrapper = containerFinder.findContainer(sc);
		ServiceFactory serviceFactory = (ServiceFactory) containerWrapper.lookup(ComponentKeys.WEBSERVICE_FACTORY);
		return serviceFactory;
	}",Get the service factory from the container.
"public Combinator.Type getDerivingCombinatorType() {
    if (combinator == null) {
      return Combinator.Type.OTHER;
    } else {
      return combinator.getType();
    }
  }",Get the type of the combinator.
"public static QueryAction create(Client client, String sql) throws SqlParseException, SQLFeatureNotSupportedException {
		sql = sql.replaceAll(""\n"","" "");
        String firstWord = sql.substring(0, sql.indexOf(' '));
        switch (firstWord.toUpperCase()) {
			case ""SELECT"":
			    //zhongshu-comment 将sql字符串解析成AST，即SQLQueryExpr sqlExpr就是AST了，下面的代码就开始访问AST、从中获取token
				SQLQueryExpr sqlExpr = (SQLQueryExpr) toSqlExpr(sql);
                if(isMulti(sqlExpr)){//zhongshu-comment 判断是不是union查询，union查询两个select语句，btw：子查询也有多个select语句，至少2个
                    MultiQuerySelect multiSelect = new SqlParser().parseMultiSelect((SQLUnionQuery) sqlExpr.getSubQuery().getQuery());
                    handleSubQueries(client,multiSelect.getFirstSelect());
                    handleSubQueries(client,multiSelect.getSecondSelect());
                    return new MultiQueryAction(client, multiSelect);
                }
                else if(isJoin(sqlExpr,sql)){//zhongshu-comment join连接查询
                    JoinSelect joinSelect = new SqlParser().parseJoinSelect(sqlExpr);
                    handleSubQueries(client, joinSelect.getFirstTable());
                    handleSubQueries(client, joinSelect.getSecondTable());
                    return ESJoinQueryActionFactory.createJoinAction(client, joinSelect);
                }
                else {
                    //zhongshu-comment 大部分查询都是走这个分支，先看懂这个分支
                    Select select = new SqlParser().parseSelect(sqlExpr);
                    //todo 看不懂，测试了好几个常见的sql，都没有进去handleSubQueries该方法，那就先不理了，看别的
                    handleSubQueries(client, select);
                    return handleSelect(client, select);
                }
			case ""DELETE"":
                SQLStatementParser parser = createSqlStatementParser(sql);
				SQLDeleteStatement deleteStatement = parser.parseDeleteStatement();
				Delete delete = new SqlParser().parseDelete(deleteStatement);
				return new DeleteQueryAction(client, delete);
            case ""SHOW"":
                return new ShowQueryAction(client,sql);
			default:
				throw new SQLFeatureNotSupportedException(String.format(""Unsupported query: %s"", sql));
		}
	}",Create a new QueryAction object from the given SQL
"protected double getEdgeSimilarity(SparseMatrix sm, Edge e1, Edge e2) {
        // Determing the keystone (shared) node by the edges and the other two
        // impost (unshared) nodes.
        int keystone = -1;
        int impost1 = -1;
        int impost2 = -1;
        if (e1.from == e2.from) {
            keystone = e1.from;
            impost1 = e1.to;
            impost2 = e2.to;
        }
        else if (e1.from == e2.to) {
            keystone = e1.from;
            impost1 = e1.to;
            impost2 = e2.from;
        }
        else if (e2.to == e1.from) {
            keystone = e1.from;
            impost1 = e1.to;
            impost2 = e2.from;
        }
        else if (e1.to == e2.to) {
            keystone = e1.to;
            impost1 = e1.from;
            impost2 = e2.from;
        }
        else
            return 0d;

        // Determine the overlap between the neighbors of the impost nodes
        int[] impost1edges = getImpostNeighbors(sm, impost1);
        int[] impost2edges = getImpostNeighbors(sm, impost2);
        double similarity = Similarity.jaccardIndex(impost1edges, impost2edges);
        return similarity;
    }",Get the edge similarity of two edges in the sparse matrix.
"@Override
    public void subscribe(ListEngineDisplayListener<T> listener) {
        if (!listeners.contains(listener)) {
            listeners.add(listener);
        }
    }",Subscribe to a list engine display listener.
"public static JawrCacheManager getCacheManager(JawrConfig config, String resourceType) {

		String cacheMgrAttributeName = CACHE_ATTR_PREFIX + resourceType.toUpperCase() + CACHE_ATTR_SUFFIX;
		JawrCacheManager cacheManager = (JawrCacheManager) config.getContext().getAttribute(cacheMgrAttributeName);
		if (cacheManager == null) {
			String cacheManagerClass = config.getProperty(CACHE_PROPERTY_NAME, BasicCacheManager.class.getName());
			cacheManager = (JawrCacheManager) ClassLoaderResourceUtils.buildObjectInstance(cacheManagerClass,
					new Object[] { config });
			config.getContext().setAttribute(cacheMgrAttributeName, cacheManager);
		}
		return cacheManager;
	}",Returns the cache manager
"public boolean isPermittedAll(Collection<String> permissions) {
        for (boolean permitted : isPermitted(permissions.toArray(new String[permissions.size()]))) {
            if (!permitted) {
                return false;
            }
        }
        return true;
    }",Check if all the permissions are granted.
"public int getPrevOpcode(int offset) {
        if (offset < 0) {
            throw new IllegalArgumentException(""offset ("" + offset + "") must be nonnegative"");
        }
        if (offset >= prevOpcode.length || offset > sizePrevOpcodeBuffer) {
            return Const.NOP;
        }
        int pos = currentPosInPrevOpcodeBuffer - offset;
        if (pos < 0) {
            pos += prevOpcode.length;
        }
        return prevOpcode[pos];
    }",Gets the value of the previous opcode.
"@Override
  public void execute() throws BuildException {
    validate();

    if (allowUndefined) {
      values.add(null);
    }

    long permutedSeed = SeedUtils.parseSeedChain(random)[0];
    permutedSeed ^= new Random(executionId.incrementAndGet()).nextLong();

    StringValue pick = RandomPicks.randomFrom(new Random(permutedSeed), values);
    if (pick != null) {
      getProject().setProperty(propertyName, pick.toString());
    }
  }","Execute the
    task."
"@Nullable
  protected List<Match> addLegacyMatches(List <Match> existingSugMatches, String messageStr,
      boolean inMessage) {
    List<Match> sugMatch = new ArrayList<>();
    int pos = 0;
    int ind = 0;
    int matchCounter = 0;
    while (pos != -1) {
      pos = messageStr.indexOf('\\', ind);
      if (pos != -1 && messageStr.length() > pos && Character.isDigit(messageStr.charAt(pos + 1))) {
        if (pos == 0 || messageStr.charAt(pos - 1) != '\u0001') {
          Match mWorker = new Match(null, null, false, null,
              null, Match.CaseConversion.NONE, false, false, Match.IncludeRange.NONE);
          mWorker.setInMessageOnly(true);
          sugMatch.add(mWorker);
        } else if (messageStr.charAt(pos - 1) == '\u0001') { // real suggestion marker
          sugMatch.add(existingSugMatches.get(matchCounter));
          if (inMessage) {
            message.deleteCharAt(pos - 1 - matchCounter);
          } else {
            suggestionsOutMsg.deleteCharAt(pos - 1 - matchCounter);
          }
          matchCounter++;
        }
      }
      ind = pos + 1;
    }

    if (sugMatch.isEmpty()) {
      return existingSugMatches;
    }
    return sugMatch;
  }",Add the legacy matches.
"protected Sample createSampleObject(List<? extends ByteBuffer> nals) {
        byte[] sizeInfo = new byte[nals.size() * 4];
        ByteBuffer sizeBuf = ByteBuffer.wrap(sizeInfo);
        for (ByteBuffer b : nals) {
            sizeBuf.putInt(b.remaining());
        }

        ByteBuffer[] data = new ByteBuffer[nals.size() * 2];

        for (int i = 0; i < nals.size(); i++) {
            data[2 * i] = ByteBuffer.wrap(sizeInfo, i * 4, 4);
            data[2 * i + 1] = nals.get(i);
        }

        return new SampleImpl(data, getCurrentSampleEntry());
    }",Create a sample object from a list of ByteBuffers.
"private String getOptionsForLanguage(Locale setLocale) {

        // get available locales from the workplace manager
        List<Locale> locales = OpenCms.getWorkplaceManager().getLocales();
        StringBuffer resultBuffer = new StringBuffer();
        int counter = 0;
        Iterator<Locale> i = locales.iterator();
        while (i.hasNext()) {
            Locale currentLocale = i.next();
            // add all locales to the select box
            String language = currentLocale.getDisplayLanguage(setLocale);
            if (CmsStringUtil.isNotEmpty(currentLocale.getCountry())) {
                language = language + "" ("" + currentLocale.getDisplayCountry(setLocale) + "")"";
            }
            if (CmsStringUtil.isNotEmpty(currentLocale.getVariant())) {
                language = language + "" ("" + currentLocale.getDisplayVariant(setLocale) + "")"";
            }
            if (counter != 0) {
                resultBuffer.append(""|"");
            }
            resultBuffer.append(currentLocale.toString()).append("":"").append(language);
            counter++;
        }
        return resultBuffer.toString();
    }",Returns the options for the language.
"public boolean hasNewHeader(int position, boolean isReverseLayout) {
        if (indexOutOfBounds(position)) {
            return false;
        }

        int originalPosition = moPubRecyclerAdapter.getOriginalPosition(position);
        if (originalPosition < 0) {
            return false;
        }

        long headerId = mAdapter.getHeaderId(originalPosition);

        if (headerId < 0) {
            return false;
        }

        long nextItemHeaderId = -1;
        int nextItemPosition = originalPosition + (isReverseLayout ? 1 : -1);
        if (!indexOutOfBounds(nextItemPosition)) {
            nextItemHeaderId = mAdapter.getHeaderId(nextItemPosition);
        }
        int firstItemPosition = isReverseLayout ? moPubRecyclerAdapter.getItemCount() - 1 : 0;

        return originalPosition == firstItemPosition || headerId != nextItemHeaderId;
    }",Check if a header is new.
"private void finishData() {
        if (!savedChunks) {
            md5 = Util.toHex(messageDigester.digest());
            messageDigester = null;
            length = totalBytes;
            savedChunks = true;
            try {
                if (inputStream != null && closeStreamOnPersist) {
                    inputStream.close();
                }
            } catch (IOException e) {
                //ignore
            }
        }
    }",Finish the data.
"public Object getProperty(String property) {
        try {
            return getProxyBuilder().doGetProperty(property);
        } catch (MissingPropertyException mpe) {
            if ((getContext() != null) && (getContext().containsKey(property))) {
                return getContext().get(property);
            } else {
                try {
                    return getMetaClass().getProperty(this, property);
                } catch(MissingPropertyException mpe2) {
                    if(mpe2.getProperty().equals(property) && propertyMissingDelegate != null) {
                        return propertyMissingDelegate.call(new Object[]{property});
                    }
                    throw mpe2;
                }
            }
        }
    }",Gets the value of the specified property.
"public void addPossiblesEventsComplex() {
        Set<Scenario> scenarios = this.getScenarios();
        for (Scenario s : scenarios) {
            for (Class<? extends Event> c : s.getPossibleEventsOfNE().keySet()) {
                if (!this.getPossibleEventsOfNE().containsKey(c)) {
                    this.addPossibleEventsOfNE(c, s.getPossibleEventsOfNE()
                            .get(c));
                } else {
                    List<Set<NetworkElement>> elements = this
                            .getPossibleEventsOfNE().get(c);
                    // elements.addAll(s.getPossibleEventsOfNE().get(c));
                    for (Set<NetworkElement> sne : s.getPossibleEventsOfNE()
                            .get(c)) {
                        if (!elements.contains(sne))
                            elements.add(sne);
                    }
                    this.addPossibleEventsOfNE(c, elements);
                }
            }
            for (Class<? extends Event> c : s.getPossibleEventsOfScenario()
                    .keySet()) {
                if (!this.getPossibleEventsOfScenario().containsKey(c)) {
                    this.addPossibleEventsOfScenario(c, s
                            .getPossibleEventsOfScenario().get(c));
                } else {
                    List<Set<Scenario>> elements = this
                            .getPossibleEventsOfScenario().get(c);
                    // elements.addAll(s.getPossibleEventsOfScenario().get(c));
                    for (Set<Scenario> sne : s.getPossibleEventsOfScenario()
                            .get(c)) {
                        if (!elements.contains(sne))
                            elements.add(sne);
                    }
                    this.addPossibleEventsOfScenario(c, elements);
                }
            }
        }

    }",AddPossiblesEventsComplex Method.
"public java.io.OutputStream setAsciiStream(
            final long pos) throws SQLException {

        if (!this.createdByConnection) {

            /** @todo - Better error message */
            throw Util.notSupported();
        }
        checkValid(this.data);

        if (pos < MIN_POS || pos > MAX_POS) {
            throw Util.outOfRangeArgument(""pos: "" + pos);
        }

        return new java.io.ByteArrayOutputStream() {

            public synchronized void close() throws java.io.IOException {

                try {
                    JDBCClob.this.setString(pos,
                            new String(toByteArray(), ""US-ASCII""));
                } catch (SQLException se) {
                    throw new java.io.IOException(se.toString());
                } finally {
                    super.close();
                }
            }
        };
    }",This method is used to set a byte array to an ASCII stream.
"public void scanProperties(final boolean allProperties, final Consumer<Description> consumer)
		throws KNXException, InterruptedException
	{
		for (int index = 0; scan(index, allProperties, consumer) > 0; ++index);
	}",Scan properties.
"public static SparseVector fromMap(Map<Integer, ? extends Number> map, int length) {
        return CompressedVector.fromMap(map, length);
    }",Create a sparse vector from a map of integers to numbers.
"private int compare(Reference<E> e1, Reference<E> e2) {
        return comparator.compare(e1.element, e2.element);
    }",Compare two references.
"private void init(Reader reader) {
		names = new TreeSet<String>();
		failedLines = new LinkedHashMap<Integer,String>();

		BufferedReader br = null;

		try {

			br = new BufferedReader(reader);

			logger.info(""Reading ASTRAL file..."");

			String line = """";
			int i = 0;
			while ((line = br.readLine()) != null) {
				if (line.startsWith("">"")) {
					try {
						String scopId = line.split(""\\s"")[0].substring(1);
						names.add(scopId);
						if (i % 1000 == 0) {
							logger.debug(""Reading ASTRAL line for "" + scopId);
						}
						i++;
					} catch (RuntimeException e) {
						failedLines.put(i, line);
						logger.warn(""Couldn't read line "" + line, e);
					}
				}
			}

			br.close();

		} catch (IOException e) {
			throw new RuntimeException(""Couldn't read the input stream "", e);
		} finally {
			if (br != null) {
				try {
					br.close();
				} catch (IOException e) {
					logger.warn(""Could not close stream"", e);
				}
			}
		}

	}",Initializes the data structures.
"@Override
    public void validate() throws ConfigurationException {
        if (host == null || host.length() == 0) {
            this.host = ""localhost"";
        }
        if (port == null || port.length() == 0) {
            this.port = ""12345"";
        }
    }",Validate the configuration.
"@Override
  public void setupHadoopJobProperties() {
    if (getJobProps().containsKey(HADOOP_GLOBAL_OPTS)) {
      String hadoopGlobalOps = getJobProps().getString(HADOOP_GLOBAL_OPTS);
      if (getJobProps().containsKey(HADOOP_OPTS)) {
        String hadoopOps = getJobProps().getString(HADOOP_OPTS);
        getJobProps().put(HADOOP_OPTS, String.format(""%s %s"", hadoopOps, hadoopGlobalOps));
      } else {
        getJobProps().put(HADOOP_OPTS, hadoopGlobalOps);
      }
    }
  }",Set the hadoop job properties.
"private  static <T> double reduceByR( final double[] array, T object ) {
        try {

            Method method = Invoker.invokeReducerLongIntReturnLongMethod(object);


            double sum = 0;
            for ( double v : array ) {
                sum = (double) method.invoke(object, sum, v);

            }
            return sum;

        } catch (Throwable throwable) {
            return handle(Long.class, throwable, ""Unable to perform reduceBy"");
        }

    }",Reduce by R.
"@ForOverride
  String getCode(int startingIndent) {
    FormattingContext initialStatements = new FormattingContext(startingIndent);
    initialStatements.appendInitialStatements(this);

    FormattingContext outputExprs = new FormattingContext(startingIndent);
    if (this instanceof Expression) {
      outputExprs.appendOutputExpression((Expression) this);
      outputExprs.append(';').endLine();
    }

    return initialStatements.concat(outputExprs).toString();
  }",Get code for a single node.
"public void processUpdates(FacesContext context) {

        if (context == null) {
            throw new NullPointerException();
        }
        if (!isRendered()) {
            return;
        }

        pushComponentToEL(context, this);
        preUpdate(context);
        iterate(context, PhaseId.UPDATE_MODEL_VALUES);
        popComponentFromEL(context);
        // This is not a EditableValueHolder, so no further processing is required

    }",This method is called to process the UPDATE_MODEL_VALUES phase of the UIComponent. This method is called by the UIViewRoot when an update is being performed.
"public static int compareVersions(String v1, String v2) {
        String[] components1 = split(v1);
        String[] components2 = split(v2);
        int diff;
        int length = Math.min(components1.length, components2.length);
        for (int i = 0; i < length; i++) {
            String s1 = components1[i];
            String s2 = components2[i];
            Integer i1 = tryParseInteger(s1);
            Integer i2 = tryParseInteger(s2);
            if (i1 != null && i2 != null) {
                diff = i1.compareTo(i2);
            } else {
                // lets assume strings instead
                diff = s1.compareTo(s2);
            }
            if (diff != 0) {
                return diff;
            }
        }
        diff = Integer.compare(components1.length, components2.length);
        if (diff == 0) {
            if (v1 == v2) {
                return 0;
            }
            /* if v1 == null then v2 can't be null here (see 'if' above).
               So for v1 == null its always smaller than v2 */;
            return v1 != null ? v1.compareTo(v2) : -1;
        }
        return diff;
    }",Compare two sets of strings.
"private MappingProject toMappingProject(Entity mappingProjectEntity) {
    String identifier = mappingProjectEntity.getString(MappingProjectMetadata.IDENTIFIER);
    String name = mappingProjectEntity.getString(MappingProjectMetadata.NAME);
    int depth = Optional.ofNullable(mappingProjectEntity.getInt(DEPTH)).orElse(3);
    List<Entity> mappingTargetEntities =
        Lists.newArrayList(
            mappingProjectEntity.getEntities(MappingProjectMetadata.MAPPING_TARGETS));
    List<MappingTarget> mappingTargets = mappingTargetRepo.toMappingTargets(mappingTargetEntities);

    return new MappingProject(identifier, name, depth, mappingTargets);
  }",Converts a mapping project entity to a mapping project object.
"public String getString(int index)
  {
    Object value = _values[index - 1];

    if (value != null) {
      return value.toString();
    }
    else {
      return null;
    }
  }",Gets the string value at the specified index.
"@Override
    public void visitCode(Code obj) {
        Method m = getMethod();
        String name = m.getName();
        String signature = m.getSignature();

        if (""equals"".equals(name) && SignatureBuilder.SIG_OBJECT_TO_BOOLEAN.equals(signature) && prescreen(m)) {
            stack.resetForMethodEntry(this);
            super.visitCode(obj);
        }
    }",overrides the visitor to reset the stack
"protected static CfDef cfdefFromString(String st) throws IOException
    {
        assert st != null;
        TDeserializer deserializer = new TDeserializer(new TBinaryProtocol.Factory());
        CfDef cfDef = new CfDef();
        try
        {
            deserializer.deserialize(cfDef, Hex.hexToBytes(st));
        }
        catch (TException e)
        {
            throw new IOException(e);
        }
        return cfDef;
    }",Convert a string to a CFDef object.
"public ConnectionManager onError(ErrorListener listener) {
        this.errorListener = listener;
        for (DataSiftConnection conn : connections) {
            conn.setErrorListener(listener);
        }
        return this;
    }",Sets the error listener for all connections.
"public static List<CommerceWishListItem> findByCW_CP(
		long commerceWishListId, long CProductId, int start, int end,
		OrderByComparator<CommerceWishListItem> orderByComparator) {
		return getPersistence()
				   .findByCW_CP(commerceWishListId, CProductId, start, end,
			orderByComparator);
	}",Returns a range of commerce wish list items where CProductId = CProductId and start and end = 0.
"public void setProperty(String key, String value)
    {
    	if (m_properties == null)
    		m_properties = new Properties();
    	m_properties.setProperty(key, value);
    }",Sets a property in the XML document.
"public void setFormatForDatesBeforeCommonEra(DateTimeFormatter formatForDatesBeforeCommonEra) {
        this.formatForDatesBeforeCommonEraStrict
            = formatForDatesBeforeCommonEra.withResolverStyle(ResolverStyle.STRICT);
        if (parentDatePicker != null) {
            parentDatePicker.setTextFieldToValidStateIfNeeded();
        }
    }",setFormatForDatesBeforeCommonEra This method will set the value of the formatForDatesBeforeCommonEra property.
"public void releaseConnection(SQLiteConnection connection) {
        synchronized (mLock) {
            AcquiredConnectionStatus status = mAcquiredConnections.remove(connection);
            if (status == null) {
                throw new IllegalStateException(""Cannot perform this operation ""
                        + ""because the specified connection was not acquired ""
                        + ""from this pool or has already been released."");
            }

            if (!mIsOpen) {
                closeConnectionAndLogExceptionsLocked(connection);
            } else if (connection.isPrimaryConnection()) {
                if (recycleConnectionLocked(connection, status)) {
                    assert mAvailablePrimaryConnection == null;
                    mAvailablePrimaryConnection = connection;
                }
                wakeConnectionWaitersLocked();
            } else if (mAvailableNonPrimaryConnections.size() >= mMaxConnectionPoolSize - 1) {
                closeConnectionAndLogExceptionsLocked(connection);
            } else {
                if (recycleConnectionLocked(connection, status)) {
                    mAvailableNonPrimaryConnections.add(connection);
                }
                wakeConnectionWaitersLocked();
            }
        }
    }",Release a connection from the pool.
"public IntegerConstant getIntegerByValue(int value)
  {
    for (int i = 0; i < _entries.size(); i++) {
      ConstantPoolEntry entry = _entries.get(i);

      if (! (entry instanceof IntegerConstant))
        continue;

      IntegerConstant integerEntry = (IntegerConstant) entry;

      if (integerEntry.getValue() == value)
        return integerEntry;
    }

    return null;
  }",Gets the IntegerConstant object for the given value.
"protected void activate(ComponentContext context) throws Throwable {
        if (TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_CORE.isLoggable(Level.FINER)) {
            LoggingUtil.SESSION_LOGGER_CORE.entering(CLASS_NAME, ""activate"", context);
        }
        this.context = context;
        if(sessionStoreService == null && this.foundSessionStoreServiceConfig()) {
            if (TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_CORE.isLoggable(Level.FINE)) {
                LoggingUtil.SESSION_LOGGER_CORE.logp(Level.FINE, CLASS_NAME, ""activate"", ""Will not register default SessionManager service because a SesionStoreService will be available soon"");
            }
        } else {
            this.registerSessionManager();            
        }
        if (TraceComponent.isAnyTracingEnabled() && LoggingUtil.SESSION_LOGGER_CORE.isLoggable(Level.FINER)) {
            LoggingUtil.SESSION_LOGGER_CORE.exiting(CLASS_NAME, ""activate"");
        }
    }",This method is called by the OSGi framework to activate the SessionManager
"public <N, S extends Session<L>> void discoverChildren(
            Resource<L> parent,
            ResourceType<L> childType,
            Session<L> session,
            EndpointService<L, S> service,
            Consumer<Resource<L>> resourceConsumer) {

        try {

            L parentLocation = parent != null ? parent.getLocation() : null;
            log.debugf(""Discovering children of [%s] of type [%s]"", parent, childType);
            final L childQuery = session.getLocationResolver().absolutize(parentLocation, childType.getLocation());
            Map<L, N> nativeResources = session.getDriver().fetchNodes(childQuery);

            for (Map.Entry<L, N> entry : nativeResources.entrySet()) {
                L location = entry.getKey(); // this is the unique DMR address for this resource
                String resourceName = session.getLocationResolver().applyTemplate(childType.getResourceNameTemplate(),
                        location, session.getEndpoint().getName());
                ID id = InventoryIdUtil.generateResourceId(
                        session.getFeedId(),
                        session.getEndpoint(),
                        location.toString());
                Builder<L> builder = Resource.<L> builder()
                        .id(id)
                        .name(new Name(resourceName))
                        .location(location)
                        .type(childType);

                if (parent != null) {
                    builder.parent(parent);
                }

                // get the configuration of the resource
                discoverResourceConfiguration(id, childType, location, entry.getValue(), builder, session);

                // populate the metrics based on the resource's type
                addMetricInstances(id, childType, location, entry.getValue(), builder, session);

                // build the resource now - we might need it to generate metric IDs
                Resource<L> resource = builder.build();

                // The resource is built (and measurement instances assigned to it) so we can generate family names/labels
                for (MeasurementInstance<L, MetricType<L>> instance : resource.getMetrics()) {
                    instance.setMetricFamily(service.generateMetricFamily(instance));
                    instance.setMetricLabels(service.generateMetricLabels(instance));
                }

                log.debugf(""Discovered resource [%s]"", resource);

                // tell our consumer about our new resource
                if (resourceConsumer != null) {
                    resourceConsumer.accept(resource);
                }

                // recursively discover children of child types
                Set<ResourceType<L>> childTypes = session.getResourceTypeManager()
                        .getChildren(childType);
                for (ResourceType<L> nextLevelChildType : childTypes) {
                    discoverChildren(resource, nextLevelChildType, session, service, resourceConsumer);
                }

            }
        } catch (Exception e) {
            log.errorFailedToDiscoverResources(e, session.getEndpoint());
            resourceConsumer.report(e);
        }
    }",Discover children of a resource.
"@Override
  public Double min11(Double arg1, Double arg2) {
    if (arg1 == null || arg2 == null) {
      return Double.NaN;
    } else {
      return Math.min(arg1, arg2);
    }
  }",Method min11.
"@Override
    public String get(Object key) {
        if (containsKey(key)) {
            return super.get(key);
        }
        return null;
    }",Override to return the value of the key.
"@Benchmark
  @BenchmarkMode(Mode.AverageTime)
  @OutputTimeUnit(TimeUnit.NANOSECONDS)
  @Fork
  public void manual(final Blackhole blackhole) {
    MoreExecutors.directExecutor().execute(Context.current().wrap(new MyRunnable(blackhole)));
  }",Benchmarks a single node in the cluster.
"@Deprecated
  public static <T extends Activity> T setupActivity(Class<T> activityClass) {
    return buildActivity(activityClass).setup().get();
  }",Setup an activity.
"public static void installInOneColumn(JTable table, int colViewIndex, int alignment) {
        TableColumn tableColumn = table.getColumnModel().getColumn(colViewIndex);

        TableCellRenderer headerRenderer = tableColumn.getHeaderRenderer();
        if (headerRenderer == null) {
            headerRenderer = table.getTableHeader().getDefaultRenderer();
        }
        if (!(headerRenderer instanceof  RendererAlignmentDecorator)) {  // Don't install a redundant decorator.
            tableColumn.setHeaderRenderer(new RendererAlignmentDecorator(headerRenderer, alignment));
        }

        TableCellRenderer cellRenderer = tableColumn.getCellRenderer();
        if (cellRenderer == null) {
            cellRenderer = table.getDefaultRenderer(table.getColumnClass(colViewIndex));
        }
        if (!(cellRenderer instanceof RendererAlignmentDecorator)) {  // Don't install a redundant decorator.
            tableColumn.setCellRenderer(new RendererAlignmentDecorator(cellRenderer, alignment));
        }
    }",Installs a decorator in one column.
"public boolean checkRootingDevice() {
		boolean isRootingFlag = false;
		BufferedReader reader = null;
		try {
			Process process = Runtime.getRuntime().exec(""find / -name su"");

			reader = new BufferedReader(new InputStreamReader(
					process.getInputStream()));
			
			String result = reader.readLine();
			if (result == null) {
				Log.d(TAG, ""Failed to execute find command to check if a file which is evidence of root exists"");
				throw new RuntimeException(""Unable to check if device is rooted"");
			}
				
			if (result.contains(""/su"") == true) {
				isRootingFlag = true;
			}

		} catch (Exception e) {
			isRootingFlag = false;
		} finally {
			if (reader != null) {
				try {
					reader.close();
				} catch (IOException e) {
					Log.d(TAG, ""Error occured while closing input stream"");
				}
			}
		}

		if (!isRootingFlag) {
			isRootingFlag = checkRootingFiles(PLACES);
		}

		return isRootingFlag;
	}",Checks if the device is rooted.
"@SafeVarargs
  public static <T> Iterable<T> concat(Iterable<? extends T>... inputs) {
    return FluentIterable.concat(inputs);
  }",Concatenates the given iterable objects into a single iterable.
"public void put(byte[] data, String remoteFileName, String remoteTargetDirectory) throws IOException {
        put(data, remoteFileName, remoteTargetDirectory, ""0600"");
    }",Put a byte array into the cache.
"private Node parseParamTypeExpression(JsDocToken token) {
    boolean restArg = false;
    if (token == JsDocToken.ELLIPSIS) {
      token = next();
      if (token == JsDocToken.RIGHT_CURLY) {
        restoreLookAhead(token);
        // EMPTY represents the UNKNOWN type in the Type AST.
        return wrapNode(Token.ELLIPSIS, IR.empty());
      }
      restArg = true;
    }

    Node typeNode = parseTopLevelTypeExpression(token);
    if (typeNode != null) {
      skipEOLs();
      if (restArg) {
        typeNode = wrapNode(Token.ELLIPSIS, typeNode);
      } else if (match(JsDocToken.EQUALS)) {
        next();
        skipEOLs();
        typeNode = wrapNode(Token.EQUALS, typeNode);
      }
    }

    return typeNode;
  }",Parse a param type expression.
"public static List<Window> windows(String words, @NonNull TokenizerFactory tokenizerFactory, int windowSize,
                    WordVectors vectors) {
        Tokenizer tokenizer = tokenizerFactory.create(words);
        List<String> list = new ArrayList<>();
        while (tokenizer.hasMoreTokens()) {
            String token = tokenizer.nextToken();

            // if we don't have UNK word defined - we have to skip this word
            if (vectors.getWordVectorMatrix(token) != null)
                list.add(token);
        }

        if (list.isEmpty())
            throw new IllegalStateException(""No tokens found for windows"");

        return windows(list, windowSize);
    }",Returns a list of windows for the given words using the given tokenizer factory and word vectors.
"private void setupNNRelations(Entity entity) {
        Iterator<ForeignKey> i = getForeignKeys(entity).iterator();

        //
        // Our terminology and convention are as follow:
        //
        // INTERMEDIATE TABLE
        // Left Table <--------[left col config/fk left | right col configu/fk right]--------> Right table
        //
        // The forward relation (ie a collection of right entities) is on the left entity.
        // However, from a configuration standpoint, to make it easier to read, the xxxConfig used to configure the forward relation is a child
        // of the right column config. The xxxConfig to configure the inverse relation is a child of the left col config.
        //

        ForeignKey fkLeft = i.next();
        ForeignKey fkRight = i.next();

        // Let's prevent association to table that are filtered out.
        if (!cfg().hasTable(fkLeft.getImportedKey().getPkTableName())) {
            log.info(""Skip simple NN association carried by entity "" + entity.getName() + "". Reason: foreign key references an excluded table: ""
                    + fkLeft.toString());
            return;
        }

        if (!cfg().hasTable(fkRight.getImportedKey().getPkTableName())) {
            log.info(""Skip simple NN association carried by entity "" + entity.getName() + "". Reason: foreign key references an excluded table: ""
                    + fkRight.toString());
            return;
        }

        if (log.isInfoEnabled()) {
            log.info(""middle table: "" + entity.getTableName() + "" "" + getForeignKeys(entity).size() + "" "" + entity.getSimpleAttributes().getSize());
        }

        // first: look at natural order, the higher ordinal position is the inverse side by convention.
        Attribute attrLeft = entity.getAttributeByTableAndColumnName(entity.getTableName(), fkLeft.getImportedKey().getFkColumnName());
        Attribute attrRight = entity.getAttributeByTableAndColumnName(entity.getTableName(), fkRight.getImportedKey().getFkColumnName());

        if (attrLeft.getColumnConfig().getOrdinalPosition() > attrRight.getColumnConfig().getOrdinalPosition()) {
            ForeignKey fkTemp = fkLeft;
            fkLeft = fkRight;
            fkRight = fkTemp;

            attrLeft = attrRight;
            attrRight = null; // so we do not use it by mistake.
        }

        // Now that we have the real left side by convention, let's check if the user want to change the convention.
        if (attrLeft.getColumnConfig().getInverse() == TRUE) {
            ForeignKey fkTemp = fkLeft;
            fkLeft = fkRight;
            fkRight = fkTemp;
        }

        // TODO: support composite in many to many
        if (fkLeft.getSize() == 1 && fkRight.getSize() == 1) {

            // build intermediate relations to ease our pain (!)
            Relation middleToLeft = buildSimpleRelation(entity, fkLeft);
            Relation middleToRight = buildSimpleRelation(entity, fkRight);

            if (middleToRight.getFromAttribute().getColumnConfig().getManyToOneConfig() == null) {
                // many to many + inverse many to many
                buildIntermediateManyToManyManyToMany(middleToLeft, entity, middleToRight);
            } else {
                // MANY TO ONE with intermediate table
                buildIntermediateManyToOneOneToMany(middleToLeft, entity, middleToRight);
            }
            // TODO: intermediate one to one ...

            // mark this middle join entity
            entity.setManyToManyJoinEntity(true);
        } else {
            log.warn(""NN relations with composite FK is not supported. Skipping "" + entity.getTableName());
        }
    }",Setup the NN relations for the given entity.
"public static String signRequest(final URL url, final String yourGooglePrivateKeyString)
		throws NoSuchAlgorithmException, InvalidKeyException, UnsupportedEncodingException,
		URISyntaxException
	{

		// Retrieve the proper URL components to sign
		final String resource = url.getPath() + '?' + url.getQuery();

		// Get an HMAC-SHA1 signing key from the raw key bytes
		final SecretKeySpec sha1Key = new SecretKeySpec(
			convertToKeyByteArray(yourGooglePrivateKeyString), ""HmacSHA1"");

		// Get an HMAC-SHA1 Mac instance and initialize it with the HMAC-SHA1
		// key
		final Mac mac = Mac.getInstance(""HmacSHA1"");
		mac.init(sha1Key);

		// compute the binary signature for the request
		final byte[] sigBytes = mac.doFinal(resource.getBytes());

		// base 64 encode the binary signature
		// Base64 is JDK 1.8 only - older versions may need to use Apache
		// Commons or similar.
		String signature = Base64.getEncoder().encodeToString(sigBytes);

		// convert the signature to 'web safe' base 64
		signature = signature.replace('+', '-');
		signature = signature.replace('/', '_');
		final String signedRequestPath = resource + ""&signature="" + signature;
		final String urlGoogleMapSignedRequest = url.getProtocol() + ""://"" + url.getHost()
			+ signedRequestPath;
		return urlGoogleMapSignedRequest;
	}",Sign a URL using the Google Private Key
"public void setVersion(String version) {

        m_number = 0L;
        if ((version == null) || (version.charAt(0) == '.') || (version.charAt(version.length() - 1) == '.')) {
            throw new CmsIllegalArgumentException(Messages.get().container(Messages.ERR_NOT_NUMBER_0));
        }
        String[] split = CmsStringUtil.splitAsArray(version, '.');
        m_dots = split.length;
        if (m_dots > 4) {
            throw new CmsIllegalArgumentException(
                Messages.get().container(Messages.ERR_INVALID_VERSION_LENGTH_1, version));
        }
        String[] numbers = new String[5];
        System.arraycopy(split, 0, numbers, 1, m_dots);
        numbers[0] = ""1"";
        for (int i = 1 + m_dots; i < 5; i++) {
            numbers[i] = ""0"";
        }
        for (int i = numbers.length - 1; i >= 0; i--) {
            try {
                int number = Integer.valueOf(numbers[numbers.length - i - 1]).intValue();

                if ((number > 999) || (number < 0)) {
                    throw new CmsIllegalArgumentException(
                        Messages.get().container(Messages.ERR_INVALID_VERSION_SUBNUMBER_1, new Integer(number)));
                }
                m_number = ((long)Math.pow(1000.0, i) * number) + m_number;
            } catch (NumberFormatException e) {
                // no valid version provided
                throw new CmsIllegalArgumentException(Messages.get().container(Messages.ERR_NOT_NUMBER_0));
            }
        }

        setVersion(m_number);
    }",Sets the version of the application.
"public Configuration getConfigurationByKey(String configurationKeyParam)
    {
        Configuration configuration = new Configuration();

        configuration.setKey(configurationKeyParam);

        if(this.serviceTicket != null)
        {
            configuration.setServiceTicket(this.serviceTicket);
        }

        return new Configuration(this.postJson(
                configuration, WS.Path.Configuration.Version1.getByKey()));
    }",Get a configuration object by key.
"@Pure
	public static String[] extensions(URL filename) {
		if (filename == null) {
			return new String[0];
		}
		final String largeBasename = largeBasename(filename);
		final String[] parts = largeBasename.split(Pattern.quote(Character.toString(getFileExtensionCharacter())));
		if (parts.length <= 1) {
			return new String[0];
		}
		final String[] result = new String[parts.length - 1];
		for (int i = 0; i < result.length; ++i) {
			result[i] = decodeHTMLEntities(parts[i + 1]);
		}
		return result;
	}",Returns the extensions of the given file.
"public TimeSeries pick(TimeScale timeScale) {
        switch (timeScale) {
        case HOUR:  return hour;
        case MIN:   return min;
        case SEC10: return sec10;
        default:    throw new AssertionError();
        }
    }",Picks a TimeSeries from this TimeSeries.
"public RolloutGroupConditionBuilder successCondition(final RolloutGroupSuccessCondition condition,
            final String expression) {
        conditions.setSuccessCondition(condition);
        conditions.setSuccessConditionExp(expression);
        return this;
    }",Sets the success condition.
"public int getAndAdd(final int key, final int amount)
    {
        final int[] entries = this.entries;
        final int initialValue = this.initialValue;
        @DoNotSub final int mask = entries.length - 1;
        @DoNotSub int index = Hashing.evenHash(key, mask);
        int oldValue = initialValue;

        while (entries[index + 1] != initialValue)
        {
            if (entries[index] == key)
            {
                oldValue = entries[index + 1];
                break;
            }

            index = next(index, mask);
        }

        if (amount != 0)
        {
            final int newValue = oldValue + amount;
            entries[index + 1] = newValue;

            if (oldValue == initialValue)
            {
                ++size;
                entries[index] = key;
                increaseCapacity();
            }
            else if (newValue == initialValue)
            {
                size--;
                compactChain(index);
            }
        }

        return oldValue;
    }",Gets the getAndAdd method.
"final int getGregorianYearFromFixedDate(long fixedDate) {
        long d0;
        int  d1, d2, d3, d4;
        int  n400, n100, n4, n1;
        int  year;

        if (fixedDate > 0) {
            d0 = fixedDate - 1;
            n400 = (int)(d0 / 146097);
            d1 = (int)(d0 % 146097);
            n100 = d1 / 36524;
            d2 = d1 % 36524;
            n4 = d2 / 1461;
            d3 = d2 % 1461;
            n1 = d3 / 365;
            d4 = (d3 % 365) + 1;
        } else {
            d0 = fixedDate - 1;
            n400 = (int)CalendarUtils.floorDivide(d0, 146097L);
            d1 = (int)CalendarUtils.mod(d0, 146097L);
            n100 = CalendarUtils.floorDivide(d1, 36524);
            d2 = CalendarUtils.mod(d1, 36524);
            n4 = CalendarUtils.floorDivide(d2, 1461);
            d3 = CalendarUtils.mod(d2, 1461);
            n1 = CalendarUtils.floorDivide(d3, 365);
            d4 = CalendarUtils.mod(d3, 365) + 1;
        }
        year = 400 * n400 + 100 * n100 + 4 * n4 + n1;
        if (!(n100 == 4 || n1 == 4)) {
            ++year;
        }
        return year;
    }",Gets the Gregorian year from a fixed date.
"public DecisionDefinitionEntity getPreviousDefinition() {
    DecisionDefinitionEntity previousDecisionDefinition = null;

    String previousDecisionDefinitionId = getPreviousDecisionDefinitionId();
    if (previousDecisionDefinitionId != null) {

      previousDecisionDefinition = loadDecisionDefinition(previousDecisionDefinitionId);

      if (previousDecisionDefinition == null) {
        resetPreviousDecisionDefinitionId();
        previousDecisionDefinitionId = getPreviousDecisionDefinitionId();

        if (previousDecisionDefinitionId != null) {
          previousDecisionDefinition = loadDecisionDefinition(previousDecisionDefinitionId);
        }
      }
    }

    return previousDecisionDefinition;
  }",Get the previous decision definition.
"public void delete(Property.Builder property,
			Collection<String> channelNames) throws ChannelFinderException {
		for (String channel : channelNames) {
			delete(property, channel);
		}
	}",Delete a collection of entities from a property.
"public EClass getGBAR() {
		if (gbarEClass == null) {
			gbarEClass = (EClass)EPackage.Registry.INSTANCE.getEPackage(AfplibPackage.eNS_URI).getEClassifiers().get(438);
		}
		return gbarEClass;
	}",Get the GBAREClass.
"public String get(ConfigKey pKey) {
        String value = globalConfig.get(pKey);
        if (value == null) {
            value = pKey.getDefaultValue();
        }
        return value;
    }",Gets the value of a class attribute.
"@Override
    public void afterWrite(List<? extends SnapshotContentItem> items) {
        //be sure not to count snapshot prop file.
        int size = items.size();
        for (SnapshotContentItem item : items) {
            if (item.getContentId().equals(Constants.SNAPSHOT_PROPS_FILENAME)) {
                size -= 1;
            }
        }
        addToItemsRead(size);
    }",After writing the content items to the file we need to count the number of snapshot prop files.
"public DescribeRepositoriesResult withRepositories(Repository... repositories) {
        if (this.repositories == null) {
            setRepositories(new java.util.ArrayList<Repository>(repositories.length));
        }
        for (Repository ele : repositories) {
            this.repositories.add(ele);
        }
        return this;
    }",A list of repositories to describe.
"public T authentication(String username, String password, boolean allowAnyHost) {
        if (StringUtils.isNotBlank(username)) {
            if (defaultHost == null || StringUtils.isBlank(defaultHost.getHostName())) {
                throw new IllegalStateException(""Cannot configure authentication when host is not set."");
            }
            AuthScope authscope = allowAnyHost ?
                    new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT, AuthScope.ANY_REALM) :
                    new AuthScope(defaultHost.getHostName(), AuthScope.ANY_PORT, AuthScope.ANY_REALM);
            credsProvider.setCredentials(authscope, new UsernamePasswordCredentials(username, password));
        }
        return self();
    }",Configure authentication.
"public GVRShaderId getShaderType(Class<? extends GVRShader> shaderClass)
    {
        GVRShaderId shaderId = mShaderTemplates.get(shaderClass);

        if (shaderId == null)
        {
            GVRContext ctx = getGVRContext();
            shaderId = new GVRShaderId(shaderClass);
            mShaderTemplates.put(shaderClass, shaderId);
            shaderId.getTemplate(ctx);
        }
        return shaderId;
    }",Get the GVRShaderId for a given shader class.
"public QueueConsumer createQueueTextMessageListener(final String topic, final ConsumerCallback<String> messageCallback)
    {
        Preconditions.checkState(connectionFactory != null, ""connection factory was never injected!"");
        return new QueueConsumer(connectionFactory, jmsConfig, topic, new TextMessageConsumerCallback(messageCallback));
    }",Creates a queue consumer that will receive messages from a topic.
"public Observable<DataBoxEdgeDeviceInner> beginCreateOrUpdateAsync(String deviceName, String resourceGroupName, DataBoxEdgeDeviceInner dataBoxEdgeDevice) {
        return beginCreateOrUpdateWithServiceResponseAsync(deviceName, resourceGroupName, dataBoxEdgeDevice).map(new Func1<ServiceResponse<DataBoxEdgeDeviceInner>, DataBoxEdgeDeviceInner>() {
            @Override
            public DataBoxEdgeDeviceInner call(ServiceResponse<DataBoxEdgeDeviceInner> response) {
                return response.body();
            }
        });
    }",Creates or updates a CDN image.
"public static void main(String[] args) throws Exception {
      String hostPort = """";
      if (args.length > 0) {
        hostPort = args[0];
      }
      JmxCollector jc = new JmxCollector((""{""
      + ""`hostPort`: `"" + hostPort + ""`,""
      + ""}"").replace('`', '""'));
      for(MetricFamilySamples mfs : jc.collect()) {
        System.out.println(mfs);
      }
    }",Main method to run the CRA - D2 test.
"public ServiceFuture<List<DetectorDefinitionInner>> listSiteDetectorsSlotAsync(final String resourceGroupName, final String siteName, final String diagnosticCategory, final String slot, final ListOperationCallback<DetectorDefinitionInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listSiteDetectorsSlotSinglePageAsync(resourceGroupName, siteName, diagnosticCategory, slot),
            new Func1<String, Observable<ServiceResponse<Page<DetectorDefinitionInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<DetectorDefinitionInner>>> call(String nextPageLink) {
                    return listSiteDetectorsSlotNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }",Gets a list of detectors in a site.
"public void setIfexistsall(String elements) {

        if (elements != null) {
            m_elementlist = elements;
            m_checkall = true;
            m_checknone = false;
        }
    }",Sets the elementlist and checknone flags.
"public void setTitle(java.lang.String title) {
        getStateHelper().put(PropertyKeys.title, title);
        handleAttribute(""title"", title);
    }",Sets the title of the application.
"private int divadd(int[] a, int[] result, int offset) {
        long carry = 0;

        for (int j=a.length-1; j >= 0; j--) {
            long sum = (a[j] & LONG_MASK) +
                       (result[j+offset] & LONG_MASK) + carry;
            result[j+offset] = (int)sum;
            carry = sum >>> 32;
        }
        return (int)carry;
    }",divadd - add - add
"public static <T> Class<T> box(Class<T> type)
	{
		Class<T> boxedType;
		
		if (Boolean.TYPE.equals(type))
		{
			boxedType = (Class<T>) Boolean.class;
		}
		else if (Byte.TYPE.equals(type))
		{
			boxedType = (Class<T>) Byte.class;
		}
		else if (Short.TYPE.equals(type))
		{
			boxedType = (Class<T>) Short.class;
		}
		else if (Integer.TYPE.equals(type))
		{
			boxedType = (Class<T>) Integer.class;
		}
		else if (Long.TYPE.equals(type))
		{
			boxedType = (Class<T>) Long.class;
		}
		else if (Character.TYPE.equals(type))
		{
			boxedType = (Class<T>) Character.class;
		}
		else if (Float.TYPE.equals(type))
		{
			boxedType = (Class<T>) Float.class;
		}
		else if (Double.TYPE.equals(type))
		{
			boxedType = (Class<T>) Double.class;
		}
		else
		{
			boxedType = type;
		}
		
		return boxedType;
	}",Returns the boxed type of the given type.
"@Override
    public Long strLen(byte[] key) {
        try {
            if (isPipelined()) {
                pipeline(new JedisResult(pipeline.strlen(key)));
                return null;
            }

            return client.strlen(key);
        } catch (Exception ex) {
            throw convertException(ex);
        }
    }",Get the length of a string in bytes.
"protected String getMessageFor(ThrowableFailureEvent event, Bundle arguments) {
        int msgResId = config.getMessageIdForThrowable(event.throwable);
        return config.resources.getString(msgResId);
    }",Get the message for a ThrowableFailureEvent.
"public PagedList<CloudJob> listJobs(DetailLevel detailLevel, Iterable<BatchClientBehavior> additionalBehaviors) throws BatchErrorException, IOException {
        JobListOptions jobListOptions = new JobListOptions();

        BehaviorManager bhMgr = new BehaviorManager(this.customBehaviors(), additionalBehaviors);
        bhMgr.appendDetailLevelToPerCallBehaviors(detailLevel);
        bhMgr.applyRequestBehaviors(jobListOptions);

        return this.parentBatchClient.protocolLayer().jobs().list(jobListOptions);
    }",Gets a list of jobs.
"public static GrailsApplication findApplication(ServletContext servletContext) {
        ApplicationContext wac = findApplicationContext(servletContext);
        if(wac != null) {
            return (GrailsApplication)wac.getBean(GrailsApplication.APPLICATION_ID);
        }
        return null;
    }",Find the GrailsApplication instance from the ServletContext.
"@InterfaceStability.Experimental
    @InterfaceAudience.Public
    public Single<JsonDocument> getFirstPrimaryOrReplica(final String id,
        final Bucket bucket, final long timeout) {
        return getFirstPrimaryOrReplica(id, bucket, timeout, timeout);
    }",Gets the first primary or replica document.
"protected void createAndAdd(Model model, String id, String localName)
	{
		BioPAXElement bpe = this.getFactory().create(localName, id);

		if (log.isTraceEnabled())
		{
			log.trace(""id:"" + id + "" "" + localName + "" : "" + bpe);
		}
		/* null might occur here,
		 * so the following is to prevent the NullPointerException
		 * and to continue the model assembling.
		 */
		if (bpe != null)
		{
			model.add(bpe);
		} else
		{
			log.warn(""null object created during reading. It might not be an official BioPAX class.ID: "" + id +
			         "" Class "" +
			         ""name "" + localName);
		}
	}",Creates and adds the BioPAX element to the model.
"public static void copyProperties(Object target, Object source) throws IkasoaException {
		Class<?> sourceClz = source.getClass(), targetClz = target.getClass();
		Field[] fields = sourceClz.getDeclaredFields();
		if (fields.length == 0)
			fields = sourceClz.getSuperclass().getDeclaredFields();
		for (short i = 0; i < fields.length; i++) {
			String fieldName = fields[i].getName();
			Field targetField = null;
			try {
				targetField = targetClz.getDeclaredField(fieldName);
			} catch (NoSuchFieldException e) {
				try {
					targetField = targetClz.getSuperclass().getDeclaredField(fieldName);
				} catch (NoSuchFieldException | SecurityException e1) {
					throw new IkasoaException(e1);
				}
			}
			if (fields[i].getType() == targetField.getType()) {
				String getMethodName = new StringBuilder(""get"").append(fieldName.substring(0, 1).toUpperCase())
						.append(fieldName.substring(1)).toString();
				String setMethodName = new StringBuilder(""set"").append(fieldName.substring(0, 1).toUpperCase())
						.append(fieldName.substring(1)).toString();
				Method getMethod, setMethod;
				try {
					try {
						getMethod = sourceClz.getDeclaredMethod(getMethodName, new Class[] {});
					} catch (NoSuchMethodException e) {
						getMethod = sourceClz.getSuperclass().getDeclaredMethod(getMethodName, new Class[] {});
					}
					try {
						setMethod = targetClz.getDeclaredMethod(setMethodName, fields[i].getType());
					} catch (NoSuchMethodException e) {
						setMethod = targetClz.getSuperclass().getDeclaredMethod(setMethodName, fields[i].getType());
					}
					setMethod.invoke(target, getMethod.invoke(source, new Object[] {}));
				} catch (IllegalAccessException | IllegalArgumentException | InvocationTargetException e) {
					throw new IkasoaException(e);
				} catch (NoSuchMethodException e) {
				} catch (Exception e) {
					log.warn(""Object copy failed : {}"", e.getMessage());
				}
			} else {
				throw new IkasoaException(""Object copy failed ! Attribute type error !"");
			}
		}
	}",Copy properties from source to target.
"private void checkPrimaryKey(ClassDescriptorDef classDef, String checkLevel) throws ConstraintException
    {
        if (CHECKLEVEL_NONE.equals(checkLevel))
        {
            return;
        }

        if (classDef.getBooleanProperty(PropertyHelper.OJB_PROPERTY_GENERATE_TABLE_INFO, true) &&
            classDef.getPrimaryKeys().isEmpty())
        {
            LogHelper.warn(true,
                           getClass(),
                           ""checkPrimaryKey"",
                           ""The class ""+classDef.getName()+"" has no primary key"");
        }
    }",Checks if the primary key is set.
"public void setLcLp(int lc, int lp) throws UnsupportedOptionsException {
        if (lc < 0 || lp < 0 || lc > LC_LP_MAX || lp > LC_LP_MAX
                || lc + lp > LC_LP_MAX)
            throw new UnsupportedOptionsException(
                    ""lc + lp must not exceed "" + LC_LP_MAX + "": ""
                    + lc + "" + "" + lp);

        this.lc = lc;
        this.lp = lp;
    }",Sets the LC and LP values for this class.
"@Override
	public EClass getIfcProtectiveDevice() {
		if (ifcProtectiveDeviceEClass == null) {
			ifcProtectiveDeviceEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)
					.getEClassifiers().get(480);
		}
		return ifcProtectiveDeviceEClass;
	}",Get the IfcProtectiveDeviceEClass attribute of the class.
"@Override
    public void injectionMetaDataCreated(InjectionMetaData injectionMetaData) throws InjectionException {

        // PI22432 Adding the judgement for null
        if (injectionMetaData == null)
            return;

        ModuleMetaData mmd = injectionMetaData.getModuleMetaData();

        if (mmd == null)
            return;

        JaxWsModuleMetaData jaxWsmoduleMetaData = JaxWsMetaDataManager.getJaxWsModuleMetaData(mmd);

        if (jaxWsmoduleMetaData == null) {
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""Unsupported Module, no JaxWsModuleMetaData is created for "" + mmd.getName() + "", Injection Processing for web service is ignored"");
            }
            return;
        }

        if (!jaxWsmoduleMetaData.getJ2EEName().equals(mmd.getJ2EEName())) {
            //Only process the injection event for the main module, e.g. EJB WS Router module and EJB module share the same JaxWsModuleMetaData
            //While, we only process the injection event if it is from EJB Module itself
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""Not main module for the JaxWsModuleMetaData {0} or the jaxWsModuleMetaData has been initialized, Injection Processing for web service is ignored"",
                         mmd.getName());
            }
            return;
        }

        List<Class<?>> injectionClasses = injectionMetaData.getComponentNameSpaceConfiguration().getInjectionClasses();
        if (injectionClasses != null) {
            for (Class<?> clazz : injectionClasses) {
                jaxWsmoduleMetaData.setReferenceContext(clazz, injectionMetaData.getReferenceContext());
            }
        }

//        try {
//            if (JaxWsUtils.isEJBModule(jaxWsmoduleMetaData.getModuleContainer())) {
//                //only one ReferenceContextInjectionInstanceInterceptor is needed in InstanceManager
//                InstanceInterceptor interceptor = jaxWsmoduleMetaData.getJaxWsInstanceManager().getInterceptor(ReferenceContextInjectionInstanceInterceptor.class.getName());
//                if (interceptor == null) {
//                    jaxWsmoduleMetaData.getJaxWsInstanceManager().addInterceptor(new ReferenceContextInjectionInstanceInterceptor(jaxWsmoduleMetaData.getReferenceContextMap()));
//                }
//            }
//        } catch (UnableToAdaptException e) {
//            throw new InjectionException(e);
//        }

    }",Called by the EJB container when the injection event is created.
"public static String simpleTemplateToRegEx(String template) {
		StringBuilder sb = new StringBuilder();
		Matcher m = TEMPLATE_PATTERN.matcher(template);
		int n = 0;
		while(m.find(n)) {
			if (m.start() != n) {
				throw new IllegalArgumentException(""Cannot tokenize ["" + template + ""]"");
			}
			String match = m.group();
			if (m.group(1) != null) {
				sb.append(match);
			}
			else if (m.group(2) != null) {
				sb.append(""\\s+"");
			}
			else if (m.group(3) != null) {
				sb.append('\\').append(match);
			}
			else {
				sb.append(match);
			}
			n = m.end();
		}
		return sb.toString();
	}",Convert a simple template to a regular expression.
"public void close() throws Exception {
        for (Entry<TransactionType, ShardingTransactionManager> entry : transactionManagerMap.entrySet()) {
            entry.getValue().close();
        }
    }",Close all sharding transaction managers.
"public static void applyMultiIconTo(Drawable icon, int iconColor, Drawable selectedIcon, int selectedIconColor, boolean tinted, ImageView imageView) {
        //if we have an icon then we want to set it
        if (icon != null) {
            //if we got a different color for the selectedIcon we need a StateList
            if (selectedIcon != null) {
                if (tinted) {
                    imageView.setImageDrawable(new PressedEffectStateListDrawable(icon, selectedIcon, iconColor, selectedIconColor));
                } else {
                    imageView.setImageDrawable(UIUtils.getIconStateList(icon, selectedIcon));
                }
            } else if (tinted) {
                imageView.setImageDrawable(new PressedEffectStateListDrawable(icon, iconColor, selectedIconColor));
            } else {
                imageView.setImageDrawable(icon);
            }
            //make sure we display the icon
            imageView.setVisibility(View.VISIBLE);
        } else {
            //hide the icon
            imageView.setVisibility(View.GONE);
        }
    }",Apply a multi icon to an imageView
"public static rewritepolicy_stats get(nitro_service service, String name) throws Exception{
		rewritepolicy_stats obj = new rewritepolicy_stats();
		obj.set_name(name);
		rewritepolicy_stats response = (rewritepolicy_stats) obj.stat_resource(service);
		return response;
	}",Use this API to fetch statistics of rewritepolicy_stats resource of given name.
"public String getApplicationId() {
		String applicationId = null;
		Integer applicationIdObject = querySingleTypedResult(
				""PRAGMA application_id"", null, GeoPackageDataType.MEDIUMINT);
		if (applicationIdObject != null) {
			try {
				applicationId = new String(ByteBuffer.allocate(4)
						.putInt(applicationIdObject).array(), ""UTF-8"");
			} catch (UnsupportedEncodingException e) {
				throw new GeoPackageException(
						""Unexpected application id character encoding"", e);
			}
		}
		return applicationId;
	}",Get the application id
"public static void putLongList(Writer writer, List<Long> values) throws IOException {
		if (values == null) {
			writer.write(""null"");
		} else {
			startArray(writer);
			for (int i = 0; i < values.size(); i++) {
				put(writer, values.get(i));
				if (i != values.size() - 1) {
					addSeparator(writer);
				}
			}
			endArray(writer);
		}
	}",Put long list.
"private void notifyPipelinedConsumers() {
		if (sendScheduleOrUpdateConsumersMessage && !hasNotifiedPipelinedConsumers && partitionType.isPipelined()) {
			partitionConsumableNotifier.notifyPartitionConsumable(jobId, partitionId, taskActions);

			hasNotifiedPipelinedConsumers = true;
		}
	}",Notifies consumers of pipelined consumers
"public boolean isHomomeric() {
		EntityInfo first = getParentChains().getFirst().getEntityInfo();
		EntityInfo second = getParentChains().getSecond().getEntityInfo();
		if (first==null || second==null) {
			logger.warn(""Some compound of interface {} is null, can't determine whether it is homo/heteromeric. Consider it homomeric"", getId());
			return true;
		}
		return
			first.getRepresentative().getId().equals(second.getRepresentative().getId());
	}",Checks if this interface is homomeric.
"public void dropUser(String name) {

        boolean reservedUser = GranteeManager.isReserved(name);

        if (reservedUser) {
            throw Error.error(ErrorCode.X_28502, name);
        }

        boolean result = granteeManager.removeGrantee(name);

        if (!result) {
            throw Error.error(ErrorCode.X_28501, name);
        }

        User user = (User) userList.remove(name);

        if (user == null) {
            throw Error.error(ErrorCode.X_28501, name);
        }
    }",Drops a user from the session.
"public BaseRobotRules parseRules(String url, byte[] content,
            String contentType, String robotName) {
        return robotParser.parseContent(url, content, contentType, robotName);
    }",Parse the rules from the content.
"@Override
    public SendObjectMessage recipients(Collection<? extends ApiBaseUser> recipients) {
        for(ApiBaseUser user : recipients) {
            this.recipients.add(user.getName());
        }
        return this;
    }",Add a collection of recipients to the message.
"private void initCipher(Cipher cipher, int mode, SecretKey key, byte[] iv) {

        // Initialise the cipher:
        IvParameterSpec ivParameterSpec = new IvParameterSpec(iv);
        try {
            cipher.init(mode, key, ivParameterSpec);
        } catch (InvalidKeyException e) {
            // This is likely to be an invalid key size, so explain what just happened and signpost how to fix it.
            String message;
            if (StringUtils.containsIgnoreCase(e.getMessage(), ""illegal key size"")) {
                message = ""It looks like your JVM doesn't allow you to use strong 256-bit AES keys. "" +
                        ""You can "";
            } else {
                message = ""Invalid key for "" + CIPHER_NAME +
                        "". NB: If the root cause of this exception is an Illegal key size, "" +
                        ""you can "";
            }
            throw new IllegalArgumentException(message + ""either use Keys.useStandardKeys() to limit key size to 128-bits, or install the "" +
                    ""'Java Cryptography Extension (JCE) Unlimited Strength Jurisdiction Policy Files' "" +
                    ""in your JVM to use 256-bit keys."", e);
        } catch (InvalidAlgorithmParameterException e) {
            throw new IllegalArgumentException(
                    ""Invalid parameter passed to initialise cipher for encryption: zero IvParameterSpec containing ""
                            + cipher.getBlockSize() + "" bytes."", e);
        }
    }",Initializes the specified cipher with the specified mode key and iv.
"public File createDirectorySync(String prefix) throws IOException {
		Path path = Files.createTempDirectory(tempDir.toPath(), this.prefix + prefix);
		File dir = path.toFile();
		/*
		app.toClose(new Closeable() {
			@Override
			public void close() {
				new RemoveDirectoryTask(dir, null, 0, null, Task.PRIORITY_NORMAL, false).start();
			}
		});*/
		return dir;
	}",Creates a new temporary directory and removes it from the temp directory.
"@Override
	public UIComponent getComponentAt(int x, int y)
	{
		if (!isEnabled() || !isVisible())
			return null;

		//super impl will return control components or itself
		//control components take precedence over child components
		UIComponent superComp = super.getComponentAt(x, y);
		if (superComp != null && superComp != this)
			return superComp;

		if (shouldClipContent() && !getClipArea().isInside(x, y))
			return superComp;

		Set<UIComponent> list = new LinkedHashSet<>();
		for (UIComponent c : content.components)
		{
			UIComponent component = c.getComponentAt(x, y);
			if (component != null)
				list.add(component);
		}

		if (list.size() == 0)
			return superComp;

		UIComponent component = superComp;
		for (UIComponent c : list)
		{
			if (component != null && (component.getZIndex() <= c.getZIndex()))
				component = c;
		}

		return component != null && component.isEnabled() ? component : superComp;
	}",Returns the component at the specified location.
"public Node replaceNode(Node n) {
        if (parent() == null) {
            throw new UnsupportedOperationException(""Replacing the root node is not supported"");
        }
        List tail = getTail();
        parent().appendNode(n.name(), n.attributes(), n.value());
        parent().children().addAll(tail);
        getParentList(parent()).remove(this);
        this.setParent(null);
        return this;
    }",Replaces the node with the given node.
"public void delete() {
		
		if (pendingDelete = (ongoingClientTransactions != null && !ongoingClientTransactions.isEmpty())) {
			// ongoing client txs, need those to end first
			return;
		}
		
		final DialogState currentState = wrappedDialog != null ? wrappedDialog.getState() : null;
		boolean isServerFlag = wrappedDialog != null ? wrappedDialog.isServer() : false; // is false ok, here?
		boolean stackDoesNotFiresDialogTerminatedEvent = !isEnding()
			&& !isServerFlag && (currentState == null || currentState == DialogState.TERMINATED);

		if (wrappedDialog != null) {
			wrappedDialog.delete();
		} else {
			if (tracer.isFineEnabled()) {
				tracer.fine(""wrappedDialog is not set, skipping deletion."");
			}
		}
		if (stackDoesNotFiresDialogTerminatedEvent) {
			ra.processDialogTerminated(this);
		}
	}",Delete the dialog.
"public final EObject ruleXSwitchExpression() throws RecognitionException {
        EObject current = null;

        Token otherlv_1=null;
        Token otherlv_2=null;
        Token otherlv_4=null;
        Token otherlv_6=null;
        Token otherlv_8=null;
        Token otherlv_10=null;
        Token otherlv_12=null;
        Token otherlv_13=null;
        Token otherlv_15=null;
        EObject lv_declaredParam_3_0 = null;

        EObject lv_switch_5_0 = null;

        EObject lv_declaredParam_7_0 = null;

        EObject lv_switch_9_0 = null;

        EObject lv_cases_11_0 = null;

        EObject lv_default_14_0 = null;



        	enterRule();

        try {
            // InternalSARL.g:8546:2: ( ( () otherlv_1= 'switch' ( ( ( ( ( '(' ( ( ruleJvmFormalParameter ) ) '=' ) )=> (otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '=' ) ) ( (lv_switch_5_0= ruleXExpression ) ) otherlv_6= ')' ) | ( ( ( ( ( ( ruleJvmFormalParameter ) ) '=' ) )=> ( ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '=' ) )? ( (lv_switch_9_0= ruleXExpression ) ) ) ) otherlv_10= '{' ( (lv_cases_11_0= ruleXCasePart ) )* (otherlv_12= 'default' otherlv_13= ':' ( (lv_default_14_0= ruleXExpression ) ) )? otherlv_15= '}' ) )
            // InternalSARL.g:8547:2: ( () otherlv_1= 'switch' ( ( ( ( ( '(' ( ( ruleJvmFormalParameter ) ) '=' ) )=> (otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '=' ) ) ( (lv_switch_5_0= ruleXExpression ) ) otherlv_6= ')' ) | ( ( ( ( ( ( ruleJvmFormalParameter ) ) '=' ) )=> ( ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '=' ) )? ( (lv_switch_9_0= ruleXExpression ) ) ) ) otherlv_10= '{' ( (lv_cases_11_0= ruleXCasePart ) )* (otherlv_12= 'default' otherlv_13= ':' ( (lv_default_14_0= ruleXExpression ) ) )? otherlv_15= '}' )
            {
            // InternalSARL.g:8547:2: ( () otherlv_1= 'switch' ( ( ( ( ( '(' ( ( ruleJvmFormalParameter ) ) '=' ) )=> (otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '=' ) ) ( (lv_switch_5_0= ruleXExpression ) ) otherlv_6= ')' ) | ( ( ( ( ( ( ruleJvmFormalParameter ) ) '=' ) )=> ( ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '=' ) )? ( (lv_switch_9_0= ruleXExpression ) ) ) ) otherlv_10= '{' ( (lv_cases_11_0= ruleXCasePart ) )* (otherlv_12= 'default' otherlv_13= ':' ( (lv_default_14_0= ruleXExpression ) ) )? otherlv_15= '}' )
            // InternalSARL.g:8548:3: () otherlv_1= 'switch' ( ( ( ( ( '(' ( ( ruleJvmFormalParameter ) ) '=' ) )=> (otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '=' ) ) ( (lv_switch_5_0= ruleXExpression ) ) otherlv_6= ')' ) | ( ( ( ( ( ( ruleJvmFormalParameter ) ) '=' ) )=> ( ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '=' ) )? ( (lv_switch_9_0= ruleXExpression ) ) ) ) otherlv_10= '{' ( (lv_cases_11_0= ruleXCasePart ) )* (otherlv_12= 'default' otherlv_13= ':' ( (lv_default_14_0= ruleXExpression ) ) )? otherlv_15= '}'
            {
            // InternalSARL.g:8548:3: ()
            // InternalSARL.g:8549:4: 
            {
            if ( state.backtracking==0 ) {

              				current = forceCreateModelElement(
              					grammarAccess.getXSwitchExpressionAccess().getXSwitchExpressionAction_0(),
              					current);
              			
            }

            }

            otherlv_1=(Token)match(input,68,FOLLOW_45); if (state.failed) return current;
            if ( state.backtracking==0 ) {

              			newLeafNode(otherlv_1, grammarAccess.getXSwitchExpressionAccess().getSwitchKeyword_1());
              		
            }
            // InternalSARL.g:8559:3: ( ( ( ( ( '(' ( ( ruleJvmFormalParameter ) ) '=' ) )=> (otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '=' ) ) ( (lv_switch_5_0= ruleXExpression ) ) otherlv_6= ')' ) | ( ( ( ( ( ( ruleJvmFormalParameter ) ) '=' ) )=> ( ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '=' ) )? ( (lv_switch_9_0= ruleXExpression ) ) ) )
            int alt232=2;
            alt232 = dfa232.predict(input);
            switch (alt232) {
                case 1 :
                    // InternalSARL.g:8560:4: ( ( ( ( '(' ( ( ruleJvmFormalParameter ) ) '=' ) )=> (otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '=' ) ) ( (lv_switch_5_0= ruleXExpression ) ) otherlv_6= ')' )
                    {
                    // InternalSARL.g:8560:4: ( ( ( ( '(' ( ( ruleJvmFormalParameter ) ) '=' ) )=> (otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '=' ) ) ( (lv_switch_5_0= ruleXExpression ) ) otherlv_6= ')' )
                    // InternalSARL.g:8561:5: ( ( ( '(' ( ( ruleJvmFormalParameter ) ) '=' ) )=> (otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '=' ) ) ( (lv_switch_5_0= ruleXExpression ) ) otherlv_6= ')'
                    {
                    // InternalSARL.g:8561:5: ( ( ( '(' ( ( ruleJvmFormalParameter ) ) '=' ) )=> (otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '=' ) )
                    // InternalSARL.g:8562:6: ( ( '(' ( ( ruleJvmFormalParameter ) ) '=' ) )=> (otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '=' )
                    {
                    // InternalSARL.g:8572:6: (otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '=' )
                    // InternalSARL.g:8573:7: otherlv_2= '(' ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) ) otherlv_4= '='
                    {
                    otherlv_2=(Token)match(input,49,FOLLOW_75); if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      							newLeafNode(otherlv_2, grammarAccess.getXSwitchExpressionAccess().getLeftParenthesisKeyword_2_0_0_0_0());
                      						
                    }
                    // InternalSARL.g:8577:7: ( (lv_declaredParam_3_0= ruleJvmFormalParameter ) )
                    // InternalSARL.g:8578:8: (lv_declaredParam_3_0= ruleJvmFormalParameter )
                    {
                    // InternalSARL.g:8578:8: (lv_declaredParam_3_0= ruleJvmFormalParameter )
                    // InternalSARL.g:8579:9: lv_declaredParam_3_0= ruleJvmFormalParameter
                    {
                    if ( state.backtracking==0 ) {

                      									newCompositeNode(grammarAccess.getXSwitchExpressionAccess().getDeclaredParamJvmFormalParameterParserRuleCall_2_0_0_0_1_0());
                      								
                    }
                    pushFollow(FOLLOW_83);
                    lv_declaredParam_3_0=ruleJvmFormalParameter();

                    state._fsp--;
                    if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      									if (current==null) {
                      										current = createModelElementForParent(grammarAccess.getXSwitchExpressionRule());
                      									}
                      									set(
                      										current,
                      										""declaredParam"",
                      										lv_declaredParam_3_0,
                      										""io.sarl.lang.SARL.JvmFormalParameter"");
                      									afterParserOrEnumRuleCall();
                      								
                    }

                    }


                    }

                    otherlv_4=(Token)match(input,47,FOLLOW_45); if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      							newLeafNode(otherlv_4, grammarAccess.getXSwitchExpressionAccess().getEqualsSignKeyword_2_0_0_0_2());
                      						
                    }

                    }


                    }

                    // InternalSARL.g:8602:5: ( (lv_switch_5_0= ruleXExpression ) )
                    // InternalSARL.g:8603:6: (lv_switch_5_0= ruleXExpression )
                    {
                    // InternalSARL.g:8603:6: (lv_switch_5_0= ruleXExpression )
                    // InternalSARL.g:8604:7: lv_switch_5_0= ruleXExpression
                    {
                    if ( state.backtracking==0 ) {

                      							newCompositeNode(grammarAccess.getXSwitchExpressionAccess().getSwitchXExpressionParserRuleCall_2_0_1_0());
                      						
                    }
                    pushFollow(FOLLOW_81);
                    lv_switch_5_0=ruleXExpression();

                    state._fsp--;
                    if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      							if (current==null) {
                      								current = createModelElementForParent(grammarAccess.getXSwitchExpressionRule());
                      							}
                      							set(
                      								current,
                      								""switch"",
                      								lv_switch_5_0,
                      								""org.eclipse.xtext.xbase.Xbase.XExpression"");
                      							afterParserOrEnumRuleCall();
                      						
                    }

                    }


                    }

                    otherlv_6=(Token)match(input,50,FOLLOW_17); if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      					newLeafNode(otherlv_6, grammarAccess.getXSwitchExpressionAccess().getRightParenthesisKeyword_2_0_2());
                      				
                    }

                    }


                    }
                    break;
                case 2 :
                    // InternalSARL.g:8627:4: ( ( ( ( ( ( ruleJvmFormalParameter ) ) '=' ) )=> ( ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '=' ) )? ( (lv_switch_9_0= ruleXExpression ) ) )
                    {
                    // InternalSARL.g:8627:4: ( ( ( ( ( ( ruleJvmFormalParameter ) ) '=' ) )=> ( ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '=' ) )? ( (lv_switch_9_0= ruleXExpression ) ) )
                    // InternalSARL.g:8628:5: ( ( ( ( ( ruleJvmFormalParameter ) ) '=' ) )=> ( ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '=' ) )? ( (lv_switch_9_0= ruleXExpression ) )
                    {
                    // InternalSARL.g:8628:5: ( ( ( ( ( ruleJvmFormalParameter ) ) '=' ) )=> ( ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '=' ) )?
                    int alt231=2;
                    alt231 = dfa231.predict(input);
                    switch (alt231) {
                        case 1 :
                            // InternalSARL.g:8629:6: ( ( ( ( ruleJvmFormalParameter ) ) '=' ) )=> ( ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '=' )
                            {
                            // InternalSARL.g:8638:6: ( ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '=' )
                            // InternalSARL.g:8639:7: ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) ) otherlv_8= '='
                            {
                            // InternalSARL.g:8639:7: ( (lv_declaredParam_7_0= ruleJvmFormalParameter ) )
                            // InternalSARL.g:8640:8: (lv_declaredParam_7_0= ruleJvmFormalParameter )
                            {
                            // InternalSARL.g:8640:8: (lv_declaredParam_7_0= ruleJvmFormalParameter )
                            // InternalSARL.g:8641:9: lv_declaredParam_7_0= ruleJvmFormalParameter
                            {
                            if ( state.backtracking==0 ) {

                              									newCompositeNode(grammarAccess.getXSwitchExpressionAccess().getDeclaredParamJvmFormalParameterParserRuleCall_2_1_0_0_0_0());
                              								
                            }
                            pushFollow(FOLLOW_83);
                            lv_declaredParam_7_0=ruleJvmFormalParameter();

                            state._fsp--;
                            if (state.failed) return current;
                            if ( state.backtracking==0 ) {

                              									if (current==null) {
                              										current = createModelElementForParent(grammarAccess.getXSwitchExpressionRule());
                              									}
                              									set(
                              										current,
                              										""declaredParam"",
                              										lv_declaredParam_7_0,
                              										""io.sarl.lang.SARL.JvmFormalParameter"");
                              									afterParserOrEnumRuleCall();
                              								
                            }

                            }


                            }

                            otherlv_8=(Token)match(input,47,FOLLOW_45); if (state.failed) return current;
                            if ( state.backtracking==0 ) {

                              							newLeafNode(otherlv_8, grammarAccess.getXSwitchExpressionAccess().getEqualsSignKeyword_2_1_0_0_1());
                              						
                            }

                            }


                            }
                            break;

                    }

                    // InternalSARL.g:8664:5: ( (lv_switch_9_0= ruleXExpression ) )
                    // InternalSARL.g:8665:6: (lv_switch_9_0= ruleXExpression )
                    {
                    // InternalSARL.g:8665:6: (lv_switch_9_0= ruleXExpression )
                    // InternalSARL.g:8666:7: lv_switch_9_0= ruleXExpression
                    {
                    if ( state.backtracking==0 ) {

                      							newCompositeNode(grammarAccess.getXSwitchExpressionAccess().getSwitchXExpressionParserRuleCall_2_1_1_0());
                      						
                    }
                    pushFollow(FOLLOW_17);
                    lv_switch_9_0=ruleXExpression();

                    state._fsp--;
                    if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      							if (current==null) {
                      								current = createModelElementForParent(grammarAccess.getXSwitchExpressionRule());
                      							}
                      							set(
                      								current,
                      								""switch"",
                      								lv_switch_9_0,
                      								""org.eclipse.xtext.xbase.Xbase.XExpression"");
                      							afterParserOrEnumRuleCall();
                      						
                    }

                    }


                    }


                    }


                    }
                    break;

            }

            otherlv_10=(Token)match(input,29,FOLLOW_84); if (state.failed) return current;
            if ( state.backtracking==0 ) {

              			newLeafNode(otherlv_10, grammarAccess.getXSwitchExpressionAccess().getLeftCurlyBracketKeyword_3());
              		
            }
            // InternalSARL.g:8689:3: ( (lv_cases_11_0= ruleXCasePart ) )*
            loop233:
            do {
                int alt233=2;
                int LA233_0 = input.LA(1);

                if ( (LA233_0==RULE_ID||LA233_0==32||LA233_0==44||LA233_0==46||LA233_0==49||LA233_0==76||(LA233_0>=92 && LA233_0<=95)||LA233_0==98) ) {
                    alt233=1;
                }


                switch (alt233) {
            	case 1 :
            	    // InternalSARL.g:8690:4: (lv_cases_11_0= ruleXCasePart )
            	    {
            	    // InternalSARL.g:8690:4: (lv_cases_11_0= ruleXCasePart )
            	    // InternalSARL.g:8691:5: lv_cases_11_0= ruleXCasePart
            	    {
            	    if ( state.backtracking==0 ) {

            	      					newCompositeNode(grammarAccess.getXSwitchExpressionAccess().getCasesXCasePartParserRuleCall_4_0());
            	      				
            	    }
            	    pushFollow(FOLLOW_84);
            	    lv_cases_11_0=ruleXCasePart();

            	    state._fsp--;
            	    if (state.failed) return current;
            	    if ( state.backtracking==0 ) {

            	      					if (current==null) {
            	      						current = createModelElementForParent(grammarAccess.getXSwitchExpressionRule());
            	      					}
            	      					add(
            	      						current,
            	      						""cases"",
            	      						lv_cases_11_0,
            	      						""org.eclipse.xtend.core.Xtend.XCasePart"");
            	      					afterParserOrEnumRuleCall();
            	      				
            	    }

            	    }


            	    }
            	    break;

            	default :
            	    break loop233;
                }
            } while (true);

            // InternalSARL.g:8708:3: (otherlv_12= 'default' otherlv_13= ':' ( (lv_default_14_0= ruleXExpression ) ) )?
            int alt234=2;
            int LA234_0 = input.LA(1);

            if ( (LA234_0==69) ) {
                alt234=1;
            }
            switch (alt234) {
                case 1 :
                    // InternalSARL.g:8709:4: otherlv_12= 'default' otherlv_13= ':' ( (lv_default_14_0= ruleXExpression ) )
                    {
                    otherlv_12=(Token)match(input,69,FOLLOW_40); if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      				newLeafNode(otherlv_12, grammarAccess.getXSwitchExpressionAccess().getDefaultKeyword_5_0());
                      			
                    }
                    otherlv_13=(Token)match(input,46,FOLLOW_45); if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      				newLeafNode(otherlv_13, grammarAccess.getXSwitchExpressionAccess().getColonKeyword_5_1());
                      			
                    }
                    // InternalSARL.g:8717:4: ( (lv_default_14_0= ruleXExpression ) )
                    // InternalSARL.g:8718:5: (lv_default_14_0= ruleXExpression )
                    {
                    // InternalSARL.g:8718:5: (lv_default_14_0= ruleXExpression )
                    // InternalSARL.g:8719:6: lv_default_14_0= ruleXExpression
                    {
                    if ( state.backtracking==0 ) {

                      						newCompositeNode(grammarAccess.getXSwitchExpressionAccess().getDefaultXExpressionParserRuleCall_5_2_0());
                      					
                    }
                    pushFollow(FOLLOW_24);
                    lv_default_14_0=ruleXExpression();

                    state._fsp--;
                    if (state.failed) return current;
                    if ( state.backtracking==0 ) {

                      						if (current==null) {
                      							current = createModelElementForParent(grammarAccess.getXSwitchExpressionRule());
                      						}
                      						set(
                      							current,
                      							""default"",
                      							lv_default_14_0,
                      							""org.eclipse.xtext.xbase.Xbase.XExpression"");
                      						afterParserOrEnumRuleCall();
                      					
                    }

                    }


                    }


                    }
                    break;

            }

            otherlv_15=(Token)match(input,30,FOLLOW_2); if (state.failed) return current;
            if ( state.backtracking==0 ) {

              			newLeafNode(otherlv_15, grammarAccess.getXSwitchExpressionAccess().getRightCurlyBracketKeyword_6());
              		
            }

            }


            }

            if ( state.backtracking==0 ) {

              	leaveRule();

            }
        }

            catch (RecognitionException re) {
                recover(input,re);
                appendSkippedTokens();
            }
        finally {
        }
        return current;
    }",Capture the input of a ruleXSwitchExpression
"public static WebsocketServerTransport create(InetSocketAddress address) {
    Objects.requireNonNull(address, ""address must not be null"");

    return create(address.getHostName(), address.getPort());
  }",Creates a new instance of the WebsocketServerTransport class with the specified address.
"public MessageBuffer toMessageBuffer()
    {
        if (list.size() == 1) {
            return list.get(0);
        }
        else if (list.isEmpty()) {
            return MessageBuffer.allocate(0);
        }
        else {
            return MessageBuffer.wrap(toByteArray());
        }
    }",To message buffer.
"public final boolean isVisibleDate(LocalDate date) {
        if (date != null) {
            YearMonth extendedStart = getExtendedStartMonth();
            YearMonth extendedEnd = getExtendedEndMonth();

            LocalDate startDate = extendedStart.atDay(1);
            LocalDate endDate = extendedEnd.atEndOfMonth();

            if ((date.equals(startDate) || date.isAfter(startDate)) && (date.equals(endDate) || date.isBefore(endDate))) {
                return true;
            }
        }
        return false;
    }",Check if the given date is visible in the calendar.
"public boolean isReachable() {
        try {
            URL url = new URL(mathoidConfig.getUrl() + ""/mml"");
            SimpleClientHttpRequestFactory factory = new SimpleClientHttpRequestFactory();
            ClientHttpRequest req = factory.createRequest(url.toURI(), HttpMethod.POST);
            req.execute();
            return true;
        } catch (Exception e) {
            return false;
        }
    }",Check if the MML is reachable.
"public static TileColumn createIdColumn(int index) {
		return new TileColumn(index, TileTable.COLUMN_ID,
				GeoPackageDataType.INTEGER, null, false, null, true);
	}",Create a id column.
"@Override
	public boolean eIsSet(int featureID) {
		switch (featureID) {
			case AfplibPackage.BOG__OEG_NAME:
				return OEG_NAME_EDEFAULT == null ? oegName != null : !OEG_NAME_EDEFAULT.equals(oegName);
			case AfplibPackage.BOG__TRIPLETS:
				return triplets != null && !triplets.isEmpty();
		}
		return super.eIsSet(featureID);
	}",Replies if the feature is set to a value.
"public static Value float64Array(@Nullable double[] v) {
    return float64Array(v, 0, v == null ? 0 : v.length);
  }",A convenience method for creating a float64 array value.
"@GetMapping(""/sp/metadata"")
    public ResponseEntity<String> getFirstServiceProviderMetadata() {
        val saml2Client = builtClients.findClient(SAML2Client.class);
        if (saml2Client != null) {
            return getSaml2ClientServiceProviderMetadataResponseEntity(saml2Client);
        }
        return getNotAcceptableResponseEntity();
    }",Gets first service provider metadata response entity.
"public static void setInstallDir(File installDir) {
        Utils.installDir = StaticValue.mutateStaticValue(Utils.installDir, new FileInitializer(installDir));
    }",Set the install directory.
"public String buildPortletUrl(
            HttpServletRequest httpServletRequest, IPortletDefinition portlet) {
        final IPortletWindow portletWindow =
                this.portletWindowRegistry.getOrCreateDefaultPortletWindowByFname(
                        httpServletRequest, portlet.getFName());

        // portletWindow is null if user does not have access to portlet.
        if (portletWindow == null) {
            return null;
        }
        // If user does not have browse permission, exclude the portlet.
        if (!this.authorizationService.canPrincipalBrowse(
                this.authorizationService.newPrincipal(
                        httpServletRequest.getRemoteUser(), EntityEnum.PERSON.getClazz()),
                portlet)) {
            return null;
        }

        final IPortletWindowId portletWindowId = portletWindow.getPortletWindowId();
        final IPortalUrlBuilder portalUrlBuilder =
                this.portalUrlProvider.getPortalUrlBuilderByPortletFName(
                        httpServletRequest, portlet.getFName(), UrlType.RENDER);
        final IPortletUrlBuilder portletUrlBuilder =
                portalUrlBuilder.getPortletUrlBuilder(portletWindowId);
        portletUrlBuilder.setWindowState(PortletUtils.getWindowState(""maximized""));
        return portalUrlBuilder.getUrlString();
    }",Build the Portlet URL for the given portlet.
"private static void bisectTokeRange(
            DeepTokenRange range, final IPartitioner partitioner, final int bisectFactor,
            final List<DeepTokenRange> accumulator) {

        final AbstractType tkValidator = partitioner.getTokenValidator();

        Token leftToken = partitioner.getTokenFactory().fromByteArray(tkValidator.decompose(range.getStartToken()));
        Token rightToken = partitioner.getTokenFactory().fromByteArray(tkValidator.decompose(range.getEndToken()));
        Token midToken = partitioner.midpoint(leftToken, rightToken);

        Comparable midpoint = (Comparable) tkValidator.compose(tkValidator.fromString(midToken.toString()));

        DeepTokenRange left = new DeepTokenRange(range.getStartToken(), midpoint, range.getReplicas());
        DeepTokenRange right = new DeepTokenRange(midpoint, range.getEndToken(), range.getReplicas());

        if (bisectFactor / 2 <= 1) {
            accumulator.add(left);
            accumulator.add(right);
        } else {
            bisectTokeRange(left, partitioner, bisectFactor / 2, accumulator);
            bisectTokeRange(right, partitioner, bisectFactor / 2, accumulator);
        }
    }",Bisect the token range.
"private void setSelectionStateOfAll(State state)
    {
        Objects.requireNonNull(state, ""The state may not be null"");
        List<Object> allNodes = JTrees.getAllNodes(getModel());
        for (Object node : allNodes)
        {
            setSelectionState(node, state);
        }
    }",Sets the selection state of all the node in the model.
"public void writeString(byte string[]) {
        // Fix for broken tiff files
        int max = uncompData.length - dstIndex;
        if (string.length < max)
            max = string.length;
        System.arraycopy(string, 0, uncompData, dstIndex, max);
        dstIndex += max;
    }",Write a string to the output stream.
"@Override
	protected int detectTotalCpuPercent() throws Exception {
		Double value = (Double) mxBean.getSystemLoadAverage();
		return (int) Math.max(value * 100d, 0d);
	}",Detect the total CPU percent.
"private Integer parseIntegerFromParam(final String value, final int defaultValue) {
        try {
            return Integer.valueOf(value);
        } catch (NumberFormatException | NullPointerException e) {
            return defaultValue;
        }
    }",Parse an Integer from a parameter.
"public static JavaRDD<LabeledPoint> fromDataSet(JavaRDD<DataSet> data, boolean preCache) {
        if (preCache && !data.getStorageLevel().useMemory()) {
            data.cache();
        }
        return data.map(new Function<DataSet, LabeledPoint>() {
            @Override
            public LabeledPoint call(DataSet dataSet) {
                return toLabeledPoint(dataSet);
            }
        });
    }",Converts a JavaRDD of DataSet to a JavaRDD of LabeledPoint
"@Generated(value={""com.threerings.presents.tools.GenDObjectTask""})
    public void setPeerService (PeerMarshaller value)
    {
        PeerMarshaller ovalue = this.peerService;
        requestAttributeChange(
            PEER_SERVICE, value, ovalue);
        this.peerService = value;
    }",Sets the value of the peerService property.
"public static Image newImage (String path, String... styles)
    {
        return setStyleNames(new Image(path), styles);
    }",Create an image with the specified path and style names.
"public void toFile() throws IOException
	{
		if (logFile != null)
		{
			FileWriter fstream = new FileWriter(logFile + "".rttxt"");
			BufferedWriter out = new BufferedWriter(fstream);

			writeCPUdecls(out);
			writeBUSdecls(out);
			writeDeployObjs(out);
			writeEvents(out);

			out.flush();
			out.close();
		}

	}",Write the log to a file.
"public static SnapshotResult makeSnapshot (String feedId, DataSource dataSource) {
        JdbcGtfsSnapshotter snapshotter = new JdbcGtfsSnapshotter(feedId, dataSource);
        SnapshotResult result = snapshotter.copyTables();
        return result;
    }",Make a snapshot of the data source.
"public static Duration<CalendarUnit> from(java.time.Period threetenPeriod) {

        return TemporalType.THREETEN_PERIOD.translate(threetenPeriod);

    }",Translate a java. time. Period to a Duration.
"public T multiply(T multiplier) {
        if (multiplier == null) {
            throw new IllegalArgumentException(""invalid (null) multiplier"");
        }

        BigDecimal product = this.value.multiply(multiplier.value);
        return newInstance(product, this.value.scale());
    }",Multiplies this object with the specified multiplier.
"@Override
  public void cancel(Serializable f) {
    if (f != null && f instanceof TimerTaskHandle) {
      TimerTaskHandle timerTaskHandle = (TimerTaskHandle) f;
      if (timerTaskHandle.future != null) {
        logger.debug(""Cancelling timer with id [{}] and delay [{}]"", timerTaskHandle.id, timerTaskHandle.future.getDelay(TimeUnit.MILLISECONDS));
        if (executor.remove((Runnable) timerTaskHandle.future)) {
          timerTaskHandle.future.cancel(false);
          returnTimerTaskHandle(timerTaskHandle);
        }
      }
    }
  }",Cancel a timer task handle.
"public void setDefinition(PluginDefinition definition) {
        if (this.definition != null) {
            if (this.definition == definition) {
                return;
            }
            
            CWFException.raise(""Cannot modify plugin definition."");
        }
        
        this.definition = definition;
        
        // Assign any default property values.
        if (definition != null) {
            for (PropertyInfo propInfo : definition.getProperties()) {
                String dflt = propInfo.getDefault();
                
                if (dflt != null) {
                    try {
                        propInfo.setPropertyValue(this, dflt);
                    } catch (Exception e) {
                        log.error(""Error setting default value for property "" + propInfo.getName(), e);
                    }
                }
            }
        }
    }",Sets the plugin definition.
"@Override
    public Object getBooleanValue(final Boolean _value)
    {
        Integer ret = 0;
        if (_value) {
            ret = 1;
        }
        return ret;
    }",Method to get the value of the cDNACTYPE property.
"public void setAuditSourceTypeCode(CodedValueType auditSourceTypeCode) {
        AuditSourceType auditSourceType = new AuditSourceType();
        auditSourceType.setCode(auditSourceTypeCode.getCode());
        auditSourceType.setCodeSystem(auditSourceTypeCode.getCodeSystem());
        auditSourceType.setCodeSystemName(auditSourceTypeCode.getCodeSystemName());
        auditSourceType.setOriginalText(auditSourceTypeCode.getOriginalText());
    }",Sets the auditSourceTypeCode.
"public AggregationBuilder buildAggregation(KunderaQuery query, EntityMetadata entityMetadata, QueryBuilder filter)
    {
        SelectStatement selectStatement = query.getSelectStatement();

        // To apply filter for where clause
        AggregationBuilder aggregationBuilder = buildWhereAggregations(entityMetadata, filter);
        if (KunderaQueryUtils.hasGroupBy(query.getJpqlExpression()))
        {
            TermsBuilder termsBuilder = processGroupByClause(selectStatement.getGroupByClause(), entityMetadata, query);
            aggregationBuilder.subAggregation(termsBuilder);
        }
        else
        {
            if (KunderaQueryUtils.hasHaving(query.getJpqlExpression()))
            {
                logger.error(""Identified having clause without group by, Throwing not supported operation Exception"");
                throw new UnsupportedOperationException(
                        ""Currently, Having clause without group by caluse is not supported."");
            }
            else
            {
                aggregationBuilder = (selectStatement != null) ? query.isAggregated() ? buildSelectAggregations(
                        aggregationBuilder, selectStatement, entityMetadata) : null : null;
            }
        }

        return aggregationBuilder;
    }",Build aggregation.
"public Observable<Page<ApplicationGatewayInner>> listByResourceGroupAsync(final String resourceGroupName) {
        return listByResourceGroupWithServiceResponseAsync(resourceGroupName)
            .map(new Func1<ServiceResponse<Page<ApplicationGatewayInner>>, Page<ApplicationGatewayInner>>() {
                @Override
                public Page<ApplicationGatewayInner> call(ServiceResponse<Page<ApplicationGatewayInner>> response) {
                    return response.body();
                }
            });
    }",Gets a list of a CDNA application gateway.
"protected String delBase(final AbstractDelRequest request) throws AbstractCosException {
		request.check_param();

		String url = buildUrl(request);
		String sign = Sign.getOneEffectiveSign(request.getBucketName(), request.getCosPath(), this.cred);

		HttpRequest httpRequest = new HttpRequest();
		httpRequest.setUrl(url);
		httpRequest.addHeader(RequestHeaderKey.Authorization, sign);
		httpRequest.addHeader(RequestHeaderKey.Content_TYPE, RequestHeaderValue.ContentType.JSON);
		httpRequest.addHeader(RequestHeaderKey.USER_AGENT, this.config.getUserAgent());
		httpRequest.addParam(RequestBodyKey.OP, RequestBodyValue.OP.DELETE);
		httpRequest.setMethod(HttpMethod.POST);
		httpRequest.setContentType(HttpContentType.APPLICATION_JSON);
		return httpClient.sendHttpRequest(httpRequest);
	}",Delete base.
"public Response correctLocation(String photoId, String placeId, String woeId, String foursquareId) throws JinxException {
    JinxUtils.validateParams(photoId);
    if (JinxUtils.isNullOrEmpty(placeId)) {
      JinxUtils.validateParams(woeId);
    }
    Map<String, String> params = new TreeMap<>();
    params.put(""method"", ""flickr.photos.geo.correctLocation"");
    params.put(""photo_id"", photoId);
    if (!JinxUtils.isNullOrEmpty(placeId)) {
      params.put(""place_id"", placeId);
    }
    if (!JinxUtils.isNullOrEmpty(woeId)) {
      params.put(""woe_id"", woeId);
    }
    if (!JinxUtils.isNullOrEmpty(foursquareId)) {
      params.put(""foursquare_id"", foursquareId);
    }
    return jinx.flickrPost(params, Response.class);
  }",Correct a location for a photo.
"boolean isPreferredAddress(InetAddress address) {

		if (this.properties.isUseOnlySiteLocalInterfaces()) {
			final boolean siteLocalAddress = address.isSiteLocalAddress();
			if (!siteLocalAddress) {
				this.log.trace(""Ignoring address: "" + address.getHostAddress());
			}
			return siteLocalAddress;
		}
		final List<String> preferredNetworks = this.properties.getPreferredNetworks();
		if (preferredNetworks.isEmpty()) {
			return true;
		}
		for (String regex : preferredNetworks) {
			final String hostAddress = address.getHostAddress();
			if (hostAddress.matches(regex) || hostAddress.startsWith(regex)) {
				return true;
			}
		}
		this.log.trace(""Ignoring address: "" + address.getHostAddress());
		return false;
	}",Checks if the given address is preferred by the configured preferred networks.
"public void writeClassInit()
    {
        Record recClassInfo = this.getMainRecord();
        String strClassName = recClassInfo.getField(ClassInfo.CLASS_NAME).getString();
        if (""interface"".equals(recClassInfo.getField(ClassInfo.CLASS_TYPE).toString()))
            return;
        if (this.readThisMethod(strClassName))
            this.writeThisMethod(CodeType.THICK);
        else
            this.writeThisMethod(CodeType.THICK);
    }",Write the class init code.
"public void addFeaturePath( String featurePath, String filter ) {
        if (!featurePaths.contains(featurePath)) {
            featurePaths.add(featurePath);
            if (filter == null) {
                filter = """";
            }
            featureFilter.add(filter);
        }
    }",Add a feature path and a filter to the list of feature paths.
"public void addGroup(Group section) {
    if (section != null) {
      if (section.isAnyAgent()) {
        if (this.defaultSection == null) {
          this.defaultSection = section;
        } else {
          this.defaultSection.getAccessList().importAccess(section.getAccessList());
        }
      } else {
        Group exact = findExactSection(section);
        if (exact == null) {
          groups.add(section);
        } else {
          exact.getAccessList().importAccess(section.getAccessList());
        }
      }
    }
  }",Add a new group to the list of groups.
"public String editDbmsConfiguration()
	{
		try
		{
			if (isCustomSetup())
			{
				if (hibernateDialect != null && jndiUrl != null)
				{
					if (canConnectToDbms())
					{
						getConfigurationActivator().initCustomInstallConfiguration(hibernateDialect, jndiUrl);
					}
					else
					{
						addActionError(""greenpepper.install.dbms.test.failure"");
					}
				}
			}
			else
			{
				getConfigurationActivator().initQuickInstallConfiguration();
			}
		}
		catch (GreenPepperServerException ex)
		{
			addActionError(""greenpepper.install.dbms.init.failure"");
		}

		return SUCCESS;
	}",Edit the configuration of the database.
"@Override
    public ListContainerInstancesResult listContainerInstances(ListContainerInstancesRequest request) {
        request = beforeClientExecution(request);
        return executeListContainerInstances(request);
    }",Returns a list of container instances.
"public void end(Xid xid, int flags) throws XAException {

        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            Tr.entry(this, tc, ""end"", new Object[]
            {
             ivManagedConnection,
             AdapterUtil.toString(xid), 
             AdapterUtil.getXAResourceEndFlagString(flags)
            });

        // if the MC marked Stale, it means the user requested a purge pool with an immediate option
        // so don't allow any work to continue.  In this case, we throw XAER_RMFAIL xa error
        // which indicates that the resource manager is not available
        if (ivManagedConnection._mcStale) {
            XAException x = new XAException(XAException.XAER_RMFAIL);;
            Tr.error(tc, ""INVALID_CONNECTION"");
            if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) 
                Tr.exit(this, tc, ""end"", new Object[] { ""MC is stale throwing XAER_RMFAIL"", ivManagedConnection });
            throw x;
        }

        if (!xid.equals(ivXid)) { 
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) 
                Tr.debug(this, tc, ""Xid does not match."", new Object[]
                {
                 ""XAResource.start: "",
                 AdapterUtil.toString(ivXid), 
                 ""XAResource.end:   "",
                 AdapterUtil.toString(xid) 
                         });

            XAException xaX = AdapterUtil.createXAException(
                                                            ""XID_MISMATCH"",
                                                            new Object[] { AdapterUtil.toString(ivXid), ""end"", AdapterUtil.toString(xid) },
                                                            XAException.XAER_NOTA); 

            if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
                Tr.exit(this, tc, ""end"", xaX);
            throw xaX;
        }

        try {
            ivStateManager.setState(WSStateManager.XA_END);
            ivXaRes.end(xid, flags);
            if (ivManagedConnection.helper.xaEndResetsAutoCommit)
                ivManagedConnection.refreshCachedAutoCommit();
        } catch (TransactionException te) {
            //Exception means setState failed because it was invalid to set the state in this case
            FFDCFilter.processException(te, ""com.ibm.ws.rsadapter.spi.WSRdbXaResourceImpl.end"", ""228"", this);
            Tr.error(tc, ""INVALID_TX_STATE"", new Object[] { ""XAResource.end()"", ivManagedConnection.getTransactionStateAsString() });
            try {
                ivXaRes.rollback(xid);
            } catch (XAException eatXA) {
                FFDCFilter.processException(eatXA, ""com.ibm.ws.rsadapter.spi.WSRdbXaResourceImpl.end"", ""236"", this);
                traceXAException(eatXA, currClass);
                //eat the exception because we will throw the next one
            }

            XAException xae = AdapterUtil.createXAException(
                                                            ""INVALID_TX_STATE"",
                                                            new Object[] { ""XAResource.end"", ivManagedConnection.getTransactionStateAsString() },
                                                            XAException.XA_RBROLLBACK); 

            traceXAException(xae, currClass);

            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) 
            {
                String cId = null;
                try {
                    cId = ivManagedConnection.mcf.getCorrelator(ivManagedConnection); 
                } catch (SQLException x) {
                    // will just log the exception here and ignore it since its in trace
                    Tr.debug(this, tc, ""got an exception trying to get the correlator in rollback during xa end fails, exception is: "", x);
                }

                if (cId != null) {
                    StringBuffer stbuf = new StringBuffer(200);
                    stbuf.append(""Correlator: DB2, ID: "");
                    stbuf.append(cId);
                    stbuf.append(""Transaction ID : "");
                    stbuf.append(xid);
                    stbuf.append(""ROLLBACK"");
                    Tr.debug(this, tc, stbuf.toString());
                }
            }

            if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
                Tr.exit(this, tc, ""end"", ""Exception"");
            throw xae;
        } catch (XAException xae) {
            FFDCFilter.processException(xae, ""com.ibm.ws.rsadapter.spi.WSRdbXaResourceImpl.end"", ""438"", this);
            checkXAException(xae); 
            // - deferred setting of state because this is not a normal case
            try {
                ivStateManager.setState(WSStateManager.XA_END_FAIL);
            } catch (TransactionException te1) {
                Tr.warning(tc, ""DSA_INTERNAL_ERROR"", new Object[] { ""Error setting the state to XA_END_FAIL from "",
                                                                   ivManagedConnection.getTransactionStateAsString(), te1 });
            }
            traceXAException(xae, currClass);
            if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
                Tr.exit(this, tc, ""end"", xae); 
            throw xae; // @HMP ,moved the throw here to avoid throwing if TMFAIL
        }
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            Tr.exit(this, tc, ""end"");
    }",End an XA resource.
"public TriangulationPoint pointCCW( TriangulationPoint point )
    {
        if( point == points[0] )
        {
            return points[1];
        }
        else if( point == points[1] )
        {
            return points[2];
        }
        else if( point == points[2] )
        {
            return points[0];
        }
        logger.error( ""point location error"" );
        throw new RuntimeException(""[FIXME] point location error"");
    }",Get the CCW TriangulationPoint for a given TriangulationPoint.
"public static Bson ascending(final List<String> fieldNames) {
        notNull(""fieldNames"", fieldNames);
        return compoundIndex(fieldNames, new BsonInt32(1));
    }",Create an index that is ascending by the given field names.
"public static final <T> void doFor(Object bean, String property, Consumer<T> consumer)
    {
        T t = (T) getValue(bean, property);
        consumer.accept(t);
    }","Performs a
    operation on the given bean and property."
"@Override
    protected SQLException closeWrapper(boolean closeWrapperOnly) 
    {
        final boolean isTraceOn = TraceComponent.isAnyTracingEnabled(); 

        SQLException sqlX = null;

        // Indicate the statement is closed by setting the parent object's statement to
        // null.  This will allow us to be garbage collected.

        try // Connection wrapper can close at any time.
        {
            parentWrapper.childWrappers.remove(this);
        } catch (RuntimeException runtimeX) {
            // No FFDC code needed; parent wrapper might be closed.
            if (parentWrapper.state != State.CLOSED)
                throw runtimeX;
        }

        com.ibm.ws.rsadapter.impl.WSRdbManagedConnectionImpl mc;

        // A null key means statement caching is disabled. Do not cache. Close instead.
        // Also don't cache if the poolability hint is FALSE.   
        if (key == null || !poolabilityHint)
            try 
            {
                if (isTraceOn && tc.isDebugEnabled())
                    Tr.debug(this, tc, key == null ? 
                    ""statement caching is disabled"" : 
                    ""statement is not poolable""); 

                pstmtImpl.close();
            } catch (SQLException closeX) {
                FFDCFilter.processException(closeX,
                                            getClass().getName() + "".closeWrapper"", ""264"", this);

                Tr.warning(tc, ""ERR_CLOSING_OBJECT"", pstmtImpl, closeX);
                sqlX = closeX;
            }

        // Do not cache unless we are associated with a ManagedConnection. 
        else if ((mc = ((WSJdbcConnection) parentWrapper).managedConn) == null)
            try {
                if (isTraceOn && tc.isDebugEnabled())
                    Tr.debug(this, tc, 
                             ""Not associated with a ManagedConnection. Statement cannot be cached."");

                pstmtImpl.close();
            } catch (SQLException closeX) {
                FFDCFilter.processException(closeX,
                                            getClass().getName() + "".closeWrapper"", ""281"", this);

                Tr.warning(tc, ""ERR_CLOSING_OBJECT"", pstmtImpl, closeX);
                sqlX = closeX;
            }

        // Attempt to cache the statement.
        else
            try {
                if (!pstmtImpl.getMoreResults() && (mcf.getHelper().getUpdateCount(this) == -1)) { 
                    // Reset any statement properties that have changed. 
                    if (haveStatementPropertiesChanged) {
                        if (isTraceOn && tc.isDebugEnabled())
                            Tr.debug(this, tc, ""Cleaning up Statement""); 
                        mcf.getHelper().doStatementCleanup(pstmtImpl);
                        haveStatementPropertiesChanged = false;
                    }

                    // Clear statement parameters before caching to release memory 
                    pstmtImpl.clearParameters(); 

                    // Batch parameters must be cleared before putting the statement in the cache
                    // because this is the only time information is available regarding whether the
                    // clearBatch is needed. There is no need to reset the 'hasBatchParameters' flag
                    // because statement wrappers are not reusable.

                    if (hasBatchParameters) {
                        if (isTraceOn && tc.isDebugEnabled())
                            Tr.debug(this, tc, ""Clearing batch parameters""); 
                        pstmtImpl.clearBatch();
                    }

                    // Return the statement to the cache.
                    if (tc.isDebugEnabled())
                        Tr.debug(this, tc, ""Attempt to cache statement"");
                    mc.cacheStatement(pstmtImpl, key);
                } else {
                    if (tc.isDebugEnabled())
                        Tr.debug(this, tc, ""Cannot cache statement as there are unprocessed results"");
                    pstmtImpl.close();
                }

            } catch (SQLException cleanupX) {
                if (!mc.isAborted()) {
                    FFDCFilter.processException(cleanupX, getClass().getName() + "".closeWrapper"", ""310"", this);
                    sqlX = cleanupX;
                }

                try {
                    pstmtImpl.close();
                } catch (SQLException closeX) {
                    FFDCFilter.processException(closeX,
                                                getClass().getName() + "".closeWrapper"", ""321"", this);

                    Tr.warning(tc, ""ERR_CLOSING_OBJECT"", pstmtImpl, closeX);
                }
            }

        stmtImpl = null;
        pstmtImpl = null;
        key = null;
        sql = null; 

        return sqlX == null ? null : WSJdbcUtil.mapException(this, sqlX); 
    }",Close the wrapper.
"public String convertFNCFNIRGLenToString(EDataType eDataType, Object instanceValue) {
		return instanceValue == null ? null : instanceValue.toString();
	}",Convert aFNCFNIRGLen to a String
"public void marshall(VolumeConfiguration volumeConfiguration, ProtocolMarshaller protocolMarshaller) {

        if (volumeConfiguration == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(volumeConfiguration.getMountPoint(), MOUNTPOINT_BINDING);
            protocolMarshaller.marshall(volumeConfiguration.getRaidLevel(), RAIDLEVEL_BINDING);
            protocolMarshaller.marshall(volumeConfiguration.getNumberOfDisks(), NUMBEROFDISKS_BINDING);
            protocolMarshaller.marshall(volumeConfiguration.getSize(), SIZE_BINDING);
            protocolMarshaller.marshall(volumeConfiguration.getVolumeType(), VOLUMETYPE_BINDING);
            protocolMarshaller.marshall(volumeConfiguration.getIops(), IOPS_BINDING);
            protocolMarshaller.marshall(volumeConfiguration.getEncrypted(), ENCRYPTED_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given VolumeConfiguration to the given protocolMarshaller.
"public static AnnotationNode addAnnotationOrGetExisting(ClassNode classNode, Class<? extends Annotation> annotationClass, Map<String, Object> members) {
        ClassNode annotationClassNode = ClassHelper.make(annotationClass);
        return addAnnotationOrGetExisting(classNode, annotationClassNode, members);
    }",Add an annotation or get an existing annotation node.
"@Override
    public T add(final Asset asset, final String target, final String name) throws IllegalArgumentException {
        Validate.notNull(target, ""target must be specified"");
        final ArchivePath path = ArchivePaths.create(target);
        return this.add(asset, path, name);
    }",Add an asset to the cache.
"@Override
  public HistoryEvent createBatchStartEvent(Batch batch) {
    HistoryEvent historicBatch = createBatchEvent((BatchEntity) batch, HistoryEventTypes.BATCH_START);

    if (isHistoryRemovalTimeStrategyStart()) {
      provideRemovalTime((HistoricBatchEntity) historicBatch);
    }

    return historicBatch;
  }",Create batch start event
"public static byte[] hmac(SecurityAlgorithm securityAlgorithm,
                              byte[] secretKey,
                              ByteBuffer... buffers) throws UaException {

        String transformation = securityAlgorithm.getTransformation();

        try {
            Mac mac = Mac.getInstance(transformation);
            mac.init(new SecretKeySpec(secretKey, transformation));

            for (ByteBuffer buffer : buffers) {
                mac.update(buffer);
            }

            return mac.doFinal();
        } catch (GeneralSecurityException e) {
            throw new UaException(StatusCodes.Bad_SecurityChecksFailed, e);
        }
    }",HMAC - SHA - 1 of a byte array using a secret key and a list of buffers.
"@CheckReturnValue
  public static byte[][] toRawSerializedHeaders(byte[][] http2Headers) {
    for (int i = 0; i < http2Headers.length; i += 2) {
      byte[] key = http2Headers[i];
      byte[] value = http2Headers[i + 1];
      if (endsWith(key, binaryHeaderSuffixBytes)) {
        // Binary header
        for (int idx = 0; idx < value.length; idx++) {
          if (value[idx] == (byte) ',') {
            return serializeHeadersWithCommasInBin(http2Headers, i);
          }
        }
        byte[] decodedVal = BaseEncoding.base64().decode(new String(value, US_ASCII));
        http2Headers[i + 1] = decodedVal;
      } else {
        // Non-binary header
        // Nothing to do, the value is already in the right place.
      }
    }
    return http2Headers;
  }",Serialize the HTTP2 headers.
"protected void onTransformerErrorOccurred(TransformerErrorEvent event) {

        for (TransformerEventListener listener : transformerEventListeners)
            fireTransformerErrorEvent(listener, event);
    }

    /**
     * Helper method that fires the given event on the given listener.
     * @param listener The listener to fire the event on.
     * @param event The event to fire.
     */
    private void fireTransformerErrorEvent(TransformerEventListener listener, TransformerErrorEvent event) {

        try {
            listener.ErrorOccurred(event);
        }
        catch (RuntimeException e) {
            // Log this somehow
            System.err.println(""Exception thrown while trying to invoke event listener, removing bed behaved listener."");
            e.printStackTrace();
            removeTransformerEventListener(listener);
        }
    }

    public void addSourceEventListener(TransformerSourceEventListener listener) {

        if (listener != null)
            transformerSourceEventListeners.add(listener);
    }

    public void removeSourceEventListener(TransformerSourceEventListener listener) {

        transformerSourceEventListeners.remove(listener);
    }

    /**
     * (Re)-fires the given event
     * @param event The event to fire.
     */
    protected void onTransformerSourceErrorOccurred(TransformerSourceErrorEvent event) {

        for (TransformerSourceEventListener listener : transformerSourceEventListeners)
            fireTransformerSourceErrorEvent(listener, event);
    }

    /**
     * Helper method that fires the given event on the given listener.
     * @param listener The listener to fire the event on.
     * @param event The event to fire.
     */
    private void fireTransformerSourceErrorEvent(TransformerSourceEventListener listener, TransformerSourceErrorEvent event) {

        try {
            listener.ErrorOccurred(event);
        }
        catch (RuntimeException e) {
            // Log this somehow
            System.err.println(""Exception thrown while trying to invoke event listener, removing bed behaved listener."");
            e.printStackTrace();
            removeSourceEventListener(listener);
        }
    }

    public void addSinkEventListener(TransformerSinkEventListener listener) {

        if (listener != null)
            transformerSinkEventListeners.add(listener);
    }

    public void removeSinkEventListener(TransformerSinkEventListener listener) {

        transformerSinkEventListeners.remove(listener);
    }

    /**
     * (Re)-fires the given event
     * @param event The event to fire.
     */
    protected void onTransformerSinkErrorOccurred(TransformerSinkErrorEvent event) {

        for (TransformerSinkEventListener listener : transformerSinkEventListeners)
            fireTransformerSinkErrorEvent(listener, event);
    }

    private void fireTransformerSinkErrorEvent(TransformerSinkEventListener listener, TransformerSinkErrorEvent event) {

        try {
            listener.ErrorOccurred(event);
        }
        catch (RuntimeException e) {
            // Log this somehow
            System.err.println(""Exception thrown while trying to invoke event listener, removing bad behaved listener."");
            e.printStackTrace();
            removeSinkEventListener(listener);
        }
    }
}",Method that fires the error event on the transformer error event listener.
"private static void handlePing(final Channel channel, final ManagementProtocolHeader header) throws IOException {
        final ManagementProtocolHeader response = new ManagementPongHeader(header.getVersion());
        final MessageOutputStream output = channel.writeMessage();
        try {
            writeHeader(response, output);
            output.close();
        } finally {
            StreamUtils.safeClose(output);
        }
    }",Handle a ping request.
"@Override
    public StartInstanceResult startInstance(StartInstanceRequest request) {
        request = beforeClientExecution(request);
        return executeStartInstance(request);
    }",Start an instance.
"public ListElasticsearchVersionsResult withElasticsearchVersions(String... elasticsearchVersions) {
        if (this.elasticsearchVersions == null) {
            setElasticsearchVersions(new java.util.ArrayList<String>(elasticsearchVersions.length));
        }
        for (String ele : elasticsearchVersions) {
            this.elasticsearchVersions.add(ele);
        }
        return this;
    }",A list of Elasticsearch versions to retrieve.
"public ArrayList<String> serviceName_whitelist_GET(String serviceName, String ip, Boolean service, Boolean sftp) throws IOException {
		String qPath = ""/hosting/privateDatabase/{serviceName}/whitelist"";
		StringBuilder sb = path(qPath, serviceName);
		query(sb, ""ip"", ip);
		query(sb, ""service"", service);
		query(sb, ""sftp"", sftp);
		String resp = exec(qPath, ""GET"", sb.toString(), null);
		return convertTo(resp, t1);
	}",List of private database whitelist
"public static <T> Supplier<T> supplier(CheckedSupplier<T> supplier) {
        return supplier(supplier, THROWABLE_TO_RUNTIME_EXCEPTION);
    }",Create a supplier that throws an exception if the exception is thrown.
"public ScreenParent makeScreen(ScreenLoc itsLocation, ComponentParent parentScreen, int iDocMode, Map<String,Object> properties)
    {
        ScreenParent screen = null;
        if ((iDocMode & ClassProject.CLASS_DETAIL_MODE) == ClassProject.CLASS_DETAIL_MODE)
            screen = Record.makeNewScreen(ClassInfo.CLASS_INFO_GRID_SCREEN_CLASS, itsLocation, parentScreen, iDocMode | ScreenConstants.DONT_DISPLAY_FIELD_DESC, properties, this, true);
        else if ((iDocMode & ClassProject.RESOURCE_DETAIL_MODE) == ClassProject.RESOURCE_DETAIL_MODE)
            screen = Record.makeNewScreen(Resource.RESOURCE_GRID_SCREEN_CLASS, itsLocation, parentScreen, iDocMode | ScreenConstants.DONT_DISPLAY_FIELD_DESC, properties, this, true);
        else if ((iDocMode & ScreenConstants.DETAIL_MODE) == ScreenConstants.DETAIL_MODE)
            screen = Record.makeNewScreen(CLASS_PROJECT_GRID_SCREEN_CLASS, itsLocation, parentScreen, iDocMode | ScreenConstants.DONT_DISPLAY_FIELD_DESC, properties, this, true);
        else if ((iDocMode & ScreenConstants.MAINT_MODE) == ScreenConstants.MAINT_MODE)
            screen = Record.makeNewScreen(CLASS_PROJECT_SCREEN_CLASS, itsLocation, parentScreen, iDocMode | ScreenConstants.DONT_DISPLAY_FIELD_DESC, properties, this, true);
        else if ((iDocMode & ScreenConstants.DISPLAY_MODE) != 0)
            screen = Record.makeNewScreen(CLASS_PROJECT_GRID_SCREEN_CLASS, itsLocation, parentScreen, iDocMode | ScreenConstants.DONT_DISPLAY_FIELD_DESC, properties, this, true);
        else if ((iDocMode & ScreenConstants.MENU_MODE) != 0)
            screen = Record.makeNewScreen(CLASS_PROJECT_SCREEN_CLASS, itsLocation, parentScreen, iDocMode | ScreenConstants.DONT_DISPLAY_FIELD_DESC, properties, this, true);
        else
            screen = super.makeScreen(itsLocation, parentScreen, iDocMode, properties);
        return screen;
    }",Make the screen.
"public void initEventHandlers(final CmsSitemapTreeNode node) {

        node.getOpener().addClickListener(new ClickListener() {

            private static final long serialVersionUID = 1L;

            public void buttonClick(ClickEvent event) {

                CmsSitemapTreeController.this.onClickOpen(node);
            }
        });
    }",Initialize event handlers.
"@Override
	public CPOption fetchByUUID_G(String uuid, long groupId) {
		return fetchByUUID_G(uuid, groupId, true);
	}",Returns the cp option with the matching UUID and group.
"public I run(RunnableWithException runnable) {
        try {
            runnable.run();
        } catch (Exception e) {
            sneakyThrow(e);
        }
        return getThis();
    }",Run a RunnableWithException in a thread.
"@Deprecated
    public static ZProxy newZProxy(ZContext ctx, String name, SelectorCreator selector, Proxy sockets,
                                   String motdelafin, Object... args)
    {
        return newZProxy(ctx, name, sockets, motdelafin, args);
    }",Create a new instance of a CID   .
"private void emit() throws TTIOException {
        // Emit pending end elements.
        if (mCloseElements) {
            if (!mStack.empty() && mStack.peek() != ((ITreeStructData)mRtx.getNode()).getLeftSiblingKey()) {
                mRtx.moveTo(mStack.pop());
                emitEndTag();
                mRtx.moveTo(mKey);
            } else if (!mStack.empty()) {
                mRtx.moveTo(mStack.pop());
                emitEndTag();
                mRtx.moveTo(mKey);
                mCloseElements = false;
                mCloseElementsEmitted = true;
            }
        } else {
            mCloseElementsEmitted = false;

            // Emit node.
            emitNode();

            final long nodeKey = mRtx.getNode().getDataKey();
            mLastKey = nodeKey;

            // Push end element to stack if we are a start element.
            if (mRtx.getNode().getKind() == ELEMENT) {
                mStack.push(nodeKey);
            }

            // Remember to emit all pending end elements from stack if
            // required.
            if (!((ITreeStructData)mRtx.getNode()).hasFirstChild()
                && !((ITreeStructData)mRtx.getNode()).hasRightSibling()) {
                mGoUp = true;
                moveToNextNode();
            } else if (mRtx.getNode().getKind() == ELEMENT && !((ElementNode)mRtx.getNode()).hasFirstChild()) {
                // Case: Empty elements with right siblings.
                mGoBack = true;
                moveToNextNode();
            }
        }
    }",Emit the entire XML file.
"public static List<String> expandEnvironmentVariables(final List<String> command) {
    final ArrayList<String> res = new ArrayList<>(command.size());
    for (final String cmd : command) {
      res.add(expandEnvironmentVariables(cmd));
    }
    return res;
  }",Expand environment variables in a list of command.
"public byte[] bytes() {
		return writer == null ? Arrays.copyOf(bytes, length) : writer.getBytes(false);
	}",Returns the bytes of this buffer.
"public void setCalendar(ProjectCalendar calendar)
   {
      set(TaskField.CALENDAR, calendar);
      setCalendarUniqueID(calendar == null ? null : calendar.getUniqueID());
   }",Sets the calendar object.
"public static String toHtml5DataName(String headlessCamelCaseName) {
    if (StringUtils.isEmpty(headlessCamelCaseName)) {
      throw new IllegalArgumentException(""Property name is empty."");
    }
    if (!isHeadlessCamelCaseName(headlessCamelCaseName)) {
      throw new IllegalArgumentException(""This is not a valid headless camel case property name: "" + headlessCamelCaseName);
    }

    StringBuilder html5DataName = new StringBuilder(HTML5_DATA_PREFIX);
    for (int i = 0; i < headlessCamelCaseName.length(); i++) {
      char c = headlessCamelCaseName.charAt(i);
      if (CharUtils.isAsciiAlphaUpper(c)) {
        html5DataName.append('-');
      }
      html5DataName.append(Character.toLowerCase(c));
    }

    return html5DataName.toString();
  }",Converts a headless camel case property name to an HTML5 data name.
"MutableBigInteger euclidModInverse(int k) {
        MutableBigInteger b = new MutableBigInteger(1);
        b.leftShift(k);
        MutableBigInteger mod = new MutableBigInteger(b);

        MutableBigInteger a = new MutableBigInteger(this);
        MutableBigInteger q = new MutableBigInteger();
        MutableBigInteger r = b.divide(a, q);

        MutableBigInteger swapper = b;
        // swap b & r
        b = r;
        r = swapper;

        MutableBigInteger t1 = new MutableBigInteger(q);
        MutableBigInteger t0 = new MutableBigInteger(1);
        MutableBigInteger temp = new MutableBigInteger();

        while (!b.isOne()) {
            r = a.divide(b, q);

            if (r.intLen == 0)
                throw new ArithmeticException(""BigInteger not invertible."");

            swapper = r;
            a = swapper;

            if (q.intLen == 1)
                t1.mul(q.value[q.offset], temp);
            else
                q.multiply(t1, temp);
            swapper = q;
            q = temp;
            temp = swapper;
            t0.add(q);

            if (a.isOne())
                return t0;

            r = b.divide(a, q);

            if (r.intLen == 0)
                throw new ArithmeticException(""BigInteger not invertible."");

            swapper = b;
            b =  r;

            if (q.intLen == 1)
                t0.mul(q.value[q.offset], temp);
            else
                q.multiply(t0, temp);
            swapper = q; q = temp; temp = swapper;

            t1.add(q);
        }
        mod.subtract(t1);
        return mod;
    }",Euclid Mod inverse.
"private static boolean canBeContinued(final byte[] data, final List<Policy> policies) {
		boolean result = true;
		for (Policy policy : policies) {
			result &= policy.continueCurrentFile(data);
		}
		return result;
	}",Check if the data can be continued.
"public static void convertSixBitToBits(String str, int padBits, boolean bitSet[],
	        boolean[] calculated, int from, int to) {
		if (str.length() == 0)
			return;
		int index = from - from % 6;
		int strFrom = from / 6;
		int slen = str.length() - 1;
		int strTo = to / 6 + 1;
		for (int i = strFrom; i < Math.min(strTo, slen); i++) {
			if (!calculated[i]) {
				char chr = str.charAt(i);
				int binVal = INT_TO_SIX_BIT[chr];
				if (binVal == -1) {
					throw new SixBitException(""Illegal sixbit ascii char: "" + chr);
				}
				bitSet[index] = (binVal & 32) > 0;
				bitSet[index + 1] = (binVal & 16) > 0;
				bitSet[index + 2] = (binVal & 8) > 0;
				bitSet[index + 3] = (binVal & 4) > 0;
				bitSet[index + 4] = (binVal & 2) > 0;
				bitSet[index + 5] = (binVal & 1) > 0;

				calculated[i] = true;
			}

			index += 6;
		}
		if (strTo > slen) {
			// Process the last char which might be padded
			char chr = str.charAt(slen);
			int binVal = INT_TO_SIX_BIT[chr];
			if (binVal == -1) {
				throw new SixBitException(""Illegal sixbit ascii char: "" + chr);
			}
			int bits = 6 - padBits;

			switch (bits) {
			case 6:
				bitSet[index + 5] = (binVal & 1) > 0;
			case 5:
				bitSet[index + 4] = (binVal & 2) > 0;
			case 4:
				bitSet[index + 3] = (binVal & 4) > 0;
			case 3:
				bitSet[index + 2] = (binVal & 8) > 0;
			case 2:
				bitSet[index + 1] = (binVal & 16) > 0;
			case 1:
				bitSet[index] = (binVal & 32) > 0;
			}

			calculated[slen] = true;
		}
	}",Convert a string of sixbits to bits.
"JCExpression retype(JCExpression tree, Type erasedType, Type target) {
//      System.err.println(""retype "" + tree + "" to "" + erasedType);//DEBUG
        if (!erasedType.isPrimitive()) {
            if (target != null && target.isPrimitive()) {
                target = erasure(tree.type);
            }
            tree.type = erasedType;
            if (target != null) {
                return coerce(tree, target);
            }
        }
        return tree;
    }",retype - Method to convert a JCExpression to a type
"public InterceptorConfigurationBuilder clearProperties() {
      TypedProperties properties = attributes.attribute(PROPERTIES).get();
      properties.clear();
      attributes.attribute(PROPERTIES).set(TypedProperties.toTypedProperties(properties));
      return this;
   }",Clear the properties of the interceptor.
"public String remove(String name)
    {
        String old=null;
        FieldInfo info=getFieldInfo(name);
        Field field=getField(info,true);

        if (field!=null)
        {
            old=field._value;
            while(field!=null)
            {
                field.clear();
                field=field._next;
            }
        }
        
        return old;
    }",Removes the value of a single SECTYPE field from the record.
"public T end(String element) throws IOException {
		writer.write(""</"");
		writer.write(element);
		writer.write('>');
		return (T) this;
	}",Ends a tag with the specified element.
"public Governator addModules(List<Module> modules) {
        if (modules != null) {
            this.modules.addAll(modules);
        }
        return this;
    }",Add the modules to the list of modules.
"public static <D> SipAssembler<D> forPdiAndContentWithContentHashing(PackagingInformation prototype,
      Assembler<HashedContents<D>> pdiAssembler, DigitalObjectsExtraction<D> contentsExtraction,
      HashAssembler contentHashAssembler) {
    return forPdiAndContentWithHashing(prototype, pdiAssembler, new NoHashAssembler(), contentsExtraction,
        contentHashAssembler);
  }",Create a sip assembly for a packed information object containing a PDI and a set of objects.
"@Override
	public void set(final PreparedStatement st, final int index, final Array value, final int dbSqlType) throws SQLException {
		st.setArray(index, value);
	}",Set an Array value in the PreparedStatement.
"public Snapshot withNodeSnapshots(NodeSnapshot... nodeSnapshots) {
        if (this.nodeSnapshots == null) {
            setNodeSnapshots(new com.amazonaws.internal.SdkInternalList<NodeSnapshot>(nodeSnapshots.length));
        }
        for (NodeSnapshot ele : nodeSnapshots) {
            this.nodeSnapshots.add(ele);
        }
        return this;
    }",Sets the value of the nodeSnapshots property.
"@NonNull
    public final Router getChildRouter(@NonNull ViewGroup container, @Nullable String tag) {
        //noinspection ConstantConditions
        return getChildRouter(container, tag, true);
    }",Get the child Router of a specific tag.
"@SuppressWarnings(""unchecked"")
    protected <D> void evalResponse(Request request, Deferred<D> deferred, Class<D> resolveType,
                                    Class<?> parametrizedType, RawResponse response) {
        if (parametrizedType != null) {
            processor.process(request, response, parametrizedType, (Class<Collection>) resolveType,
                    (Deferred<Collection>) deferred);
        } else {
            processor.process(request, response, resolveType, deferred);
        }
    }",Evaluate the response.
"private synchronized void complete(String message) {
    
    // This is a weird problem with writing stuff while idling. Need to investigate it more, but
    // for now just ignore it.
    if (MESSAGE_COULDNT_BE_FETCHED_REGEX.matcher(message).matches()) {
      log.warn(""Some messages in the batch could not be fetched for {}\n"" +
          ""---cmd---\n{}\n---wire---\n{}\n---end---\n"", new Object[] {
          config.getUsername(),
          getCommandTrace(),
          getWireTrace()
      });
      errorStack.push(new Error(completions.peek(), message, wireTrace.list()));
      final CommandCompletion completion = completions.peek();
      String errorMsg = ""Some messages in the batch could not be fetched for user "" + config.getUsername();
      RuntimeException ex = new RuntimeException(errorMsg);
      if (completion != null) {
        completion.error(errorMsg, new MailHandlingException(getWireTrace(), errorMsg, ex));
        completions.poll();
      } else {
        throw ex;
      }
    }

    CommandCompletion completion = completions.peek();
    if (completion == null) {
      if (""+ idling"".equalsIgnoreCase(message)) {
        synchronized (idleMutex) {
          idler.idleStart();
          log.trace(""IDLE entered."");
          idleAcknowledged.set(true);
        }
      } else {
        log.error(""Could not find the completion for message {} (Was it ever issued?)"", message);
        errorStack.push(new Error(null, ""No completion found!"", wireTrace.list()));
      }
      return;
    }
    
    if (completion.complete(message)) {
      completions.poll();
    }
  }",Completes the command.
"static List<String> valueAsStringList(Map<String, Object> map, Key key, List<String> defaultValue) {
        Validate.notNullOrEmpty(key.key, ""Key for plugin configuration must be set"");
        if (map.containsKey(key.key)) {
            Object rawMapOrObject = map.get(key.key);

            // handles non-nested content
            if (key.subKey == null) {
                if (rawMapOrObject == null) {
                    return defaultValue;
                } else {
                    return tokenize(rawMapOrObject, key.delimiter);
                }
            }

            // go for nested content
            if (rawMapOrObject == null) {
                return defaultValue;

            } else if (!(rawMapOrObject instanceof Map)) {
                return Arrays.asList(rawMapOrObject.toString());
            }

            // 1/ we can either have <excludes>foo,bar</excludes>
            // 2/ or <excludes><exclude>foo</exclude><exclude>bar</exclude></excludes>
            @SuppressWarnings(""unchecked"")
            Map<String, Object> subMap = (Map<String, Object>) rawMapOrObject;
            Object nestedRaw = subMap.get(key.subKey);
            if (nestedRaw == null) {
                return defaultValue;
            }
            // format 2/
            else if (nestedRaw instanceof Iterable<?>) {
                List<String> list = new ArrayList<String>();
                for (Object nested : (Iterable<?>) nestedRaw) {
                    list.addAll(tokenize(nested, key.delimiter));
                }
                return list;
            }
            // format 1/
            else {
                return tokenize(nestedRaw, key.delimiter);
            }
        }
        return defaultValue;
    }",Returns the value of the value of the key in the map as a list of strings.
"protected ConversionExecutor getPropertyConversionExecutor() {
        if (conversionExecutor == null) {
            conversionExecutor = getConversionService().getConversionExecutor(Object[].class, getPropertyType());
        }
        return conversionExecutor;
    }",Get the conversion executor for the property type.
"public static double subtract(double minuend, double reduction, int scale) {
        BigDecimal minuendBd = new BigDecimal(Double.toString(minuend));
        BigDecimal reductionBd = new BigDecimal(Double.toString(reduction));
        MathContext mathContext = new MathContext(scale, RoundingMode.HALF_UP);
        return minuendBd.subtract(reductionBd, mathContext).doubleValue();
    }",Subtracts two numbers.
"public static <T extends Appendable> boolean escapeUnprintable(T result, int c) {
        try {
            if (isUnprintable(c)) {
                result.append('\\');
                if ((c & ~0xFFFF) != 0) {
                    result.append('U');
                    result.append(DIGITS[0xF&(c>>28)]);
                    result.append(DIGITS[0xF&(c>>24)]);
                    result.append(DIGITS[0xF&(c>>20)]);
                    result.append(DIGITS[0xF&(c>>16)]);
                } else {
                    result.append('u');
                }
                result.append(DIGITS[0xF&(c>>12)]);
                result.append(DIGITS[0xF&(c>>8)]);
                result.append(DIGITS[0xF&(c>>4)]);
                result.append(DIGITS[0xF&c]);
                return true;
            }
            return false;
        } catch (IOException e) {
            throw new IllegalIcuArgumentException(e);
        }
    }",Escape an int value as an UNPRINTABLE string.
"public static boolean checkService(Context context, Class<?> service) {
    try {
      ServiceInfo info = context.getPackageManager().getServiceInfo(
          new ComponentName(context, service), 0);
      return null != info;
    } catch (PackageManager.NameNotFoundException e) {
      printErrorLog(""service "" + service.getName() + "" is missing!"");
      return false;
    }
  }",Check if the service is available in the context
"protected final void maskedPrintCommandLine(@Nonnull List<String> cmd, @CheckForNull boolean[] mask, @CheckForNull FilePath workDir) {
        if(mask==null) {
            printCommandLine(cmd.toArray(new String[0]),workDir);
            return;
        }
        
        assert mask.length == cmd.size();
        final String[] masked = new String[cmd.size()];
        for (int i = 0; i < cmd.size(); i++) {
            if (mask[i]) {
                masked[i] = ""********"";
            } else {
                masked[i] = cmd.get(i);
            }
        }
        printCommandLine(masked, workDir);
    }",Print command line.
"private int updateList(Pathfindable mover,
                           int stx,
                           int sty,
                           int dtx,
                           int dty,
                           boolean ignoreRef,
                           Node current,
                           int maxDepth)
    {
        int depth = maxDepth;
        final Tile tile = map.getTile(current.getX(), current.getY());
        final TilePath tilePath = tile.getFeature(TilePath.class);
        for (int y = -1; y < 2; y++)
        {
            for (int x = -1; x < 2; x++)
            {
                if (!(x == 0 && y == 0))
                {
                    depth = check(tilePath, depth, x, y, mover, stx, sty, dtx, dty, ignoreRef, current, maxDepth);
                }
            }
        }
        return depth;
    }",Update the list of all the image.
"private void readPropertySourceFromLoader(String fileName, String filePath, PropertySourceLoader propertySourceLoader, List<PropertySource> propertySources) throws ConfigurationException {
        ResourceResolver resourceResolver = new ResourceResolver();
        Optional<ResourceLoader> resourceLoader = resourceResolver.getSupportingLoader(filePath);
        ResourceLoader loader = resourceLoader.orElse(FileSystemResourceLoader.defaultLoader());
        try {
            Optional<InputStream> inputStream = loader.getResourceAsStream(filePath);
            if (inputStream.isPresent()) {
                Map<String, Object> properties = propertySourceLoader.read(fileName, inputStream.get());
                propertySources.add(PropertySource.of(properties));
            }
        } catch (IOException e) {
            throw new ConfigurationException(""Unsupported properties file: "" + fileName);
        }
    }",Read property source from loader.
"@Override
	public SICoreConnection createConnection(ClientConnection cc,
			String credentialType, String userid, String password)
			throws SIResourceException, SINotAuthorizedException,
			SIAuthenticationException {
		// Basically this method will not be called
		// It is there in the interface just to be called by the Comms component to MessageProcessor
		if (TRACE.isEntryEnabled()) {
            SibTr.entry(this, TRACE, ""createConnection"", new Object[] {cc, credentialType, userid, password});
        }
		SibTr.error(TRACE, ""This method should not have been called"");
		if (TRACE.isEntryEnabled()) {
            SibTr.exit(this, TRACE, ""createConnection"", null);
        }
		return null;
	}",This method is called by the SICoreConnection interface to create a SICoreConnection object.
"@Override
    protected void shutdown() {
        if (isSmEnabled()) {
            try {
                // Try to send a last SM Acknowledgement. Most servers won't find this information helpful, as the SM
                // state is dropped after a clean disconnect anyways. OTOH it doesn't hurt much either.
                sendSmAcknowledgementInternal();
            } catch (InterruptedException | NotConnectedException e) {
                LOGGER.log(Level.FINE, ""Can not send final SM ack as connection is not connected"", e);
            }
        }
        shutdown(false);
    }",Shutdown the service.
"@SuppressWarnings(""unchecked"")
	public EList<IfcComplexProperty> getPartOfComplex() {
		return (EList<IfcComplexProperty>) eGet(Ifc2x3tc1Package.Literals.IFC_PROPERTY__PART_OF_COMPLEX, true);
	}",Gets the part of complex.
"public void validate(Object submittedValue, VariableMap submittedValues, FormFieldHandler formFieldHandler, VariableScope variableScope) {
    try {

      FormFieldValidatorContext context = new DefaultFormFieldValidatorContext(variableScope, config, submittedValues, formFieldHandler);
      if(!validator.validate(submittedValue, context)) {
        throw new FormFieldValidatorException(formFieldHandler.getId(), name, config, submittedValue, ""Invalid value submitted for form field '""+formFieldHandler.getId()+""': validation of ""+this+"" failed."");
      }
    } catch(FormFieldValidationException e) {
      throw new FormFieldValidatorException(formFieldHandler.getId(), name, config, submittedValue, ""Invalid value submitted for form field '""+formFieldHandler.getId()+""': validation of ""+this+"" failed."", e);
    }
  }",Validate the submitted value.
"public int call(String method, Object[] params,
            DDPListener resultListener) {
        return getDDP().call(method, params, resultListener);
    }",Call a method on the DDP.
"public static Optional<DeclaredType> nonObjectSuperclass(final Types types, Elements elements,
      DeclaredType type) {
    checkNotNull(types);
    checkNotNull(elements);
    checkNotNull(type);

    final TypeMirror objectType =
        elements.getTypeElement(Object.class.getCanonicalName()).asType();
    // It's guaranteed there's only a single CLASS superclass because java doesn't have multiple
    // class inheritance.
    TypeMirror superclass =
        getOnlyElement(
            FluentIterable.from(types.directSupertypes(type))
                .filter(
                    new Predicate<TypeMirror>() {
                      @Override
                      public boolean apply(TypeMirror input) {
                        return input.getKind().equals(TypeKind.DECLARED)
                            && (MoreElements.asType(MoreTypes.asDeclared(input).asElement()))
                                .getKind()
                                .equals(ElementKind.CLASS)
                            && !types.isSameType(objectType, input);
                      }
                    }),
            null);
    return superclass != null
        ? Optional.of(MoreTypes.asDeclared(superclass))
        : Optional.<DeclaredType>absent();
  }",Get the non - object superclass of the given type.
"@Override
  @Deprecated
  public ORecordIteratorCluster<ODocument> browseCluster(String iClusterName, long startClusterPosition, long endClusterPosition,
      boolean loadTombstones) {
    checkSecurity(ORule.ResourceGeneric.CLUSTER, ORole.PERMISSION_READ, iClusterName);

    return new ORecordIteratorCluster<ODocument>(this, getClusterIdByName(iClusterName), startClusterPosition, endClusterPosition,
        OStorage.LOCKING_STRATEGY.DEFAULT);
  }",browseCluster This is a deprecated method.
"private double ssqerr(int k0, int kmax, double[] logk, double[] log_kDist, double m, double t) {
    int k = kmax - k0;
    double result = 0;
    for(int i = 0; i < k; i++) {
      // double h = log_kDist[i] - (m * (logk[i] - logk[0]) + t); ???
      double h = log_kDist[i] - m * logk[i] - t;
      result += h * h;
    }
    return result;
  }",SSQERR - compute the squared error of a given distribution.
"private void resetNextProxy(HttpUrl url, Proxy proxy) {
    if (proxy != null) {
      // If the user specifies a proxy, try that and only that.
      proxies = Collections.singletonList(proxy);
    } else {
      // Try each of the ProxySelector choices until one connection succeeds.
      List<Proxy> proxiesOrNull = address.proxySelector().select(url.uri());
      proxies = proxiesOrNull != null && !proxiesOrNull.isEmpty()
          ? Util.immutableList(proxiesOrNull)
          : Util.immutableList(Proxy.NO_PROXY);
    }
    nextProxyIndex = 0;
  }",Reset the next proxy.
"@SuppressWarnings(""unchecked"")
    public <T extends AbstractJaxb> void removeDescendants(Class<T> tagType) {
        RemoveDescendantsUtil.removeDescendants((T) this, tagType);
    }",Remove all descendants of the given tag type from this tag.
"public static String getElementText(Element elem) {
        StringBuilder result = new StringBuilder();
        NodeList nodeList = elem.getChildNodes();
        for (int index = 0; index < nodeList.getLength(); index++) {
            Node childNode = nodeList.item(index);
            if (childNode != null && (childNode instanceof Text)) {
                result.append("" "");
                result.append(((Text)childNode).getData());
            }
        }
        return result.toString().trim();
    }",Gets the text content of an Element.
"public static char[] flagsToChars(final short flags)
    {
        final char[] chars = new char[]{ '0', '0', '0', '0', '0', '0', '0', '0' };
        final int length = chars.length;
        short mask = (short)(1 << (length - 1));

        for (int i = 0; i < length; i++)
        {
            if ((flags & mask) == mask)
            {
                chars[i] = '1';
            }

            mask >>= 1;
        }

        return chars;
    }",Returns a char array with the flags.
"public Select addSelect(String tag,
                            String label,
                            boolean multiple,
                            int size,
                            Enumeration values)
    {
        Select s = addSelect(tag,label,multiple,size);
        s.setSize(size);
        while (values.hasMoreElements())
            s.add(values.nextElement().toString());
        return s;
    }",Add a Select object to this Collection.
"@Override
    public GetTagKeysResult getTagKeys(GetTagKeysRequest request) {
        request = beforeClientExecution(request);
        return executeGetTagKeys(request);
    }",Returns a list of tag keys for a specific language.
"public WebElement findElement(SearchContext context) {
    List<WebElement> allElements = findElements(context);
    if (allElements == null || allElements.isEmpty()) {
      throw new NoSuchElementException(""Cannot locate an element using "" + toString());
    }
    return allElements.get(0);
  }",Find an element using the specified search context.
"private void processCellValue(Record record) {
		Object value = null;
		
		switch (record.getSid()) {
		case BlankRecord.sid:
			// 空白记录
			BlankRecord brec = (BlankRecord) record;
			rowCellList.add(brec.getColumn(), StrUtil.EMPTY);
			break;
		case BoolErrRecord.sid: // 布尔类型
			BoolErrRecord berec = (BoolErrRecord) record;
			rowCellList.add(berec.getColumn(), berec.getBooleanValue());
			break;
		case FormulaRecord.sid: // 公式类型
			FormulaRecord frec = (FormulaRecord) record;
			if (isOutputFormulaValues) {
				if (Double.isNaN(frec.getValue())) {
					// Formula result is a string
					// This is stored in the next record
					isOutputNextStringRecord = true;
				} else {
					value = formatListener.formatNumberDateCell(frec);
				}
			} else {
				value = '""' + HSSFFormulaParser.toFormulaString(stubWorkbook, frec.getParsedExpression()) + '""';
			}
			rowCellList.add(frec.getColumn(), value);
			break;
		case StringRecord.sid:// 单元格中公式的字符串
			if (isOutputNextStringRecord) {
				// String for formula
				StringRecord srec = (StringRecord) record;
				value = srec.getString();
				isOutputNextStringRecord = false;
			}
			break;
		case LabelRecord.sid:
			LabelRecord lrec = (LabelRecord) record;
			this.rowCellList.add(lrec.getColumn(), value);
			break;
		case LabelSSTRecord.sid: // 字符串类型
			LabelSSTRecord lsrec = (LabelSSTRecord) record;
			if (sstRecord == null) {
				rowCellList.add(lsrec.getColumn(), StrUtil.EMPTY);
			} else {
				value = sstRecord.getString(lsrec.getSSTIndex()).toString();
				rowCellList.add(lsrec.getColumn(), value);
			}
			break;
		case NumberRecord.sid: // 数字类型
			NumberRecord numrec = (NumberRecord) record;
			
			final String formatString = formatListener.getFormatString(numrec);
			if(formatString.contains(StrUtil.DOT)) {
				//浮点数
				value = numrec.getValue();
			}else if(formatString.contains(StrUtil.SLASH) || formatString.contains(StrUtil.COLON)) {
				//日期
				value = formatListener.formatNumberDateCell(numrec);
			}else {
				double numValue = numrec.getValue();
				final long longPart = (long) numValue;
				// 对于无小数部分的数字类型，转为Long，否则保留原数字
				value = (longPart == numValue) ? longPart : numValue;
			}

			// 向容器加入列值
			rowCellList.add(numrec.getColumn(), value);
			break;
		default:
			break;
		}
	}",Process a cell value.
"public final <U2> Tuple3<T1, U2, T3> map2(Function<? super T2, ? extends U2> function) {
        return Tuple.tuple(v1, function.apply(v2), v3);
    }",Maps this tuple to a tuple of two values using the supplied function.
"protected EmailTextField newEmailTextField(final String id, final IModel<M> model)
	{
		return ComponentFactory.newEmailTextField(id,
			new PropertyModel<String>(model.getObject(), getId()));
	}",Factory method for creating the EmailTextField. This method is invoked in the constructor from the derived classes and can be overridden so users can provide their own version of a EmailTextField.
"public Period withField(DurationFieldType field, int value) {
        if (field == null) {
            throw new IllegalArgumentException(""Field must not be null"");
        }
        int[] newValues = getValues();  // cloned
        super.setFieldInto(newValues, field, value);
        return new Period(newValues, getPeriodType());
    }",Sets the value of the specified field to the specified value.
"public Image addImage(String listId, AddImageOptionalParameter addImageOptionalParameter) {
        return addImageWithServiceResponseAsync(listId, addImageOptionalParameter).toBlocking().single().body();
    }",Adds an image to a list.
"public synchronized void applyToAll(SocketOperator op) throws Exception {
        Enumeration keys = allSockets.keys();
        while (keys.hasMoreElements()) {
            SocketBox myBox = (SocketBox) keys.nextElement();
            op.operate(myBox);
        }
    }",Apply the given operator to all sockets.
"public int read(final Reader reader) throws IOException {
        final int c = reader.read(cbuf);
        if (c > 0) {
            addData(cbuf, 0, c);
        }
        return c;
    }",Read a single record from the specified reader.
"public static String valueString(long value, Denomination denomination) {
      BigDecimal d = BigDecimal.valueOf(value);
      d = d.divide(denomination.getOneUnitInSatoshis());
      return d.toPlainString();
   }",Get value string from long value and Denomination
"@Override
    public int available () throws IOException {
        try ( SmbFileHandleImpl fd = this.handle.ensureOpen();
              SmbTreeHandleImpl th = fd.getTree() ) {
            if ( th.isSMB2() ) {
                Smb2IoctlRequest req = new Smb2IoctlRequest(th.getConfig(), Smb2IoctlRequest.FSCTL_PIPE_PEEK, fd.getFileId());
                req.setMaxOutputResponse(16);
                req.setFlags(Smb2IoctlRequest.SMB2_O_IOCTL_IS_FSCTL);
                Smb2IoctlResponse resp = th.send(req, RequestParam.NO_RETRY);
                return ((SrvPipePeekResponse)resp.getOutputData()).getReadDataAvailable();
            }
            TransPeekNamedPipe req = new TransPeekNamedPipe(th.getConfig(), this.handle.getUncPath(), fd.getFid());
            TransPeekNamedPipeResponse resp = new TransPeekNamedPipeResponse(th.getConfig());
            th.send(req, resp, RequestParam.NO_RETRY);
            if ( resp.getStatus() == TransPeekNamedPipeResponse.STATUS_DISCONNECTED
                    || resp.getStatus() == TransPeekNamedPipeResponse.STATUS_SERVER_END_CLOSED ) {
                fd.markClosed();
                return 0;
            }
            return resp.getAvailable();
        }
        catch ( SmbException se ) {
            throw seToIoe(se);
        }
    }",Returns the available bytes in the file.
"public boolean eq(IntDoubleSortedVector other, double delta) {
        // This is slow, but correct.
        IntDoubleSortedVector v1 = IntDoubleSortedVector.getWithNoZeroValues(this, delta);
        IntDoubleSortedVector v2 = IntDoubleSortedVector.getWithNoZeroValues(other, delta);
                
        if (v2.size() != v1.size()) {
            return false;
        }

        for (IntDoubleEntry ve : v1) {
            if (!Primitives.equals(ve.get(), v2.get(ve.index()), delta)) {
                return false;
            }
        }
        for (IntDoubleEntry ve : v2) {
            if (!Primitives.equals(ve.get(), v1.get(ve.index()), delta)) {
                return false;
            }
        }
        return true;
    }",Check if two IntDoubleSortedVectors are equal.
"public static boolean valueChanged(Boolean before, Boolean after) {
        if ((before == null && after == null) || after == null) {
            return false;
        }

        if (before == null) {
            return true;
        }

        return !before.equals(after);
    }",Check if the value of the attribute has changed.
"public static Server from(ServiceAccessor accessor,
                              Vertx vertx,
                              String name,
                              Configuration configuration) {
        return new Server(
                accessor,
                vertx,
                name,
                configuration.getIntegerOrDie(""port""),
                configuration.getBooleanWithDefault(""ssl"", false),
                configuration.getBooleanWithDefault(""authentication"", false),
                configuration.get(""host""),
                configuration.getList(""allow""),
                configuration.getList(""deny""),
                configuration.get(""onDenied"")
        );
    }",Create a new server from the given configuration.
"public static Hashtable<String,Vector<Object>> errorAsHastable(String msgId)
    {
        Hashtable<String,Vector<Object>> table = new Hashtable<String,Vector<Object>>();
        table.put(GreenPepperServerErrorKey.ERROR, errorAsVector(msgId));
        return table;
    }",Create a Hashtable of String values representing the error as a Hastable Hashtable of String values.
"public String readString() throws IOException {
		StringBuilder result = new StringBuilder();
		while (true) {
			int c = r.read();
			if (c < 0) {
				throw new IllegalStateException(""Premature end of stream"");
			} else if (c == '""') {
				break;
			} else if (c == '\\') {
				int c2 = r.read();
				if (c2 == '""' || c2 == '\\' || c2 == '/') {
					result.append((char)c2);
				} else if (c2 == 'b') {
					result.append(""\b"");
				} else if (c2 == 'f') {
					result.append(""\f"");
				} else if (c2 == 'n') {
					result.append(""\n"");
				} else if (c2 == 'r') {
					result.append(""\r"");
				} else if (c2 == 't') {
					result.append(""\t"");
				} else if (c2 == 'u') {
					int d1 = r.read();
					int d2 = r.read();
					int d3 = r.read();
					int d4 = r.read();
					checkHexDigit(d1);
					checkHexDigit(d2);
					checkHexDigit(d3);
					checkHexDigit(d4);
					int e = Character.digit(d1, 16);
					e = (e << 4) + Character.digit(d2, 16);
					e = (e << 4) + Character.digit(d3, 16);
					e = (e << 4) + Character.digit(d4, 16);
					result.append((char)e);
				}
			} else {
				result.append((char)c);
			}
		}
		return result.toString();
	}",Reads a string from the stream.
"public ApiResponse<SubscriptionsEnvelope> getAllSubscriptionsWithHttpInfo(String uid, Integer offset, Integer count) throws ApiException {
        com.squareup.okhttp.Call call = getAllSubscriptionsValidateBeforeCall(uid, offset, count, null, null);
        Type localVarReturnType = new TypeToken<SubscriptionsEnvelope>(){}.getType();
        return apiClient.execute(call, localVarReturnType);
    }",Get all subscriptions. getAllSubscriptions
"public ExpressRoutePortInner createOrUpdate(String resourceGroupName, String expressRoutePortName, ExpressRoutePortInner parameters) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, expressRoutePortName, parameters).toBlocking().last().body();
    }",Creates or updates an ExpressRoutePort resource.
"@Subscribe
    public void complete(ReplicationCompleted rc) {
        mHandler.post(new Runnable() {
            @Override
            public void run() {
                if (mListener != null) {
                    mListener.replicationComplete();
                }
            }
        });
    }",Called when a replication is complete.
"@Override
	public CPDefinitionInventory fetchByCPDefinitionId(long CPDefinitionId,
		boolean retrieveFromCache) {
		Object[] finderArgs = new Object[] { CPDefinitionId };

		Object result = null;

		if (retrieveFromCache) {
			result = finderCache.getResult(FINDER_PATH_FETCH_BY_CPDEFINITIONID,
					finderArgs, this);
		}

		if (result instanceof CPDefinitionInventory) {
			CPDefinitionInventory cpDefinitionInventory = (CPDefinitionInventory)result;

			if ((CPDefinitionId != cpDefinitionInventory.getCPDefinitionId())) {
				result = null;
			}
		}

		if (result == null) {
			StringBundler query = new StringBundler(3);

			query.append(_SQL_SELECT_CPDEFINITIONINVENTORY_WHERE);

			query.append(_FINDER_COLUMN_CPDEFINITIONID_CPDEFINITIONID_2);

			String sql = query.toString();

			Session session = null;

			try {
				session = openSession();

				Query q = session.createQuery(sql);

				QueryPos qPos = QueryPos.getInstance(q);

				qPos.add(CPDefinitionId);

				List<CPDefinitionInventory> list = q.list();

				if (list.isEmpty()) {
					finderCache.putResult(FINDER_PATH_FETCH_BY_CPDEFINITIONID,
						finderArgs, list);
				}
				else {
					CPDefinitionInventory cpDefinitionInventory = list.get(0);

					result = cpDefinitionInventory;

					cacheResult(cpDefinitionInventory);
				}
			}
			catch (Exception e) {
				finderCache.removeResult(FINDER_PATH_FETCH_BY_CPDEFINITIONID,
					finderArgs);

				throw processException(e);
			}
			finally {
				closeSession(session);
			}
		}

		if (result instanceof List<?>) {
			return null;
		}
		else {
			return (CPDefinitionInventory)result;
		}
	}",Returns the cp definition inventory in the database or adds it if it does not exist.
"public static <K, V> ListMultimap<K, V> newListMultimap(
      Map<K, Collection<V>> map, final Supplier<? extends List<V>> factory) {
    return new CustomListMultimap<K, V>(map, factory);
  }",Creates a new ListMultimap from a map.
"public Matcher region(int start, int end) {
        if ((start < 0) || (start < 0))
            throw new IndexOutOfBoundsException(""start"");
        if ((end < 0) || (end > matcher.dataEnd()))
            throw new IndexOutOfBoundsException(""end"");
        if (start > end)
            throw new IndexOutOfBoundsException(""start > end"");
        matcher.setTarget(matcher.targetChars(), start, end - start);
        return this;
    }",region Method.
"public final void setInstructionObserverThreshold(int threshold)
    {
        if (sealed) onSealedMutation();
        if (threshold < 0) throw new IllegalArgumentException();
        instructionThreshold = threshold;
        setGenerateObserverCount(threshold > 0);
    }",Sets the threshold of instruction observers to use.
"public Credentials toCredentials(String username, String password) {
	return CredentialsImpl.toCredentials(username, password);
    }",Returns a Credentials object that can be used to authenticate the user with the specified password.
"@Override
    public void run() {
        log.debug(""HostProcess.run"");

        try {
            hostProcessStartTime = System.currentTimeMillis();

            // Initialise plugin factory to report the state of the plugins ASAP.
            pluginFactory.reset();
            synchronized (mapPluginStats) {
                for (Plugin plugin : pluginFactory.getPending()) {
                    mapPluginStats.put(plugin.getId(), new PluginStats(plugin.getName()));
                }
            }

            for (StructuralNode startNode : startNodes) {
                traverse(startNode, true, node -> {
                    if (canScanNode(node)) {
                        messagesIdsToAppScan.add(node.getHistoryReference().getHistoryId());
                    }
                });

                getAnalyser().start(startNode);
            }
            nodeInScopeCount = messagesIdsToAppScan.size();

            if (!messagesIdsToAppScan.isEmpty()) {
                messageIdToHostScan = messagesIdsToAppScan.get(0);
            }

            logScanInfo();
            
            Plugin plugin;
            
            while (!isStop() && pluginFactory.existPluginToRun()) {
                checkPause();
                if (isStop()) {
                    break;
                }

                plugin = pluginFactory.nextPlugin();
                
                if (plugin != null) {
                    plugin.setDelayInMs(this.scannerParam.getDelayInMs());
                    plugin.setTechSet(this.techSet);
                    processPlugin(plugin);
                
                } else {
                    // waiting for dependency - no test ready yet
                    Util.sleep(1000);
                }
            }
            threadPool.waitAllThreadComplete(300000);
        } catch (Exception e) {
            log.error(""An error occurred while active scanning:"", e);
            stop();
        } finally {
            notifyHostProgress(null);
            notifyHostComplete();
            getHttpSender().shutdown();
        }
    }",Run the HostProcess.
"public void updateChangeLog(final Principal user, final Verb verb, final String linkType, final String linkId, final String object, final Direction direction) {

		if (Settings.ChangelogEnabled.getValue()) {

			final JsonObject obj = new JsonObject();

			obj.add(""time"",     toElement(System.currentTimeMillis()));
			obj.add(""userId"",   toElement(user.getUuid()));
			obj.add(""userName"", toElement(user.getName()));
			obj.add(""verb"",     toElement(verb));
			obj.add(""rel"",      toElement(linkType));
			obj.add(""relId"",    toElement(linkId));
			obj.add(""relDir"",   toElement(direction));
			obj.add(""target"",   toElement(object));

			changeLog.append(obj.toString());
			changeLog.append(""\n"");
		}
	}",Update change log.
"public List<EntityExtractor> listCustomPrebuiltEntities(UUID appId, String versionId) {
        return listCustomPrebuiltEntitiesWithServiceResponseAsync(appId, versionId).toBlocking().single().body();
    }",Gets a list of entities that can be prebuilt by the application.
"public static MatrixStatistics extractStatistics(
            File inputMatrixFile, Format format) {
        return extractStatistics(inputMatrixFile, format, false, false);
    }",Extract the statistics from the CIDIVA file.
"static boolean isNestedArrayPattern(Node n) {
    checkState(n.isArrayPattern());
    for (Node key = n.getFirstChild(); key != null; key = key.getNext()) {
      if (key.hasChildren()) {
        return true;
      }
    }
    return false;
  }",Checks if the node is an array pattern.
"public static void registerMappingsFromConfig(Registry registry, Config cfg) {
    registry.register(new JmxMeter(registry, JmxConfig.from(cfg)));
  }",Register the JmxMeter mappings from the given configuration.
"public boolean startCall(MuxInputStream in, MuxOutputStream out)
        throws IOException
    {
        int channel = isClient ? 2 : 3;

        return startCall(channel, in, out);
    }",This method is called by the application to start a new HTTP call.
"public static List<Setting> groupsToSettings(List<Group> groups) {
    return groups.stream()
        .map(Group::getSettings)
        .flatMap(Collection::stream)
        .collect(Collectors.toList());
  }",Groups to settings list.
"public T getObject(Connection conn, DataObject object) throws Exception {
        return executeSelect(conn, object, new ResultSetMapper<SingleObjectCollector<T>>(new SingleObjectCollector<T>())).value;
    }",Get an object from the database.
"@Override
    public Collection<String> findBySurnamesBeginWith(final FinderObject owner,
            final String beginsWith) {
        return owner.findInParentBySurnamesBeginWith(beginsWith);
    }",Find by surnames begin with.
"public synchronized ID replaceSessionId(final USER user, final ID oldSessionId,
		final ID newSessionId, final SESSION newSession)
	{
		remove(oldSessionId);
		return addOnline(user, newSessionId, newSession);
	}",Replace the session id.
"private void deleteObject(final WebContext ctx, final Bucket bucket, final String id) {
        StoredObject object = bucket.getObject(id);
        object.delete();

        ctx.respondWith().status(HttpResponseStatus.OK);
        signalObjectSuccess(ctx);
    }",Delete object.
"public static Matcher<PrintableResult> hasSingleFailureMatching(final Matcher<Throwable> matcher) {
        return new TypeSafeMatcher<PrintableResult>() {
            @Override
            public boolean matchesSafely(PrintableResult item) {
                return item.failureCount() == 1 && matcher.matches(item.failures().get(0).getException());
            }

            public void describeTo(Description description) {
                description.appendText(""has failure with exception matching "");
                matcher.describeTo(description);
            }
        };
    }",Creates a matcher that matches if the result has exactly one failure matching the given matcher.
"@Override
    public List<InputRecord> generate() throws Exception {
        List<InputRecord> result = new ArrayList<InputRecord>();
        this.validate();
        DateFormat format = new SimpleDateFormat(this.getInput().getValue());
        DateFormat baseFormat = new SimpleDateFormat(""dd-MM-yyyy"");

        InputRecord testRecord = (InputRecord) this.getInput().clone();
        // Add current date
        testRecord.setValue(format.format(this.clock.now()));
        testRecord.setValidInput(true);
        result.add(testRecord);

        // Before Unix era
        testRecord = (InputRecord) this.getInput().clone();
        testRecord.setValue(format.format(baseFormat.parse(""12-04-1961"")));
        testRecord.setValidInput(true);
        result.add(testRecord);

        // Empty value
        testRecord = (InputRecord) this.getInput().clone();
        testRecord.setValue("""");
        testRecord.setValidInput(false);
        result.add(testRecord);

        return result;
    }",Method to generate the input records for the CID
"public static Builder newBuilder(Context context, int themeResId) {
        if (Build.VERSION.SDK_INT >= 21) {
            return new APi21Builder(context, themeResId);
        }
        return new Api20Builder(context, themeResId);
    }",Create a new instance of the Builder class.
"public void setDigits4Map(String[] digits4Map) {

        ArgUtils.notEmpty(digits4Map, ""digits4Map"");

        if(digits4Map.length != 4) {
            throw new IllegalArgumentException(""digits4Map length should be 4."");
        }

        this.digits4Map = digits4Map;
    }",Set the digits4Map property.
"public static void invokeAndWait(Runnable runnable) throws InvocationTargetException,
			InterruptedException {
		if (EventQueue.isDispatchThread()) {
			runnable.run();
		} else {
			EventQueue.invokeAndWait(runnable);
		}
	}",Invoke the given runnable and wait for the result.
"public static int cusparseCdotci(
        cusparseHandle handle, 
        int nnz, 
        Pointer xVal, 
        Pointer xInd, 
        Pointer y, 
        Pointer resultDevHostPtr, 
        int idxBase)
    {
        return checkResult(cusparseCdotciNative(handle, nnz, xVal, xInd, y, resultDevHostPtr, idxBase));
    }",CUSPARSE SEGMENTS
"public RemoveAttributesFromFindingsRequest withFindingArns(String... findingArns) {
        if (this.findingArns == null) {
            setFindingArns(new java.util.ArrayList<String>(findingArns.length));
        }
        for (String ele : findingArns) {
            this.findingArns.add(ele);
        }
        return this;
    }",A list of finding ARNs to remove.
"public void internalAssociateWithJtaTx() {
        isInTx = TransactionUtil.isInTx(transactionManager);

        // ensure that a different XPC (with same name) is not already present in the TX
        if (isInTx) {

            // 7.6.3.1 throw EJBException if a different persistence context is already joined to the
            // transaction (with the same puScopedName).
            EntityManager existing = TransactionUtil.getTransactionScopedEntityManager(puScopedName, transactionSynchronizationRegistry);
            if (existing != null && existing != this) {
                // should be enough to test if not the same object
                throw JpaLogger.ROOT_LOGGER.cannotUseExtendedPersistenceTransaction(puScopedName, existing, this);
            } else if (existing == null) {

                if (SynchronizationType.SYNCHRONIZED.equals(synchronizationType)) {
                    // JPA 7.9.1 join the transaction if not already done for SynchronizationType.SYNCHRONIZED.
                    underlyingEntityManager.joinTransaction();
                }
                // associate the entity manager with the current transaction
                TransactionUtil.putEntityManagerInTransactionRegistry(puScopedName, this, transactionSynchronizationRegistry);
            }
        }
    }",This method is called by the application to associate the entity manager with the transaction manager.
"@Override
	public boolean eIsSet(int featureID) {
		switch (featureID) {
			case AfplibPackage.OBJECT_BYTE_OFFSET__DIR_BY_OFF:
				return DIR_BY_OFF_EDEFAULT == null ? dirByOff != null : !DIR_BY_OFF_EDEFAULT.equals(dirByOff);
			case AfplibPackage.OBJECT_BYTE_OFFSET__DIR_BY_HI:
				return DIR_BY_HI_EDEFAULT == null ? dirByHi != null : !DIR_BY_HI_EDEFAULT.equals(dirByHi);
		}
		return super.eIsSet(featureID);
	}",Replies if the feature is set to a value.
"public void writeBits (final int aValue, @Nonnegative final int nNumBits) throws IOException
  {
    ValueEnforcer.isBetweenInclusive (nNumBits, ""NumberOfBits"", 1, CGlobal.BITS_PER_INT);

    for (int i = nNumBits - 1; i >= 0; i--)
      writeBit ((aValue >> i) & 1);
  }

  /**
   * Write the current cache to the stream and reset the buffer.
   *
   * @throws IOException
   *         In case writing to the output stream failed
   */
  public void flush () throws IOException
  {
    if (m_nBufferedBitCount > 0)
    {
      if (m_nBufferedBitCount != CGlobal.BITS_PER_BYTE)
        if (LOGGER.isDebugEnabled ())
          LOGGER.debug (""Flushing BitOutputStream with only "" + m_nBufferedBitCount + "" bits"");
      m_aOS.write ((byte) m_nBuffer);
      m_nBufferedBitCount = 0;
      m_nBuffer = 0;
    }
  }

  /**
   * Flush the data and close the underlying output stream.
   */
  public void close ()
  {
    StreamHelper.flush (this);
    StreamHelper.close (m_aOS);
    m_aOS = null;
  }

  @Override
  public String toString ()
  {
    return new ToStringGenerator (this).append (""OS"", m_aOS)
                                       .append (""highOrderBitFirst"", m_bHighOrderBitFirst)
                                       .append (""buffer"", m_nBuffer)
                                       .append (""bitCount"", m_nBufferedBitCount)
                                       .getToString ();
  }
}",Write bits to the output stream.
"private Collection<TypeElement> implementingClasses(TypeElement te) {
        Collection<TypeElement> ret = classToImplementingClass.get(te);
        if (ret == null) {
            ret = new TreeSet<>(utils.makeClassUseComparator());
            Set<TypeElement> impl = classtree.implementingClasses(te);
            if (impl != null) {
                ret.addAll(impl);
                for (TypeElement anImpl : impl) {
                    ret.addAll(subclasses(anImpl));
                }
            }
            for (TypeElement intfc : subinterfaces(te)) {
                ret.addAll(implementingClasses(intfc));
            }
            addAll(classToImplementingClass, te, ret);
        }
        return ret;
    }",Get all classes implemented by this type element.
"@Override
    public void activate(final T instance, final Object key) throws DempsyException {
        wrap(() -> activationMethod.invoke(instance, key));
    }",Activates the entity with the specified key.
"public final Point2D getXY() {
		if (isEmptyImpl())
			throw new GeometryException(
					""This operation should not be performed on an empty geometry."");

		Point2D pt = new Point2D();
		pt.setCoords(m_attributes[0], m_attributes[1]);
		return pt;
	}",Returns the coordinates of this Point.
"public final BooleanExpression contains(Expression<E> child) {
        return Expressions.booleanOperation(Ops.IN, child, mixin);
    }",Create an expression representing whether this class contains the given child class.
"public static <K, V> Map<K, V> sortByValue(Map<K, V> map, final Comparator<? super V> comparator) {
		return sortByValueInternal(map, new EntryValueComparator<K, V>(comparator));
	}",Sort by value.
"protected void activeStatusChanged(boolean newActiveState) throws PushStateException {
      active = newActiveState;
      log.debugf(""changed mode %s"", this);
      if (active && singletonConfiguration.pushStateWhenCoordinator())
         doPushState();
   }",Called when the active status of the service has changed.
"public static FileOutputStream openExampleFileOuputStream(String filename)
			throws IOException {
		Path directoryPath;
		if ("""".equals(lastDumpFileName)) {
			directoryPath = Paths.get(EXAMPLE_OUTPUT_DIRECTORY);
		} else {
			directoryPath = Paths.get(EXAMPLE_OUTPUT_DIRECTORY);
			createDirectory(directoryPath);
			directoryPath = directoryPath.resolve(
					lastDumpFileName);
		}

		createDirectory(directoryPath);
		Path filePath = directoryPath.resolve(filename);
		return new FileOutputStream(filePath.toFile());
	}",Open a file out of a stream.
"void ensureCapacity(@NonNegative long expectedInsertions, @NonNegative double fpp) {
    checkArgument(expectedInsertions >= 0);
    checkArgument(fpp > 0 && fpp < 1);

    double optimalBitsFactor = -Math.log(fpp) / (Math.log(2) * Math.log(2));
    int optimalNumberOfBits = (int) (expectedInsertions * optimalBitsFactor);
    int optimalSize = optimalNumberOfBits >>> BITS_PER_LONG_SHIFT;
    if ((table != null) && (table.length >= optimalSize)) {
      return;
    } else if (optimalSize == 0) {
      tableShift = Integer.SIZE - 1;
      table = new long[1];
    } else {
      int powerOfTwoShift = Integer.SIZE - Integer.numberOfLeadingZeros(optimalSize - 1);
      tableShift = Integer.SIZE - powerOfTwoShift;
      table = new long[1 << powerOfTwoShift];
    }
  }",Ensure that the table is large enough to hold the specified number of insertions.
"public DescribeNatGatewaysResult withNatGateways(NatGateway... natGateways) {
        if (this.natGateways == null) {
            setNatGateways(new com.amazonaws.internal.SdkInternalList<NatGateway>(natGateways.length));
        }
        for (NatGateway ele : natGateways) {
            this.natGateways.add(ele);
        }
        return this;
    }",Adds the value of the natGateways property.
"public int setValue(String key, String value) {
    return VideoJNI.KeyValueBag_setValue__SWIG_0(swigCPtr, this, key, value);
  }",Set the value of a key in this key value bag.
"public void start() throws Exception {
        /*
         * SJ uses this barrier if this node becomes the leader to know when ZooKeeper
         * has been finished bootstrapping.
         */
        CountDownLatch zkInitBarrier = new CountDownLatch(1);

        /*
         * If start returns true then this node is the leader, it bound to the coordinator address
         * It needs to bootstrap its agreement site so that other nodes can join
         */
        if(m_joiner.start(zkInitBarrier)) {
            m_network.start();

            /*
             * m_localHostId is 0 of course.
             */
            long agreementHSId = getHSIdForLocalSite(AGREEMENT_SITE_ID);

            /*
             * A set containing just the leader (this node)
             */
            HashSet<Long> agreementSites = new HashSet<Long>();
            agreementSites.add(agreementHSId);

            /*
             * A basic site mailbox for the agreement site
             */
            SiteMailbox sm = new SiteMailbox(this, agreementHSId);
            createMailbox(agreementHSId, sm);


            /*
             * Construct the site with just this node
             */
            m_agreementSite =
                new AgreementSite(
                        agreementHSId,
                        agreementSites,
                        0,
                        sm,
                        new InetSocketAddress(
                                m_config.zkInterface.split("":"")[0],
                                Integer.parseInt(m_config.zkInterface.split("":"")[1])),
                        m_config.backwardsTimeForgivenessWindow,
                        m_failedHostsCallback);
            m_agreementSite.start();
            m_agreementSite.waitForRecovery();
            m_zk = org.voltcore.zk.ZKUtil.getClient(
                    m_config.zkInterface, 60 * 1000, VERBOTEN_THREADS);
            if (m_zk == null) {
                throw new Exception(""Timed out trying to connect local ZooKeeper instance"");
            }

            CoreZK.createHierarchy(m_zk);

            /*
             * This creates the ephemeral sequential node with host id 0 which
             * this node already used for itself. Just recording that fact.
             */
            final int selectedHostId = selectNewHostId(m_config.coordinatorIp.toString());
            if (selectedHostId != 0) {
                org.voltdb.VoltDB.crashLocalVoltDB(""Selected host id for coordinator was not 0, "" + selectedHostId, false, null);
            }

            /*
             * seed the leader host criteria ad leader is always host id 0
             */
            m_acceptor.accrue(selectedHostId, m_acceptor.decorate(new JSONObject(), Optional.empty()));

            // Store the components of the instance ID in ZK
            JSONObject instance_id = new JSONObject();
            instance_id.put(""coord"",
                    ByteBuffer.wrap(m_config.coordinatorIp.getAddress().getAddress()).getInt());
            instance_id.put(""timestamp"", System.currentTimeMillis());
            hostLog.debug(""Cluster will have instance ID:\n"" + instance_id.toString(4));
            byte[] payload = instance_id.toString(4).getBytes(""UTF-8"");
            m_zk.create(CoreZK.instance_id, payload, Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);

            /*
             * Store all the hosts and host ids here so that waitForGroupJoin
             * knows the size of the mesh. This part only registers this host
             */
            final HostInfo hostInfo = new HostInfo(m_config.coordinatorIp.toString(), m_config.group, m_config.localSitesCount,
                    m_config.recoveredPartitions);
            m_zk.create(CoreZK.hosts_host + selectedHostId, hostInfo.toBytes(), Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);
        }
        zkInitBarrier.countDown();
    }",Starts the cluster.
"public T text(int resid, Object... formatArgs) {
        if (context != null) {
            CharSequence text = context.getString(resid, formatArgs);
            text(text);
        }
        return self();
    }",Set the text of the record in the calendar.
"public static void wave(View[] layers, float scale, int duration, float offset) {
        int step = 0;

        for (View l : layers) {
            wave(l, scale, duration, ((float) 1 / layers.length) * step * offset);
            step++;
        }
    }",Wave the layers.
"protected Props createProps() {
		final Props props = new Props();
		props.setSkipEmptyProps(true);
		props.setIgnoreMissingMacros(true);
		return props;
	}",Create the props.
"protected <T extends AbstractBase> ResponseEntity<Response<T>> buildNOKResponse(HttpStatus code, String msg, T... params) {
        return buildResponse(code, msg, """", params);
    }",Build a NOK response.
"private int renderOrderedOptions(final WMultiSelectPair multiSelectPair, final List<?> options,
			final int startIndex, final XmlStringBuilder xml,
			final boolean renderSelectionsOnly) {

		List<?> selections = multiSelectPair.getSelected();
		int optionIndex = startIndex;

		// We can't just render all the unselected options followed by the selected ones
		// in the order they are given to us, as unselected/selected may be intermingled
		// due to the option groups. We therefore recursively render each group.
		// For each group, we:
		// - iterate through the options and
		//     - render the unselected ones
		//     - keep track of the selected ones (index within the selection list + index within the option list)
		// - Once all the unselected items have been rendered, we render the selections
		// This maps selection indices to option indices for the current group
		Map<Integer, Integer> currentSelectionIndices = new HashMap<>();

		for (Object option : options) {
			if (option instanceof OptionGroup) {
				xml.appendTagOpen(""ui:optgroup"");
				xml.appendAttribute(""label"", ((OptionGroup) option).getDesc());
				xml.appendClose();

				// Recurse to render options inside option groups.
				List<?> nestedOptions = ((OptionGroup) option).getOptions();
				optionIndex += renderOrderedOptions(multiSelectPair, nestedOptions, optionIndex, xml,
						renderSelectionsOnly);

				xml.appendEndTag(""ui:optgroup"");
			} else {
				int index = selections.indexOf(option);

				if (index == -1) {
					renderOption(multiSelectPair, option, optionIndex++, xml, selections,
							renderSelectionsOnly);
				} else {
					currentSelectionIndices.put(index, optionIndex++);
				}
			}
		}

		if (!currentSelectionIndices.isEmpty()) {
			// Now sort the selected item's indices and render them in the correct order.
			List<Integer> sortedSelectedIndices = new ArrayList<>(currentSelectionIndices.keySet());
			Collections.sort(sortedSelectedIndices);

			for (int selectionIndex : sortedSelectedIndices) {
				int selectionOptionIndex = currentSelectionIndices.get(selectionIndex);

				renderOption(multiSelectPair, selections.get(selectionIndex), selectionOptionIndex,
						xml, selections, renderSelectionsOnly);
			}
		}

		return optionIndex - startIndex;
	}",Render the options in the order they are given to us.
"public static void invertPinhole( DMatrix3x3 K , DMatrix3x3 Kinv) {
		double fx = K.a11;
		double skew = K.a12;
		double cx = K.a13;
		double fy = K.a22;
		double cy = K.a23;
		Kinv.a11 = 1.0/fx;
		Kinv.a12 = -skew/(fx*fy);
		Kinv.a13 = (skew*cy - cx*fy)/(fx*fy);
		Kinv.a22 = 1.0/fy;
		Kinv.a23 = -cy/fy;
		Kinv.a33 = 1;
	}",Inverts the pinhole matrix.
"public void marshall(EbsConfiguration ebsConfiguration, ProtocolMarshaller protocolMarshaller) {

        if (ebsConfiguration == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(ebsConfiguration.getEbsBlockDeviceConfigs(), EBSBLOCKDEVICECONFIGS_BINDING);
            protocolMarshaller.marshall(ebsConfiguration.getEbsOptimized(), EBSOPTIMIZED_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given EBSConfiguration to the JSON object.
"public static TaggableReadPreference secondary(final TagSet tagSet,
                                                   final long maxStaleness, final TimeUnit timeUnit) {
        return new SecondaryReadPreference(singletonList(tagSet), maxStaleness, timeUnit);
    }",Create a secondary read preference.
"public static Map<String, String> read(final String path) {

        Map<String, String> map = new HashMap<String, String>();

        if (path != null) {
            try {
                Properties p = loadProperties(path);

                for (Object key : p.keySet()) {

                    String value = p.getProperty(String.valueOf(key));

                    // remove single/double quotes
                    if ((value.startsWith(""\"""") && value.endsWith(""\"""")) ||
                            (value.startsWith(""\'"") && value.endsWith(""\'""))) {
                        value = value.substring(1, value.length() - 1);
                    }

                    value = value.trim();

                    if (!value.equals("""")) {
                        map.put(String.valueOf(key), value);
                    }
                }

            } catch (Exception e) {
                log.error(e.getMessage(), e);
            }
        }

        return map;
    }",Read a map of the class file.
"public PropertyEditorRegistry getPropertyEditorRegistry() {
        final HttpServletRequest servletRequest = getCurrentRequest();
        PropertyEditorRegistry registry = (PropertyEditorRegistry) servletRequest.getAttribute(GrailsApplicationAttributes.PROPERTY_REGISTRY);
        if (registry == null) {
            registry = new PropertyEditorRegistrySupport();
            PropertyEditorRegistryUtils.registerCustomEditors(this, registry, RequestContextUtils.getLocale(servletRequest));
            servletRequest.setAttribute(GrailsApplicationAttributes.PROPERTY_REGISTRY, registry);
        }
        return registry;
    }",Gets the PropertyEditorRegistry.
"public Properties getProperties(String group) {
		final Properties properties = new Properties();
		properties.putAll(getMap(group));
		return properties;
	}",Gets the properties for the specified group.
"public void restoreAll() throws Exception
    {

        if (!backupProvider.isPresent()) {
            log.info(""No backup provider configured. Skipping restore."");
            return;
        }

        ZooKeeperLogFiles logFiles = new ZooKeeperLogFiles(exhibitor);
        log.info(""Restoring log files from backup."");
        if (!logFiles.isValid()) {
            log.error(""Backup path invalid. Skipping restore."");
            return;
        }
        if (logFiles.getPaths().isEmpty()) {
            log.info(""Backup path(s) empty. Skipping restore."");
            return;
        }
        File dataDir = ZooKeeperLogFiles.getDataDir(exhibitor);
        for (BackupMetaData data : getAvailableBackups()) {
            String fileName = data.getName();
            log.info(String.format(""Restoring file: %s"", fileName));
            File file = new File(dataDir, fileName);
            restore(data, file);
        }
        log.info(""Restoring logs from backup done."");
    }",Restores all the log files from the backup.
"public void resendScheduledRejects()
  {
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.entry(tc, ""resendScheduledRejects"");

    _rejectedTOM.driveAllActiveEntries();

    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.exit(tc, ""resendScheduledRejects"");
  }",Resend the scheduled rejects
"private FilterDefinition[] collectFilterDefinitions(Injector injector) {
    List<FilterDefinition> filterDefinitions = Lists.newArrayList();
    for (Binding<FilterDefinition> entry : injector.findBindingsByType(FILTER_DEFS)) {
      filterDefinitions.add(entry.getProvider().get());
    }

    // Copy to a fixed-size array for speed of iteration.
    return filterDefinitions.toArray(new FilterDefinition[filterDefinitions.size()]);
  }",Collect the filter definitions from the injector.
"public EncoderConfig defaultQueryParameterCharset(String charset) {
        return new EncoderConfig(defaultContentCharset, charset, shouldAppendDefaultContentCharsetToContentTypeIfUndefined, contentEncoders, contentTypeToDefaultCharset, true);
    }",Default query parameter charset.
"public static <K, V> Cache<K, V> createCache(int maximumSize, long expiryDurationSeconds) {
        Cache<K, V> cache = CacheBuilder.newBuilder().maximumSize(maximumSize)
                .expireAfterAccess(expiryDurationSeconds, TimeUnit.SECONDS).build();
        return cache;
    }",Create a cache with maximumSize and expiryDurationSeconds
"public Response bind(String name, Object model) {
        getLocals().put(name, model);

        return this;
    }",Binds a single value to the context of the response.
"public Note getMergeRequestNote(Object projectIdOrPath, Integer mergeRequestIid, Integer noteId) throws GitLabApiException {
        Response response = get(Response.Status.OK, getDefaultPerPageParam(),
                ""projects"", getProjectIdOrPath(projectIdOrPath), ""merge_requests"", mergeRequestIid, ""notes"", noteId);
        return (response.readEntity(Note.class));
    }",Get a single merge request s note.
"@Override
    @Deprecated
    public void getOffsetFromLocal(long date,
            int nonExistingTimeOpt, int duplicatedTimeOpt, int[] offsets) {
        offsets[0] = getRawOffset();
        int fields[] = new int[6];
        Grego.timeToFields(date, fields);
        offsets[1] = getOffset(GregorianCalendar.AD,
              fields[0], fields[1], fields[2],
              fields[3], fields[5]) - offsets[0];

        boolean recalc = false;

        // Now, we need some adjustment
        if (offsets[1] > 0) {
            if ((nonExistingTimeOpt & STD_DST_MASK) == LOCAL_STD
                || (nonExistingTimeOpt & STD_DST_MASK) != LOCAL_DST
                && (nonExistingTimeOpt & FORMER_LATTER_MASK) != LOCAL_LATTER) {
                date -= getDSTSavings();
                recalc = true;
            }
        } else {
            if ((duplicatedTimeOpt & STD_DST_MASK) == LOCAL_DST
                || (duplicatedTimeOpt & STD_DST_MASK) != LOCAL_STD
                && (duplicatedTimeOpt & FORMER_LATTER_MASK) == LOCAL_FORMER) {
                date -= getDSTSavings();
                recalc = true;
            }
        }

        if (recalc) {
            Grego.timeToFields(date, fields);
            offsets[1] = getOffset(GregorianCalendar.AD,
                    fields[0], fields[1], fields[2],
                    fields[3], fields[5]) - offsets[0];
        }
    }",This method is called to get the offset from the local calendar.
"@Override
    Collection<Proposition> traverse(Proposition proposition,
            Map<Proposition, Set<Proposition>> forwardDerivations,
            Map<Proposition, Set<Proposition>> backwardDerivations,
            Map<UniqueId, Proposition> references,
            KnowledgeSourceCache ksCache, Set<Proposition> cache) {
        List<Proposition> props = new ArrayList<>();
        String[] refNames =
                this.referenceNames.length > 0
                ? this.referenceNames
                : proposition.getReferenceNames();
        for (String referenceName : refNames) {
            List<UniqueId> uids = proposition.getReferences(
                    referenceName);
            for (UniqueId uid : uids) {
                Proposition prop = references.get(uid);
                if (prop != null && cache.add(prop) && isMatch(prop)) {
                    props.add(prop);
                }
            }
        }

        return createResults(props);
    }",Traverses a collection of protein objects.
"private static String joinString(String[] array) {
    StringBuilder sb = new StringBuilder();
    for (String value : array) {
      if (sb.length() > 0) {
        sb.append("" "");
      }
      sb.append(value);
    }
    return sb.toString();
  }",Join a string array to a single string.
"@Override
  public Optional<Property> lookup(String name)
  {
    return Optional.of(Property.newFrom(name, base, prefix));
  }",Override to override the lookup method.
"public Matrix4f normal(Matrix4f dest) {
        if ((properties & PROPERTY_IDENTITY) != 0)
            return dest.identity();
        else if ((properties & PROPERTY_ORTHONORMAL) != 0)
            return normalOrthonormal(dest);
        return normalGeneric(dest);
    }",Normalise the matrix dest.
"public void addClientObserver (ClientObserver observer)
    {
        _clobservers.add(observer);
        if (observer instanceof DetailedClientObserver) {
            _dclobservers.add((DetailedClientObserver)observer);
        }
    }",Add a client observer to the list of observers.
"public String readString() throws IOException {
        final int len = readInt();

        // check for null string
        if (len == VoltType.NULL_STRING_LENGTH) {
            return null;
        }

        if (len < VoltType.NULL_STRING_LENGTH) {
            throw new IOException(""String length is negative "" + len);
        }
        if (len > buffer.remaining()) {
            throw new IOException(""String length is bigger than total buffer "" + len);
        }

        // now assume not null
        final byte[] strbytes = new byte[len];
        readFully(strbytes);
        return new String(strbytes, Constants.UTF8ENCODING);
    }",Read a string from the underlying stream.
"int syncHeader(byte syncmode) throws BitstreamException
	{
		boolean sync;
		int headerstring;
		// read additional 2 bytes
		int bytesRead = readBytes(syncbuf, 0, 3);

		if (bytesRead!=3) throw newBitstreamException(STREAM_EOF, null);

		headerstring = ((syncbuf[0] << 16) & 0x00FF0000) | ((syncbuf[1] << 8) & 0x0000FF00) | ((syncbuf[2] << 0) & 0x000000FF);

		do
		{
			headerstring <<= 8;

			if (readBytes(syncbuf, 3, 1)!=1)
				throw newBitstreamException(STREAM_EOF, null);

			headerstring |= (syncbuf[3] & 0x000000FF);

			sync = isSyncMark(headerstring, syncmode, syncword);
		}
		while (!sync);

		current_frame_number++;
		if (last_frame_number < current_frame_number) last_frame_number = current_frame_number;

		return headerstring;
	}",Read the header string from the stream.
"public RAMDirectory mkdir(String name) throws IOException
  {
    RAMEntry entry = getEntry(name);
    if(entry instanceof RAMDirectory)
    {
      RAMDirectory ramDirectory = (RAMDirectory) entry;
      return ramDirectory;
    }
    else
    {
      if(entry == null)
      {
        RAMDirectory directory = new RAMDirectory(_clock, name);
        return (RAMDirectory) add(directory);
      }
      else
      {
        throw new IOException(""File exists: "" + name);
      }
    }
  }",Create a new directory.
"protected ItemData getPersistedItemData(String identifier) throws RepositoryException
   {
      ItemData data = super.getItemData(identifier);

      // set ACL

      if (data != null && data.isNode())
      {
         data = initACL(null, (NodeData)data);
      }

      if (cache.isEnabled())
      {
         if (data != null)
         {
            cache.put(data);
         }
         else if (identifier != null)
         {
            // no matter does property or node expected - store NullNodeData
            cache.put(new NullNodeData(identifier));
         }
      }
      return data;
   }",Get persisted item data.
"@Override
  public ExecutorService getListenerExecutorService() {
    if (executorService == null) {
      ThreadFactory threadFactory = new ThreadFactory() {
        @Override
        public Thread newThread(Runnable r) {
          return new Thread(r, ""FutureNotifyListener"");
        }
      };

      executorService = new ThreadPoolExecutor(
        0,
        Runtime.getRuntime().availableProcessors(),
        60L,
        TimeUnit.SECONDS,
        new LinkedBlockingQueue<Runnable>(),
        threadFactory
      );
    }

    return executorService;
  }",Get the executor service
"@Override
	@SuppressWarnings(""unchecked"")
	public void setValue(ELContext context, Object base, Object property, Object value) {
		if (context == null) {
			throw new NullPointerException(""context is null"");
		}
		if (isResolvable(base)) {
			if (readOnly) {
				throw new PropertyNotWritableException(""resolver is read-only"");
			}
			List list = (List) base;
			int index = toIndex(list, property);
			try {
				list.set(index, value);
			} catch (UnsupportedOperationException e) {
				throw new PropertyNotWritableException(e);
			} catch (ArrayStoreException e) {
				throw new IllegalArgumentException(e);
			}
			context.setPropertyResolved(true);
		}
	}",Override the setValue method for the IA1 method.
"public void write(byte[] b, int off, int len) throws IOException {
        // BEGIN Android-added: perform checks for parameters first.
        // See org.apache.harmony.security.tests.j.s.DigestOutputStreamTest#test_write$BII_6
        if (b == null || off + len > b.length) {
            throw new IllegalArgumentException(""wrong parameters for write"");
        }
        if (off < 0 || len < 0) {
            throw new IndexOutOfBoundsException(""wrong index for write"");
        }
        // END Android-added
        out.write(b, off, len);
        if (on) {
            digest.update(b, off, len);
        }
    }",Write a byte array to the output stream.
"private CheckpointQueryBuilder parseCheckpoint(CheckpointQueryBuilder query)
  {
    Token token = scanToken();

    if (token != Token.IDENTIFIER) {
      throw error(""Expected IDENTIFIER at {0}"", token);
    }
    
    String pod = _lexeme;
    String name;
    
    if (peekToken() == Token.DOT) {
      scanToken();

      if ((token = scanToken()) != Token.IDENTIFIER) {
        throw error(""Expected IDENTIFIER at {0}"", token);
      }
      
      name = _lexeme; 
    }
    else {
      name = pod;
      pod = getPodName();
    }
    
    query.setTableName(pod + '.' + name);

    return query;
  }",Parse a checkpoint query.
"public static String canonize(String ipv6Address) throws IllegalArgumentException {

        if (ipv6Address == null) {
            return null;
        }

        // Definitely not an IPv6, return untouched input.
        if (!mayBeIPv6Address(ipv6Address)) {
            return ipv6Address;
        }

        // Length without zone ID (%zone) or IPv4 address
        int ipv6AddressLength = ipv6Address.length();
        if (isIPv4AddressInIPv6(ipv6Address)) {
            // IPv4 in IPv6
            // e.g. 0:0:0:0:0:FFFF:127.0.0.1
            int lastColonPos = ipv6Address.lastIndexOf("":"");
            int lastColonsPos = ipv6Address.lastIndexOf(""::"");
            if (lastColonsPos >= 0 && lastColonPos == lastColonsPos + 1) {
                // IPv6 part ends with two consecutive colons, last colon is part of IPv6 format.
                // e.g. ::127.0.0.1
                ipv6AddressLength = lastColonPos + 1;
            } else {
                // IPv6 part ends with only one colon, last colon is not part of IPv6 format.
                // e.g. ::FFFF:127.0.0.1
                ipv6AddressLength = lastColonPos;
            }
        } else if (ipv6Address.contains("":"") && ipv6Address.contains(""%"")) {
            // Zone ID
            // e.g. fe80:0:0:0:f0f0:c0c0:1919:1234%4
            ipv6AddressLength = ipv6Address.lastIndexOf(""%"");
        }

        StringBuilder result = new StringBuilder();
        char [][] groups = new char[IPV6_LEN][MAX_GROUP_LENGTH];
        int groupCounter = 0;
        int charInGroupCounter = 0;

        // Index of the current zeroGroup, -1 means not found.
        int zeroGroupIndex = -1;
        int zeroGroupLength = 0;

        // maximum length zero group, if there is more then one, then first one
        int maxZeroGroupIndex = -1;
        int maxZeroGroupLength = 0;

        boolean isZero = true;
        boolean groupStart = true;

        /*
         *  Two consecutive colons, initial expansion.
         *  e.g. 2001:db8:0:0:1::1 -> 2001:db8:0:0:1:0:0:1
         */
        StringBuilder expanded = new StringBuilder(ipv6Address);
        int colonsPos = ipv6Address.indexOf(""::"");
        int length = ipv6AddressLength;
        int change = 0;

        if (colonsPos >= 0 && colonsPos < ipv6AddressLength - 2) {
            int colonCounter = 0;
            for (int i = 0; i < ipv6AddressLength; i++) {
                if (ipv6Address.charAt(i) == ':') {
                    colonCounter++;
                }
            }

            if (colonsPos == 0) {
                expanded.insert(0, ""0"");
                change = change + 1;
            }

            for (int i = 0; i < IPV6_LEN - colonCounter; i++) {
                expanded.insert(colonsPos + 1, ""0:"");
                change = change + 2;
            }


            if (colonsPos == ipv6AddressLength - 2) {
                expanded.setCharAt(colonsPos + change + 1, '0');
            } else {
                expanded.deleteCharAt(colonsPos + change + 1);
                change = change - 1;
            }
            length = length + change;
        }


        // Processing one char at the time
        for (int charCounter = 0; charCounter < length; charCounter++) {
            char c = expanded.charAt(charCounter);
            if (c >= 'A' && c <= 'F') {
                c = (char) (c + 32);
            }
            if (c != ':') {
                groups[groupCounter][charInGroupCounter] = c;
                if (!(groupStart && c == '0')) {
                    ++charInGroupCounter;
                    groupStart = false;
                }
                if (c != '0') {
                    isZero = false;
                }
            }
            if (c == ':' || charCounter == (length - 1)) {
                // We reached end of current group
                if (isZero) {
                    ++zeroGroupLength;
                    if (zeroGroupIndex == -1) {
                        zeroGroupIndex = groupCounter;
                    }
                }

                if (!isZero || charCounter == (length - 1)) {
                    // We reached end of zero group
                    if (zeroGroupLength > maxZeroGroupLength) {
                        maxZeroGroupLength = zeroGroupLength;
                        maxZeroGroupIndex = zeroGroupIndex;
                    }
                    zeroGroupLength = 0;
                    zeroGroupIndex = -1;
                }
                ++groupCounter;
                charInGroupCounter = 0;
                isZero = true;
                groupStart = true;
            }
        }

        int numberOfGroups = groupCounter;

        // Output results
        for (groupCounter = 0; groupCounter < numberOfGroups; groupCounter++) {
            if (maxZeroGroupLength <= 1 || groupCounter < maxZeroGroupIndex
                    || groupCounter >= maxZeroGroupIndex + maxZeroGroupLength) {
                for (int j = 0; j < MAX_GROUP_LENGTH; j++) {
                    if (groups[groupCounter][j] != 0) {
                        result.append(groups[groupCounter][j]);
                    }
                }
                if (groupCounter < (numberOfGroups - 1)
                        && (groupCounter != maxZeroGroupIndex - 1
                                || maxZeroGroupLength <= 1)) {
                    result.append(':');
                }
            } else if (groupCounter == maxZeroGroupIndex) {
                result.append(""::"");
            }
        }

        // Solve problem with three colons in IPv4 in IPv6 format
        // e.g. 0:0:0:0:0:0:127.0.0.1 -> :::127.0.0.1 -> ::127.0.0.1
        int resultLength = result.length();
        if (result.charAt(resultLength - 1) == ':' && ipv6AddressLength < ipv6Address.length()
                && ipv6Address.charAt(ipv6AddressLength) == ':') {
            result.delete(resultLength - 1, resultLength);
        }

        /*
         * Append IPv4 from IPv4-in-IPv6 format or Zone ID
         */
        for (int i = ipv6AddressLength; i < ipv6Address.length(); i++) {
            result.append(ipv6Address.charAt(i));
        }

        return result.toString();
    }",Canonicalize IPv6 address.
"public void marshall(StopRunRequest stopRunRequest, ProtocolMarshaller protocolMarshaller) {

        if (stopRunRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(stopRunRequest.getArn(), ARN_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given StopRunRequest to the given protocolMarshaller.
"@Override
	public RandomVariableInterface getNumeraire(double time) throws CalculationException {
		int timeIndex = getLiborPeriodIndex(time);

		if(timeIndex < 0) {
			// Interpolation of Numeraire: log linear interpolation.
			int upperIndex = -timeIndex-1;
			int lowerIndex = upperIndex-1;
			if(lowerIndex < 0) {
				throw new IllegalArgumentException(""Numeraire requested for time "" + time + "". Unsupported"");
			}

			double alpha = (time-getLiborPeriod(lowerIndex)) / (getLiborPeriod(upperIndex) - getLiborPeriod(lowerIndex));
			RandomVariableInterface numeraire = getNumeraire(getLiborPeriod(upperIndex)).log().mult(alpha).add(getNumeraire(getLiborPeriod(lowerIndex)).log().mult(1.0-alpha)).exp();

			/*
			 * Adjust for discounting, i.e. funding or collateralization
			 */
			if(discountCurve != null) {
				// This includes a control for zero bonds
				double deterministicNumeraireAdjustment = numeraire.invert().getAverage() / discountCurve.getDiscountFactor(curveModel, time);
				numeraire = numeraire.mult(deterministicNumeraireAdjustment);
			}

			return numeraire;
		}

		/*
		 * Calculate the numeraire, when time is part of liborPeriodDiscretization
		 */

		/*
		 * Check if numeraire cache is valid (i.e. process did not change)
		 */
		if(getProcess() != numerairesProcess) {
			numeraires.clear();
			numerairesProcess = getProcess();
		}

		/*
		 * Check if numeraire is part of the cache
		 */
		RandomVariableInterface numeraire = numeraires.get(timeIndex);
		if(numeraire == null) {
			/*
			 * Calculate the numeraire for timeIndex
			 */

			// Initialize to 1.0
			numeraire = getRandomVariableForConstant(1.0);


			// Get the start and end of the product
			int firstLiborIndex, lastLiborIndex;

			if(measure == Measure.TERMINAL) {
				firstLiborIndex	= getLiborPeriodIndex(time);
				if(firstLiborIndex < 0) {
					throw new CalculationException(""Simulation time discretization not part of forward rate tenor discretization."");
				}

				lastLiborIndex 	= liborPeriodDiscretization.getNumberOfTimeSteps()-1;
			}
			else if(measure == Measure.SPOT) {
				// Spot measure
				firstLiborIndex	= 0;
				lastLiborIndex	= getLiborPeriodIndex(time)-1;
			}
			else {
				throw new CalculationException(""Numeraire not implemented for specified measure."");
			}

			// The product
			for(int liborIndex = firstLiborIndex; liborIndex<=lastLiborIndex; liborIndex++) {
				RandomVariableInterface libor = getLIBOR(getTimeIndex(Math.min(time,liborPeriodDiscretization.getTime(liborIndex))), liborIndex);

				double periodLength = liborPeriodDiscretization.getTimeStep(liborIndex);

				if(measure == Measure.SPOT) {
					numeraire = numeraire.accrue(libor, periodLength);
				}
				else {
					numeraire = numeraire.discount(libor, periodLength);
				}
			}
			numeraires.put(timeIndex, numeraire);
		}

		/*
		 * Adjust for discounting, i.e. funding or collateralization
		 */
		if(discountCurve != null) {
			// This includes a control for zero bonds
			double deterministicNumeraireAdjustment = numeraire.invert().getAverage() / discountCurve.getDiscountFactor(curveModel, time);
			numeraire = numeraire.mult(deterministicNumeraireAdjustment);
		}
		return numeraire;
	}",This method returns the numeraire of the random variable at a given time.
"public URIBuilder queryParameters( Map<String, String> queryParams )
    {
        this.queryParams.clear();
        this.queryParams.putAll( queryParams );
        return this;
    }",Sets the query parameters.
"public Set<String> keySet() {

		// Copy key set, so return value is independent from the object's internal data structure
		final Set<String> retVal = new HashSet<String>();

		synchronized (this.confData) {

			final Iterator<String> it = this.confData.keySet().iterator();
			while (it.hasNext()) {
				retVal.add(it.next());
			}
		}

		return retVal;
	}",Returns a set of all keys in this configuration.
"private void markDuplicatedTextForDeletionLater(@NonNull Editable text, int cursor, @NonNull Tokenizer tokenizer) {
        while (cursor > 0 && tokenizer.isWordBreakingChar(text.charAt(cursor - 1))) {
            cursor--;
        }
        int wordStart = findStartOfWord(text, cursor);
        PlaceholderSpan[] placeholderSpans = text.getSpans(wordStart, wordStart + 1, PlaceholderSpan.class);
        for (PlaceholderSpan span : placeholderSpans) {
            int spanEnd = span.originalEnd;
            int copyEnd = spanEnd + (spanEnd - wordStart);
            if (copyEnd > spanEnd && copyEnd <= text.length()) {
                CharSequence endOfMention = text.subSequence(wordStart, spanEnd);
                CharSequence copyOfEndOfMentionText = text.subSequence(spanEnd, copyEnd);
                // Note: Comparing strings since we do not want to compare any other aspects of spanned strings
                if (endOfMention.toString().equals(copyOfEndOfMentionText.toString())) {
                    text.setSpan(new DeleteSpan(),
                            spanEnd,
                            copyEnd,
                            Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
                }
            }
        }
    }",Mark duplicated textForDeletionLater Method.
"public static MongoClient create(String hosts) {
        MongoClientURI connectionString = new MongoClientURI(hosts);
        return new MongoClient(connectionString);
    }",Create a new instance of the class based on the given hosts.
"private void mapArrayCollectionToVertex(ITypedInstance typedInstance, AtlasVertex instanceVertex,
                                            AttributeInfo attributeInfo, Operation operation) throws AtlasException {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""Mapping instance {} for array attribute {} vertex {}"", typedInstance.toShortString(),
                    attributeInfo.name, string(instanceVertex));
        }

        List newElements = (List) typedInstance.get(attributeInfo.name);
        boolean newAttributeEmpty = (newElements == null || newElements.isEmpty());

        IDataType elementType = ((DataTypes.ArrayType) attributeInfo.dataType()).getElemType();
        String propertyName = GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo);

        List<Object> currentElements = GraphHelper.getArrayElementsProperty(elementType, instanceVertex, propertyName);

        List<Object> newElementsCreated = new ArrayList<>();

        if (!newAttributeEmpty) {
            int index = 0;
            for (; index < newElements.size(); index++) {
                Object currentElement = (currentElements != null && index < currentElements.size()) ?
                        currentElements.get(index) : null;
                if (LOG.isDebugEnabled()) {
                    LOG.debug(""Adding/updating element at position {}, current element {}, new element {}"", index,
                            currentElement, newElements.get(index));
                }

                Object newEntry = addOrUpdateCollectionEntry(instanceVertex, attributeInfo, elementType,
                        newElements.get(index), currentElement, propertyName, operation);
                newElementsCreated.add(newEntry);
            }
        }

        if(GraphHelper.isReference(elementType)) {
            if (attributeInfo.reverseAttributeName != null && newElementsCreated.size() > 0) {
                // Set/add the new reference value(s) on the reverse reference.
                for (Object newElement : newElementsCreated) {
                    if ((newElement instanceof AtlasEdge)) {
                        AtlasEdge newEdge = (AtlasEdge) newElement;
                        addReverseReference(instanceVertex, attributeInfo.reverseAttributeName, newEdge);
                    }
                    else {
                        throw new AtlasException(""Invalid array element type "" + newElement.getClass().getName() + "" - expected "" + AtlasEdge.class.getName() +
                            "" for reference "" + GraphHelper.getQualifiedFieldName(typedInstance, attributeInfo) + "" on vertex "" + GraphHelper.getVertexDetails(instanceVertex));
                    }
                }
            }

            List<AtlasEdge> additionalEdges = removeUnusedEntries(instanceVertex, propertyName, (List)currentElements,
                    (List)newElementsCreated, elementType, attributeInfo);
            newElementsCreated.addAll(additionalEdges);
        }

        // for dereference on way out
        GraphHelper.setArrayElementsProperty(elementType, instanceVertex, propertyName, newElementsCreated);
    }",Maps a collection of objects to the array vertex.
"private Collection<?> resolveChildren(FieldData field) {
        if (field.metaData.isLazy()) {
            // The field is explicitly lazy, e.g. @Children Lazy<List<Page>> children. Thus, we are asked to load the children at this point since
            // the lazy field is trying to access the children.
            return loadChildren(field);
        } else {
            // Create a lazy loading proxy for the collection
            return (Collection<?>) field.metaData.getCollectionProxyFactory().newInstance(new LazyChildrenLoader(field, this));
        }
    }",Resolves the children of the field.
"public void setCheckConfig(boolean checkConfig) {
        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
            Tr.debug(tc, ""setCheckConfig: "" + checkConfig);
        ivCheckConfig = checkConfig;
    }",Set the checkConfig property.
"@Override
    public synchronized void start( BootstrapContext ctx ) throws ResourceAdapterInternalException {
        if (engine == null) {
            engine = new ModeShapeEngine();
            engine.start();
        }
    }",Start the mode shape engine.
"@Override
	public int compareTo(final RDFItem o) {

		if (id != null && o != null && o.id != null) {
			return id.compareTo(o.id);
		}

		return -1;
	}",Compares two RDFItems.
"protected Tree traverseLocate(Tree[] daughterTrees, String[] how, boolean lastResort) {
    int headIdx = 0;
    String childCat;
    boolean found = false;

    if (how[0].equals(""left"")) {
      twoloop:
        for (int i = 1; i < how.length; i++) {
          for (headIdx = 0; headIdx < daughterTrees.length; headIdx++) {
            childCat = tlp.basicCategory(daughterTrees[headIdx].label().value());
            if (how[i].equals(childCat)) {
              found = true;
              break twoloop;
            }
          }
        }
    } else if (how[0].equals(""leftdis"")) {
      twoloop:
        for (headIdx = 0; headIdx < daughterTrees.length; headIdx++) {
          childCat = tlp.basicCategory(daughterTrees[headIdx].label().value());
          for (int i = 1; i < how.length; i++) {
            if (how[i].equals(childCat)) {
              found = true;
              break twoloop;
            }
          }
        }
    } else if (how[0].equals(""right"")) {
      // from right
      twoloop:
        for (int i = 1; i < how.length; i++) {
          for (headIdx = daughterTrees.length - 1; headIdx >= 0; headIdx--) {
            childCat = tlp.basicCategory(daughterTrees[headIdx].label().value());
            if (how[i].equals(childCat)) {
              found = true;
              break twoloop;
            }
          }
        }
    } else if (how[0].equals(""rightdis"")) {
      // from right, but search for any, not in turn
      twoloop:
        for (headIdx = daughterTrees.length - 1; headIdx >= 0; headIdx--) {
          childCat = tlp.basicCategory(daughterTrees[headIdx].label().value());
          for (int i = 1; i < how.length; i++) {
            if (how[i].equals(childCat)) {
              found = true;
              break twoloop;
            }
          }
        }
    } else if (how[0].equals(""leftexcept"")) {
      for (headIdx = 0; headIdx < daughterTrees.length; headIdx++) {
        childCat = tlp.basicCategory(daughterTrees[headIdx].label().value());
        found = true;
        for (int i = 1; i < how.length; i++) {
          if (how[i].equals(childCat)) {
            found = false;
          }
        }
        if (found) {
          break;
        }
      }
    } else if (how[0].equals(""rightexcept"")) {
      for (headIdx = daughterTrees.length - 1; headIdx >= 0; headIdx--) {
        childCat = tlp.basicCategory(daughterTrees[headIdx].label().value());
        found = true;
        for (int i = 1; i < how.length; i++) {
          if (how[i].equals(childCat)) {
            found = false;
          }
        }
        if (found) {
          break;
        }
      }
    } else {
      throw new RuntimeException(""ERROR: invalid direction type "" + how[0] + "" to nonTerminalInfo map in AbstractCollinsHeadFinder."");
    }
    
    // what happens if our rule didn't match anything
    if (!found) {
      if (lastResort) {
        // use the default rule to try to match anything except categoriesToAvoid
        // if that doesn't match, we'll return the left or rightmost child (by
        // setting headIdx).  We want to be careful to ensure that postOperationFix
        // runs exactly once.
        String[] rule;
        if (how[0].startsWith(""left"")) {
          headIdx = 0;
          rule = defaultLeftRule;
        } else {
          headIdx = daughterTrees.length - 1;
          rule = defaultRightRule;
        }
        Tree child = traverseLocate(daughterTrees, rule, false);
        if (child != null) {
          return child;
        }
      } else {
        // if we're not the last resort, we can return null to let the next rule try to match
        return null;
      }
    }
    
    headIdx = postOperationFix(headIdx, daughterTrees);

    return daughterTrees[headIdx];
  }",Traverse the list of trees looking for the how elements in the list of strings.
"@Override
    protected List<Object> recursivelyPopulateEntities(EntityMetadata m, Client client)
    {
        // required in case of associated entities.
        List ls = onQuery(m, client);
        return setRelationEntities(ls, client, m);
    }",Recursive method to populate the entity list.
"@Override
    @SuppressWarnings(""rawtypes"")
    public Map<String, Object> toMap(StreamMessage message) throws ConvertFailException
    {
        Map<String, Object> result = new LinkedHashMap<String, Object>();

        // Messageヘッダのうち、DBに格納する値を取得する
        result.put(""messageId"", message.getHeader().getMessageId());
        result.put(""timestamp"", new Timestamp(message.getHeader().getTimestamp()));

        result.put(""source"", message.getHeader().getSource());

        List<String> bodyStrList = new ArrayList<String>();
        // BodyがIterableの場合はStringリスト形式としてDB格納値を取得
        // Iterableでない場合はtoStringの結果をそのまま詰める。
        if (message.getBody() instanceof Iterable)
        {
            Iterator list = ((Iterable) message.getBody()).iterator();
            while (list.hasNext())
            {
                bodyStrList.add(list.next().toString());
            }
        }
        else
        {
            bodyStrList.add(message.getBody().toString());
        }

        result.put(""body"", bodyStrList);

        return result;
    }",Method to convert a StreamMessage to a Map.
"public Login login(String username, String password) throws Exception {
    return login(username, password, null);
  }",Login with the given username and password.
"public void buildSignature(XMLNode node, Content enumConstantsTree) {
        enumConstantsTree.addContent(writer.getSignature(
                (FieldDoc) enumConstants.get(currentEnumConstantsIndex)));
    }",Build the signature for the class.
"@Override
    public long[] read(ScanBuffer buffer) {
        int length = getLength(buffer);
        if (length<0) return null;
        return buffer.getLongs(length);
    }","Reads a
    from the given ScanBuffer."
"public MediaItem createMediaItem(String parentId, String mediaId, String title, int flag) {
    final MediaMetadataCompat metadataCompat =
        new MediaMetadataCompat.Builder()
            .putString(MediaMetadataCompat.METADATA_KEY_MEDIA_ID, mediaId)
            .putString(MediaMetadataCompat.METADATA_KEY_TITLE, title)
            .putString(MediaMetadataCompat.METADATA_KEY_MEDIA_URI, Uri.parse(mediaId).toString())
            .build();
    final MediaItem mediaItem = new MediaItem(metadataCompat.getDescription(), flag);
    mediaItems.put(mediaId, mediaItem);

    // If this MediaItem is the child of a MediaItem that has already been created. This applies to
    // all MediaItems except the root.
    if (parentId != null) {
      final MediaItem parentItem = mediaItems.get(parentId);
      List<MediaItem> children = mediaItemChildren.get(parentItem);
      if (children == null) {
        children = new ArrayList<>();
        mediaItemChildren.put(parentItem, children);
      }
      children.add(mediaItem);
    }

    return mediaItem;
  }",Create a new MediaItem.
"protected void writeAnnotations(
            Map<String, List<String>> effectiveAnnotationMap,
            Map<String, List<String>> currentAnnotationMap, Writer writer)
            throws IOException, BELRuntimeException {

        List<Map.Entry<String, List<String>>> entriesToSet =
                new ArrayList<Map.Entry<String, List<String>>>();
        for (Map.Entry<String, List<String>> effEntry : effectiveAnnotationMap
                .entrySet()) {
            if (!currentAnnotationMap.containsKey(effEntry.getKey())) {
                //set annotation that are unique to the effective map
                entriesToSet.add(effEntry);
            } else {
                List<String> currentValues =
                        currentAnnotationMap.get(effEntry.getKey());
                List<String> effectiveValues = effEntry.getValue();
                if (currentValues == null || effectiveValues == null) {
                    throw new BELRuntimeException(""Invalid annotation value"",
                            ExitCode.PARSE_ERROR);
                }
                //set annotation that exist in both map, but values are different in effective map
                //this will override the annotation
                if (!currentValues.equals(effectiveValues)) {
                    entriesToSet.add(effEntry);
                }
            }
        }

        //remove annotations that are no longer in the effective set
        currentAnnotationMap.keySet()
                .removeAll(effectiveAnnotationMap.keySet());
        if (!currentAnnotationMap.keySet().isEmpty() || !entriesToSet.isEmpty()) {
            writer.write(""\n"");
            //unset
            for (String name : currentAnnotationMap.keySet()) {
                unsetAnnotation(name, writer);
            }
            //set
            for (Map.Entry<String, List<String>> entry : entriesToSet) {
                setAnnotation(entry.getKey(), entry.getValue(), writer);
            }
            writer.write(""\n"");
        }

        //current annotation map now reflects the effective annotations
        currentAnnotationMap.clear();
        currentAnnotationMap.putAll(effectiveAnnotationMap);
    }",Write the annotations from the effective annotation map to the writer.
"public static <T, U, R> BiFunction<T, U, R> biFunction(CheckedBiFunction<T, U, R> function, Consumer<Throwable> handler) {
        return (t, u) -> {
            try {
                return function.apply(t, u);
            }
            catch (Throwable e) {
                handler.accept(e);

                throw new IllegalStateException(""Exception handler must throw a RuntimeException"", e);
            }
        };
    }",Bi function.
"private void fireMessageEventRequestListeners(
        Jid from,
        String packetID,
        String methodName) {
        try {
            Method method =
                MessageEventRequestListener.class.getDeclaredMethod(
                    methodName,
                    new Class<?>[] { Jid.class, String.class, MessageEventManager.class });
            for (MessageEventRequestListener listener : messageEventRequestListeners) {
                method.invoke(listener, new Object[] { from, packetID, this });
            }
        } catch (Exception e) {
            LOGGER.log(Level.SEVERE, ""Error while invoking MessageEventRequestListener's  "" + methodName, e);
        }
    }",Fires all MessageEventRequestListeners.
"public FunctionList signature(final Class... args) {
        return filter(new Filter() {
            public boolean keep(Function m) {
                return Arrays.equals(m.getParameterTypes(), args);
            }
        });
    }",Returns a list of functions that have the same parameter types as the given argument types.
"public QualifiedName nestedType(String simpleName) {
    return new QualifiedName(packageName,
        ImmutableList.<String>builder().addAll(simpleNames).add(simpleName).build());
  }",Returns a QualifiedName representing a nested type.
"public <P extends ParaObject> List<P> findTermInList(String type, String field, List<String> terms, Pager... pager) {
		MultivaluedMap<String, String> params = new MultivaluedHashMap<>();
		params.putSingle(""field"", field);
		params.put(""terms"", terms);
		params.putSingle(Config._TYPE, type);
		params.putAll(pagerToParams(pager));
		return getItems(find(""in"", params), pager);
	}",Find term in list.
"boolean writeIndex(String name, File idxFile, CoordinateRuntime masterRuntime, List<Group> groups, List<MFile> files,
                            GribCollectionImmutable.Type type, CalendarDateRange dateRange) throws IOException {
    Grib2Record first = null; // take global metadata from here
    boolean deleteOnClose = false;

    if (idxFile.exists()) {
      RandomAccessFile.eject(idxFile.getPath());
      if (!idxFile.delete()) {
        logger.error(""gc2 cant delete index file {}"", idxFile.getPath());
      }
    }
    logger.debug("" createIndex for {}"", idxFile.getPath());

    try (RandomAccessFile raf = new RandomAccessFile(idxFile.getPath(), ""rw"")) {
      //// header message
      raf.order(RandomAccessFile.BIG_ENDIAN);
      raf.write(MAGIC_START.getBytes(CDM.utf8Charset));
      raf.writeInt(version);
      long lenPos = raf.getFilePointer();
      raf.writeLong(0); // save space to write the length of the record section
      long countBytes = 0;
      int countRecords = 0;

      Set<Integer> allFileSet = new HashSet<>();
      for (Group g : groups) {
        g.fileSet = new HashSet<>();
        for (Grib2CollectionBuilder.VariableBag vb : g.gribVars) {
          if (first == null) first = vb.first;
          GribCollectionProto.SparseArray vr = writeSparseArray(vb, g.fileSet);
          byte[] b = vr.toByteArray();
          vb.pos = raf.getFilePointer();
          vb.length = b.length;
          raf.write(b);
          countBytes += b.length;
          countRecords += vb.coordND.getSparseArray().countNotMissing();
        }
        allFileSet.addAll(g.fileSet);
      }

      if (logger.isDebugEnabled()) {
        long bytesPerRecord = countBytes / ((countRecords == 0) ? 1 : countRecords);
        logger.debug(""  write RecordMaps: bytes = {} record = {} bytesPerRecord={}"", countBytes, countRecords, bytesPerRecord);
      }

      if (first == null) {
        deleteOnClose = true;
        throw new IOException(""GribCollection "" + name + "" has no records"");
      }

      long pos = raf.getFilePointer();
      raf.seek(lenPos);
      raf.writeLong(countBytes);
      raf.seek(pos); // back to the output.

      /*
      message GribCollection {
        string name = 1;         // must be unique - index filename is name.ncx
        string topDir = 2;       // MFile, Partition filenames are reletive to this
        repeated MFile mfiles = 3;        // list of grib MFiles
        repeated Dataset dataset = 4;
        repeated Gds gds = 5;             // unique Gds, shared amongst datasets
        Coord masterRuntime = 6;  // list of runtimes in this GC

        int32 center = 7;      // these 4 fields are to get a GribCustomizer
        int32 subcenter = 8;
        int32 master = 9;
        int32 local = 10;       // grib1 table Version

        int32 genProcessType = 11;
        int32 genProcessId = 12;
        int32 backProcessId = 13;
        int32 version = 14;     // >= 3 for proto3 (5.0+)

        // repeated Parameter params = 20;      // not used
        FcConfig config = 21;

        // extensions
        repeated Partition partitions = 100;
        bool isPartitionOfPartitions = 101;
        repeated uint32 run2part = 102 [packed=true];  // masterRuntime index to partition index
      }
       */
      GribCollectionProto.GribCollection.Builder indexBuilder = GribCollectionProto.GribCollection.newBuilder();
      indexBuilder.setName(name);
      indexBuilder.setTopDir(dcm.getRoot());
      indexBuilder.setVersion(currentVersion);

      // directory and mfile list
      File directory = new File(dcm.getRoot());
      List<GcMFile> gcmfiles = GcMFile.makeFiles(directory, files, allFileSet);
      for (GcMFile gcmfile : gcmfiles) {
        GribCollectionProto.MFile.Builder b = GribCollectionProto.MFile.newBuilder();
        b.setFilename(gcmfile.getName());
        b.setLastModified(gcmfile.getLastModified());
        b.setLength(gcmfile.getLength());
        b.setIndex(gcmfile.index);
        indexBuilder.addMfiles(b.build());
      }

      indexBuilder.setMasterRuntime(writeCoordProto(masterRuntime));

       //gds
      for (Object go : groups) {
        Group g = (Group) go;
        indexBuilder.addGds(writeGdsProto(g.gdss.getRawBytes(), -1));
      }

      // the GC dataset
      indexBuilder.addDataset(writeDatasetProto(type, groups));

      // what about just storing first ??
      Grib2SectionIdentification ids = first.getId();
      indexBuilder.setCenter(ids.getCenter_id());
      indexBuilder.setSubcenter(ids.getSubcenter_id());
      indexBuilder.setMaster(ids.getMaster_table_version());
      indexBuilder.setLocal(ids.getLocal_table_version());

      Grib2Pds pds = first.getPDS();
      indexBuilder.setGenProcessType(pds.getGenProcessType());
      indexBuilder.setGenProcessId(pds.getGenProcessId());
      indexBuilder.setBackProcessId(pds.getBackProcessId());

      indexBuilder.setStartTime(dateRange.getStart().getMillis());
      indexBuilder.setEndTime(dateRange.getEnd().getMillis());

      GribCollectionProto.GribCollection index = indexBuilder.build();
      byte[] b = index.toByteArray();
      NcStream.writeVInt(raf, b.length); // message size
      raf.write(b);  // message  - all in one gulp
      logger.debug(""  write GribCollectionIndex= {} bytes"", b.length);

    } finally {
      // remove it on failure
      if (deleteOnClose && !idxFile.delete())
        logger.error("" gc2 cant deleteOnClose index file {}"", idxFile.getPath());
    }

    return true;
  }",Write the index file.
"public void marshall(ListImagesFilter listImagesFilter, ProtocolMarshaller protocolMarshaller) {

        if (listImagesFilter == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(listImagesFilter.getTagStatus(), TAGSTATUS_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given listImagesFilter to the given protocolMarshaller.
"private void doAsynSend(final String topicName, final String messageKey,final DefaultMessage message) {
		// 异步发送
        this.kafkaProducer.send(new ProducerRecord<String, Object>(topicName, messageKey,message.sendBodyOnly() ? message.getBody() : message), new Callback() {

            @Override
            public void onCompletion(RecordMetadata metadata, Exception ex) {
                if (ex != null) {
                	for (ProducerEventHandler handler : eventHanlders) {
                		try {handler.onError(topicName, message);} catch (Exception e) {}
    				}
                	log.error(""kafka_send_fail,topic=""+topicName+"",messageId=""+messageKey,ex);
                } else {
                	for (ProducerEventHandler handler : eventHanlders) {
                		try {handler.onSuccessed(topicName, metadata);} catch (Exception e) {}
    				}
                    if (log.isDebugEnabled()) {
                        log.debug(""kafka_send_success,topic="" + topicName + "", messageId="" + messageKey + "", partition="" + metadata.partition() + "", offset="" + metadata.offset());
                    }
                }
            }
        });
	}",send message to Kafka
"private int getTaskCode(String field) throws MPXJException
   {
      Integer result = m_taskNumbers.get(field.trim());

      if (result == null)
      {
         throw new MPXJException(MPXJException.INVALID_TASK_FIELD_NAME + "" "" + field);
      }

      return (result.intValue());
   }",Get the task code for a field.
"public String getTree(Record recPackages)
    {
        try {
            if (m_recPackagesTree == null)
            {
                RecordOwner recordOwner = this.getOwner().findRecordOwner();
                m_recPackagesTree = new Packages(recordOwner);
                if (recordOwner != null)
                    recordOwner.removeRecord(m_recPackagesTree);
            }
            String strPackagesTree = recPackages.getField(Packages.NAME).toString();
            m_recPackagesTree.addNew();
            m_recPackagesTree.getField(Packages.ID).moveFieldToThis(recPackages.getField(Packages.PARENT_FOLDER_ID));
            while ((m_recPackagesTree.getField(Packages.ID).getValue() > 0) && (m_recPackagesTree.seek(null)))
            {
                strPackagesTree = m_recPackagesTree.getField(Packages.NAME).toString() + '.' + strPackagesTree;
                m_recPackagesTree.getField(Packages.ID).moveFieldToThis(m_recPackagesTree.getField(Packages.PARENT_FOLDER_ID));
            }
            return strPackagesTree;
            
        } catch (DBException ex) {
            ex.printStackTrace();
            return null;
        }
    }",Get the tree of this record.
"private String getPathInfoforSecureloginlogout(String currentURI, String securityString) {
        String pathInfo = null;
        int lastIndex_Security = currentURI.lastIndexOf(securityString);
        String restURI = currentURI.substring(lastIndex_Security + securityString.length());

        if (restURI.equals(""""))
            pathInfo = null;
        else
            pathInfo = restURI;
        return pathInfo;
    }",get getPathInfoforSecureloginlogout This method is used to get the pathInfo for the secureloginlogout request.
"public static Iterable<CallSet> getCallSets(String variantSetId, OfflineAuth auth)
      throws IOException {
    Genomics genomics = GenomicsFactory.builder().build().fromOfflineAuth(auth);
    return Paginator.Callsets.create(genomics)
        .search(new SearchCallSetsRequest().setVariantSetIds(Lists.newArrayList(variantSetId)),
            ""callSets,nextPageToken"");
  }",Get CallSets for a given variantSetId
"public static base_responses add(nitro_service client, nsip6 resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			nsip6 addresources[] = new nsip6[resources.length];
			for (int i=0;i<resources.length;i++){
				addresources[i] = new nsip6();
				addresources[i].ipv6address = resources[i].ipv6address;
				addresources[i].scope = resources[i].scope;
				addresources[i].type = resources[i].type;
				addresources[i].vlan = resources[i].vlan;
				addresources[i].nd = resources[i].nd;
				addresources[i].icmp = resources[i].icmp;
				addresources[i].vserver = resources[i].vserver;
				addresources[i].telnet = resources[i].telnet;
				addresources[i].ftp = resources[i].ftp;
				addresources[i].gui = resources[i].gui;
				addresources[i].ssh = resources[i].ssh;
				addresources[i].snmp = resources[i].snmp;
				addresources[i].mgmtaccess = resources[i].mgmtaccess;
				addresources[i].restrictaccess = resources[i].restrictaccess;
				addresources[i].dynamicrouting = resources[i].dynamicrouting;
				addresources[i].hostroute = resources[i].hostroute;
				addresources[i].ip6hostrtgw = resources[i].ip6hostrtgw;
				addresources[i].metric = resources[i].metric;
				addresources[i].vserverrhilevel = resources[i].vserverrhilevel;
				addresources[i].ospf6lsatype = resources[i].ospf6lsatype;
				addresources[i].ospfarea = resources[i].ospfarea;
				addresources[i].state = resources[i].state;
				addresources[i].map = resources[i].map;
				addresources[i].ownernode = resources[i].ownernode;
				addresources[i].td = resources[i].td;
			}
			result = add_bulk_request(client, addresources);
		}
		return result;
	}",Use this API to add nsip6 resources.
"@Override
	public PType caseALetStm(ALetStm node, TypeCheckInfo question)
			throws AnalysisException
	{
		node.setType(typeCheckLet(node, node.getLocalDefs(),node.getStatement(),question));
		return node.getType();
	}",typeCheckALetStm This is a no - op for ASetStm.
"public BigDecimal subtract(BigDecimal subtrahend, MathContext mc) {
        if (mc.precision == 0)
            return subtract(subtrahend);
        // share the special rounding code in add()
        return add(subtrahend.negate(), mc);
    }",Subtracts the subtrahend from this number.
"@Override
    public Set<String> getPreferredIDs(
        Locale locale,
        boolean smart
    ) {

        String country = FormatUtils.getRegion(locale);

        if (smart) {
            if (country.equals(""US"")) {
                Set<String> tzids = new LinkedHashSet<>();
                tzids.add(""America/New_York"");
                tzids.add(""America/Chicago"");
                tzids.add(""America/Denver"");
                tzids.add(""America/Los_Angeles"");
                tzids.add(""America/Anchorage"");
                tzids.add(""Pacific/Honolulu"");
                tzids.add(""America/Adak"");
                return Collections.unmodifiableSet(tzids);
            } else {
                String primaryZone = PRIMARIES.get(country);

                if (primaryZone != null) {
                    return Collections.singleton(primaryZone);
                }
            }
        }

        Set<String> result = TERRITORIES.get(country);

        if (result == null) {
            result = Collections.emptySet();
        }

        return result;

    }",Get preferred IDs for a single calendar.
"public Object mapTo(final Object objectToMap, final JBBPMapperCustomFieldProcessor customFieldProcessor) {
    return JBBPMapper.map(this, objectToMap, customFieldProcessor);
  }",Map to object.
"public static void generate(ConfigurationImpl configuration, ClassTree classtree) throws DocFileIOException  {
        ClassUseMapper mapper = new ClassUseMapper(configuration, classtree);
        for (TypeElement aClass : configuration.getIncludedTypeElements()) {
            // If -nodeprecated option is set and the containing package is marked
            // as deprecated, do not generate the class-use page. We will still generate
            // the class-use page if the class is marked as deprecated but the containing
            // package is not since it could still be linked from that package-use page.
            if (!(configuration.nodeprecated &&
                  configuration.utils.isDeprecated(configuration.utils.containingPackage(aClass))))
                ClassUseWriter.generate(configuration, mapper, aClass);
        }
        for (PackageElement pkg : configuration.packages) {
            // If -nodeprecated option is set and the package is marked
            // as deprecated, do not generate the package-use page.
            if (!(configuration.nodeprecated && configuration.utils.isDeprecated(pkg)))
                PackageUseWriter.generate(configuration, mapper, pkg);
        }
    }",Generate the class - use pages.
"public JsonNode getApplicationsTree() throws IOException {
        Invocation invocation = getJerseyClient().target(getEndpoint() + ""/v1/applications/fetch"").request().buildGet();
        return invocation.invoke().readEntity(JsonNode.class);
    }",Get the application tree.
"public R call() throws BackendException {
        while (hasNext) {
            pagesProcessed++;
            next();
        }
        delegate.updatePagesHistogram(apiName, tableName, pagesProcessed);
        return getMergedPages();
    }",Call the method.
"public static boolean copy(InputStream input, OutputStream output, int bufferSize)
   {
      try
      {
         byte[] buffer = new byte[bufferSize];

         int read = input.read(buffer);
         while (read != -1) {
            output.write(buffer, 0, read);
            read = input.read(buffer);
         }

         output.flush();
      }
      catch (IOException e) {
         return false;
      }
      return true;
   }",Copy a stream to an output stream.
"private List<TagRenderData> buildTagRenderDataList() {
        final List<TagRenderData> tagRenderData = new ArrayList<TagRenderData>();
        final Collection<TagCloudTag> tags = tagCollectionModel.getObject();

        int minWeight = Integer.MAX_VALUE;
        int maxWeight = Integer.MIN_VALUE;

        for (final TagCloudTag tag : tags) {
            minWeight = Math.min(minWeight, tag.getWeight());
            maxWeight = Math.max(maxWeight, tag.getWeight());
        }

        final int fontRange = maxFontSizeInPixels - minFontSizeInPixels;

        int weightRange = 1;
        if (minWeight != maxWeight) {
            weightRange = maxWeight - minWeight;
        }

        float weightIncrease = 0;
        if (fontRange >= weightRange) {
            weightIncrease = fontRange / weightRange;
        } else {
            weightIncrease = weightRange / fontRange;
        }

        for (final TagCloudTag tag : tags) {

            final int fontSize = Math.round(minFontSizeInPixels + (tag.getWeight() - minWeight) * weightIncrease);
            tagRenderData.add(new TagRenderData(tag, fontSize));
        }
        return tagRenderData;
    }",Build TagRenderData list.
"private String getChunk(final String string, final int slength,
            final int marker) {
        if (isDigit(string.charAt(marker))) {
            return getNumericChunk(string, slength, marker);
        } else {
            return getTextChunk(string, slength, marker);
        }
    }",Gets the chunk.
"public SchemaMapping fromArrow(Schema arrowSchema) {
    List<Field> fields = arrowSchema.getFields();
    List<TypeMapping> parquetFields = fromArrow(fields);
    MessageType parquetType = addToBuilder(parquetFields, Types.buildMessage()).named(""root"");
    return new SchemaMapping(arrowSchema, parquetType, parquetFields);
  }",Creates a schema mapping from an arrow schema.
"public void accessRestriction_ip_id_PUT(Long id, OvhIpRestriction body) throws IOException {
		String qPath = ""/me/accessRestriction/ip/{id}"";
		StringBuilder sb = path(qPath, id);
		exec(qPath, ""PUT"", sb.toString(), body);
	}",Update access restriction
"@Override
    public ResultSet getProcedures(String catalog, String schemaPattern, String procedureNamePattern) throws SQLException
    {
        if (procedureNamePattern != null && !procedureNamePattern.equals(""%""))
            throw new SQLException(String.format(""getProcedures('%s','%s','%s') does not support pattern filtering"", catalog, schemaPattern, procedureNamePattern));

        checkClosed();
        this.sysCatalog.setString(1, ""PROCEDURES"");
        ResultSet res = this.sysCatalog.executeQuery();
        return res;
    }",Retrieves a description of all the PROCEDURES in the database.
"public static nspbr_stats get(nitro_service service, String name) throws Exception{
		nspbr_stats obj = new nspbr_stats();
		obj.set_name(name);
		nspbr_stats response = (nspbr_stats) obj.stat_resource(service);
		return response;
	}",Use this API to fetch statistics of nspbr_stats resource of given name.
"protected boolean changeCameraConfiguration() {
		Log.i(TAG,""CameraCaptureSession.changeCameraConfiguration()"");
		if (Looper.getMainLooper().getThread() != Thread.currentThread()) {
			throw new RuntimeException(""Not on main looper! Modify code to remove assumptions"");
		}
		if (null == open.mCameraDevice || null == open.mCameraSize) {
			Log.i(TAG,""  aborting changeCameraConfiguration. Camera not open yet."");
			return false;
		}

		try {
			open.mLock.lock();
			// configuration change still in progress
			if( null == mPreviewSession ) {
				Log.i(TAG,"" Abort camera configuration change. Not ready yet"");
				return false;
			}
			createCaptureSession();
		} catch (CameraAccessException e) {
			e.printStackTrace();
		} finally {
			open.mLock.unlock();
		}
		return true;
	}",Changes camera configuration.
"@Override
    public void getScalingEvents(final String scopeName, final String streamName, final Long from, final Long to,
                                 final SecurityContext securityContext, final AsyncResponse asyncResponse) {
        long traceId = LoggerHelpers.traceEnter(log, ""getScalingEvents"");

        try {
            restAuthHelper.authenticateAuthorize(
                    getAuthorizationHeader(),
                    AuthResourceRepresentation.ofStreamInScope(scopeName, streamName), READ);
        } catch (AuthException e) {
            log.warn(""Get scaling events for {} failed due to authentication failure."", scopeName + ""/"" + streamName);
            asyncResponse.resume(Response.status(Status.fromStatusCode(e.getResponseCode())).build());
            LoggerHelpers.traceLeave(log, ""Get scaling events"", traceId);
            return;
        }

        if (from < 0 || to < 0 || from > to) {
            log.warn(""Received invalid request from client for scopeName/streamName: {}/{} "", scopeName, streamName);
            asyncResponse.resume(Response.status(Status.BAD_REQUEST).build());
            LoggerHelpers.traceLeave(log, ""getScalingEvents"", traceId);
            return;
        }

        controllerService.getScaleRecords(scopeName, streamName, from, to).thenApply(listScaleMetadata -> {
            Iterator<ScaleMetadata> metadataIterator = listScaleMetadata.iterator();
            List<ScaleMetadata> finalScaleMetadataList = new ArrayList<ScaleMetadata>();

            // referenceEvent is the Event used as reference for the events between 'from' and 'to'.
            ScaleMetadata referenceEvent = null;

            while (metadataIterator.hasNext()) {
                ScaleMetadata scaleMetadata = metadataIterator.next();
                if (scaleMetadata.getTimestamp() >= from && scaleMetadata.getTimestamp() <= to) {
                    finalScaleMetadataList.add(scaleMetadata);
                } else if ((scaleMetadata.getTimestamp() < from) &&
                            !(referenceEvent != null && referenceEvent.getTimestamp() > scaleMetadata.getTimestamp())) {
                    // This check is required to store a reference event i.e. an event before the 'from' datetime
                    referenceEvent = scaleMetadata;
                }
            }

            if (referenceEvent != null) {
                finalScaleMetadataList.add(0, referenceEvent);
            }
            log.info(""Successfully fetched required scaling events for scope: {}, stream: {}"", scopeName, streamName);
            return Response.status(Status.OK).entity(finalScaleMetadataList).build();
        }).exceptionally(exception -> {
            if (exception.getCause() instanceof StoreException.DataNotFoundException
                    || exception instanceof StoreException.DataNotFoundException) {
                log.warn(""Stream/Scope name: {}/{} not found"", scopeName, streamName);
                return Response.status(Status.NOT_FOUND).build();
            } else {
                log.warn(""getScalingEvents for scopeName/streamName: {}/{} failed with exception "",
                        scopeName, streamName, exception);
                return Response.status(Status.INTERNAL_SERVER_ERROR).build();
            }
        }).thenApply(asyncResponse::resume)
                .thenAccept(x -> LoggerHelpers.traceLeave(log, ""getScalingEvents"", traceId));
    }",Method to get scaling events.
"public InputStream tryGetInputStream(HttpServletRequest request, MutableObject<byte[]> sourceMapResult) throws IOException {
		InputStream result = null;
		// Check bytes before filename when reading and reverse order when setting
		if (bytes != null || filename != null) {
			try {
				result = getInputStream(request, sourceMapResult);
			} catch (Exception e) {
				if (LayerImpl.log.isLoggable(Level.SEVERE)) {
					LayerImpl.log.log(Level.SEVERE, e.getMessage(), e);
				}
				// just return null
			}
		}
		return result;
	}",This method is used to try to get an input stream from the server.
"synchronized CleanupStatus removeFinishedWrites() {
        Exceptions.checkNotClosed(this.closed, this);
        long currentTime = this.timeSupplier.get();
        long totalElapsed = 0;
        int removedCount = 0;
        boolean failedWrite = false;
        while (!this.writes.isEmpty() && this.writes.peekFirst().isDone()) {
            Write w = this.writes.removeFirst();
            this.totalLength = Math.max(0, this.totalLength - w.data.getLength());
            removedCount++;
            totalElapsed += currentTime - w.getQueueAddedTimestamp();
            failedWrite |= w.getFailureCause() != null;
        }

        if (removedCount > 0) {
            this.lastDurationMillis = (int) (totalElapsed / removedCount / AbstractTimer.NANOS_TO_MILLIS);
        }

        return failedWrite
                ? CleanupStatus.WriteFailed
                : this.writes.isEmpty() ? CleanupStatus.QueueEmpty : CleanupStatus.QueueNotEmpty;
    }",Remove finished writes from the queue.
"public static Optional<StartMusicRequest> createStartMusicRequest(Identification source, Identification target, TrackInfo trackInfo) {
        return createStartMusicRequest(source, target, trackInfo, true);
    }",Create a StartMusicRequest Optional.
"static void initPaths() {
		if (config != null && config.getPaths() != null) {
			for (PathChain pathChain : config.getPaths()) {
				pathChain.validate(configName + "" config""); // raises exception on misconfiguration
				if(pathChain.getPath() == null) {
					addSourceChain(pathChain);
				} else {
					addPathChain(pathChain);
				}
			}
		}
	}",Initializes the paths.
"public long getExecutedTasks() {
		long result = 0L;
		for (int i = 0; i < getExecutors().length; i++) {
			result += getExecutedTasks(i);			
		}
		return result;
	}",Gets the number of executed tasks.
"@NotNull
  public PaginatedResult<Candidate> listCandidates() {
    PaginatedResult<Candidate> result = restAdapter.listCandidates();

    for (Candidate candidate : result.getData()) {
      candidate.setAdapter(restAdapter);
    }

    return result;
  }",List Candidate.
"public Map<String, CmsXmlContentProperty> getPropertyConfigurationAsMap() {

        Map<String, CmsXmlContentProperty> result = new LinkedHashMap<String, CmsXmlContentProperty>();
        for (CmsPropertyConfig propConf : getPropertyConfiguration()) {
            result.put(propConf.getName(), propConf.getPropertyData());
        }
        return result;
    }",Returns a map of all property configurations as a map.
"public EmbedBuilder appendDescription(CharSequence description)
    {
        Checks.notNull(description, ""description"");
        Checks.check(this.description.length() + description.length() <= MessageEmbed.TEXT_MAX_LENGTH,
                ""Description cannot be longer than %d characters."", MessageEmbed.TEXT_MAX_LENGTH);
        this.description.append(description);
        return this;
    }",Appends the description to the embed.
"@Override
	public JobExecutionResult execute(String jobName) throws Exception {
		Plan p = createProgramPlan(jobName);
		
		PlanExecutor executor = PlanExecutor.createLocalExecutor();
		initLogging();
		return executor.executePlan(p);
	}",Execute a single job.
"public synchronized boolean replace(XEvent event, int index)
			throws IOException {
		// check for index sanity
		if (index < 0 || index >= size) {
			throw new IndexOutOfBoundsException();
		}
		// determine and set appropriate file pointer position
		navigateToIndex(index);
		storage.seek(position);
		long atePosition = position;
		// read navigation data
		int fwd = storage.readInt();
		// skip backwards pointer and payload size, not relevant
		storage.skipBytes(8);
		int segmentSize = fwd - 12;
		// encode event
		byte[] evtEnc = encode(event);
		boolean success = false;
		if (evtEnc.length <= segmentSize) {
			// overwrite event
			storage.seek(atePosition + 8);
			storage.writeInt(evtEnc.length);
			// insert new padding
			byte segmentPadding[] = new byte[segmentSize - evtEnc.length];
			Arrays.fill(segmentPadding, (byte) 0);
			storage.write(evtEnc);
			storage.write(segmentPadding);
			success = true;
		} else {
			success = false;
		}
		// return to prior position
		this.position = atePosition;
		storage.seek(this.position);
		return success;
	}",Replaces the event with the given event at the given index.
"private List<MigrationInfo> resolved(MigrationInfo[] migrationInfos) {
        if (migrationInfos.length == 0)
            throw new NotFoundException();
        List<MigrationInfo> resolvedMigrations = Lists.newArrayList();
        for (MigrationInfo migrationInfo : migrationInfos) {
            if (migrationInfo.getState().isResolved()) {
                resolvedMigrations.add(migrationInfo);
            }
        }

        return resolvedMigrations;
    }",Get the list of migrations that are resolved.
"public Result readHashcodeByRange(int index, int length, boolean debug, boolean useValue) // LI4337-17
    {
        final String methodName = ""readHashcodeByRange()"";
        Result result = getFromResultPool();
        result.data = null;
        HashtableOnDisk cache_instance = object_cache;;
        try {
            rwLock.readLock().lock();
            if (cache_instance != null) {
                if (index < 0) {
                    index = cache_instance.getPreviousRangeIndex();
                } else if (index > 0) {
                    index = cache_instance.getNextRangeIndex();
                } else {
                    cache_instance.initRangeIndex();
                }
                if (length == -1) {
                    length = cache_instance.size();
                }
                if (length <= 0) {
                    return result;
                }
                if (tc.isDebugEnabled())
                    Tr.debug(tc, methodName, ""cacheName="" + this.cacheName + "" before range index="" + index + "" length="" + length);
                HashcodeReadCallback hrcb = new HashcodeReadCallback(invalidationBuffer, debug, useValue);
                int rangeIndex = cache_instance.iterateKeys(hrcb, index, length);
                cache_instance.addRangeIndex(rangeIndex);
                if (hrcb.isValidHashCode == true) {
                    result.totalHashcode = hrcb.totalHashcode;
                    result.data = hrcb.list;
                    result.dataSize = hrcb.count;
                    if ((hrcb.count + hrcb.expiredCount) == 100) {
                        result.bMore = true;
                    } else {
                        result.bMore = false;
                    }
                } else {
                    result.returnCode = HTODDynacache.NO_HASHCODE_OLD_FORMAT;
                }
            }
        } catch (FileManagerException ex) {
            this.diskCacheException = ex;
            result.diskException = ex;
            result.returnCode = DISK_EXCEPTION;
        } catch (HashtableOnDiskException ex) {
            this.diskCacheException = ex;
            result.diskException = ex;
            result.returnCode = DISK_EXCEPTION;
        } catch (IOException ex) {
            this.diskCacheException = ex;
            result.diskException = ex;
            result.returnCode = DISK_EXCEPTION;
        } catch (Exception ex) {
            result.returnCode = OTHER_EXCEPTION;
            result.diskException = ex;
        } finally {
            rwLock.readLock().unlock();
            if (result.returnCode != NO_EXCEPTION) {
                if (tc.isDebugEnabled())
                    Tr.debug(tc, methodName, ""cacheName="" + this.cacheName + ""\n Exception: "" + ExceptionUtility.getStackTrace(result.diskException));
            }
            if (result.returnCode == DISK_EXCEPTION || result.returnCode == OTHER_EXCEPTION) {
                com.ibm.ws.ffdc.FFDCFilter.processException(result.diskException, ""com.ibm.ws.cache.HTODDynacache.readByRange"", ""1582"", this);
            }
        }
        if (tc.isDebugEnabled())
            Tr.debug(tc, methodName, ""cacheName="" + this.cacheName + "" returnCode="" + result.returnCode + "" size="" + result.dataSize + "" more="" + result.bMore);
        return result;
    }",readHashCodeByRange This method is called by the CacheObject. readHashCodeByRange method.
"@Override
    public void writeRemoteObject(OutputStream out, @Sensitive Object obj) throws org.omg.CORBA.SystemException {
        WSUtilService service = WSUtilService.getInstance();
        if (service != null) {
            obj = service.replaceObject(obj);
        }
        super.writeRemoteObject(out, obj);
    }",Override this method to write the object to the output stream.
"public void init(FilterConfig config) throws ServletException {
    super.init(config);

    String temp = config.getInitParameter(""approot"");

    if (temp == null) {
      throw new ServletException(""Missing required init parameter: approot"");
    }

    pstate = new PresentationState();
    pstate.setAppRoot(temp);

    temp = config.getInitParameter(""noxslt"");
    pstate.setNoXSLTSticky(""yes"".equals(temp));
  }",Override init to set the approot and noxslt parameters.
"public static final Function<Integer,Boolean> notEq(final Integer object) {
        return (Function<Integer,Boolean>)((Function)FnObject.notEq(object));
    }",Returns a function that returns true if the first argument is not equal to the second argument.
"@Override
    public final boolean offer(final E e) {
        if (null == e) {
            throw new NullPointerException();
        }
        final LinkedQueueAtomicNode<E> nextNode = new LinkedQueueAtomicNode<E>(e);
        final LinkedQueueAtomicNode<E> prevProducerNode = xchgProducerNode(nextNode);
        // Should a producer thread get interrupted here the chain WILL be broken until that thread is resumed
        // and completes the store in prev.next.
        prevProducerNode.soNext(nextNode); // StoreStore
        return true;
    }",Inserts the specified element into the queue.
"public boolean hasCurrentUserGotRoleForDomain(Role role, String domain) {
        try {
            DomainRoleEntryEntity domainRoleEntry = findByUserIdAndRole(joynrCallingPrincipal.getUsername(), role);
            return domainRoleEntry != null && domainRoleEntry.getDomains().contains(domain);
        } catch (ContextNotActiveException e) {
            logger.debug(""No joynr message scope context active. Defaulting to 'true'."");
        }
        return true;
    }",Check if the current user has the specified role for the specified domain.
"private void algorithm(final XMLEvent paramEvent) throws IOException, XMLStreamException, TTIOException {
        assert paramEvent != null;
        do {
            /*
             * Check if a node in the shreddered file on the same level equals
             * the current element node.
             */
            if (paramEvent.isStartElement()) {
                mFound = checkElement(paramEvent.asStartElement());
            } else if (paramEvent.isCharacters()) {
                mFound = checkText(paramEvent.asCharacters());
            }
            if (mWtx.getNode().getDataKey() != mNodeKey) {
                mIsRightSibling = true;
            }

            mKeyMatches = mWtx.getNode().getDataKey();
            //
            // if (mFound && mIsRightSibling) {
            // /*
            // * Root element of next subtree in shreddered file matches
            // * so check all descendants. If they match the node must be
            // * inserted.
            // */
            // switch (paramEvent.getEventType()) {
            // case XMLStreamConstants.START_ELEMENT:
            // mMoved = EMoved.FIRSTNODE;
            // //mFound = checkDescendants(paramEvent.asStartElement());
            // mFound = checkDescendants(paramEvent.asStartElement());
            // break;
            // case XMLStreamConstants.CHARACTERS:
            // mFound = checkText(paramEvent.asCharacters());
            // break;
            // default:
            // // throw new
            // AssertionError(""Node type not known or not implemented!"");
            // }
            // mWtx.moveTo(mKeyMatches);
            // }
        } while (!mFound && mWtx.moveTo(((ITreeStructData)mWtx.getNode()).getRightSiblingKey()));
        mWtx.moveTo(mNodeKey);
    }",Algorithm for the algorithm.
"Expression XreadSimpleValueSpecificationOrNull() {

        Expression e;

        switch (token.tokenType) {

            case Tokens.X_VALUE :
                e = new ExpressionValue(token.tokenValue, token.dataType);

                read();

                return e;

            case Tokens.QUESTION :
                e = new ExpressionColumn(OpTypes.DYNAMIC_PARAM);

                compileContext.parameters.add(e);
                read();

                return e;

            default :
                return null;
        }
    }",read a single value specification or null if none.
"@Override
	public void cacheResult(List<CPSpecificationOption> cpSpecificationOptions) {
		for (CPSpecificationOption cpSpecificationOption : cpSpecificationOptions) {
			if (entityCache.getResult(
						CPSpecificationOptionModelImpl.ENTITY_CACHE_ENABLED,
						CPSpecificationOptionImpl.class,
						cpSpecificationOption.getPrimaryKey()) == null) {
				cacheResult(cpSpecificationOption);
			}
			else {
				cpSpecificationOption.resetOriginalValues();
			}
		}
	}",Caches the cp specification options in the entity cache if it is enabled.
"public static String getClassNameForClassFile(String rootDir, String path) {
        path = path.replace(""/"", ""."");
        path = path.replace('\\', '.');
        path = path.substring(0, path.length() - CLASS_EXTENSION.length());
        if (rootDir != null) {
            path = path.substring(rootDir.length());
        }
        return path;
    }",Get the class name for a class file.
"public static Method getMethod (String name, Object target, Map<String, Method> cache)
    {
        Class<?> tclass = target.getClass();
        String key = tclass.getName() + "":"" + name;
        Method method = cache.get(key);

        if (method == null) {
            method = findMethod(tclass, name);
            if (method != null) {
                cache.put(key, method);
            }
        }

        return method;
    }",Gets the Method object from cache.
"public List<TColumn> columnsOfType(GeoPackageDataType type) {
		List<TColumn> columnsOfType = new ArrayList<>();
		for (TColumn column : columns) {
			if (column.getDataType() == type) {
				columnsOfType.add(column);
			}
		}
		return columnsOfType;
	}",Get the columns of the specified type.
"private double[] getAugmentedResponse(double[] y) {
        double[] ret = new double[y.length + p];
        System.arraycopy(y, 0, ret, 0, y.length);
        return ret;
    }",Augment response to a single page of a page.
"private JCTree matchAnnoToTree(AnnotationMirror findme,
                                   Element e, JCTree tree) {
        Symbol sym = cast(Symbol.class, e);
        class Vis extends JCTree.Visitor {
            List<JCAnnotation> result = null;
            public void visitTopLevel(JCCompilationUnit tree) {
                result = tree.packageAnnotations;
            }
            public void visitClassDef(JCClassDecl tree) {
                result = tree.mods.annotations;
            }
            public void visitMethodDef(JCMethodDecl tree) {
                result = tree.mods.annotations;
            }
            public void visitVarDef(JCVariableDecl tree) {
                result = tree.mods.annotations;
            }
        }
        Vis vis = new Vis();
        tree.accept(vis);
        if (vis.result == null)
            return null;

        List<Attribute.Compound> annos = sym.getRawAttributes();
        return matchAnnoToTree(cast(Attribute.Compound.class, findme),
                               annos,
                               vis.result);
    }",Match an annotation to a tree.
"@Override
    public java.util.concurrent.Future<UpdateTableResult> updateTableAsync(String tableName, ProvisionedThroughput provisionedThroughput,
            com.amazonaws.handlers.AsyncHandler<UpdateTableRequest, UpdateTableResult> asyncHandler) {

        return updateTableAsync(new UpdateTableRequest().withTableName(tableName).withProvisionedThroughput(provisionedThroughput), asyncHandler);
    }",Simplified method form for invoking the UpdateTable operation with an AsyncHandler.
"public long getCompletedPrefix()
  {
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.entry(tc, ""getCompletedPrefix"");
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.exit(tc, ""getCompletedPrefix"", Long.valueOf(_targetStream.getCompletedPrefix()));

    return _targetStream.getCompletedPrefix();
  }",Returns the prefix of the last segment in the target stream.
"public MethodInfo searchMethod(String name, Class<?>... parameterTypes) {
        MethodInfo method = ExecutableUtils.getExecutable(methodsGetter.get(), name, parameterTypes);
        if (method == null) {
            method = ExecutableUtils.searchExecutable(methodsGetter.get(), name, parameterTypes);
        }
        return method;
    }",Search method.
"public void init(ScreenLocation itsLocation, BasePanel parentScreen, Converter fieldConverter, int iDisplayFieldDesc, String strValue, String strDesc, String strImage, String strCommand, String strToolTip)
    {
        if (DBConstants.BLANK.equals(strDesc))
            strDesc = null;     // Since resources return Blank instead of null.
        m_strButtonDesc = strDesc;
        m_strCommand = strCommand;
        super.init(itsLocation, parentScreen, fieldConverter, iDisplayFieldDesc, strValue, null, strImage, null, strToolTip);

        this.setRequestFocusEnabled(false);     // By default, make user click with mouse
    }",Initialize the control.
"private static String getKeyValuePair(final String key, final String value, 
        final boolean formEncoding)
        {
        final StringBuilder sb = new StringBuilder ();
        
        final String firstEncoded;
        final String secondEncoded;
        if (formEncoding)
            {
            firstEncoded = urlFormEncode (key);
            secondEncoded = urlFormEncode (value);
            }
        else
            {
            firstEncoded = urlNonFormEncode (key);
            secondEncoded = urlNonFormEncode (value);
            }
        sb.append (firstEncoded);
        sb.append ('=');
        sb.append (secondEncoded);
        
        return sb.toString ();
        }",Get the key value pair.
"public DfuServiceInitiator setZip(@Nullable final Uri uri, @Nullable final String path) {
		return init(uri, path, 0, DfuBaseService.TYPE_AUTO, DfuBaseService.MIME_TYPE_ZIP);
	}",Sets the zip file.
"private void destroyEndpointMBeans() {
        for (Map.Entry<String, ServiceRegistration<DynamicMBean>> mbean : endpointMBeans.entrySet()) {
            String mbeanName = mbean.getKey();
            endpointMBeans.remove(mbeanName);
            mbean.getValue().unregister();
        }
    }",Destroy all endpoint MBeans.
"public String postByRead(
                    final String url,
                    final Reader input,
                    final String media_type
                    )
    {
        String  location = _execute( url, HttpMethod.POST,
                        new ReaderRequestCallback( input, MediaType.parseMediaType( media_type ) ),
                        new LocationHeaderResponseExtractor() );

        return location;
    }",Post by read.
"public static int mapToMultiallelicIndex (int parsedAllele, int numAllele) {
        int correctedAllele = parsedAllele;
        if (parsedAllele > 0) {
            if (parsedAllele == numAllele + 1) {
                correctedAllele = 1;
            } else if (parsedAllele < numAllele + 1) {
                correctedAllele = parsedAllele + 1;
            }
        }
        return correctedAllele;
    }",Map a single allele index to a multiallelic index.
"public boolean highAvailable() {
        try (Jedis jedis = getResource()) {
            String reply = jedis.ping();
            if (""PONG"".equals(reply))
                return true;
        } catch (Exception e) {
            LOG.error(e);
        }

        return false;
    }",Check if a session is high available
"protected boolean householderPivot(int j)
    {
        final double u[] = dataQR[j];

        // find the largest value in this column
        // this is used to normalize the column and mitigate overflow/underflow
        final double max = QrHelperFunctions_DDRM.findMax(u, j, numRows - j);

        if( max <= singularThreshold*maxValueAbs ) {
            return false;
        } else {
            // computes tau and normalizes u by max
            tau = QrHelperFunctions_DDRM.computeTauAndDivide(j, numRows, u, max);
            
            // divide u by u_0
            double u_0 = u[j] + tau;
            QrHelperFunctions_DDRM.divideElements(j + 1, numRows, u, u_0);

            gamma = u_0/tau;
            tau *= max;

            u[j] = -tau;
        }

        gammas[j] = gamma;

        return true;
    }",Pivot of a householder matrix.
"@Override
    public Float fromString(Class targetClass, String s)
    {
        try
        {
            if (s == null)
            {
                return null;
            }
            Float f = new Float(s);
            return f;
        }
        catch (NumberFormatException e)
        {
            log.error(""Number format exception, Caused by {}."", e);
            throw new PropertyAccessException(e);
        }
    }",This method is used to convert a String to a Float.
"protected void renderGlobalBundleLinks(BundleRendererContext ctx, Writer out, boolean debugOn) throws IOException {

		if (debugOn) {
			addComment(""Start adding global members."", out);
		}

		performGlobalBundleLinksRendering(ctx, out, debugOn);

		ctx.setGlobalBundleAdded(true);
		if (debugOn) {
			addComment(""Finished adding global members."", out);
		}
	}",Renders the global bundle links.
"public int putRawFieldData(Convert field)
    {
        String strKey = this.getFullKey(field.getFieldName());
        Class<?> classData = String.class;
        if (field.getField() != null)
            classData = this.getMessage().getNativeClassType(field.getField().getDataClass());
        Object objValue = field.getData();
        try {
            objValue = DataConverters.convertObjectToDatatype(objValue, classData, null);  // I do this just to be careful.
        } catch (Exception ex) {
            objValue = null;
        }
        this.getMessage().putNative(strKey, objValue);
        return Constant.NORMAL_RETURN;
    }",Put the raw data field data.
"public void paintShading(PdfShading shading) {
        writer.addSimpleShading(shading);
        PageResources prs = getPageResources();
        PdfName name = prs.addShading(shading.getShadingName(), shading.getShadingReference());
        content.append(name.getBytes()).append("" sh"").append_i(separator);
        ColorDetails details = shading.getColorDetails();
        if (details != null)
            prs.addColor(details.getColorName(), details.getIndirectReference());
    }",Paints a single shading.
"@Override
  public void deleteSnapshot(String snapshotName) throws IOException {
    String btSnapshotName = getClusterName().toSnapshotName(snapshotName);
    DeleteSnapshotRequest request = DeleteSnapshotRequest.newBuilder()
        .setName(btSnapshotName)
        .build();

    Futures.getUnchecked(tableAdminClientWrapper.deleteSnapshotAsync(request));
  }",Delete a snapshot.
"public boolean isIBMSessionListenerImplemented(ArrayList listeners) {
        for (int i = 0; i < listeners.size(); i++) {
            HttpSessionListener listener = (HttpSessionListener) listeners.get(i);
            if ((listener != null) && (listener instanceof IBMSessionListener)) {
                return true;
            }
        }
        return false;
    }",isIBMSessionListenerImplemented This method is used to check if the IBMSessionListener is implemented in the HttpSessionListener list.
"private CellFormatter getCellFormatter(final Locale locale) {
        if(locale == null) {
            return defaultFormatter;

        } else if(formatterMap.containsKey(locale)) {
            return formatterMap.get(locale);
        }

        return defaultFormatter;
    }",Gets the cell formatter for the given locale.
"protected Session getSession( HttpServletRequest request,
                                  String rawRepositoryName,
                                  String rawWorkspaceName ) throws RepositoryException {
        assert request != null;
        if (ACTIVE_SESSION.get() == null) {
            Session session = RepositoryManager.getSession(request, repositoryNameFor(rawRepositoryName), workspaceNameFor(
                    rawWorkspaceName));
            ACTIVE_SESSION.set(session);
        }
        return ACTIVE_SESSION.get();
    }",Get the session for the given repository name and workspace name.
"private Description handleLocal(DCLInfo info, VisitorState state) {
    JCExpressionStatement expr = getChild(info.synchTree().getBlock(), JCExpressionStatement.class);
    if (expr == null) {
      return Description.NO_MATCH;
    }
    if (expr.getStartPosition() > ((JCTree) info.innerIf()).getStartPosition()) {
      return Description.NO_MATCH;
    }
    if (!(expr.getExpression() instanceof JCAssign)) {
      return Description.NO_MATCH;
    }
    JCAssign assign = (JCAssign) expr.getExpression();
    if (!Objects.equals(ASTHelpers.getSymbol(assign.getVariable()), info.sym())) {
      return Description.NO_MATCH;
    }
    Symbol sym = ASTHelpers.getSymbol(assign.getExpression());
    if (!(sym instanceof VarSymbol)) {
      return Description.NO_MATCH;
    }
    VarSymbol fvar = (VarSymbol) sym;
    if (fvar.getKind() != ElementKind.FIELD) {
      return Description.NO_MATCH;
    }
    return handleField(info.outerIf(), fvar, state);
  }",Handle a local declaration.
"@Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        final int height = getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec);
        final int width = getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec);
        final int min = Math.min(width, height);
        setMeasuredDimension(min, min);
        float highStroke = strokeWidth > backgroundStrokeWidth ? strokeWidth : backgroundStrokeWidth;
        rectF.set(0 + highStroke / 2, 0 + highStroke / 2, min - highStroke / 2, min - highStroke / 2);
    }",Override onMeasure to set the measure dimensions.
"public static base_responses enable(nitro_service client, lbmonitor resources[]) throws Exception {
		base_responses result = null;
		if (resources != null && resources.length > 0) {
			lbmonitor enableresources[] = new lbmonitor[resources.length];
			for (int i=0;i<resources.length;i++){
				enableresources[i] = new lbmonitor();
				enableresources[i].servicename = resources[i].servicename;
				enableresources[i].servicegroupname = resources[i].servicegroupname;
				enableresources[i].monitorname = resources[i].monitorname;
			}
			result = perform_operation_bulk_request(client, enableresources,""enable"");
		}
		return result;
	}",Use this API to enable lbmonitor resources.
"public void removeLine (final Line aLine)
  {
    if (aLine.m_aPrevious == null)
      m_aLines = aLine.m_aNext;
    else
      aLine.m_aPrevious.m_aNext = aLine.m_aNext;
    if (aLine.m_aNext == null)
      m_aLineTail = aLine.m_aPrevious;
    else
      aLine.m_aNext.m_aPrevious = aLine.m_aPrevious;
    aLine.m_aPrevious = null;
    aLine.m_aNext = null;
  }",Remove a line from the line list.
"public void collapse() {
        if (defaults != null) {
            Enumeration keysEnum = defaults.keys();
            while (keysEnum.hasMoreElements()) {
                Object key = keysEnum.nextElement();
                localValues.put(key, defaults.get(key));
            }
            defaults = null;
        }
    }",Collapse the result set.
"public static int getAlphaNumCount(final Buffer buffer) throws IndexOutOfBoundsException, IOException {
        boolean done = false;
        int count = 0;
        final int index = buffer.getReaderIndex();
        while (buffer.hasReadableBytes() && !done) {
            final byte b = buffer.readByte();
            if (isAlphaNum(b)) {
                ++count;
            } else {
                done = true;
            }
        }
        buffer.setReaderIndex(index);
        return count;
    }",Gets the alpha - num count.
"public String getWriteMethod() {
        return setterName != null ? setterName :
		        ""set"" + this.name.substring( 0, 1 ).toUpperCase() + this.name.substring( 1 );
    }",Get the name of the write method.
"@Override
    public CreateThreatIntelSetResult createThreatIntelSet(CreateThreatIntelSetRequest request) {
        request = beforeClientExecution(request);
        return executeCreateThreatIntelSet(request);
    }",Creates a ThreatIntelSet.
"public static <BEAN, KEYTYPE> BEAN get(IGet<BEAN, KEYTYPE> memcachedImpl, IGet<BEAN, KEYTYPE> mysqlImpl, KEYTYPE key) {
		// return CacheLoader1.get(memcachedImpl, mysqlImpl, key);

		BEAN bean = memcachedImpl.get(key);
		if (bean == null) {
			bean = rsyncToCache(memcachedImpl, mysqlImpl, key);
		}
		return bean;
	}",Gets a cached object from memcached and mysql.
"public static void writeToFile(final Properties p, final String fileName) throws IOException {
		writeToFile(p, new File(fileName), null);
	}",Write properties to file.
"@Override
    public IEntityGroup find(String key) throws GroupsException {
        if (log.isDebugEnabled()) {
            log.debug(DEBUG_CLASS_NAME + "".find(): group key: "" + key);
        }

        String path = getFilePathFromKey(key);
        File f = new File(path);

        GroupHolder groupHolder = cacheGet(key);

        if (groupHolder == null || (groupHolder.getLastModified() != f.lastModified())) {
            if (log.isDebugEnabled()) {
                log.debug(
                        DEBUG_CLASS_NAME
                                + "".find(): retrieving group from file system for ""
                                + path);
            }

            if (!f.exists()) {
                if (log.isDebugEnabled()) {
                    log.debug(DEBUG_CLASS_NAME + "".find(): file does not exist: "" + path);
                }
                return null;
            }

            IEntityGroup group = newInstance(f);
            groupHolder = new GroupHolder(group, f.lastModified());
            cachePut(key, groupHolder);
        }
        return groupHolder.getGroup();
    }",Find an IEntityGroup from the file system for the specified key.
"@Deprecated
    public static String encode(String s) {

        String str = null;

        try {
            str = encode(s, dfltEncName);
        } catch (UnsupportedEncodingException e) {
            // The system should always have the platform default
        }

        return str;
    }",Encode a string to a base64 string.
"public String getInstanceIdAsString()
    {
        if (mInstanceIdAsString == null)
        {
            mInstanceIdAsString = Bytes.toHexString(getInstanceId(), true);
        }

        return mInstanceIdAsString;
    }",Gets the instance id as a string.
"public static List<Formula> readCNF(final File file, final FormulaFactory f) throws IOException {
    return readCNF(file, f, ""v"");
  }",Read CNF.
"private void cancelTimers(
			List<org.mobicents.slee.example.sjr.data.RegistrationBinding> removedContacts) {
		for (RegistrationBinding binding : removedContacts) {
			ActivityContextInterfaceExt aci = (ActivityContextInterfaceExt) this.activityContextNamingFacility
					.lookup(getACIName(binding.getContactAddress(),
							binding.getSipAddress()));
			// IF exists end the activity, SLEE will cancel timers, remove aci
			// names, etc.
			if (aci != null) {
				((NullActivity) aci.getActivity()).endActivity();
			}
		}
	}",Cancels timers for contacts that have been removed from the SIP.
"public Log truncate(long index) {
    assertIsOpen();
    if (index > 0)
      assertValidIndex(index);
    Assert.index(index >= segments.commitIndex(), ""cannot truncate committed entries"");

    if (lastIndex() == index)
      return this;

    for (Segment segment : segments.reverseSegments()) {
      if (segment.validIndex(index)) {
        segment.truncate(index);
        break;
      } else if (segment.index() > index) {
        segments.removeSegment(segment);
      }
    }
    entryBuffer.clear();
    return this;
  }",Truncate the log to the given index.
"@Override
    public boolean checkTopicAccess(Subject authenticatedSubject, String topicSpace, String topicName, String operationType) throws MessagingAuthorizationException {
        String busName = null;
        String messagingEngine = null;
        String[] roles = null;
        String resource = null;
        
        if (auditManager != null) {
            if (auditManager.getJMSBusName() != null)
                busName = auditManager.getJMSBusName();
            if (auditManager.getJMSMessagingEngine() != null)
                messagingEngine = auditManager.getJMSMessagingEngine();
        }

        String destinationName = topicSpace;
        resource = ""topicSpace"";
        if (topicName != null) {
            destinationName = topicSpace + MessagingSecurityConstants.TOPIC_DELIMITER + topicName;
            resource = ""topic"";
        }
        
        SibTr.entry(tc, CLASS_NAME + ""checkTopicAccess"", new Object[] { authenticatedSubject, destinationName, operationType });
        checkIfUserIsAuthenticated(authenticatedSubject);
        String userName = null;
        String user = authenticatedSubject.getPrincipals().iterator().next().getName();
        
        Map<String, TopicPermission> mq = messagingSecurityService.getTopicPermissions();
        roles = messagingSecurityService.getDestinationRoles(mq, destinationName, user);
        SibTr.debug(tc, ""checkTopicAccess, roles: "" + Arrays.toString(roles));
        
        try {
            userName = MessagingSecurityUtility.getUniqueUserName(authenticatedSubject);
        } catch (MessagingSecurityException e) {
            if (auditManager != null && auditManager.getJMSConversationMetaData() != null) {
                ConversationMetaData cmd = (ConversationMetaData) auditManager.getJMSConversationMetaData();

                Audit.audit(Audit.EventID.SECURITY_JMS_AUTHZ_01, user, cmd.getRemoteAddress().getHostAddress(), new Integer(cmd.getRemotePort()).toString(),
                            cmd.getChainName(), busName, messagingEngine, destinationName, operationType, roles, resource,
                            Integer.valueOf(""201""));
            } else {
                Audit.audit(Audit.EventID.SECURITY_JMS_AUTHZ_01, user, null, null, null, busName, messagingEngine, destinationName, operationType, 
                            roles, resource, Integer.valueOf(""201""));
            }

            throw new MessagingAuthorizationException(Tr.formatMessage(tc, ""USER_NOT_AUTHORIZED_MSE1010"", userName, operationType, destinationName), e);
        }
        Map<String, TopicPermission> topicPermissions = messagingSecurityService.getTopicPermissions();
        TopicPermission permission = getTopicPermission(topicPermissions, destinationName);
        boolean result = checkPermission(permission, operationType, userName);
        if (!result) {
            if (auditManager != null && auditManager.getJMSConversationMetaData() != null) {
                ConversationMetaData cmd = (ConversationMetaData) auditManager.getJMSConversationMetaData();

                Audit.audit(Audit.EventID.SECURITY_JMS_AUTHZ_01, user, cmd.getRemoteAddress().getHostAddress(), new Integer(cmd.getRemotePort()).toString(),
                            cmd.getChainName(), busName, messagingEngine, destinationName, operationType, roles, resource,
                            Integer.valueOf(""201""));
            } else {
                Audit.audit(Audit.EventID.SECURITY_JMS_AUTHZ_01, user, null, null, null, busName, messagingEngine, destinationName, operationType, 
                            roles, resource, Integer.valueOf(""201""));
            }

            SibTr.debug(tc, ""USER_NOT_AUTHORIZED_MSE1010"",
                        new Object[] { userName, operationType, destinationName });
            throw new MessagingAuthorizationException(Tr.formatMessage(tc, ""USER_NOT_AUTHORIZED_MSE1010"", userName, operationType, destinationName));
        } else {
            if (auditManager != null && auditManager.getJMSConversationMetaData() != null) {
                ConversationMetaData cmd = (ConversationMetaData) auditManager.getJMSConversationMetaData();

                Audit.audit(Audit.EventID.SECURITY_JMS_AUTHZ_01, user, cmd.getRemoteAddress().getHostAddress(), new Integer(cmd.getRemotePort()).toString(),
                            cmd.getChainName(), busName, messagingEngine, destinationName, operationType, roles, resource,
                            Integer.valueOf(""200""));
            } else {
                Audit.audit(Audit.EventID.SECURITY_JMS_AUTHZ_01, user, null, null, null, busName, messagingEngine, destinationName, operationType, 
                            roles, resource, Integer.valueOf(""200""));
            }
        }

        SibTr.exit(tc, CLASS_NAME + ""checkTopicAccess"", result);
        return result;
    }",Check if the topic access is allowed for the given subject.
"private static String buildLepSignature(LepMethod method) {

        String className = Optional.ofNullable(method)
                                   .map(LepMethod::getMethodSignature)
                                   .map(MethodSignature::getDeclaringClass)
                                   .map(Class::getSimpleName).orElse(LOG_QUESTION);

        String methodName = Optional.ofNullable(method)
                                    .map(LepMethod::getMethodSignature)
                                    .map(MethodSignature::getName).orElse(LOG_QUESTION);

        return className + LOG_SEMICOLON + methodName;
    }",Build the log signature for a given lep method
"private Image loadImage(final String resourceName, final boolean skipImagesFolder) {
        Image image = null;

        final List<String> imagePaths = skipImagesFolder ? Collections.singletonList("""") : ResourceParameters.IMAGE_FOLDER.get();
        for (int i = 0; i < imagePaths.size() && image == null; i++) {

            String imagePath = imagePaths.get(i);
            if (!imagePath.isEmpty()) {
                imagePath += Resources.PATH_SEP;
            }
            final InputStream imageInputStream = Thread.currentThread().getContextClassLoader().getResourceAsStream(imagePath + resourceName);
            if (imageInputStream != null) {
                image = new Image(imageInputStream);
            }
        }
        if (image == null) {
            LOGGER.error(""Image : {} not found into base folder: {}"", resourceName, ResourceParameters.IMAGE_FOLDER.get());
        }
        return image;
    }",Load image from the image folder.
"protected void initEditOverlay(Element element) {

        CmsInlineEditOverlay.removeAll();
        m_editOverlay = CmsInlineEditOverlay.addOverlayForElement(element);
        if (m_resizeHandlerRegistration != null) {
            m_resizeHandlerRegistration.removeHandler();
        }
        // add a handler to ensure the edit overlays get adjusted to changed window size
        m_resizeHandlerRegistration = Window.addResizeHandler(new ResizeHandler() {

            private Timer m_resizeTimer;

            public void onResize(ResizeEvent event) {

                if (m_resizeTimer == null) {
                    m_resizeTimer = new Timer() {

                        @Override
                        public void run() {

                            handleResize();
                        }
                    };
                    m_resizeTimer.schedule(300);
                }
            }

            /**
             * Handles the window resize.<p>
             */
            void handleResize() {

                m_resizeTimer = null;
                CmsInlineEditOverlay.updateCurrentOverlayPosition();
            }
        });
    }",Initialize the edit overlay.
"@Override
    public Enumeration getEnumeration() throws JMSException {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.entry(this, tc, ""getEnumeration"");
        Enumeration vEnum = null;

        // Synchronize here so that you can't create an enumeration while the
        // browser is being closed.
        synchronized (enums) {

            // By the time we have synchronized on enums we have control of the
            // state of the object.
            if (state == CLOSED) {
                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
                    SibTr.debug(this, tc, ""Called getEnumeration on a closed Browser"");
                // d238447 FFDC Review. App error, no FFDC required.
                throw (JMSException) JmsErrorUtils.newThrowable(JMSException.class,
                                                                ""BROWSER_CLOSED_CWSIA0142"",
                                                                null,
                                                                tc
                                );
            }

            if (createdFirst) {
                // If we haven't yet given the user the upfront one we created.
                if (firstEnumeration != null) {
                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
                        SibTr.debug(this, tc, ""Using the enumeration that was created by the constructor"");
                    // Pass it ready to be returned.
                    vEnum = firstEnumeration;

                    // Stop us using it again.
                    firstEnumeration = null;
                }
                else {
                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
                        SibTr.debug(this, tc, ""Creating a new enumeration"");
                    // Need to create a new one.
                    vEnum = instantiateBrowser();
                }
            }

            else {
                // We have not created the first one, so do it now. The call to this
                // method will have come from the constructor so we don't need to
                // return the Enumeration - just stash it away for later use.
                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
                    SibTr.debug(this, tc, ""Creating the first Enumeration (to check existence etc)"");
                firstEnumeration = instantiateBrowser();
                createdFirst = true;
            }

        } // release the lock

        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.exit(this, tc, ""getEnumeration"", vEnum);
        return vEnum;
    }",This method is called by the application to get an Enumeration object.
"@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case AfplibPackage.GSPT__PATT:
				setPATT((Integer)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}",Override the eSet method to allow the user to override the value of the featureID attribute.
"protected int binarySearch(int value) {
		int left = 0;
		int right = size-1;
		while(left <= right) {
			int mid = (left + right)>>1;
			int midValue = elementData[mid];
			if(value==midValue) return mid;
			if(value<midValue) right = mid-1;
			else left = mid+1;
		}
		return -(left+1);
	}",Searches for the value in the array.
"public void register(RegistrationRequest registrationRequest) throws RegistrationException {
        if (!registrationRequest.getEnrollmentID().equals(getName())) {
            throw new RuntimeException(""registration enrollment ID and member name are not equal"");
        }

        this.enrollmentSecret = memberServices.register(registrationRequest, chain.getRegistrar());
        this.saveState();
    }",Register the member service with the user.
"protected void updateBuild(Build value, String xmlTag, Counter counter, Element element)
   {
      boolean shouldExist = value != null;
      Element root = updateElement(counter, element, xmlTag, shouldExist);
      if (shouldExist)
      {
         Counter innerCount = new Counter(counter.getDepth() + 1);
         findAndReplaceSimpleElement(innerCount, root, ""sourceDirectory"", value.getSourceDirectory(), null);
         findAndReplaceSimpleElement(innerCount, root, ""scriptSourceDirectory"", value.getScriptSourceDirectory(),
                  null);
         findAndReplaceSimpleElement(innerCount, root, ""testSourceDirectory"", value.getTestSourceDirectory(), null);
         findAndReplaceSimpleElement(innerCount, root, ""outputDirectory"", value.getOutputDirectory(), null);
         findAndReplaceSimpleElement(innerCount, root, ""testOutputDirectory"", value.getTestOutputDirectory(), null);
         iterateExtension(innerCount, root, value.getExtensions(), ""extensions"", ""extension"");
         findAndReplaceSimpleElement(innerCount, root, ""defaultGoal"", value.getDefaultGoal(), null);
         iterateResource(innerCount, root, value.getResources(), ""resources"", ""resource"");
         iterateResource(innerCount, root, value.getTestResources(), ""testResources"", ""testResource"");
         findAndReplaceSimpleElement(innerCount, root, ""directory"", value.getDirectory(), null);
         findAndReplaceSimpleElement(innerCount, root, ""finalName"", value.getFinalName(), null);
         findAndReplaceSimpleLists(innerCount, root, value.getFilters(), ""filters"", ""filter"");
         updatePluginManagement(value.getPluginManagement(), ""pluginManagement"", innerCount, root);
         iteratePlugin(innerCount, root, value.getPlugins(), ""plugins"", ""plugin"");
      } // end if
   }",Method updateBuild.
"@Override
    public double lengthSquared() {
        return x * x + y * y + z * z + w * w;
    }",Returns the length squared of this matrix.
"@Override
	public void synchronousStart(String launchMode, IProgressMonitor monitor) throws CoreException {
		// TODO Auto-generated method stub
		server.synchronousStart(launchMode, monitor);
	}",Override this method to start the asynchronous server.
"private List<SimpleJsonSchema> filterByRepositoryName(List<JsonSchemaRepository> schemaRepositories,
                                                          JsonMessageValidationContext jsonMessageValidationContext) {
        for (JsonSchemaRepository jsonSchemaRepository : schemaRepositories) {
            if (Objects.equals(jsonSchemaRepository.getName(), jsonMessageValidationContext.getSchemaRepository())) {
                if (log.isDebugEnabled()) {
                    log.debug(""Found specified schema-repository: \"""" +
                            jsonMessageValidationContext.getSchemaRepository() + ""\""."");
                }
                return jsonSchemaRepository.getSchemas();
            }
        }

        throw new CitrusRuntimeException(""Could not find the specified schema repository: "" +
                ""\"""" + jsonMessageValidationContext.getSchemaRepository() + ""\""."");
    }",Filter by repository name
"public static StatisticsDeviceListResult statisticsDeviceList(
            String accessToken, StatisticsDeviceList statisticsDeviceList) {
        return statisticsDeviceList(accessToken,
                JsonUtil.toJSONString(statisticsDeviceList));
    }",This method is used to retrieve a StatisticsDeviceListResult object with the specified access token and statisticsDeviceList.
"public static boolean apply(final char[][] robotsFilter, final URI url) {
		if (robotsFilter.length == 0) return true;
		final String pathQuery = BURL.pathAndQuery(url);
		int from = 0;
		int to = robotsFilter.length - 1;
		while (from <= to) {
			final int mid = (from + to) >>> 1;
			final int cmp = compare(robotsFilter[mid], pathQuery);
			if (cmp < 0) from = mid + 1;
			else if (cmp > 0) to = mid - 1;
			else return false; // key found (unlikely, but possible)
		}
		return from == 0 ? true : doesNotStartsWith(pathQuery, robotsFilter[from - 1]);
	}",Checks if the given URL matches the given robots filter.
"@Override
	public Double getMidpoint() {
		if (isEmpty())
			return null;

		// Handle null values
		if (getStart() == null && getEnd() == null)
			return 0.0;
		if (getStart() == null)
			return getEnd() - OFFSET;
		if (getEnd() == null)
			return getStart() + OFFSET;

		// Now we are sure there are no more null values involved
		if (getStart() == Double.NEGATIVE_INFINITY && getEnd() == Double.POSITIVE_INFINITY)
			return 0.0;
		if (getStart() == Double.NEGATIVE_INFINITY)
			return getEnd() - OFFSET;
		if (getEnd() == Double.POSITIVE_INFINITY)
			return getStart() + OFFSET;
		return getStart() + (getEnd() - getStart())/2;
	}",Returns the midpoint of the segment.
"ServerContext setCommitIndex(long commitIndex) {
    Assert.argNot(commitIndex < 0, ""commit index must be positive"");
    long previousCommitIndex = this.commitIndex;
    if (commitIndex > previousCommitIndex) {
      this.commitIndex = commitIndex;
      log.commit(Math.min(commitIndex, log.lastIndex()));
      long configurationIndex = cluster.getConfiguration().index();
      if (configurationIndex > previousCommitIndex && configurationIndex <= commitIndex) {
        cluster.commit();
      }
    }
    return this;
  }",Sets the commit index of this context.
"public Report run(Map<String, Object> options, Closure profiled) {
        try {
            List refs = new ArrayList();
            try {
                for (Field field : profiled.getClass().getDeclaredFields()) {
                    if (field.getType().equals(Reference.class)) {
                        field.setAccessible(true);
                        Reference ref = (Reference) field.get(profiled);
                        refs.add(ref);
                    }
                }
            } catch(Exception e) {}
            refs.add(new Reference(profiled));
            refs.add(new Reference(profiled.getDelegate()));
            Map<String, Object> _options = new HashMap(options);
            _options.put(""references"", refs);
            options = null;
            start(_options);
            try {
                profiled.call();
            } catch (Exception e) {
                e.printStackTrace();
            }
            stop();
            return getReport();
        } finally {
            reset();
        }
    }",Run a single instance of the class.
"@Override
    public XBELDocument toJAXB(final File f) throws JAXBException, IOException {
        return converter.unmarshal(f);
    }",Convert a file to an XML document.
"@Override
    public int  getRuleStatus() {
        makeRuleStatusValid();
        //   Status records have this form:
        //           Count N         <--  fLastRuleStatusIndex points here.
        //           Status val 0
        //           Status val 1
        //              ...
        //           Status val N-1  <--  the value we need to return
        //   The status values are sorted in ascending order.
        //   This function returns the last (largest) of the array of status values.
        int  idx = fLastRuleStatusIndex + fRData.fStatusTable[fLastRuleStatusIndex];
        int  tagVal = fRData.fStatusTable[idx];
        return tagVal;
    }",getRuleStatus This function is used to get the rule status of the CRA.
"public void remove(byte b, String s) {
		Collection c = getAsCollection(b);
		c.remove(s);
		set(b, c);
	}",Removes the given string from the given byte array.
"static void validateEjbClass(Class<?> ejbClass,
                                 String beanName,
                                 int beanType)
                    throws EJBConfigurationException
    {
        int modifiers = ejbClass.getModifiers();

        if (!Modifier.isPublic(modifiers))
        {
            // Log the error and throw meaningful exception.              d457128.2
            Tr.error(tc, ""JIT_NON_PUBLIC_CLASS_CNTR5003E"",
                     new Object[] { beanName,
                                   ejbClass.getName() });
            throw new EJBConfigurationException(""EJB class "" + ejbClass.getName() +
                                                "" must be defined as public : "" + beanName);
        }

        if (Modifier.isFinal(modifiers))
        {
            // Log the error and throw meaningful exception.              d457128.2
            Tr.error(tc, ""JIT_INVALID_FINAL_CLASS_CNTR5004E"",
                     new Object[] { beanName,
                                   ejbClass.getName() });
            throw new EJBConfigurationException(""EJB class "" + ejbClass.getName() +
                                                "" must not be defined as final : "" + beanName);
        }

        // CMP 2.x beans must be abstract, whereas CMP 1.x beans must NOT be
        // abstract, so just skipping CMP beans entirely.
        if (beanType != InternalConstants.TYPE_CONTAINER_MANAGED_ENTITY)
        {
            if (Modifier.isAbstract(modifiers))
            {
                // Log the error and throw meaningful exception.           d457128.2
                Tr.error(tc, ""JIT_INVALID_ABSTRACT_CLASS_CNTR5005E"",
                         new Object[] { beanName,
                                       ejbClass.getName() });
                throw new EJBConfigurationException(""EJB class "" + ejbClass.getName() +
                                                    "" must not be defined as abstract : "" + beanName);
            }
        }

        if (ejbClass.getEnclosingClass() != null)
        {
            // Log the error and throw meaningful exception.              d457128.2
            Tr.error(tc, ""JIT_NOT_TOP_LEVEL_CLASS_CNTR5006E"",
                     new Object[] { beanName,
                                   ejbClass.getName() });
            throw new EJBConfigurationException(""EJB class "" + ejbClass.getName() +
                                                "" must be a top level class : "" + beanName);
        }

        try
        {
            ejbClass.getConstructor(NO_PARAMS);
        } catch (Throwable ex)
        {
            // FFDC is not needed, as a meaningful exception is being thrown.
            // FFDCFilter.processException(ejbex, CLASS_NAME + "".validateEjbClass"", ""653"");
            // Log the error and throw meaningful exception.              d457128.2
            Tr.error(tc, ""JIT_NO_DEFAULT_CTOR_CNTR5007E"",
                     new Object[] { beanName,
                                   ejbClass.getName() });
            throw new EJBConfigurationException(""EJB class "" + ejbClass.getName() +
                                                "" must have a public constructor that takes no parameters : "" +
                                                beanName, ex);
        }

        try
        {
            ejbClass.getDeclaredMethod(""finalize"", NO_PARAMS);

            // Log the error and throw meaningful exception.              d457128.2
            Tr.error(tc, ""JIT_INVALID_FINALIZE_MTHD_CNTR5008E"",
                     new Object[] { beanName,
                                   ejbClass.getName() });
            throw new EJBConfigurationException(""EJB class "" + ejbClass.getName() +
                                                "" must not define the finalize() method : "" +
                                                beanName);
        } catch (Throwable ex)
        {
            // FFDC is not needed... finalize method should NOT be found.
            // FFDCFilter.processException(ejbex, CLASS_NAME + "".validateEjbClass"", ""667"");
        }

        if (beanType == InternalConstants.TYPE_BEAN_MANAGED_ENTITY ||
            beanType == InternalConstants.TYPE_CONTAINER_MANAGED_ENTITY)
        {
            if (!(EntityBean.class).isAssignableFrom(ejbClass))
            {
                // Log the error and throw meaningful exception.           d457128.2
                Tr.error(tc, ""JIT_MISSING_ENTITYBEAN_CNTR5009E"",
                         new Object[] { beanName,
                                       ejbClass.getName() });
                throw new EJBConfigurationException(""EJB Entity class "" + ejbClass.getName() +
                                                    "" must implement javax.ejb.EntityBean : "" + beanName);
            }
        }

        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
            Tr.debug(tc, ""validateEjbClass : successful : "" +
                         ejbClass.getName());
    }",Validate the ejbClass.
"public Node<T> node(T content) {
    final Node<T> search = nodes.get(content);
    if (search != null)
      return search;
    final Node<T> n = new Node<>(content, this);
    nodes.put(content, n);
    return n;
  }",Get the node of the given content.
"@Override
    public Map<String, Object> count(String task) {
        MappingConfig config = rdbMapping.get(task);
        MappingConfig.DbMapping dbMapping = config.getDbMapping();
        String sql = ""SELECT COUNT(1) AS cnt FROM "" + SyncUtil.getDbTableName(dbMapping);
        Connection conn = null;
        Map<String, Object> res = new LinkedHashMap<>();
        try {
            conn = dataSource.getConnection();
            Util.sqlRS(conn, sql, rs -> {
                try {
                    if (rs.next()) {
                        Long rowCount = rs.getLong(""cnt"");
                        res.put(""count"", rowCount);
                    }
                } catch (SQLException e) {
                    logger.error(e.getMessage(), e);
                }
            });
        } catch (SQLException e) {
            logger.error(e.getMessage(), e);
        } finally {
            if (conn != null) {
                try {
                    conn.close();
                } catch (SQLException e) {
                    logger.error(e.getMessage(), e);
                }
            }
        }
        res.put(""targetTable"", SyncUtil.getDbTableName(dbMapping));

        return res;
    }",Count the number of records in a single table.
"public static List random(long minLen, long maxLen, Object... values) {
		long len = randomLong(minLen, maxLen);
		if (len > 0) {
			List ret = new ArrayList();
			for (int i = 0; i < len; i++) {
				ret.add(randomOne(values));
			}
			return ret;
		}
		return null;
	}",Returns a list of random elements from the specified range.
"private KieFileSystem createKieFileSystemWithKProject(String kbaseName, String ksessionName) {
        KieModuleModel kproj = config.getKieProject();
        KieFileSystem kfs = config.getKieServicesInstance().newKieFileSystem();
        kfs.writeKModuleXML(kproj.toXML());
        return kfs;
    }",Create a KieFileSystem with the KieProject.
"public GridGeometry2D getGridGeometry( CoordinateReferenceSystem crs ) {
        GridGeometry2D gridGeometry = CoverageUtilities.gridGeometryFromRegionParams(getRegionParams(), crs);
        return gridGeometry;
    }",Get the grid geometry from the region parameters
"private boolean updateSuggestionsSectionHeight(List<? extends SearchSuggestion>
                                                           newSearchSuggestions, boolean withAnim) {

        final int cardTopBottomShadowPadding = Util.dpToPx(CARD_VIEW_CORNERS_AND_TOP_BOTTOM_SHADOW_HEIGHT);
        final int cardRadiusSize = Util.dpToPx(CARD_VIEW_TOP_BOTTOM_SHADOW_HEIGHT);

        int visibleSuggestionHeight = calculateSuggestionItemsHeight(newSearchSuggestions,
                mSuggestionListContainer.getHeight());
        int diff = mSuggestionListContainer.getHeight() - visibleSuggestionHeight;
        int addedTranslationYForShadowOffsets = (diff <= cardTopBottomShadowPadding) ?
                -(cardTopBottomShadowPadding - diff) :
                diff < (mSuggestionListContainer.getHeight() - cardTopBottomShadowPadding) ? cardRadiusSize : 0;
        final float newTranslationY = -mSuggestionListContainer.getHeight() +
                visibleSuggestionHeight + addedTranslationYForShadowOffsets;

        //todo go over
        final float fullyInvisibleTranslationY = -mSuggestionListContainer.getHeight() + cardRadiusSize;

        ViewCompat.animate(mSuggestionListContainer).cancel();
        if (withAnim) {
            ViewCompat.animate(mSuggestionListContainer).
                    setInterpolator(SUGGEST_ITEM_ADD_ANIM_INTERPOLATOR).
                    setDuration(mSuggestionSectionAnimDuration).
                    translationY(newTranslationY)
                    .setUpdateListener(new ViewPropertyAnimatorUpdateListener() {
                        @Override
                        public void onAnimationUpdate(View view) {

                            if (mOnSuggestionsListHeightChanged != null) {
                                float newSuggestionsHeight = Math.abs(view.getTranslationY() - fullyInvisibleTranslationY);
                                mOnSuggestionsListHeightChanged.onSuggestionsListHeightChanged(newSuggestionsHeight);
                            }
                        }
                    })
                    .setListener(new ViewPropertyAnimatorListenerAdapter() {
                        @Override
                        public void onAnimationCancel(View view) {
                            mSuggestionListContainer.setTranslationY(newTranslationY);
                        }
                    }).start();
        } else {
            mSuggestionListContainer.setTranslationY(newTranslationY);
            if (mOnSuggestionsListHeightChanged != null) {
                float newSuggestionsHeight = Math.abs(mSuggestionListContainer.getTranslationY() - fullyInvisibleTranslationY);
                mOnSuggestionsListHeightChanged.onSuggestionsListHeightChanged(newSuggestionsHeight);
            }
        }

        return mSuggestionListContainer.getHeight() == visibleSuggestionHeight;
    }",Update the suggestions section height.
"public void releaseAllKeys ()
    {
        long now = System.currentTimeMillis();
        Iterator<KeyInfo> iter = _keys.elements();
        while (iter.hasNext()) {
            iter.next().release(now);
        }
    }",Release all the key information.
"public void addElement(Element element) {
        if (element == null)
            return;
        if (element instanceof Image) {
            Image img = (Image)element;
            PdfPTable t = new PdfPTable(1);
            float w = img.getWidthPercentage();
            if (w == 0) {
                t.setTotalWidth(img.getScaledWidth());
                t.setLockedWidth(true);
            }
            else
                t.setWidthPercentage(w);
            t.setSpacingAfter(img.getSpacingAfter());
            t.setSpacingBefore(img.getSpacingBefore());
            switch (img.getAlignment()) {
                case Image.LEFT:
                    t.setHorizontalAlignment(Element.ALIGN_LEFT);
                    break;
                case Image.RIGHT:
                    t.setHorizontalAlignment(Element.ALIGN_RIGHT);
                    break;
                default:
                    t.setHorizontalAlignment(Element.ALIGN_CENTER);
                    break;
            }
            PdfPCell c = new PdfPCell(img, true);
            c.setPadding(0);
            c.setBorder(img.getBorder());
            c.setBorderColor(img.getBorderColor());
            c.setBorderWidth(img.getBorderWidth());
            c.setBackgroundColor(img.getBackgroundColor());
            t.addCell(c);
            element = t;
        }
        if (element.type() == Element.CHUNK) {
        	element = new Paragraph((Chunk)element);
        }
        else if (element.type() == Element.PHRASE) {
        	element = new Paragraph((Phrase)element);
        }
        if (element instanceof SimpleTable) {
        	try {
				element = ((SimpleTable)element).createPdfPTable();
			} catch (DocumentException e) {
				throw new IllegalArgumentException(""Element not allowed."" + element.type(), e);
			}
        }
        else if (element.type() != Element.PARAGRAPH && element.type() != Element.LIST && element.type() != Element.PTABLE && element.type() != Element.YMARK)
            throw new IllegalArgumentException(""Element not allowed."" + element.type());
        if (!composite) {
            composite = true;
            compositeElements = new LinkedList();
            bidiLine = null;
            waitPhrase = null;
        }
        compositeElements.add(element);
    }",Add an element to the document.
"public synchronized void initTaskSchedulerIfNot() {

        if (scheduler == null) {
            scheduler = Executors
                    .newSingleThreadScheduledExecutor(DaemonThreadFactory
                            .getInstance());
            CapacityAwareTaskScheduler runner = new CapacityAwareTaskScheduler();
            scheduler.scheduleAtFixedRate(runner,
                    ParallecGlobalConfig.schedulerInitDelay,
                    ParallecGlobalConfig.schedulerCheckInterval,
                    TimeUnit.MILLISECONDS);
            logger.info(""initialized daemon task scheduler to evaluate waitQ tasks."");
            
        }
    }",Initialize the daemon task scheduler if it is not already initialized.
"final void setAttribute(final Attribute attribute, final Object object) {
    Validate.notNull(attribute);
    LOG.debug(""setting attribute: {} with value: {}"", attribute, object);
    Validate.isTrue(attribute.isValid(object), object + "" is not of valid subType for attribute: "" + attribute);
    servletContext.setAttribute(getAttributeName(attribute), object);
  }",Sets the value of an attribute.
"private Path getOrGenerateSchemaFile(Schema schema) throws IOException {

    Preconditions.checkNotNull(schema, ""Avro Schema should not be null"");

    String hashedSchema = Hashing.sha256().hashString(schema.toString(), StandardCharsets.UTF_8).toString();

    if (!this.schemaPaths.containsKey(hashedSchema)) {

      Path schemaFilePath = new Path(this.schemaDir, String.valueOf(System.currentTimeMillis() + "".avsc""));
      AvroUtils.writeSchemaToFile(schema, schemaFilePath, fs, true);

      this.schemaPaths.put(hashedSchema, schemaFilePath);
    }

    return this.schemaPaths.get(hashedSchema);
  }",Get or generate schema file path
"protected MultivaluedMap<String, String> getDefaultPerPageParam(boolean customAttributesEnabled) {

        GitLabApiForm form = new GitLabApiForm().withParam(PER_PAGE_PARAM, getDefaultPerPage());
        if (customAttributesEnabled)
            return (form.withParam(""with_custom_attributes"", true).asMap());

        return (form.asMap());
    }",Get the default per_page param.
"Map<WorkflowInstance, RunState> readActiveStates() throws IOException {
    var timeout = CompletableFuture.runAsync(() -> {}, delayedExecutor(30, SECONDS));

    var instances = listActiveInstances0(timeout);

    // Strongly consistently read values for the instances in parallel
    var states = gatherIO(Lists.partition(List.copyOf(instances), MAX_NUMBER_OF_ENTITIES_IN_ONE_BATCH_READ).stream()
        .map(batch -> asyncIO(() -> readRunStateBatch(batch)))
        .collect(toList()), timeout)
        .stream()
        .flatMap(Collection::stream)
        .collect(toMap(RunState::workflowInstance, Function.identity()));

    timeout.cancel(true);

    return states;
  }",Read the active states.
"public static <T, E extends Throwable> @NonNull Consumer<T> unwrappingRethrowConsumer(final @NonNull ThrowingConsumer<T, E> consumer) {
    return input -> {
      try {
        consumer.throwingAccept(input);
      } catch(final Throwable t) {
        throw rethrow(unwrap(t));
      }
    };
  }",Unwraps a ThrowingConsumer into a Consumer that throws an exception.
"public static JsonSchemaValidator matchesJsonSchemaInClasspath(String pathToSchemaInClasspath) {
        return matchesJsonSchema(Thread.currentThread().getContextClassLoader().getResource(pathToSchemaInClasspath));
    }",Checks if the given path to schema in the classpath matches the JSON schema in the current thread s context class loader.
"private static int getPairIndex(int ch)
    {
        int probe = pairedCharPower;
        int index = 0;

        if (ch >= pairedChars[pairedCharExtra]) {
            index = pairedCharExtra;
        }

        while (probe > (1 << 0)) {
            probe >>= 1;

            if (ch >= pairedChars[index + probe]) {
                index += probe;
            }
        }

        if (pairedChars[index] != ch) {
            index = -1;
        }

        return index;
    }",Gets the index of the paired character.
"@Override public <T> T getProperty(final String key) {
    if (key == null)
      return null;

    final OrientBaseGraph graph = getGraph();
    if (key.equals(""_class""))
      return (T) ODocumentInternal.getImmutableSchemaClass(getRecord()).getName();
    else if (key.equals(""_version""))
      return (T) new Integer(getRecord().getVersion());
    else if (key.equals(""_rid""))
      return (T) rawElement.getIdentity().toString();

    final ODocument record = getRecord();
    if (record == null)
      // NO RECORD
      return null;

    final Object fieldValue = record.field(key);
    if (graph != null && fieldValue instanceof OIdentifiable && !(((OIdentifiable) fieldValue).getRecord() instanceof OBlob)) {
      ODocument fieldRecord = ((OIdentifiable) fieldValue).getRecord();
      if (fieldRecord != null) {
        final OClass schemaClass = fieldRecord.getSchemaClass();
        if (schemaClass != null && (schemaClass.isVertexType() || schemaClass.isEdgeType())) {
          // CONVERT IT TO VERTEX/EDGE
          return (T) graph.getElement(fieldValue);
        }
      }
      return (T) fieldValue;
    } else if (!(fieldValue instanceof Map) && OMultiValue.isMultiValue(fieldValue) && OMultiValue
        .getFirstValue(fieldValue) instanceof OIdentifiable) {
      final OIdentifiable firstValue = (OIdentifiable) OMultiValue.getFirstValue(fieldValue);

      if (firstValue instanceof ODocument) {
        final ODocument document = (ODocument) firstValue;

        /// clusterId -2 Is considered a projection so does not have a class but is a not embedded record
        if (document.getIdentity().getClusterId() != -2 && (document.isEmbedded()
            || ODocumentInternal.getImmutableSchemaClass(document) == null))
          return (T) fieldValue;
      }

      if (graph != null)
        // CONVERT IT TO ITERABLE<VERTEX/EDGE>
        return (T) new OrientElementIterable<OrientElement>(graph, OMultiValue.getMultiValueIterable(fieldValue));
    }

    return (T) fieldValue;
  }",Returns the value of the property with the specified key.
"public <T extends SimonConsolePlugin> List<T> getPluginsByType(Class<T> pluginType) {
		List<T> specPlugins = new ArrayList<>();
		for (SimonConsolePlugin plugin : plugins) {
			if (pluginType.isInstance(plugin)) {
				specPlugins.add(pluginType.cast(plugin));
			}
		}
		return Collections.unmodifiableList(specPlugins);
	}",Returns a list of plugins of the specified type.
"public static String getRealPath(final WebApplication application, final String path)
	{
		final String realPath = application.getServletContext().getRealPath(path);
		if ((null != realPath) && !realPath.isEmpty())
		{
			return realPath;
		}
		return """";
	}",Gets the real path of the given path.
"public static boolean encryptionIsReversible(ECKey originalKey, ECKey encryptedKey, KeyCrypter keyCrypter, KeyParameter aesKey) {
        try {
            ECKey rebornUnencryptedKey = encryptedKey.decrypt(keyCrypter, aesKey);
            byte[] originalPrivateKeyBytes = originalKey.getPrivKeyBytes();
            byte[] rebornKeyBytes = rebornUnencryptedKey.getPrivKeyBytes();
            if (!Arrays.equals(originalPrivateKeyBytes, rebornKeyBytes)) {
                log.error(""The check that encryption could be reversed failed for {}"", originalKey);
                return false;
            }
            return true;
        } catch (KeyCrypterException kce) {
            log.error(kce.getMessage());
            return false;
        }
    }",Check if the encryption is reversed.
"private void setChildDrawableAtIndex(int index, @Nullable Drawable drawable) {
    if (drawable == null) {
      mFadeDrawable.setDrawable(index, null);
      return;
    }
    drawable = WrappingUtils.maybeApplyLeafRounding(drawable, mRoundingParams, mResources);
    getParentDrawableAtIndex(index).setDrawable(drawable);
  }",Set the child drawable at the given index.
"@EventHandler
    public void handle(ChargingStationStatusNotificationReceivedEvent event) {
        ChargingStation chargingStation = repository.findOne(event.getChargingStationId().getId());

        if (chargingStation != null) {
            chargingStation.setStatus(event.getStatusNotification().getStatus());
            repository.createOrUpdate(chargingStation);
        }
    }",Handle a ChargingStationStatusNotificationReceivedEvent.
"public Properties getUnusedProperties()
  {
    Properties p = new Properties();
    for(Map.Entry<Object, Object> entry : properties.entrySet()) {
      if(!usedProperties.contains(entry.getKey())) {
        p.put(entry.getKey(), entry.getValue());
      }
    }
    return p;
  }",Gets the properties that are not used by the application.
"public void addIndex(ValidationData data) {
        for (ValidationDataIndex idx : this.idxs) {
            ValidationIndexUtil.addIndexData(data, idx);
        }
    }",Add the index data.
"public void putInFlightMessage(int streamId, OutboundMsgHolder inFlightMessage) {
        if (LOG.isDebugEnabled()) {
            LOG.debug(""In flight message added to channel: {} with stream id: {}  "", this, streamId);
        }
        inFlightMessages.put(streamId, inFlightMessage);
    }",Add an in - flight message to the cache.
"public Blob updateBlob(String bucketName, String blobName) {
    // [START updateBlob]
    Map<String, String> newMetadata = new HashMap<>();
    newMetadata.put(""key"", ""value"");
    storage.update(BlobInfo.newBuilder(bucketName, blobName).setMetadata(null).build());
    Blob blob =
        storage.update(BlobInfo.newBuilder(bucketName, blobName).setMetadata(newMetadata).build());
    // [END updateBlob]
    return blob;
  }",Update a CID    blob.
"@Deprecated
    public static <T extends Annotation> Class<T> classOf(Annotation annotation) {
        return (Class<T>) annotation.annotationType();
    }",Returns the type of the given annotation.
"public static <T> Iterator<T> toUnique(Iterator<T> self) {
        return new UniqueIterator<T>(self, null);
    }",To unique iterator.
"public void initializeSession()
    {
        ApplicationSessionInitializer asi = getApplicationSessionInitializer();
        if (asi != null)
        {
            asi.initializeSession();
            Map<String, Object> sessionAttributes = asi.getSessionAttributes();
            if (sessionAttributes != null)
            {
                    setSessionAttributes(sessionAttributes);
            }
            propertyChangeSupport.firePropertyChange(SESSION_ATTRIBUTES, null, sessionAttributes);
        }
    }",Initialize session.
"static String removeSubstring(final String pSource, final char pBeginBoundaryChar, final char pEndBoundaryChar, final int pOffset) {
        StringBuilder filteredString = new StringBuilder();
        boolean insideDemarcatedArea = false;
        char[] charArray = pSource.toCharArray();

        for (char c : charArray) {
            if (!insideDemarcatedArea) {
                if (c == pBeginBoundaryChar) {
                    insideDemarcatedArea = true;
                }
                else {
                    filteredString.append(c);
                }
            }
            else {
                if (c == pEndBoundaryChar) {
                    insideDemarcatedArea = false;
                }
            }
        }
        return filteredString.toString();
    }",Remove substring from a string.
"public ScreenComponent setupDefaultView(ScreenLoc itsLocation, ComponentParent targetScreen, Convert converter, int iDisplayFieldDesc, Map<String, Object> properties)
    {
        ScreenComponent screenField = super.setupDefaultView(itsLocation, targetScreen, converter, iDisplayFieldDesc, properties);
        properties = new HashMap<String,Object>();
        properties.put(ScreenModel.FIELD, this);
        properties.put(ScreenModel.COMMAND, ScreenModel.FAX);
        properties.put(ScreenModel.IMAGE, ScreenModel.FAX);
        ScreenComponent pSScreenField = createScreenComponent(ScreenModel.CANNED_BOX, targetScreen.getNextLocation(ScreenConstants.RIGHT_OF_LAST, ScreenConstants.DONT_SET_ANCHOR), targetScreen, converter, iDisplayFieldDesc, properties);
        pSScreenField.setRequestFocusEnabled(false);
        return screenField;
    }",Set up the default screen control.
"private List<DimValue> getExcluded()
    {
        final List<DimValue> ret = new ArrayList<>();
        for (final DimTreeNode node : getDimensionProvider().getRootList()) {
            ret.addAll(node.getExcluded());
        }
        return ret;
    }",Gets the excluded nodes.
"protected ISynchronizationPoint<? extends Exception> specifyMapValue(
		SerializationContext context, TypeDefinition type, List<SerializationRule> rules
	) {
		TypeDefinition elementType = new TypeDefinition(MapEntry.class, type.getParameters());
		TypeDefinition colType = new TypeDefinition(ArrayList.class, elementType);
		CollectionContext ctx = new CollectionContext(context, null, colType, elementType);
		return specifyCollectionValue(ctx, rules);
	}",Override this method to specify a map value.
"private ArrayList<String> generateDefaultEjbBindings(String interfaceName)
                    throws NameAlreadyBoundException // d457053.1
    {
        ArrayList<String> defaultJNDINames = new ArrayList<String>(2);
        StringBuilder sb = new StringBuilder(256);

        if (ivDefaultJNDIPrefix == null)
        {
            // Add the context specific (local/remote) default binding prefix first.
            if (ivContextPrefix != null)
                sb.append(ivContextPrefix);

            // Then add the component-id or j2eename
            if (ivHomeRecord.bmd.ivComponent_Id != null) { // d445912
                sb.append(ivHomeRecord.bmd.ivComponent_Id).append(""#""); // d445912
            } else {
                sb.append(ivHomeRecord.j2eeName.getApplication()).append(""/"");
                sb.append(ivHomeRecord.j2eeName.getModule()).append(""/"");
                sb.append(ivHomeRecord.j2eeName.getComponent()).append(""#""); // d443702
            }

            // cache away the string we just built up so we can resuse it again the next time
            ivDefaultJNDIPrefix = sb.toString();
        }
        else
        {
            // Use the previously cached prefix
            sb.append(ivDefaultJNDIPrefix);
        }

        sb.append(interfaceName); // d443702

        String longBindingName = sb.toString();

        // Add to the list of jndiNames to be returned
        defaultJNDINames.add(longBindingName);
        addToServerContextBindingMap(interfaceName, longBindingName);
        ivEjbContextBindingMap.put(interfaceName, longBindingName);

        // Add the short default (convienence) bindings if not explicitly disabled.
        if (ivHomeRecord.shortDefaultBindingsEnabled())
        {
            // Determine if this interface (short binding) has already been bound
            // by another EJB.
            BindingData bdata = ivServerContextBindingMap.get(interfaceName);

            // For both cases, add to the ShortDefaultName map so that it can
            // be unbound during application stop, and to the server wide
            // context map (so other ambiguous references may be found).
            addToServerContextBindingMap(interfaceName);
            ivEjbContextShortDefaultJndiNames.add(interfaceName);

            if (bdata == null)
            {
                // Has not been bound yet, so just bind this EJB.
                defaultJNDINames.add(interfaceName);
            }
            else if (bdata.ivExplicitBean == null) // d457053.1
            {
                // Has already been bound, so add an AmbiguousEJBReference to
                // the ambiguous map, which will be bound later.
                addAmbiguousShortDefaultBindingName(interfaceName);
            }
            else
            {
                // There is an explicit binding, so just ignore this
                // short-form default (convenience) binding.               d457053.1
                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
                    Tr.debug(tc, ""generateDefaultEjbBindings: "" + interfaceName +
                                 "" short-form default overridden : "" + bdata.ivExplicitBean);
            }
        }

        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
            Tr.debug(tc, ""generateDefaultEjbBindings: "" + defaultJNDINames);

        return defaultJNDINames;
    }",Generate the default bindings for an EJB.
"public void addImage( BufferedImage image , String name) {
		addImage(image, name, ScaleOptions.DOWN);
	}",Add an image to the image manager.
"public JSON with(JSONWriter w)
    {
        if (w == _writer) {
            return this;
        }
        return _with( _features, _streamFactory, _treeCodec,
                _reader, w, _prettyPrinter);
    }",Returns a copy of this object with the specified writer.
"public void initRound(Log other) {
        this.noticeWriter = other.noticeWriter;
        this.warnWriter = other.warnWriter;
        this.errWriter = other.errWriter;
        this.sourceMap = other.sourceMap;
        this.recorded = other.recorded;
        this.nerrors = other.nerrors;
        this.nwarnings = other.nwarnings;
    }",Initialize this log with the contents of the other log.
"public String resolveExpression(String expression) throws Exception {
        if (expression == null || expression.length() == 0) {
            return expression;
        }
        final ModelNode request = createRequest(""resolve-expression"", Address.root());
        request.get(""expression"").set(expression);
        final ModelNode response = execute(request);
        if (!isSuccess(response)) {
            throw new FailureException(response);
        }
        return getResults(response).asString();
    }",Resolves the given expression.
"public static Characters allBut(char... chars) {
        return chars.length == 0 ? Characters.ALL : new Characters(true, chars.clone());
    }",Returns all but chars.
"private static double[] getRandomWalk(int numPoints) {

    double[] y = new double[numPoints];
    y[0] = 0;
    for (int i = 1; i < y.length; i++) {
      y[i] = y[i - 1] + Math.random() - .5;
    }
    return y;
  }",Get a random walk of the data.
"private void signMultisigInput(Transaction tx, Transaction.SigHash hashType,
                                   boolean anyoneCanPay, @Nullable KeyParameter userKey) {
        TransactionSignature signature = tx.calculateSignature(0, serverKey, userKey, getContractScript(), hashType, anyoneCanPay);
        byte[] mySig = signature.encodeToBitcoin();
        Script scriptSig = ScriptBuilder.createMultiSigInputScriptBytes(ImmutableList.of(bestValueSignature, mySig));
        tx.getInput(0).setScriptSig(scriptSig);
    }",Sign a multisig input.
"public static Matrix random(int rows, int columns, Random random) {
        return DenseMatrix.random(rows, columns, random);
    }",Create a random matrix of size rows
"public Link createLink(String name, String url, boolean onMenu) {
        return getInstance().create().link(name, this, url, onMenu);
    }",Create a new link.
"protected void updateApiVersion(KubernetesResourceList list) {
    String version = getApiVersion();
    if (list != null && version != null && version.length() > 0) {
      List items = list.getItems();
      if (items != null) {
        for (Object item : items) {
          if (item instanceof HasMetadata) {
            updateApiVersion((HasMetadata) item);
          }
        }
      }
    }
  }",Update the API version of the resource list.
"CmsEditorContext getEditorContext() {

        CmsEditorContext result = new CmsEditorContext();
        result.getPublishParameters().put(
            CmsPublishOptions.PARAM_CONTAINERPAGE,
            """" + CmsCoreProvider.get().getStructureId());
        result.getPublishParameters().put(
            CmsPublishOptions.PARAM_DETAIL,
            """" + CmsContainerpageController.get().getData().getDetailId());
        result.getPublishParameters().put(CmsPublishOptions.PARAM_START_WITH_CURRENT_PAGE, """");
        return result;
    }",Gets the editor context.
"public static void writeObject(final InetAddress inetAddress, final int port,
		final Object objectToSend) throws IOException
	{
		Socket socketToClient = null;
		ObjectOutputStream oos = null;

		try
		{
			socketToClient = new Socket(inetAddress, port);
			oos = new ObjectOutputStream(
				new BufferedOutputStream(socketToClient.getOutputStream()));
			oos.writeObject(objectToSend);
			oos.close();
			socketToClient.close();
		}
		catch (final IOException e)
		{
			LOGGER.error(""IOException occured by trying to write the object."", e);
			throw e;
		}
		finally
		{
			try
			{
				if (oos != null)
				{
					oos.close();
				}
				close(socketToClient);
			}
			catch (final IOException e)
			{
				LOGGER.error(""IOException occured by trying to close the socket."", e);
				throw e;
			}
		}
	}",Write the object to the specified InetAddress and port using the ObjectOutputStream interface.
"public static cspolicy_cspolicylabel_binding[] get_filtered(nitro_service service, String policyname, String filter) throws Exception{
		cspolicy_cspolicylabel_binding obj = new cspolicy_cspolicylabel_binding();
		obj.set_policyname(policyname);
		options option = new options();
		option.set_filter(filter);
		cspolicy_cspolicylabel_binding[] response = (cspolicy_cspolicylabel_binding[]) obj.getfiltered(service, option);
		return response;
	}",Use this API to fetch filtered set of cspolicy_cspolicylabel_binding resources of given name.
"private boolean minimizeCost(FunctionState functionState) {
    if (!inliningLowersCost(functionState)) {
      // Try again without Block inlining references
      if (functionState.hasBlockInliningReferences()) {
        functionState.setRemove(false);
        functionState.removeBlockInliningReferences();
        if (!functionState.hasReferences() || !inliningLowersCost(functionState)) {
          return false;
        }
      } else {
        return false;
      }
    }
    return true;
  }",Minimize the cost of a function.
"public synchronized ICounter createCounter (final CounterConfig config)
  {
    ValueEnforcer.notNull (config, ""Config"");
    ValueEnforcer.isFalse (m_bShutdown, ""counter manager is shutdown"");

    final ICounter aCounter = config.createCounter ();
    if (aCounter instanceof SampledCounter)
    {
      final SampledCounter sampledCounter = (SampledCounter) aCounter;
      m_aTimer.schedule (sampledCounter.getTimerTask (),
                         sampledCounter.getIntervalMillis (),
                         sampledCounter.getIntervalMillis ());
    }
    m_aCounters.add (aCounter);
    return aCounter;
  }",Create a new counter.
"@SuppressWarnings(""unchecked"")
    public static Specification toSpecification(Vector<Object> xmlRpcParameters)
    {
        Specification specification = null;
        if(!xmlRpcParameters.isEmpty())
        {
            specification = Specification.newInstance((String)xmlRpcParameters.get(DOCUMENT_NAME_IDX));
            specification.setRepository(toRepository((Vector<Object>)xmlRpcParameters.get(DOCUMENT_REPOSITORY_IDX)));
            specification.setTargetedSystemUnderTests(toSystemUnderTestList((Vector<Object>)xmlRpcParameters.get(SPECIFICATION_SUTS_IDX)));
            if (xmlRpcParameters.size() >= 4) {
                specification.setDialectClass((String) xmlRpcParameters.get(SPECIFICATION_DIALECT_IDX));
            }
        }
        
        return specification;
    }",Converts the vector of XML - RPC parameters to a Specification object.
"public int getOrAssignOrdinal(ByteDataBuffer serializedRepresentation, int preferredOrdinal) {
        int hash = HashCodes.hashCode(serializedRepresentation);

        int ordinal = get(serializedRepresentation, hash);
        return ordinal != -1 ? ordinal : assignOrdinal(serializedRepresentation, hash, preferredOrdinal);
    }",Gets or assigns the ordinal of the class loader from the given serialized representation.
"public boolean isIPv4CompatibleAddress() {
        if ((ipaddress[0] == 0x00) && (ipaddress[1] == 0x00) &&
            (ipaddress[2] == 0x00) && (ipaddress[3] == 0x00) &&
            (ipaddress[4] == 0x00) && (ipaddress[5] == 0x00) &&
            (ipaddress[6] == 0x00) && (ipaddress[7] == 0x00) &&
            (ipaddress[8] == 0x00) && (ipaddress[9] == 0x00) &&
            (ipaddress[10] == 0x00) && (ipaddress[11] == 0x00))  {
            return true;
        }
        return false;
    }",Is the address of an IPv4 compatible address?
"public List<CmsAccessControlEntry> getAccessControlEntries(String resourceName, boolean getInherited)
    throws CmsException {

        CmsResource res = readResource(resourceName, CmsResourceFilter.ALL);
        return m_securityManager.getAccessControlEntries(m_context, res, getInherited);
    }",Returns a list of all access control entries for the given resource.
"public MetadataBuilder setTags(List<String> tags)
    {
        if (tags == null)
            this.tags = new HashSet<>();
        else
            this.tags = Collections.unmodifiableSet(new HashSet<>(tags));

        return this;
    }",Sets the tags.
"public static int[] getDimensions( JSONArray jsonArray ) {
      // short circuit for empty arrays
      if( jsonArray == null || jsonArray.isEmpty() ){
         return new int[] { 0 };
      }

      List dims = new ArrayList();
      processArrayDimensions( jsonArray, dims, 0 );
      int[] dimensions = new int[dims.size()];
      int j = 0;
      for( Iterator i = dims.iterator(); i.hasNext(); ){
         dimensions[j++] = ((Integer) i.next()).intValue();
      }
      return dimensions;
   }",Get the dimensions of a JSONArray.
"public static Authenticated authenticate(AzureTokenCredentials credentials) {
        return new AuthenticatedImpl(new RestClient.Builder()
                .withBaseUrl(credentials.environment(), AzureEnvironment.Endpoint.RESOURCE_MANAGER)
                .withCredentials(credentials)
                .withSerializerAdapter(new AzureJacksonAdapter())
                .withResponseBuilderFactory(new AzureResponseBuilder.Factory())
                .build());
    }",Creates an instance of Authenticated using the given credentials.
"@Override
    public void setHeader(String name, String value) {
        touchHeaders().set(name, value);
    }",Sets a header value.
"@Override
    public void endElement(String uri, String localName, String qName)
            throws SAXException {
        // first, deal with the situation when we are processing a block of inline XML
        if (m_inXMLMetadata) {
            if (uri.equals(METS.uri) && localName.equals(""xmlData"")
                    && m_xmlDataLevel == 0) {
                // finished all xml metadata for this datastream
                if (m_dsId.equals(""FEDORA-AUDITTRAIL"")
                        || m_dsId.equals(""AUDIT"")) {
                    // we've been looking at an audit trail... set audit record
                    AuditRecord a = new AuditRecord();
                    // In METS each audit record is in its own <digiprovMD>
                    // element within an <amdSec>.  So, pick up the XML ID
                    // of the <digiprovMD> element for the audit record id.
                    // This amdSec is treated like a datastream, and each
                    // digiprovMD is a version, so id was parsed into dsVersId.
                    a.id = m_auditId; //m_dsVersId;
                    a.processType = m_auditProcessType;
                    a.action = m_auditAction;
                    a.componentID = m_auditComponentID;
                    a.responsibility = m_auditResponsibility;
                    a.date = DateUtility.convertStringToDate(m_auditDate);
                    a.justification = m_auditJustification;
                    m_obj.getAuditRecords().add(a);
                    m_inXMLMetadata = false; // other stuff is re-initted upon
                    // startElement for next xml metadata
                    // element
                } else {
                    // Create the right kind of datastream and add to the object
                    DatastreamXMLMetadata ds = new DatastreamXMLMetadata();
                    instantiateXMLDatastream(ds);
                    m_inXMLMetadata = false;
                    m_localPrefixMap.clear();
                }
            } else {
                // finished an element within inline xml metadata
                m_dsXMLBuffer.append(""</"" + qName + "">"");
                // make sure we know when to pay attention to METS again
                if (uri.equals(METS.uri) && localName.equals(""xmlData"")) {
                    m_xmlDataLevel--;
                }
                if (m_dsId.equals(""FEDORA-AUDITTRAIL"")
                        || m_dsId.equals(""AUDIT"")) {
                    if (localName.equals(""action"")) {
                        m_auditAction = m_auditBuffer.toString();
                        m_auditBuffer = null;
                    } else if (localName.equals(""componentID"")) {
                        m_auditComponentID = m_auditBuffer.toString();
                        m_auditBuffer = null;
                    } else if (localName.equals(""responsibility"")) {
                        m_auditResponsibility = m_auditBuffer.toString();
                        m_auditBuffer = null;
                    } else if (localName.equals(""date"")) {
                        m_auditDate = m_auditBuffer.toString();
                        m_auditBuffer = null;
                    } else if (localName.equals(""justification"")) {
                        m_auditJustification = m_auditBuffer.toString();
                        m_auditBuffer = null;
                    }
                }
            }
            // ALL OTHER ELEMENT CASES: we are NOT processing a block of inline XML metadata
        } else {
            if (m_readingBinaryContent) {
                // In the version of METS Fedora uses, FContent assumes base64-encoded content
                if (uri.equals(METS.uri) && localName.equals(""FContent"")) {
                    if (m_binaryContentTempFile != null) {
                        try {
                            FileOutputStream os =
                                    new FileOutputStream(m_binaryContentTempFile);
                            // remove all spaces and newlines, this might not be necessary.
                            String elementStr =
                                    m_elementContent.toString()
                                            .replaceAll(""\\s"", """");
                            byte elementBytes[] = Base64.decode(elementStr);
                            os.write(elementBytes);
                            os.close();
                            m_dsLocationType = Datastream.DS_LOCATION_TYPE_INTERNAL;
                            m_dsLocation =
                                DatastreamManagedContent.TEMP_SCHEME
                                            + m_binaryContentTempFile
                                                    .getAbsolutePath();
                            instantiateDatastream(new DatastreamManagedContent());
                        } catch (FileNotFoundException fnfe) {
                            throw new SAXException(new StreamIOException(""Unable to open temporary file created for binary content""));
                        } catch (IOException fnfe) {
                            throw new SAXException(new StreamIOException(""Error writing to temporary file created for binary content""));
                        }
                    }
                }
                m_binaryContentTempFile = null;
                m_readingBinaryContent = false;
                m_elementContent = null;
                // all other cases...
            } else {
                if (m_readingContent) {
                    // elements for which we were reading regular content
                    if (uri.equals(METS.uri) && localName.equals(""name"")
                            && m_agentRole.equals(""IPOWNER"")) {
                        m_obj.setOwnerId(m_elementContent.toString());
                    } else if (uri.equals(METS.uri)
                            && localName.equals(""agent"")) {
                        m_agentRole = null;
                    }
                    m_readingContent = false;
                    m_elementContent = null;
                } else {
                    // no other processing requirements at this time
                }
            }
        }
    }",This method is called when an end element of an XML tag is encountered.
"private CellFormatResult createBlankCellResult() {
        CellFormatResult result = new CellFormatResult();
        result.setCellType(FormatCellType.Blank);
        result.setText("""");
        return result;
    }",Creates a blank cell result.
"@Override public ImmutableSet<Entry<K, V>> entries() {
    ImmutableSet<Entry<K, V>> result = entries;
    return (result == null)
        ? (entries = new EntrySet<K, V>(this))
        : result;
  }",Returns an immutable set of all the entries in this set.
"@SuppressWarnings(""unchecked"")
	public static ConnectionObserver childConnectionObserver(ServerBootstrap b) {
		Objects.requireNonNull(b, ""bootstrap"");
		ConnectionObserver obs = (ConnectionObserver) b.config()
		                                               .childOptions()
		                                               .get(OBSERVER_OPTION);
		if (obs == null) {
			return ConnectionObserver.emptyListener(); //will not be triggered in
		}
		b.childOption(OBSERVER_OPTION, null);
		return obs;
	}",Returns a connection observer for the specified server bootstrap.
"public static float nextFloat(final float startInclusive, final float endInclusive) {
        Validate.isTrue(endInclusive >= startInclusive,
                ""Start value must be smaller or equal to end value."");
        Validate.isTrue(startInclusive >= 0, ""Both range values must be non-negative."");

        if (startInclusive == endInclusive) {
            return startInclusive;
        }

        return startInclusive + ((endInclusive - startInclusive) * RANDOM.nextFloat());
    }",Gets the next float value.
"private void addRelevantProjectDependenciesToClasspath( List<Path> path )
        throws MojoExecutionException
    {
        if ( this.includeProjectDependencies )
        {
            getLog().debug( ""Project Dependencies will be included."" );

            List<Artifact> artifacts = new ArrayList<>();
            List<Path> theClasspathFiles = new ArrayList<>();

            collectProjectArtifactsAndClasspath( artifacts, theClasspathFiles );

            for ( Path classpathFile : theClasspathFiles )
            {
                getLog().debug( ""Adding to classpath : "" + classpathFile );
                path.add( classpathFile );
            }

            for ( Artifact classPathElement : artifacts )
            {
                getLog().debug( ""Adding project dependency artifact: "" + classPathElement.getArtifactId()
                    + "" to classpath"" );
                path.add( classPathElement.getFile().toPath() );
            }
        }
        else
        {
            getLog().debug( ""Project Dependencies will be excluded."" );
        }

    }",Add the relevant project dependencies to the classpath.
"public <T> void register(ObservableList<T> observable, ListChangeListener<? super T> listener) {
		if (!listChangeListeners.containsKey(observable)) {
			this.listChangeListeners.put(observable, Collections.newSetFromMap(new WeakHashMap<>()));
		}
		
		Set<ListChangeListener> observers = this.listChangeListeners.get(observable);
		observers.add(listener);
		observable.addListener(listener);
	}",Registers a list change listener for the specified observable list.
"public void setReservedInstances(java.util.Collection<ReservedInstances> reservedInstances) {
        if (reservedInstances == null) {
            this.reservedInstances = null;
            return;
        }

        this.reservedInstances = new com.amazonaws.internal.SdkInternalList<ReservedInstances>(reservedInstances);
    }",Sets the value reservedInstances property.
"public void close() {
        checkOpen();

        open = false;

        for (Object arg : arguments.values()) {
            if (arg instanceof File) {
                File file = (File) arg;
                if (JournalHelper.isTempFile(file)) {
                    if (file.exists()) {
                        file.delete();
                    }
                }
            }
        }
    }",Close the log file.
"public void clearAllCaches() {
        logger.warn(""beginning request to clear all caches"");
        for (final String cacheName : this.cacheManager.getCacheNames()) {
            clearCache(cacheName);
        }
        logger.warn(""completed request to clear all caches"");
    }",Clear all caches.
"public Type getCompatibleType(Type other) {
        if (other == null) {
            return null;
        }

        if (equals(other)) {
            if (this == NULL_TYPE) {
                return other;
            }
            else {
                return this;
            }
        }

        Class<?> classA = mObjectClass;
        Class<?> classB = other.mObjectClass;

        Type compat;

        if (classA == Void.class) {
            if (classB == Void.class) {
                compat = this;
            }
            else {
                return null;
            }
        }
        else if (classB == Void.class) {
            return null;
        }
        else if (other == NULL_TYPE) {
            compat = this.toNullable();
        }
        else if (this == NULL_TYPE) {
            compat = other.toNullable();
        }
        else if (Number.class.isAssignableFrom(classA) &&
            Number.class.isAssignableFrom(classB)) {

            Class<?> clazz = compatibleNumber(classA, classB);
            if (isPrimitive() && other.isPrimitive()) {
                compat = new Type(clazz, convertToPrimitive(clazz));
            }
            else {
                compat = new Type(clazz);
            }
        }
        else {
            // TODO: ensure generics are matched
            // ie: List<Number> and List<Integer> = List<Number>
            compat = new Type(findCommonBaseClass(classA, classB));
        }

        if (isNonNull() && other.isNonNull()) {
            compat = compat.toNonNull();
        }

        return compat;
    }",Get the compatible type of this type with the given other type.
"public static void open(Replicator replicator) {
        try {
            Objects.requireNonNull(replicator).open();
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }",Opens the database.
"public static boolean isValidName(String name) {
        return name != null &&
               name.length() > 1 &&
               name.charAt(0) == CommonDefs.ALIAS_FIRST_CHAR &&
               Utils.allAlphaNumUnderscore(name.substring(1));
    }","Checks if the given name is a valid name for a
 class."
"public String getDefaultPrimaryTypeName()
   {
      String result = null;
      if (nodeDefinitionData.getDefaultPrimaryType() != null)
      {
         try
         {
            result = locationFactory.createJCRName(nodeDefinitionData.getDefaultPrimaryType()).getAsString();
         }
         catch (RepositoryException e)
         {
            LOG.error(e.getLocalizedMessage(), e);
         }
      }
      return result;
   }",Get the default primary type name.
"public boolean isRefinedPartitioningOver(
            Partitioning right,
            Metadata metadata,
            Session session)
    {
        if (!handle.equals(right.handle) && !metadata.isRefinedPartitioningOver(session, handle, right.handle)) {
            return false;
        }

        return arguments.equals(right.arguments);
    }",Check if the two segments are fined partitioning over.
"public LocalTime minusMinutes(int minutes) {
        if (minutes == 0) {
            return this;
        }
        long instant = getChronology().minutes().subtract(getLocalMillis(), minutes);
        return withLocalMillis(instant);
    }",Subtracts the specified number of minutes from this time instant.
"final public SwitchExpressionBuilder<T> switchOn() {
    return new SwitchExpressionBuilder<T>(new ExpressionHandler<SwitchBuilder<T>>() {
      public SwitchBuilder<T> handleExpression(final Expression e) {
        return new SwitchBuilder<T>(e, new SwitchStatementsHandler<T>() {
          public T handleStatement(SwitchStatement switchStatement) {
            return statementHandler().handleStatement(switchStatement);
          }
        }, builder);
      }
    });
  }",Switch on.
"public static final long parseDateTimeString(final String datetime, 
      final String tz) {
    if (datetime == null || datetime.isEmpty())
      return -1;

    if (datetime.matches(""^[0-9]+ms$"")) {
      return Tags.parseLong(datetime.replaceFirst(""^([0-9]+)(ms)$"", ""$1""));
    }

    if (datetime.toLowerCase().equals(""now"")) {
      return System.currentTimeMillis();
    }

    if (datetime.toLowerCase().endsWith(""-ago"")) {
      long interval = DateTime.parseDuration(
        datetime.substring(0, datetime.length() - 4));
      return System.currentTimeMillis() - interval;
    }
    
    if (datetime.contains(""/"") || datetime.contains("":"")) {
      try {
        SimpleDateFormat fmt = null;
        switch (datetime.length()) {
          // these were pulled from cliQuery but don't work as intended since 
          // they assume a date of 1970/01/01. Can be fixed but may not be worth
          // it
          // case 5:
          //   fmt = new SimpleDateFormat(""HH:mm"");
          //   break;
          // case 8:
          //   fmt = new SimpleDateFormat(""HH:mm:ss"");
          //   break;
          case 10:
            fmt = new SimpleDateFormat(""yyyy/MM/dd"");
            break;
          case 16:
            if (datetime.contains(""-""))
              fmt = new SimpleDateFormat(""yyyy/MM/dd-HH:mm"");
            else
              fmt = new SimpleDateFormat(""yyyy/MM/dd HH:mm"");
            break;
          case 19:
            if (datetime.contains(""-""))
              fmt = new SimpleDateFormat(""yyyy/MM/dd-HH:mm:ss"");
            else
              fmt = new SimpleDateFormat(""yyyy/MM/dd HH:mm:ss"");
            break;
          default:
            // todo - deal with internationalization, other time formats
            throw new IllegalArgumentException(""Invalid absolute date: "" 
                + datetime);
        }
        if (tz != null && !tz.isEmpty())
          setTimeZone(fmt, tz);
        return fmt.parse(datetime).getTime();
      } catch (ParseException e) {
        throw new IllegalArgumentException(""Invalid date: "" + datetime  
            + "". "" + e.getMessage());
      }
    } else {
      try {
        long time;
        final boolean contains_dot = datetime.contains(""."");
        // [0-9]{10} ten digits
        // \\. a dot
        // [0-9]{1,3} one to three digits
        final boolean valid_dotted_ms = 
            datetime.matches(""^[0-9]{10}\\.[0-9]{1,3}$"");
        if (contains_dot) {
          if (!valid_dotted_ms) {
            throw new IllegalArgumentException(""Invalid time: "" + datetime  
                + "". Millisecond timestamps must be in the format ""
                + ""<seconds>.<ms> where the milliseconds are limited to 3 digits"");
          }
          time = Tags.parseLong(datetime.replace(""."", """"));   
        } else {
          time = Tags.parseLong(datetime);
        }
        if (time < 0) {
          throw new IllegalArgumentException(""Invalid time: "" + datetime  
              + "". Negative timestamps are not supported."");
        }
        // this is a nasty hack to determine if the incoming request is
        // in seconds or milliseconds. This will work until November 2286
        if (datetime.length() <= 10) {
          time *= 1000;
        }
        return time;
      } catch (NumberFormatException e) {
        throw new IllegalArgumentException(""Invalid time: "" + datetime  
            + "". "" + e.getMessage());
      }
    }
  }",Parse a date time string from a CBE file.
"public int forEachByte(int index, int length, ByteProcessor visitor) throws Exception {
        if (isOutOfBounds(index, length, length())) {
            throw new IndexOutOfBoundsException(""expected: "" + ""0 <= index("" + index + "") <= start + length("" + length
                    + "") <= "" + ""length("" + length() + ')');
        }
        return forEachByte0(index, length, visitor);
    }",Iterate over the bytes of the sequence.
"public final void synpred12_DRL6Expressions_fragment() throws RecognitionException {
		// src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:438:8: ( squareArguments shiftExpression )
		// src/main/resources/org/drools/compiler/lang/DRL6Expressions.g:438:9: squareArguments shiftExpression
		{
		pushFollow(FOLLOW_squareArguments_in_synpred12_DRL6Expressions2066);
		squareArguments();
		state._fsp--;
		if (state.failed) return;
		pushFollow(FOLLOW_shiftExpression_in_synpred12_DRL6Expressions2068);
		shiftExpression();
		state._fsp--;
		if (state.failed) return;
		}

	}",start synpred12_DRL6Expressions_fragment
"public Set<Address> getDestination(MessageID messageID) {
        MessageInfo messageInfo = sentMessages.get(messageID);
        Set<Address> destination;
        if (messageInfo != null) {
            destination = new HashSet<>(messageInfo.destinations);
        } else {
            destination = Collections.emptySet();
        }
        return destination;
    }",Gets the destination of a message.
"public String getPhase() {
        String phase = (String) getStateHelper().eval(PropertyKeys.phase);
        if (phase != null) {
            phase = phase.toUpperCase();
        }
        return phase;
    }",Gets the value of the phase property.
"public void reset() {
        boolean locked = false;
        try {
            locked = lock.tryLock() || lock.tryLock(5, TimeUnit.MILLISECONDS);
            if (locked) {
                while (queue.size() > 0) {
                    queue.remove(0).recycle();
                }
            }
        } catch (InterruptedException e) {
            if (logger.isTraceEnabled()) {
                logger.trace(""Could not acquire lock to reset jitter buffer."");
            }
        } finally {
            if (locked) {
                lock.unlock();
            }
        }
    }",Resets the buffer.
"@Override
    public boolean isValidMeasure(String name) {
        for (AbstractSqlColumn column : factTable.getMeasuresColumn().values()) {
            if (column.getBusinessName().equals(name)) {
                return true;
            }
        }
        return false;
    }",Check if a given measure is a valid measure.
"public static boolean isUriFilePath(Object value)
    {
        // nullでないこと
        if (value == null)
        {
            return false;
        }

        // String型であること
        if (String.class.isAssignableFrom(value.getClass()) == false)
        {
            return false;
        }

        // 空文字でないこと
        String valueString = (String) value;
        if (StringUtils.isEmpty(valueString))
        {
            return false;
        }

        // 有効なファイルパス指定であること
        try
        {
            new URI(valueString);
            return true;
        }
        catch (URISyntaxException ex)
        {
            return false;
        }
    }",Is the value a URI file path.
"public static String getPathFromRoot(String path) {
        for (Pattern COMPILER_ROOT_PATTERN : COMPILER_ROOT_PATTERNS) {
            Matcher m = COMPILER_ROOT_PATTERN.matcher(path);
            if (m.find()) {
                return m.group(m.groupCount()-1);
            }
        }
        return null;
    }",Get the path from the root of the path.
"public void registerDropPasteWorker(DropPasteWorkerInterface worker)
    {
        this.dropPasteWorkerSet.add(worker);
        defaultDropTarget.setDefaultActions( 
            defaultDropTarget.getDefaultActions() 
            | worker.getAcceptableActions(defaultDropTarget.getComponent())
                                           );
    }",Register a DropPasteWorkerInterface.
"public boolean match(TimeZone timezone, long millis, boolean isMatchSecond) {
		final GregorianCalendar calendar = new GregorianCalendar(timezone);
		calendar.setTimeInMillis(millis);
		return match(calendar, isMatchSecond);
	}",Returns true if this calendar object matches the given time.
"public AudioSpeakerSource makeAudioSpeakerSource(String nodeName, String textToSpeech, Vector3f location) {
        AudioSpeakerSource audioNode = createAudioSpeakingNode(textToSpeech);
        audioNode.setPositional(true);                
        audioNode.setDirectional(false);
        /*
        audioNode.setInnerAngle(180f);
        audioNode.setOuterAngle(90f);
         */
        audioNode.setName(nodeName);
        audioNode.setLocalTranslation(location);
        audioNode.setVolume(1f);
        audioNode.setMaxDistance(Float.MAX_VALUE);        
        audioNode.setRefDistance(1f);
        //audioNode.setTimeOffset((float)Math.random());
        return audioNode;
    }",Make an audio speaker source.
"@Deprecated
    public static String ingestAndCommit(FedoraAPIAMTOM apia,
                                         FedoraAPIMMTOM apim,
                                         InputStream in,
                                         String logMessage)
            throws RemoteException, IOException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        StreamUtility.pipeStream(in, out, 4096);
        DataHandler handler = new DataHandler(new ByteArrayDataSource(out.toByteArray(),
        ""text/xml""));
        String pid = apim.ingest(handler, METS_EXT1_0.uri, logMessage);
        return pid;
    }",This method is used to ingest a sequence of a sequence of objects from an input stream to an output stream.
"private ShowQueryBuilder parseShow(ShowQueryBuilder query)
  {
    Token token = scanToken();

    if (token == Token.TABLE) {
    }
    else if (token == Token.IDENTIFIER
             && _lexeme.equalsIgnoreCase(""tableinfo"")) {
      query.method(""tableinfo"");
    }
    else {
      throw error(""Expected TABLE at {0}"", token);
    }
    
    token = scanToken();

    if (token != Token.IDENTIFIER) {
      throw error(""Expected IDENTIFIER at {0}"", token);
    }
    
    String pod = _lexeme;
    String name;
    
    if (peekToken() == Token.DOT) {
      scanToken();

      if ((token = scanToken()) != Token.IDENTIFIER) {
        throw error(""Expected IDENTIFIER at {0}"", token);
      }
      
      name = _lexeme; 
    }
    else {
      name = pod;
      pod = getPodName();
    }
    
    query.setTableName(pod + '.' + name);

    return query;
  }",Parse a show query.
"public Set<String> postProcessingFields() {
        Set<String> fields = new LinkedHashSet<>();
        if (!StringUtils.isBlank(defaultField)) {
            fields.add(defaultField);
        }
        for (String term : query.split(""[ ]"")) {
            if (term.contains("":"")) {
                fields.add(term.split("":"")[0]);
            }
        }
        return fields;
    }",Post processing fields.
"public ApiResponse<List<RacesResponse>> getUniverseRacesWithHttpInfo(String acceptLanguage, String datasource,
            String ifNoneMatch, String language) throws ApiException {
        com.squareup.okhttp.Call call = getUniverseRacesValidateBeforeCall(acceptLanguage, datasource, ifNoneMatch,
                language, null);
        Type localVarReturnType = new TypeToken<List<RacesResponse>>() {
        }.getType();
        return apiClient.execute(call, localVarReturnType);
    }",Get list of RAID Races. get list of RAID Races
"static String getLibraryType(String os) {
        if (os.startsWith(""Linux"")) {
            return ""so"";
        }
        if (os.startsWith(""FreeBSD"")) {
            return ""so"";
        }
        if (os.startsWith(""Mac OS X"")) {
            return ""dylib"";
        }
        if (os.startsWith(""Windows"")) {
            return ""dll"";
        }
        throw new IllegalArgumentException();
    }",Get the library type of the given OS.
"private boolean isFixtureMethod(MethodNode method) {
    String name = method.getName();

    for (String fmName : FIXTURE_METHODS) {
      if (!fmName.equalsIgnoreCase(name)) continue;

      // assertion: is (meant to be) a fixture method, so we'll return true in the end

      if (method.isStatic())
        errorReporter.error(method, ""Fixture methods must not be static"");
      if (!fmName.equals(name))
        errorReporter.error(method, ""Misspelled '%s()' method (wrong capitalization)"", fmName);

      return true;
    }

    return false;
  }",Checks if the method is a fixture method.
"public static String readTextAsString(DataInput in) throws IOException {
    int bufLen = (int)readVLong(in);
    byte[] buf = new byte[bufLen];
    in.readFully(buf);

    return new String(buf, StandardCharsets.UTF_8);
  }",Read text as string.
"public void addLabel(JPanel panel, int x, int pickerRow, String labelText) {

        ((GridBagLayout) panel.getLayout()).rowHeights[(pickerRow - 3)] = 6;
        JLabel label = new JLabel();
        label.setText(labelText);
        panel.add(label, new GridBagConstraints(x, (pickerRow - 2), 1, 1, 0.0, 0.0,
                GridBagConstraints.WEST, GridBagConstraints.VERTICAL,
                new Insets(0, 0, 0, 0), 0, 0));
        ((GridBagLayout) panel.getLayout()).rowHeights[(pickerRow - 1)] = 3;
    }",Add a label to the given panel.
"@Indexable(type = IndexableType.DELETE)
	@Override
	public CPDefinitionGroupedEntry deleteCPDefinitionGroupedEntry(
		CPDefinitionGroupedEntry cpDefinitionGroupedEntry) {
		return cpDefinitionGroupedEntryPersistence.remove(cpDefinitionGroupedEntry);
	}",Deletes the cp definition grouped entry from the database. Also notifies the appropriate model listeners.
"@Override
    public FilterMutableType removeDescription(final String value) throws IllegalArgumentException {
        // Precondition checks
        if (value == null || value.length() == 0) {
            throw new IllegalArgumentException(""value must be specified"");
        }

        // Get all ""description"" elements
        final List<Node> descriptions = this.getRootNode().get(""description"");
        if (descriptions != null) {
            // For each description
            for (final Node description : descriptions) {
                // If matches
                if (description.getText().equals(value)) {
                    // Remove
                    description.getParent().removeChild(description);
                    System.out.println(description);
                }
            }
        }

        // Return
        return this;
    }",Remove description.
"public void attachWriter(final HttpSession newWriter) {
        // The attachWriter processing must be done in this WsebSession's IO thread so we can do
        // getProcessor().flush(). We may need to do ""thread hopping"" for this since attachWriter gets called by
        // WsebDownstreamHandler.reconnectSession during sessionOpened on the downstream, which may be running
        // in another I/O thread.
        if (Thread.currentThread() == getIoThread()) {
            attachWriter0(newWriter);
        }
        else {
            final Thread ioThread = getIoThread();
            final Executor ioExecutor = getIoExecutor();
            newWriter.setIoAlignment(NO_THREAD, NO_EXECUTOR);
            ioExecutor.execute(new Runnable() {
                @Override
                public void run() {
                    newWriter.setIoAlignment(ioThread, ioExecutor);
                    attachWriter0(newWriter);
                }
            });
        }
    }",Attach a new writer to this session.
"private void renderTextPath(SVG.TextPath obj)
   {
      debug(""TextPath render"");

      updateStyleForElement(state, obj);

      if (!display())
         return;
      if (!visible())
         return;

      SVG.SvgObject  ref = obj.document.resolveIRI(obj.href);
      if (ref == null)
      {
         error(""TextPath reference '%s' not found"", obj.href);
         return;
      }

      SVG.Path     pathObj = (SVG.Path) ref;
      Path         path = (new PathConverter(pathObj.d)).getPath();

      if (pathObj.transform != null)
         path.transform(pathObj.transform);

      PathMeasure  measure = new PathMeasure(path, false);

      float  startOffset = (obj.startOffset != null) ? obj.startOffset.floatValue(this, measure.getLength()) : 0f;

      // Handle text alignment
      Style.TextAnchor  anchor = getAnchorPosition();
      if (anchor != Style.TextAnchor.Start) {
         float  textWidth = calculateTextWidth(obj);
         if (anchor == Style.TextAnchor.Middle) {
            startOffset -= (textWidth / 2);
         } else {
            startOffset -= textWidth;  // 'End' (right justify)
         }
      }

      checkForGradientsAndPatterns((SvgElement) obj.getTextRoot());
      
      boolean  compositing = pushLayer();

      enumerateTextSpans(obj, new PathTextDrawer(path, startOffset, 0f));

      if (compositing)
         popLayer(obj);
   }",Render a TextPath object.
"@Override
	public void eUnset(int featureID) {
		switch (featureID) {
			case AfplibPackage.INCLUDE_TILE__TIRID:
				setTIRID(TIRID_EDEFAULT);
				return;
		}
		super.eUnset(featureID);
	}",Method eUnset.
"public ScanRequest withAttributesToGet(java.util.Collection<String> attributesToGet) {
        if (attributesToGet == null) {
            this.attributesToGet = null;
        } else {
            java.util.List<String> attributesToGetCopy = new java.util.ArrayList<String>(attributesToGet.size());
            attributesToGetCopy.addAll(attributesToGet);
            this.attributesToGet = attributesToGetCopy;
        }

        return this;
    }",Sets the value of the attributesToGet property.
"public final void normalClassDeclaration() throws RecognitionException {
		int normalClassDeclaration_StartIndex = input.index();

		try {
			if ( state.backtracking>0 && alreadyParsedRule(input, 7) ) { return; }

			// src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:299:5: ( 'class' Identifier ( typeParameters )? ( 'extends' type )? ( 'implements' typeList )? classBody )
			// src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:299:7: 'class' Identifier ( typeParameters )? ( 'extends' type )? ( 'implements' typeList )? classBody
			{
			match(input,72,FOLLOW_72_in_normalClassDeclaration271); if (state.failed) return;
			match(input,Identifier,FOLLOW_Identifier_in_normalClassDeclaration273); if (state.failed) return;
			// src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:299:26: ( typeParameters )?
			int alt12=2;
			int LA12_0 = input.LA(1);
			if ( (LA12_0==53) ) {
				alt12=1;
			}
			switch (alt12) {
				case 1 :
					// src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:299:27: typeParameters
					{
					pushFollow(FOLLOW_typeParameters_in_normalClassDeclaration276);
					typeParameters();
					state._fsp--;
					if (state.failed) return;
					}
					break;

			}

			// src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:300:9: ( 'extends' type )?
			int alt13=2;
			int LA13_0 = input.LA(1);
			if ( (LA13_0==81) ) {
				alt13=1;
			}
			switch (alt13) {
				case 1 :
					// src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:300:10: 'extends' type
					{
					match(input,81,FOLLOW_81_in_normalClassDeclaration289); if (state.failed) return;
					pushFollow(FOLLOW_type_in_normalClassDeclaration291);
					type();
					state._fsp--;
					if (state.failed) return;
					}
					break;

			}

			// src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:301:9: ( 'implements' typeList )?
			int alt14=2;
			int LA14_0 = input.LA(1);
			if ( (LA14_0==88) ) {
				alt14=1;
			}
			switch (alt14) {
				case 1 :
					// src/main/resources/org/drools/compiler/semantics/java/parser/Java.g:301:10: 'implements' typeList
					{
					match(input,88,FOLLOW_88_in_normalClassDeclaration304); if (state.failed) return;
					pushFollow(FOLLOW_typeList_in_normalClassDeclaration306);
					typeList();
					state._fsp--;
					if (state.failed) return;
					}
					break;

			}

			pushFollow(FOLLOW_classBody_in_normalClassDeclaration318);
			classBody();
			state._fsp--;
			if (state.failed) return;
			}

		}
		catch (RecognitionException re) {
			reportError(re);
			recover(input,re);
		}
		finally {
			// do for sure before leaving
			if ( state.backtracking>0 ) { memoize(input, 7, normalClassDeclaration_StartIndex); }

		}
	}",Starts a normal class declaration
"private SAXParserFactory getSAXParserFactory() {

        final SAXParserFactory factory = SAXParserFactory.newInstance();
        factory.setNamespaceAware(this.namespaceAware);
        factory.setSchema(this.schema);
        return factory;
    }",Get the SAXParserFactory.
"public T validateNamespace(String prefix, String namespaceUri) {
        xmlMessageValidationContext.getControlNamespaces().put(prefix, namespaceUri);
        return self;
    }",Validate namespace.
"protected MessageContext decodeSoapRequest(final HttpServletRequest request) {
        try {
            val decoder = new HTTPSOAP11Decoder();
            decoder.setParserPool(samlProfileHandlerConfigurationContext.getOpenSamlConfigBean().getParserPool());
            decoder.setHttpServletRequest(request);

            val binding = new BindingDescriptor();
            binding.setId(getClass().getName());
            binding.setShortName(getClass().getName());
            binding.setSignatureCapable(true);
            binding.setSynchronous(true);

            decoder.setBindingDescriptor(binding);
            decoder.initialize();
            decoder.decode();
            return decoder.getMessageContext();
        } catch (final Exception e) {
            LOGGER.error(e.getMessage(), e);
        }
        return null;
    }",Decode soap request message context.
"protected boolean hasReadElfTag(String tag) {
        String tagValue = getReadElfTag(tag);
        return (tagValue != null && !tagValue.isEmpty());
    }",Check if the tag is a read elf tag.
"public JSONArray put(int index, boolean value) throws JSONException {
    put(index, value ? Boolean.TRUE : Boolean.FALSE);
    return this;
  }",Put a boolean value into the JSONArray.
"public static SnapshotInfo of(SnapshotId snapshotId, DiskId source) {
    return newBuilder(snapshotId, source).build();
  }",Creates a SnapshotInfo object with the given snapshot id and source disk.
"public Map<String, Serializable> getState() {
    Map<String, Serializable> ret = new HashMap<>();
    // get potential eviction policy state
    if (evictionPolicy.getState() != null) {
      ret.put(EVICTION_STATE_KEY, (Serializable) evictionPolicy.getState());
    }
    // get potential trigger policy state
    if (triggerPolicy.getState() != null) {
      ret.put(TRIGGER_STATE_KEY, (Serializable) triggerPolicy.getState());
    }
    ret.put(QUEUE, (Serializable) this.queue);
    ret.put(EXPIRED_EVENTS, (Serializable) this.expiredEvents);
    ret.put(PRE_WINDOW_EVENTS, (Serializable) this.prevWindowEvents);
    ret.put(EVENTS_SINCE_LAST_EXPIRY, this.eventsSinceLastExpiry.get());
    return ret;
  }",Get the state of the ClusterState object.
"private void safeImageSet(final ImageResult result) {
    if (imagesManager.debug) { Log.v(ImagesManager.TAG, ""Post setting drawable for "" + request.getKey()); }

    synchronized (targets) {
      if (this.result != null) { throw new IllegalStateException(""Result is already set""); }
      memCacheImage(result);
      this.result = result;
    }

    post(new Runnable() {
      @Override
      public void run() {
        if (imagesManager.debug) {
          Log.v(TAG, ""Set drawable for "" + request.getKey());
        }

        final ArrayList<ImageConsumer> targets = ImageLoader.this.targets;
        final int count = targets.size();
        if (count > 0) {
          //noinspection ForLoopReplaceableByForEach
          for (int i = 0; i < count; i++) {
            final ImageConsumer imageHolder = targets.get(i);
            if (imagesManager.debug) {
              Log.d(TAG, ""Try to set "" + imageHolder + "" - "" + request.getKey());
            }
            setToConsumer(imageHolder, result);
          }
        } else if (imagesManager.debug) {
          Log.w(TAG, ""set drawable: have no targets in list"");
        }

      }
    });
  }",Set the result of the image.
"private void writeObject(ObjectOutputStream s) throws IOException {
    Iterator<E> it = iterator();
    s.writeInt(size() * 2);             // expectedMaxSize
    s.writeInt(size());
    while (it.hasNext())
      s.writeObject(it.next());
  }","Write a
    object."
"@Override
    public void doAction(Action action) {
        BaseComponent parent = getParent();
        
        switch (action) {
            case REMOVE:
                ActionListener.unbindActionListeners(this, actionListeners);
                detach();
                break;
            
            case HIDE:
            case COLLAPSE:
                setVisible(false);
                break;
            
            case SHOW:
            case EXPAND:
                setVisible(true);
                break;
            
            case TOP:
                parent.addChild(this, 0);
                break;
        }
        
        if (parent != null) {
            EventUtil.post(MainController.ALERT_ACTION_EVENT, parent, action);
        }
    }","Override this method to perform the action of the
   ."
"public List<Error> validate(Object target) {
		DeleteItemRequest instance = (DeleteItemRequest) target;
		List<Error> errors = ValidatorUtils.invokeValidator(new TableNameValidator(), instance.getTableName());
		errors.addAll(ValidatorUtils.invokeValidator(new KeyValidator(), instance.getKey()));
		if (instance.getExpected() != null) {
			errors.addAll(ValidatorUtils.invokeValidator(new ExpectedValidator(), instance.getExpected()));
		}
		if (instance.getReturnValues() != null) {
			errors.addAll(ValidatorUtils.rejectIfNotMatchRegex(instance.getReturnValues(), ""^(NONE|ALL_OLD)$""));
		}
		return removeNulls(errors);
	}",Validate delete item request.
"private void parseURLHost(byte[] url, int start, int end) {
        // save the host:port now, could be hostname, hostname:port, IP,
        // IP:port, or [IPv6]:port
        int length = end - start;
        if (0 >= length) {
            throw new IllegalArgumentException(""Missing host/port"");
        }
        int name_start = start;
        int name_end = end;
        int port_start = -1;
        int port_end = -1;
        if (LEFT_BRACKET != url[name_start]) {
            // hostname plus optional port if colon is found
            int colon_index = GenericUtils.byteIndexOf(url, BNFHeaders.COLON, name_start, length);
            if (-1 != colon_index) {
                name_end = colon_index;
                port_start = colon_index + 1;
                port_end = end;
            }
        } else {
            // IPV6 IP and port
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""IPV6 host in the URL"");
            }
            // find the right bracket marking the end of the IPV6 IP
            // name_start++; // skip past the bracket
            int index = GenericUtils.byteIndexOf(url, RIGHT_BRACKET, name_start, length);
            if (-1 != index) {
                // save the ip, then check for port
                // Note: reverse these 2 lines if we want to strip []s off
                index++;
                name_end = index;
                if (index < end && BNFHeaders.COLON == url[index]) {
                    port_start = index + 1;
                    port_end = end;
                }
            } else {
                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                    Tr.debug(tc, ""No end to the IPV6 IP"");
                }
                throw new IllegalArgumentException(""Invalid IPV6 IP"");
            }
        }
        // save the hostname information
        length = name_end - name_start;
        if (0 >= length) {
            throw new IllegalArgumentException(""Hostname not present"");
        }
        this.sUrlHost = GenericUtils.getEnglishString(url, name_start, name_end);
        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
            Tr.debug(tc, ""Found URL host: "" + this.sUrlHost);
        }
        // save the port information
        if (-1 != port_start && port_end > port_start) {
            length = port_end - port_start;
            this.iUrlPort = GenericUtils.asIntValue(url, port_start, length);
        } else {
            // PK06407
            // if the port was not in the URL but the host was, then default the
            // virtual host to match the scheme
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""Defaulting URL port to match scheme: "" + getScheme());
            }
            if (SchemeValues.HTTPS.equals(getSchemeValue())) {
                this.iUrlPort = 443;
            } else {
                this.iUrlPort = 80;
            }
        }
        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
            Tr.debug(tc, ""Found URL port of "" + this.iUrlPort);
        }
    }",Parse the URL host.
"public List<CmsClientSitemapEntry> getLoadedDescendants(String path) {

        LinkedList<CmsClientSitemapEntry> remainingEntries = new LinkedList<CmsClientSitemapEntry>();
        List<CmsClientSitemapEntry> result = new ArrayList<CmsClientSitemapEntry>();
        CmsClientSitemapEntry entry = getEntry(path);
        remainingEntries.add(entry);
        while (remainingEntries.size() > 0) {
            CmsClientSitemapEntry currentEntry = remainingEntries.removeFirst();
            result.add(currentEntry);
            for (CmsClientSitemapEntry subEntry : currentEntry.getSubEntries()) {
                remainingEntries.add(subEntry);
            }
        }

        return result;

    }",Gets the list of all descendants of the given path.
"protected void checkPreconditions(List<ConsumerHolder> consumerHolders) throws IOException {
        Channel channel = createChannel();
        for (ConsumerHolder consumerHolder : consumerHolders) {
            String queue = consumerHolder.getConfiguration().getQueueName();
            try {
                channel.queueDeclarePassive(queue);
                LOGGER.debug(""Queue {} found on broker"", queue);
            } catch (IOException e) {
                LOGGER.error(""Queue {} not found on broker"", queue);
                throw e;
            }
        }
        channel.close();
    }","Checks the preconditions for the
 banner."
"public void setOutboundInterface(SipURI outboundInterface) {
		checkSessionValidity();
		if(outboundInterface == null) {
			throw new NullPointerException(""outbound Interface param shouldn't be null"");
		}
		List<SipURI> list = proxy.getSipFactoryImpl().getSipNetworkInterfaceManager().getOutboundInterfaces();
		SipURI networkInterface = null;
		for(SipURI networkInterfaceURI : list) {
			if(networkInterfaceURI.equals(outboundInterface)) {
				networkInterface = networkInterfaceURI;
				break;
			}
		}
		
		if(networkInterface == null) throw new IllegalArgumentException(""Network interface for "" +
				outboundInterface + "" not found"");		
		
		this.outboundInterface = networkInterface;
	}",Set the outbound interface for this session.
"public void deleteStaticExportPublishedResource(
        CmsDbContext dbc,
        String resourceName,
        int linkType,
        String linkParameter)
    throws CmsException {

        getProjectDriver(dbc).deleteStaticExportPublishedResource(dbc, resourceName, linkType, linkParameter);
    }",Deletes a static export published resource.
"public void blockWhileQueueExceeds(int count) {
    boolean loop = true;
    boolean interrupted = false;
    try {
      do {
      synchronized(outstandingCountLock) {
        if(outstandingCount > count) {
          try {
            outstandingCountLock.wait();
          }catch(InterruptedException e) {
            //ignore interruption, loop again.
            interrupted = true;
          }
        }
        else
        loop = false;
        }
      }while(loop);
    }finally {
      if(interrupted)
      Thread.currentThread().interrupt();
    }
  }",Block while the queue exceeds the specified number of times.
"public static Vec stringToCategorical(Vec vec) {
    final String[] vecDomain = new CollectStringVecDomain().domain(vec);

    MRTask task = new MRTask() {
      transient private java.util.HashMap<String, Integer> lookupTable;

      @Override
      protected void setupLocal() {
        lookupTable = new java.util.HashMap<>(vecDomain.length);
        for (int i = 0; i < vecDomain.length; i++) {
          // FIXME: boxing
          lookupTable.put(vecDomain[i], i);
        }
      }

      @Override
      public void map(Chunk c, NewChunk nc) {
        BufferedString bs = new BufferedString();
        for (int row = 0; row < c.len(); row++) {
          if (c.isNA(row)) {
            nc.addNA();
          } else {
            c.atStr(bs, row);
            String strRepresentation = bs.toString();
            if (strRepresentation.contains(""\uFFFD"")) {
              nc.addNum(lookupTable.get(bs.toSanitizedString()), 0);
            } else {
              nc.addNum(lookupTable.get(strRepresentation), 0);
            }
          }
        }
      }
    };
    // Invoke tasks - one input vector, one ouput vector
    task.doAll(new byte[] {Vec.T_CAT}, vec);
    // Return result
    return task.outputFrame(null, null, new String[][] {vecDomain}).vec(0);
  }",Convert a byte array to a categorical vector.
"@Override
    public UserFeed getUserRequestedBy() throws InstagramException {
        return createInstagramObject(Verbs.GET, UserFeed.class, Methods.USERS_SELF_REQUESTED_BY, null);
    }",Gets the UserRequestedBy object.
"protected void register(String id, Promise promise, long timeoutAt, String nodeID, String action) {
		promises.put(id, new PendingPromise(promise, timeoutAt, nodeID, action));

		long nextTimeoutAt = prevTimeoutAt.get();
		if (nextTimeoutAt == 0 || (timeoutAt / 100 * 100) + 100 < nextTimeoutAt || promises.size() < 3) {
			scheduler.execute(() -> {
				reschedule(timeoutAt);
			});
		}
	}",Registers a pending promise with the scheduler.
"@Override
    public final void process(final HttpRequest request, final HttpContext context) throws HttpException, IOException {

        AuthState authState = (AuthState) context.getAttribute(HttpClientContext.TARGET_AUTH_STATE);
        if (authState.getAuthScheme() == null) {

            HttpHost targetHost = (HttpHost) context.getAttribute(HttpCoreContext.HTTP_TARGET_HOST);
            AuthCache authCache = new BasicAuthCache();
            authCache.put(targetHost, new BasicScheme());
            context.setAttribute(HttpClientContext.AUTH_CACHE, authCache);
        }
    }",Override this method to add the authentication scheme to the context.
"public String getWorkspaceKey() {
        if (workspaceKey == null) {
            // Value is idempotent, so it's okay to do this without synchronizing ...
            workspaceKey = key.substring(WORKSPACE_START_INDEX, WORKSPACE_END_INDEX);
        }
        return workspaceKey;
    }",Gets the workspace key.
"public static Client createClient(ClientConfig config) {
        Client client = null;
        synchronized (ClientFactory.class) {
            if (!m_preserveResources && ++m_activeClientCount == 1) {
                VoltLogger.startAsynchronousLogging();
                EstTimeUpdater.start();
                ReverseDNSCache.start();
            }
        }
        client = new ClientImpl(config);
        return client;
    }",Create a new client instance.
"@Override
  public IoBuffer putObject(Object o) {
    int oldPos = position();
    skip(4); // Make a room for the length field.
    try {
      ObjectOutputStream out = new ObjectOutputStream(asOutputStream()) {
        @Override
        protected void writeClassDescriptor(ObjectStreamClass desc) throws IOException {
          if (desc.forClass().isPrimitive()) {
            write(0);
            super.writeClassDescriptor(desc);
          } else {
            write(1);
            writeUTF(desc.getName());
          }
        }
      };
      out.writeObject(o);
      out.flush();
    } catch (IOException e) {
      throw new BufferDataException(e);
    }

    // Fill the length field
    int newPos = position();
    position(oldPos);
    putInt(newPos - oldPos - 4);
    position(newPos);
    return this;
  }",Write an object into the buffer.
"public JQueryElement getDropdownContainerElement() {
        JQueryElement element = $(getElement()).find("".select2 .selection .select2-selection__rendered"");
        if (element == null) {
            GWT.log(""The element dropdown-container element is undefined."", new NullPointerException());
        }
        return element;
    }",Gets the element that is the element that is used to display the dropdown.
"public int getImageSize() {
		int filePages = (int) header.get(FILE_PAGES);
		int lastPageSize = (int) header.get(LAST_PAGE_SIZE);

		int imageSize = (filePages - 1) * PAGE_SIZE + lastPageSize;
		if (lastPageSize == 0) {
			imageSize += PAGE_SIZE;
		}
		return imageSize;
	}",Get the image size.
"public <E> TerminalResult LTE(E value) {
		getPredicateExpression().setOperator(Operator.LTE);
		getPredicateExpression().setValue_2(value);
		TerminalResult ret = APIAccess.createTerminalResult(this.getPredicateExpression());
		QueryRecorder.recordInvocation(this, ""LTE"", ret, QueryRecorder.placeHolder(value));
		return ret;
	}",Create a new LTE terminal result
"public SecurityIdentityType<SessionBeanType<T>> getOrCreateSecurityIdentity()
   {
      Node node = childNode.getOrCreate(""security-identity"");
      SecurityIdentityType<SessionBeanType<T>> securityIdentity = new SecurityIdentityTypeImpl<SessionBeanType<T>>(this, ""security-identity"", childNode, node);
      return securityIdentity;
   }",Get the SecurityIdentityType of the SessionBeanType.
"public static Stopwatch createStarted(VoidCallable callable) {
        Stopwatch stopwatch = new Stopwatch();
        stopwatch.callable = callable;
        stopwatch.start();
        return stopwatch;
    }",Creates a stopwatch that stops the process.
"public static Shell createConsoleShell(String prompt, String appName, Object... handlers) {
        ConsoleIO io = new ConsoleIO();

        List<String> path = new ArrayList<String>(1);
        path.add(prompt);

        MultiMap<String, Object> modifAuxHandlers = new ArrayHashMultiMap<String, Object>();
        modifAuxHandlers.put(""!"", io);

        Shell theShell = new Shell(new Shell.Settings(io, io, modifAuxHandlers, false),
                new CommandTable(new DashJoinedNamer(true)), path);
        theShell.setAppName(appName);

        theShell.addMainHandler(theShell, ""!"");
        theShell.addMainHandler(new HelpCommandHandler(), ""?"");
        for (Object h : handlers) {
            theShell.addMainHandler(h, """");
        }

        return theShell;
    }",Create a new Console Shell with the specified prompt and application name and handlers.
"@Override
    public boolean hasScope(String scope) throws InternalCacheEngineException {
        try {
            return cacheStoreAdapter.hasScope(scope);
        } catch (Exception ex) {
            throw new InternalCacheEngineException(""Exception while checking if the scope "" + scope + "" exists in the"" +
                "" cache"", ex);
        }
    }",Check if the cache has the specified scope.
"public synchronized void setResponse(HttpServletResponse response) {

        if (perThreadResponse == null) {
            perThreadResponse = new ThreadLocal<HttpServletResponse>();
        }
        perThreadResponse.set(response);
    }",Sets the response object.
"public boolean after(JKTimeObject thareTime) {
		if (getYear() == thareTime.getYear() || thareTime.getYear() > getYear()) {
			System.out.println(""after:: Year true"");
			if (thareTime.getMonth() < getMonth()) {
				return true;
			}
			if (getMonth() == thareTime.getMonth()) {
				System.out.println(""after:: Month true"");
				if (thareTime.getDay() < getDay()) {
					System.out.println(""after:: Day true"");
					return true;
				}
				if (getDay() == thareTime.getDay()) {
					if (getHour() == thareTime.getHour()) {
						if (thareTime.getMunite() < getMunite()) {
							return true;
						}
					}
					if (getHour() > thareTime.getHour()) {
						return true;
					}
				}
			}
		}
		return false;

	}",Checks if this date is after the specified date
"public static int cublasAlloc(int n, int elemSize, Pointer ptr)
    {
        return checkResult(cublasAllocNative(n, elemSize, ptr));
    }",Allocs a contiguous block of unique elements.
"private byte parseBinaryLiteral(Token input) {
		String text = input.text;
		if (text.length() > 11) {
			// FIXME: this will be deprecated!
			syntaxError(""invalid binary literal (too long)"", input);
		}
		int val = 0;
		// Start past 0b
		for (int i = 2; i != text.length(); ++i) {
			char c = text.charAt(i);
			// Skip underscore
			if(c == '_') { continue; }
			val = val << 1;
			if (c == '1') {
				val = val | 1;
			} else if (c == '0') {

			} else {
				syntaxError(""invalid binary literal (invalid characters)"", input);
			}
		}
		return (byte) val;
	}",Parse a binary literal.
"protected void handleSimpleCORS(
            final HttpServletRequest request,
            final HttpServletResponse response,
            final FilterChain filterChain)
            throws IOException, ServletException {

        CorsFilter.CORSRequestType requestType = checkRequestType(request);
        if (!(requestType == CorsFilter.CORSRequestType.SIMPLE
                || requestType == CorsFilter.CORSRequestType.ACTUAL)) {
            throw new IllegalArgumentException(
                    ""Expects a HttpServletRequest object of type ""
                            + CorsFilter.CORSRequestType.SIMPLE
                            + "" or ""
                            + CorsFilter.CORSRequestType.ACTUAL);
        }

        final String originOrNull = request.getHeader(CorsFilter.REQUEST_HEADER_ORIGIN);
        log.debug(""Request origin: {}"", originOrNull);
        final String origin = originOrNull == null ? """" : originOrNull.toLowerCase(Locale.ENGLISH);
        final String methodOrNull = request.getMethod();
        log.debug(""Request method: {}"", methodOrNull);
        final String method = methodOrNull == null ? """" : methodOrNull.toUpperCase(Locale.ENGLISH);

        // Section 6.1.2
        if (!isOriginAllowed(origin)) {
            handleInvalidCORS(request, response, filterChain);
            return;
        }

        if (!allowedHttpMethods.contains(method)) {
            handleInvalidCORS(request, response, filterChain);
            return;
        }

        // Section 6.1.3
        // Add a single Access-Control-Allow-Origin header.
        if (anyOriginAllowed && !supportsCredentials) {
            // If resource doesn't support credentials and if any origin is
            // allowed
            // to make CORS request, return header with '*'.
            response.addHeader(CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN, ""*"");
        } else {
            // If the resource supports credentials add a single
            // Access-Control-Allow-Origin header, with the value of the Origin
            // header as value.
            response.addHeader(CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN, origin);
        }

        // Section 6.1.3
        // If the resource supports credentials, add a single
        // Access-Control-Allow-Credentials header with the case-sensitive
        // string ""true"" as value.
        if (supportsCredentials) {
            response.addHeader(CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS, ""true"");
        }

        // Section 6.1.4
        // If the list of exposed headers is not empty add one or more
        // Access-Control-Expose-Headers headers, with as values the header
        // field names given in the list of exposed headers.
        if ((exposedHeaders != null) && (exposedHeaders.size() > 0)) {
            String exposedHeadersString = join(exposedHeaders, "","");
            response.addHeader(
                    CorsFilter.RESPONSE_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS, exposedHeadersString);
        }

        // Indicate the response depends on the origin
        response.addHeader(CorsFilter.REQUEST_HEADER_VARY, CorsFilter.REQUEST_HEADER_ORIGIN);

        // Forward the request down the filter chain.
        filterChain.doFilter(request, response);
    }",Handle a single HTTP CORS request.
"public static String getArea(String idCard) {
        // 用户所属省份
        String province;
        // 用户所属地区
        String area;
        String pre = idCard.substring(0, 6);

        if (AREA.get(pre) == null) {
            logger.warn(""地区不存在或者地区已不在最新行政区划代码中"");
        }

        // 判断是否输入台湾省和特别行政区
        if (Tools.contains(pre, HK)) {
            // 台湾省和特别行政区
            area = AREA.get(pre + ""0000"");
        } else {
            // 查询用户所属省份
            province = AREA.get(idCard.substring(0, 2) + ""0000"");
            // 判断用户所属地区是否是直辖市

            Matcher areamM = AREA_PATTERN.matcher(province);
            StringBuilder sb = new StringBuilder();
            if (!areamM.matches()) {
                // 不是直辖市，加上用户所属市区名
                sb.append(AREA.get(idCard.substring(0, 4) + ""00""));
            }

            sb.append(AREA.get(idCard.substring(0, 6)));
            // 用户的地址
            area = sb.toString();
        }
        return area;
    }",Get the AREA value for a given ID card.
"public static String resolveProperty(
            final String nodeAttribute,
            final String defaultValue,
            final INodeEntry node,
            final IRundeckProject frameworkProject,
            final Framework framework
    )
    {
        if (null != node.getAttributes().get(nodeAttribute)) {
            return node.getAttributes().get(nodeAttribute);
        } else if (frameworkProject.hasProperty(JschNodeExecutor.PROJ_PROP_PREFIX + nodeAttribute)
                   && !"""".equals(frameworkProject.getProperty(JschNodeExecutor.PROJ_PROP_PREFIX + nodeAttribute))) {
            return frameworkProject.getProperty(JschNodeExecutor.PROJ_PROP_PREFIX + nodeAttribute);
        } else if (framework.hasProperty(JschNodeExecutor.FWK_PROP_PREFIX + nodeAttribute)) {
            return framework.getProperty(JschNodeExecutor.FWK_PROP_PREFIX + nodeAttribute);
        } else {
            return defaultValue;
        }
    }",Resolves the property value for a node.
"@Override
    public void batchProcess(Map<String, List<Row>> batchData)
    {
        for (String tableName : batchData.keySet())
        {
            List<Row> actions = batchData.get(tableName);
            try
            {
                Table hTable = gethTable(tableName);
                hTable.batch(actions, new Object[actions.size()]);
            }
            catch (IOException | InterruptedException e)
            {
                logger.error(""Error while batch processing on HTable: "" + tableName);
                throw new PersistenceException(e);
            }

        }

    }",Batch processing of a single CRS table.
"private static String encode(final CharSequence text, final char[][] buff, final int bufflen) {
		int len;
		if ((text == null) || ((len = text.length()) == 0)) {
			return StringPool.EMPTY;
		}

		StringBuilder buffer = new StringBuilder(len + (len >> 2));

		for (int i = 0; i < len; i++) {
			char c = text.charAt(i);

			if (c < bufflen) {
				buffer.append(buff[c]);
			} else {
				buffer.append(c);
			}
		}
		return buffer.toString();
	}",Encode a CharSequence using a char array and a byte array length.
"public static void clearCookie (HttpServletResponse rsp, String name)
    {
        Cookie c = new Cookie(name, ""x"");
        c.setPath(""/"");
        c.setMaxAge(0);
        rsp.addCookie(c);
    }",Clear the Cookie in the HttpServletResponse.
"public Date getDate(FrenchRepublicanAlgorithm algorithm) {

        if (algorithm == DEFAULT_ALGORITHM) {
            return new Date(this, DEFAULT_ALGORITHM);
        }

        long utcDays = DEFAULT_ALGORITHM.transform(this);
        return new Date(algorithm.transform(utcDays), algorithm);

    }",Gets the date in the French Republican algorithm.
"public static <K, V> HashMap<K, V> newHashMap(@NotNull final K[] keys, @NotNull final V[] values) {
		Validate.isTrue(keys.length == values.length, ""keys.length is %d but values.length is %d"", keys.length,
				values.length);

		HashMap<K, V> map = new HashMap<K, V>(keys.length * 2);

		for (int i = 0; i < keys.length; i++) {
			map.put(keys[i], values[i]);
		}

		return map;
	}",Create a new HashMap from the given keys and values.
"public GelfMessageBuilder withField(String key, String value) {
        this.additionalFields.put(key, value);
        return this;
    }",Add an additional field to the message.
"public double Function1D(double x) {
        double frequency = initFrequency;
        double amplitude = initAmplitude;
        double sum = 0;

        // octaves
        for (int i = 0; i < octaves; i++) {
            sum += SmoothedNoise(x * frequency) * amplitude;

            frequency *= 2;
            amplitude *= persistence;
        }
        return sum;
    }",Function 1D.
"public int getRepeatRate (int keyCode)
    {
        KeyRecord krec = _keys.get(keyCode);
        return (krec == null) ? DEFAULT_REPEAT_RATE : krec.repeatRate;
    }",Gets the repeat rate for the specified key code.
"@Override
    public Set<Tuple> zRevRangeByScoreWithScores(byte[] key, double min, double max) {
        try {
            if (isPipelined()) {
                pipeline(new JedisResult(pipeline.zrevrangeByScoreWithScores(key, max, min),
                        JedisConverters.tupleSetToTupleSet()));
            }

            return JedisConverters.toTupleSet(client.zrevrangeByScoreWithScores(key, max, min));
        } catch (Exception ex) {
            throw convertException(ex);
        }
    }",zRevRangeByScoreWithScores This method is used to retrieve a set of tuples from a sorted set.
"public void marshall(Event event, ProtocolMarshaller protocolMarshaller) {

        if (event == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(event.getEventId(), EVENTID_BINDING);
            protocolMarshaller.marshall(event.getEventName(), EVENTNAME_BINDING);
            protocolMarshaller.marshall(event.getReadOnly(), READONLY_BINDING);
            protocolMarshaller.marshall(event.getAccessKeyId(), ACCESSKEYID_BINDING);
            protocolMarshaller.marshall(event.getEventTime(), EVENTTIME_BINDING);
            protocolMarshaller.marshall(event.getEventSource(), EVENTSOURCE_BINDING);
            protocolMarshaller.marshall(event.getUsername(), USERNAME_BINDING);
            protocolMarshaller.marshall(event.getResources(), RESOURCES_BINDING);
            protocolMarshaller.marshall(event.getCloudTrailEvent(), CLOUDTRAILEVENT_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given event to the JSON object.
"public Object extractObject(ObjectToJsonConverter pConverter, Object pValue, Stack<String> pPathParts, boolean jsonify)
            throws AttributeNotFoundException {
        String path = pPathParts.isEmpty() ? null : pPathParts.pop();
        ValueFaultHandler faultHandler = pConverter.getValueFaultHandler();
        if (path != null) {
            return extractWithPath(pConverter, pValue, pPathParts, jsonify, path, faultHandler);
        } else {
            return jsonify ? extractAll(pConverter, (T) pValue, pPathParts, jsonify) : pValue;
        }
    }",Extract object.
"private static boolean isLeftTurn(Point2D a, Point2D b, Point2D c) {
        return winding(a, b, c) > 0;
    }",Is left turn.
