code,summary
"public static MediaTable create(String tableName, String idColumnName,
			List<UserCustomColumn> additionalColumns) {

		List<UserCustomColumn> columns = new ArrayList<>();
		columns.addAll(createRequiredColumns(idColumnName));

		if (additionalColumns != null) {
			columns.addAll(additionalColumns);
		}

		return new MediaTable(tableName, columns, idColumnName);
	}",Creates a new media table with the required columns.
"public boolean isAsync() {
        return invokeType != null && (RpcConstants.INVOKER_TYPE_CALLBACK.equals(invokeType)
            || RpcConstants.INVOKER_TYPE_FUTURE.equals(invokeType));
    }",Returns true if this method is async.
"protected final static int getConversionFnid(int authoritative_type, int new_type) {
        if (new_type == authoritative_type) return 0;
        switch (new_type) {
            case AS_TYPE.null_value:
                assert( authoritative_type == AS_TYPE.string_value );
                return from_string_conversion[AS_TYPE.null_value];
            case AS_TYPE.boolean_value:
                assert( authoritative_type == AS_TYPE.string_value );
                return from_string_conversion[AS_TYPE.boolean_value];
            case AS_TYPE.int_value:
                return to_int_conversion[authoritative_type];
            case AS_TYPE.long_value:
                return to_long_conversion[authoritative_type];
            case AS_TYPE.bigInteger_value:
                return to_bigInteger_conversion[authoritative_type];
            case AS_TYPE.decimal_value:
                return to_decimal_conversion[authoritative_type];
            case AS_TYPE.double_value:
                return to_double_conversion[authoritative_type];
            case AS_TYPE.string_value:
                return to_string_conversions[authoritative_type];
            case AS_TYPE.date_value:
                assert( authoritative_type == AS_TYPE.timestamp_value );
                return FNID_FROM_TIMESTAMP_TO_DATE;
            case AS_TYPE.timestamp_value:
                assert( authoritative_type == AS_TYPE.date_value );
                return FNID_FROM_DATE_TO_TIMESTAMP;
        }
        String message = ""can't convert from ""
                       + getValueTypeName(authoritative_type)
                       + "" to ""
                       + getValueTypeName(new_type);
        throw new CantConvertException(message);
    }",Get the fnid of conversion from the authoritative_type to the new_type.
"protected void setNextValue(final long pValue, final int pLength, final int pMaxSize) {
		long value = pValue;
		// Set to max value if pValue cannot be stored on pLength bits.
		long bitMax = (long) Math.pow(2, Math.min(pLength, pMaxSize));
		if (pValue > bitMax) {
			value = bitMax - 1;
		}
		// size to wrote
		int writeSize = pLength;
		while (writeSize > 0) {
			// modulo
			int mod = currentBitIndex % BYTE_SIZE;
			byte ret = 0;
			if (mod == 0 && writeSize <= BYTE_SIZE || pLength < BYTE_SIZE - mod) {
				// shift left value
				ret = (byte) (value << BYTE_SIZE - (writeSize + mod));
			} else {
				// shift right
				long length = Long.toBinaryString(value).length();
				ret = (byte) (value >> writeSize - length - (BYTE_SIZE - length - mod));
			}
			byteTab[currentBitIndex / BYTE_SIZE] |= ret;
			long val = Math.min(writeSize, BYTE_SIZE - mod);
			writeSize -= val;
			currentBitIndex += val;
		}
	}",Sets the next value in the sequence of bytes.
"@SafeVarargs
    public static Function<CharSequence, TemporalAccessor> orderedParseAttempter(Function<CharSequence, TemporalAccessor>... parsers) {
        return date -> {
            RuntimeException first = null;
            for (Function<CharSequence, TemporalAccessor> parser : parsers) {
                try { return parser.apply(date); }
                catch (RuntimeException ex) {
                    if (first == null) first = ex;
                }
            }
            if (first == null) throw new IllegalStateException(""Empty parse attempter"");
            throw first;
        };
    }",Returns a function that parses the given date using the given parsers.
"@Override
    public Predicate lt(Expression<? extends Number> arg0, Number arg1)
    {
        return new ComparisonPredicate(arg0, arg1, ConditionalOperator.LT);
    }",Create a predicate that returns true if the two expressions in the sequence are less than the first.
"protected Map<String, WeakReference<T>> getClassLoaderCache(ClassLoader cl)
   {
      synchronized (cache)
      {
         Map<String, WeakReference<T>> result = cache.get(cl);
         if (result == null)
         {
            result = CollectionsFactory.createConcurrentReaderMap();
            cache.put(cl, result);
         }
         return result;
      }
   }",Get the class loader cache.
"protected final Value decodeNumberLax(boolean minus) {
        char[] array = charArray;

        final int startIndex = __index;
        int index = __index;
        char currentChar;
        boolean doubleFloat = false;
        boolean foundDot = false;
        boolean foundSign = false;
        boolean foundExp = false;

        if (minus && index + 1 < array.length) {
            index++;
        }

        while (true) {
            currentChar = array[index];
            if (isNumberDigit(currentChar)) {
                //noop
            } else if (currentChar <= 32) { //white
                break;
            } else if (isDelimiter(currentChar)) {
                break;
            } else if (isDecimalChar(currentChar)) {
                switch (currentChar) {
                    case DECIMAL_POINT:
                        if (foundDot || foundExp) { return decodeStringLax(); }
                        foundDot = true;
                        break;
                    case LETTER_E:
                    case LETTER_BIG_E:
                        if (foundExp) { return decodeStringLax(); }
                        foundExp = true;
                        break;
                    case MINUS:
                    case PLUS:
                        if (foundSign || !foundExp) { return decodeStringLax(); }
                        if (foundExp && array[index - 1] != LETTER_E && array[index - 1] != LETTER_BIG_E) {
                            return decodeStringLax();
                        }
                        foundSign = true;
                        break;
                }
                doubleFloat = true;
            } else {
                return decodeStringLax();
            }
            index++;
            if (index >= array.length) break;
        }

        // Handle the case where the exponential number ends without the actual exponent
        if (foundExp) {
            char prevChar = array[index - 1];
            if (prevChar == LETTER_E || prevChar == LETTER_BIG_E || prevChar == MINUS || prevChar == PLUS) {
                return decodeStringLax();
            }
        }

        __index = index;
        __currentChar = currentChar;

        Type type = doubleFloat ? Type.DOUBLE : Type.INTEGER;

        return new NumberValue(chop, type, startIndex, __index, this.charArray);
    }",Decode a number from the string.
"public CandidateList getStatewide(String stateId) throws VoteSmartException, VoteSmartErrorException {
		return api.query(""Officials.getStatewide"", new ArgMap(""stateId"", stateId), CandidateList.class );
	}",Get the list of candidate objects that are in the given state.
"public com.google.privacy.dlp.v2.FixedSizeBucketingConfigOrBuilder
      getFixedSizeBucketingConfigOrBuilder() {
    if (transformationCase_ == 5) {
      return (com.google.privacy.dlp.v2.FixedSizeBucketingConfig) transformation_;
    }
    return com.google.privacy.dlp.v2.FixedSizeBucketingConfig.getDefaultInstance();
  }",Gets the value of the fixedSizeBucketingConfig property.
"private static int parseOffsetISO8601(String text, ParsePosition pos, boolean extendedOnly, Output<Boolean> hasDigitOffset) {
        if (hasDigitOffset != null) {
            hasDigitOffset.value = false;
        }
        int start = pos.getIndex();
        if (start >= text.length()) {
            pos.setErrorIndex(start);
            return 0;
        }

        char firstChar = text.charAt(start);
        if (Character.toUpperCase(firstChar) == ISO8601_UTC.charAt(0)) {
            // ""Z"" - indicates UTC
            pos.setIndex(start + 1);
            return 0;
        }

        int sign;
        if (firstChar == '+') {
            sign = 1;
        } else if (firstChar == '-') {
            sign = -1;
        } else {
            // Not an ISO 8601 offset string
            pos.setErrorIndex(start);
            return 0;
        }
        ParsePosition posOffset = new ParsePosition(start + 1);
        int offset = parseAsciiOffsetFields(text, posOffset, ':', OffsetFields.H, OffsetFields.HMS);
        if (posOffset.getErrorIndex() == -1 && !extendedOnly && (posOffset.getIndex() - start <= 3)) {
            // If the text is successfully parsed as extended format with the options above, it can be also parsed
            // as basic format. For example, ""0230"" can be parsed as offset 2:00 (only first digits are valid for
            // extended format), but it can be parsed as offset 2:30 with basic format. We use longer result.
            ParsePosition posBasic = new ParsePosition(start + 1);
            int tmpOffset = parseAbuttingAsciiOffsetFields(text, posBasic, OffsetFields.H, OffsetFields.HMS, false);
            if (posBasic.getErrorIndex() == -1 && posBasic.getIndex() > posOffset.getIndex()) {
                offset = tmpOffset;
                posOffset.setIndex(posBasic.getIndex());
            }
        }

        if (posOffset.getErrorIndex() != -1) {
            pos.setErrorIndex(start);
            return 0;
        }

        pos.setIndex(posOffset.getIndex());
        if (hasDigitOffset != null) {
            hasDigitOffset.value = true;
        }
        return sign * offset;
    }",Parse ISO 8601 offset string.
"@Generated(value = ""com.sun.tools.xjc.Driver"", date = ""2018-10-12T02:54:50+02:00"", comments = ""JAXB RI v2.2.11"")
    public void setBueroTyp(BueroPraxen.BueroTyp value) {
        this.bueroTyp = value;
    }",Sets the value of the bueroTyp property.
"@Override
    public boolean isConnectedTo(IBond bond) {
        for (IAtom atom : atoms) {
            if (bond.contains(atom)) return true;
        }
        return false;
    }",Returns true if this molecule is connected to the given bond.
"private Locale getLocale() {
        Locale userlocale = null;
        if (localeName.length() > 0) {
            int firstuscore = localeName.indexOf('_');
            int seconduscore = -1;
            String language = null;
            String country = null;
            String variant = null;
            if (firstuscore == 2) {
                language = localeName.substring(0, firstuscore);
                seconduscore = localeName.indexOf('_', firstuscore + 1);
                if (seconduscore > 0) {
                    if (seconduscore != firstuscore + 3 ||
                           localeName.length() <= seconduscore + 1) {
                        docenv.error(null, ""main.malformed_locale_name"", localeName);
                        return null;
                    }
                    country = localeName.substring(firstuscore + 1,
                                                   seconduscore);
                    variant = localeName.substring(seconduscore + 1);
                } else if (localeName.length() == firstuscore + 3) {
                    country = localeName.substring(firstuscore + 1);
                } else {
                    docenv.error(null, ""main.malformed_locale_name"", localeName);
                    return null;
                }
            } else if (firstuscore == -1 && localeName.length() == 2) {
                language = localeName;
            } else {
                docenv.error(null, ""main.malformed_locale_name"", localeName);
                return null;
            }
            userlocale = searchLocale(language, country, variant);
            if (userlocale == null) {
                docenv.error(null, ""main.illegal_locale_name"", localeName);
                return null;
            } else {
                return userlocale;
            }
        } else {
            return Locale.getDefault();
        }
    }",Gets the locale.
"@Override
    public STATE onHeadersReceived(HttpResponseHeaders headers) throws Exception {
        if (handshakeOccurred.get()) {
            return super.onHeadersReceived(headers);
        }
        return STATE.CONTINUE;
    }",Override onHeadersReceived to handle headers received by the client.
"public void addChildrenOf(CSTNode of) {
        for (int i = 1; i < of.size(); i++) {
            add(of.get(i));
        }
    }",Add children of another node.
"public void setDestinationResolver(DestinationResolver destinationResolver) {
        Assert.notNull(destinationResolver, ""destinationResolver must not be null"");
        this.jmsTemplate.setDestinationResolver(destinationResolver);
        this.messageListenerContainer.setDestinationResolver(destinationResolver);
    }",Sets the destinationResolver for this localization.
"public static String repeat(final String s, final int repeat) {
        if (s == null) {
            return null;
        }
        if (repeat <= 0) {
            return """";
        }
        final int inputLength = s.length();
        if (repeat == 1 || inputLength == 0) {
            return s;
        }

        final int outputLength = inputLength * repeat;
        switch (inputLength) {
        case 1:
            return repeat(s.charAt(0), repeat);
        case 2:
            final char ch0 = s.charAt(0);
            final char ch1 = s.charAt(1);
            final char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            final StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(s);
            }
            return buf.toString();
        }
    }",Repeats a string in a sequence of times.
"public int convertTo(StringToUniqueIntegerMap other, int localId) {
        if (other == null) {
            throw new IllegalStateException(""Other map is null"");
        }
        String localKey = store.reverseGet(localId);
        if (localKey == null) {
            throw new IllegalArgumentException(""Cannot convert an id that is not registered locally."");
        }

        Integer foreignId = null;

        if (other == this) {
            return localId;
        } else if (other == parent) {
            foreignId = thisToParentMap.get(localId);
        } else if (other.parent == this) {
            foreignId = other.parentToThisMap.get(localId);
        }

        // Cache hit
        if (foreignId != null) {
            return foreignId;
        }

        Integer integerForeignId = other.store.get(localKey);

        // The other map doesn't have an entry for this key
        if (integerForeignId == null) {
            integerForeignId = other.register(localKey);
        }

        // Add the key/value pair to the cache
        if (other == parent) {
            thisToParentMap.set(localId, integerForeignId);
            parentToThisMap.set(integerForeignId, localId);
        } else if (other.parent == this) {
            other.thisToParentMap.set(integerForeignId, localId);
            other.parentToThisMap.set(localId, integerForeignId);
        }

        return integerForeignId;
    }",Convert a String to Unique Integer Map.
"@SuppressWarnings(""Unchecked"")
    public static Object checkImmutable(String className, String fieldName, Object field) {
        if (field == null || field instanceof Enum || inImmutableList(field.getClass().getName())) return field;
        if (field instanceof Collection) return DefaultGroovyMethods.asImmutable((Collection) field);
        if (field.getClass().getAnnotation(MY_CLASS) != null) return field;
        final String typeName = field.getClass().getName();
        throw new RuntimeException(createErrorMessage(className, fieldName, typeName, ""constructing""));
    }",Checks if the field is an immutable field.
"void markAsCollapsedCommand(HystrixCollapserKey collapserKey, int sizeOfBatch) {
        eventNotifier.markEvent(HystrixEventType.COLLAPSED, this.commandKey);
        executionResult = executionResult.markCollapsed(collapserKey, sizeOfBatch);
    }",Mark this command as collapsed.
"public <O extends BaseOption> ArgumentParser add(O option) {
        if (option.getName() != null) {
            if (longNameOptions.containsKey(option.getName())) {
                throw new IllegalArgumentException(""Option "" + option.getName() + "" already exists"");
            }
            if (parent != null && parent.longNameOptions.containsKey(option.getName())) {
                throw new IllegalArgumentException(""Option "" + option.getName() + "" already exists in parent"");
            }

            longNameOptions.put(option.getName(), option);
        }

        if (option instanceof Flag) {
            String negate = ((Flag) option).getNegateName();
            if (negate != null) {
                if (longNameOptions.containsKey(negate)) {
                    throw new IllegalArgumentException(""Flag "" + negate + "" already exists"");
                }
                if (parent != null && parent.longNameOptions.containsKey(negate)) {
                    throw new IllegalArgumentException(""Flag "" + negate + "" already exists in parent"");
                }

                longNameOptions.put(negate, option);
            }
        }

        if (option.getShortNames()
                  .length() > 0) {
            for (char s : option.getShortNames()
                                .toCharArray()) {
                if (shortOptions.containsKey(s)) {
                    throw new IllegalArgumentException(""Short option -"" + s + "" already exists"");
                }
                if (parent != null && parent.shortOptions.containsKey(s)) {
                    throw new IllegalArgumentException(""Short option -"" + s + "" already exists in parent"");
                }

                shortOptions.put(s, option);
            }
        }

        this.options.add(option);
        return this;
    }",Add an option to the command line.
"public List<IAtom> getRgroupQueryAtoms(Integer rgroupNumber) {

        List<IAtom> rGroupQueryAtoms = null;

        if (rootStructure != null) {
            rGroupQueryAtoms = new ArrayList<IAtom>();

            for (int i = 0; i < rootStructure.getAtomCount(); i++) {
                IAtom atom = rootStructure.getAtom(i);
                if (atom instanceof IPseudoAtom) {
                    IPseudoAtom rGroup = (IPseudoAtom) atom;
                    if (!rGroup.getLabel().equals(""R"")
                            && // just ""R"" is not a proper query atom
                            rGroup.getLabel().startsWith(""R"")
                            && (rgroupNumber == null || Integer.valueOf(rGroup.getLabel().substring(1)).equals(
                                    rgroupNumber))) rGroupQueryAtoms.add(atom);
                }
            }
        }
        return rGroupQueryAtoms;
    }",Get the Rgroup query atoms.
"public ServiceFuture<List<RecommendationInner>> listRecommendedRulesForWebAppAsync(final String resourceGroupName, final String siteName, final Boolean featured, final String filter, final ListOperationCallback<RecommendationInner> serviceCallback) {
        return AzureServiceFuture.fromPageResponse(
            listRecommendedRulesForWebAppSinglePageAsync(resourceGroupName, siteName, featured, filter),
            new Func1<String, Observable<ServiceResponse<Page<RecommendationInner>>>>() {
                @Override
                public Observable<ServiceResponse<Page<RecommendationInner>>> call(String nextPageLink) {
                    return listRecommendedRulesForWebAppNextSinglePageAsync(nextPageLink);
                }
            },
            serviceCallback);
    }",List recommended rules for an App Service Environment.
"@TargetApi(Build.VERSION_CODES.HONEYCOMB_MR2)
    public static boolean hasPortraitScreenFeature(Context context) {
        return hasPortraitScreenFeature(context.getPackageManager());
    }",Check if the application has a homespan screen feature.
"public void close() throws IOException {
		writer.write(""</rdf:RDF>"");
		writer.write(""</x:xmpmeta>\n"");
		for (int i = 0; i < extraSpace; i++) {
			writer.write(EXTRASPACE);
		}
		writer.write(end == 'r' ? XPACKET_PI_END_R : XPACKET_PI_END_W);
		writer.flush();
		writer.close();
	}",Writes the RDF and XMP meta data to the output stream.
"@Override
    public DeploymentPlanBuilder andDeploy() {
        String addedKey = getAddedContentKey();
        DeploymentActionImpl deployMod = DeploymentActionImpl.getDeployAction(addedKey);
        return new DeploymentPlanBuilderImpl(this, deployMod);
    }",Create a new DeploymentPlanBuilder and deploy the content key.
"void set3(int newPrice, int optCur, int back2, int len2, int back) {
        price = newPrice;
        optPrev = optCur + len2 + 1;
        backPrev = back;
        prev1IsLiteral = true;
        hasPrev2 = true;
        optPrev2 = optCur;
        backPrev2 = back2;
    }",Set the 3 - tuple of tokens.
"private synchronized ReceiveAllowedThread getReceiveAllowedThread(DestinationHandler destinationHandler)
    {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.entry(tc, ""getReceiveAllowedThread"", destinationHandler);

        if (_receiveAllowedThread == null)
        {
            _receiveAllowedThread = new ReceiveAllowedThread(destinationHandler);
            if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
                SibTr.exit(tc, ""getReceiveAllowedThread"", _receiveAllowedThread);

            return _receiveAllowedThread;
        }

        _receiveAllowedThread.markForUpdate();
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.exit(tc, ""getReceiveAllowedThread"", null);
        return null;
    }",Gets the ReceiveAllowedThread object.
"public User get(String loginname, String password) {
        Connection conn = null;
        User user = null;
        if (loginname == null || password == null) return null;
        String cryptpassword = MD5.encodeString(password,null);
        try {
            conn = ConnectionUtils.getConnection();
            user = userDAO.get(conn,loginname,cryptpassword);
        } catch(SQLException e) {
            logger.error(e.getMessage());
        } finally {
            DbUtils.closeQuietly(conn);
        }
        return user;
    }",Get a user from the database.
"public static void elementPower(double a , DMatrixD1 B , DMatrixD1 C ) {

        if( B.numRows != C.numRows || B.numCols != C.numCols ) {
            throw new MatrixDimensionException(""All matrices must be the same shape"");
        }

        int size = B.getNumElements();
        for( int i = 0; i < size; i++ ) {
            C.data[i] = Math.pow(a, B.data[i]);
        }
    }",This method convert a double to element power.
"public void changePassword(String newPassword) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
        if (!connection().isSecureConnection() && !allowSensitiveOperationOverInsecureConnection) {
            throw new IllegalStateException(""Changing password over insecure connection."");
        }
        Map<String, String> map = new HashMap<>();
        map.put(""username"",  connection().getUser().getLocalpart().toString());
        map.put(""password"",newPassword);
        Registration reg = new Registration(map);
        reg.setType(IQ.Type.set);
        reg.setTo(connection().getXMPPServiceDomain());
        createStanzaCollectorAndSend(reg).nextResultOrThrow();
    }",Change the password of a user.
"public boolean isTriggeringEvent(LoggingEvent event) {
    //
    //   in the abnormal case of no contained filters
    //     always return true to avoid each logging event
    //     from having its own file.
    if (headFilter == null) {
      return false;
    }

    //
    //    otherwise loop through the filters
    //
    for (Filter f = headFilter; f != null; f = f.next) {
      switch (f.decide(event)) {
      case Filter.DENY:
        return false;

      case Filter.ACCEPT:
        return true;
      }
    }

    return true;
   }",Checks if the event is triggered by the filter
"public static void readLine(final String line, final Map<Long, List<Pair<Long, Double>>> mapUserRecommendations) {
        String[] toks = line.split(""\t"");
        // mymedialite format: user \t [item:score,item:score,...]
        if (line.contains("":"") && line.contains("","")) {
            Long user = Long.parseLong(toks[0]);
            String items = toks[1].replace(""["", """").replace(""]"", """");
            for (String pair : items.split("","")) {
                String[] pairToks = pair.split("":"");
                Long item = Long.parseLong(pairToks[0]);
                Double score = Double.parseDouble(pairToks[1]);
                List<Pair<Long, Double>> userRec = mapUserRecommendations.get(user);
                if (userRec == null) {
                    userRec = new ArrayList<Pair<Long, Double>>();
                    mapUserRecommendations.put(user, userRec);
                }
                userRec.add(new Pair<Long, Double>(item, score));
            }
        } else {
            Long user = Long.parseLong(toks[0]);
            Long item = Long.parseLong(toks[1]);
            Double score = Double.parseDouble(toks[2]);
            List<Pair<Long, Double>> userRec = mapUserRecommendations.get(user);
            if (userRec == null) {
                userRec = new ArrayList<Pair<Long, Double>>();
                mapUserRecommendations.put(user, userRec);
            }
            userRec.add(new Pair<Long, Double>(item, score));
        }
    }",Read a line of CRA - CRA related information.
"public CmsGroup getParent(CmsDbContext dbc, String groupname) throws CmsException {

        CmsGroup group = readGroup(dbc, groupname);
        if (group.getParentId().isNullUUID()) {
            return null;
        }

        // try to read from cache
        CmsGroup parent = m_monitor.getCachedGroup(group.getParentId().toString());
        if (parent == null) {
            parent = getUserDriver(dbc).readGroup(dbc, group.getParentId());
            m_monitor.cacheGroup(parent);
        }
        return parent;
    }",Returns the parent group of the given name.
"@Override
	public EClass getIfcCrewResource() {
		if (ifcCrewResourceEClass == null) {
			ifcCrewResourceEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)
					.getEClassifiers().get(154);
		}
		return ifcCrewResourceEClass;
	}",Get the IfcCrewResourceEClass for the ifcCrewResource feature.
"public synchronized void remove()
  {
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.entry(tc, ""remove"");

    if(removable != null)
    {
      index.remove(removable);
    }
    else
    {
      if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
        SibTr.exit(tc, ""remove"", ""IllegalStateException"");
      throw new IllegalStateException(
        nls.getFormattedMessage(
          ""NO_ELEMENTS_ERROR_CWSIP0602"",
          null,
          null));
    }

    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.exit(tc, ""remove"");
  }",Remove a single element from the index.
"public void write(File file, Integer indent) throws TransformerException, IOException {
		write(file, indent, null);
	}",Write the XML document to a file.
"public String getName(int i) {
        if (i < 0 || i >= names.size()) {
            return null;
        }
        return names.get(i);
    }",Gets the name of the i th record.
"@JsonProperty(""e"")
    @JsonSerialize(using = Base64UrlJsonSerializer.class)
    @JsonDeserialize(using = Base64UrlJsonDeserializer.class)
    public byte[] e() {
        return ByteExtensions.clone(this.e);
    }",Get the value of the e property.
"public static MozuUrl deleteAccountContactUrl(Integer accountId, Integer contactId)
	{
		UrlFormatter formatter = new UrlFormatter(""/api/commerce/customer/accounts/{accountId}/contacts/{contactId}"");
		formatter.formatUrl(""accountId"", accountId);
		formatter.formatUrl(""contactId"", contactId);
		return new MozuUrl(formatter.getResourceUrl(), MozuUrl.UrlLocation.TENANT_POD) ;
	}",Get Resource Url for DeleteAccountContact
"protected ModalShownHandler createShownHandler(final DisplayerSettings settings) {

        return new ModalShownHandler() {
            @Override
            public void onShown(ModalShownEvent modalShownEvent) {
                editor.init(settings);
                setTitle(editor.isBrandNewDisplayer() ? newDisplayerTitle : editDisplayerTitle);
                removeShownHandler();
            }
        };
    }",Create the modalShownHandler.
"@Override
    public <T> void apply(final Query<T> query) {
        pathProperties.each(props -> {
            String path = props.getPath();
            String propsStr = props.getPropertiesAsString();

            if (path == null || path.isEmpty()) {
                query.select(propsStr);
            } else {
                query.fetch(path, propsStr);
            }
        });
    }",Apply the filter to a query.
"public static double convertFromCelsius(TemperatureScale to, double temperature) {

        switch(to) {

            case FARENHEIT:
                return convertCelsiusToFarenheit(temperature);
            case CELSIUS:
                return temperature;
            case KELVIN:
                return convertCelsiusToKelvin(temperature);
            case RANKINE:
                return convertCelsiusToRankine(temperature);
            default:
                throw(new RuntimeException(""Invalid termpature conversion""));
        }
    }",Convert from CELSIUS temperature scale to CELSIUS temperature scale.
"private void updateImageInfo() {

        String crop = getCrop();
        String point = getPoint();
        m_imageInfoDisplay.fillContent(m_info, crop, point);
    }",Update the image info display.
"public Response createSystemProperty(SystemProperty property) {
		return restClient.post(""system/properties"", property, new HashMap<String, String>());
	}",Create a system property.
"public final void mUNION() throws RecognitionException {
		try {
			int _type = UNION;
			int _channel = DEFAULT_TOKEN_CHANNEL;
			// hql.g:67:7: ( 'union' )
			// hql.g:67:9: 'union'
			{
			match(""union""); if (state.failed) return;

			}

			state.type = _type;
			state.channel = _channel;
		}
		finally {
			// do for sure before leaving
		}
	}",start UNION
"public static <T> TypeLiteral<T> get(Class<T> type) {
    return new TypeLiteral<T>(type);
  }",Get a type literal for a class.
"public final <A extends Number & Comparable<?>> BooleanExpression lt(Expression<A> right) {
        return Expressions.booleanOperation(Ops.LT, this, right);
    }",Gets the less than expression for this expression
"public static boolean parseBoolean(String bool, boolean defaultInt) {
        if (bool == null) {
            return defaultInt;
        } else {
            return Boolean.parseBoolean(bool);
        }
    }",Parse boolean.
"protected <T> T getPropertyOrStaticPropertyOrFieldValue(String name, Class<T> type) {
        return ClassPropertyFetcher.getStaticPropertyValue(getClazz(), name, type);
    }",Gets the property or static property or field value.
"@Override
    public int removeProperties(String pattern, Character escape) throws Exception {
        StringBuilder delete = new StringBuilder(58)
                        .append(""DELETE FROM Property WHERE ID LIKE :pattern"");
        if (escape != null)
            delete.append("" ESCAPE :escape"");

        final boolean trace = TraceComponent.isAnyTracingEnabled();
        if (trace && tc.isEntryEnabled())
            Tr.entry(this, tc, ""removeProperties"", pattern, escape, delete);

        EntityManager em = getPersistenceServiceUnit().createEntityManager();
        try {
            Query query = em.createQuery(delete.toString());
            query.setParameter(""pattern"", pattern);
            if (escape != null)
                query.setParameter(""escape"", escape);
            int count = query.executeUpdate();

            if (trace && tc.isEntryEnabled())
                Tr.exit(this, tc, ""removeProperties"", count);
            return count;
        } finally {
            em.close();
        }
    }",Removes all properties matching the specified pattern from the database.
"public <E> E deserialize(final String str, final Class<E> type, final Collection<Converter<?>> converters) {
        logger.debug(""deserialize(\""{}\"", {})"", str, type);

        if (converters == null || converters.isEmpty()) {
            // when possible, just reuse the base converter
            @SuppressWarnings(""unchecked"") final E result = (E) _baseConverter.fromString(type, str);
            return result;
        }

        final DelegatingConverter delegatingConverter = new DelegatingConverter();

        if (converters != null) {
            for (final Converter<?> converter : converters) {
                delegatingConverter.addConverter(converter);
                delegatingConverter.initialize(converter, _injectionManager);
            }
        }

        final List<Converter<?>> baseconverters = _baseConverter.getConverters();
        for (final Converter<?> converter : baseconverters) {
            delegatingConverter.addConverter(converter);
        }

        @SuppressWarnings(""unchecked"") final E result = (E) delegatingConverter.fromString(type, str);
        return result;
    }",Deserialize the given string into an object of the specified type using the given converters.
"@SafeVarargs
    public final PromiseAggregator<V, F> add(Promise<V>... promises) {
        if (promises == null) {
            throw new NullPointerException(""promises"");
        }
        if (promises.length == 0) {
            return this;
        }
        synchronized (this) {
            if (pendingPromises == null) {
                int size;
                if (promises.length > 1) {
                    size = promises.length;
                } else {
                    size = 2;
                }
                pendingPromises = new LinkedHashSet<Promise<V>>(size);
            }
            for (Promise<V> p : promises) {
                if (p == null) {
                    continue;
                }
                pendingPromises.add(p);
                p.addListener(this);
            }
        }
        return this;
    }",Add a list of Promises to the aggregator.
"public IfcWallTypeEnum createIfcWallTypeEnumFromString(EDataType eDataType, String initialValue) {
		IfcWallTypeEnum result = IfcWallTypeEnum.get(initialValue);
		if (result == null)
			throw new IllegalArgumentException(
					""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");
		return result;
	}",Converts a String to a IfcWallTypeEnum object.
"@SuppressFBWarnings(value = ""DM_DEFAULT_ENCODING"", justification = ""Open TODO item for wider rework"")
    @Override
    protected void eol(byte[] bytes, int len) throws IOException {
        String line = new String(bytes, 0, len);
        if(passwordsAsPattern != null) {
            line = passwordsAsPattern.matcher(line).replaceAll(MASKED_PASSWORD);
        }
        logger.write(line.getBytes());
    }",Write a line of bytes.
"public void setTerminal(AbstractUDPTerminal terminal) {
        this.terminal = terminal;
        if (terminal.isActive()) {
            transport = terminal.getTransport();
        }
    }",Sets the terminal.
"protected int getTransactionIsolation() {
		String val = props.get(PROPS_TRANSACTION_ISOLATION);
		return val == null ? -1 : Integer.parseInt(val);
	}",Returns the transaction isolation level.
"@Override
    public String getText() {
        String retType = AstToTextHelper.getClassText(returnType);
        String exceptionTypes = AstToTextHelper.getThrowsClauseText(exceptions);
        String parms = AstToTextHelper.getParametersText(parameters);
        return AstToTextHelper.getModifiersText(modifiers) + "" "" + retType + "" "" + name + ""("" + parms + "") "" + exceptionTypes + "" { ... }"";
    }",Get the text of the exception.
"private void getImportResource() throws CmsVfsException {

        // get the import resource
        m_importResource = new File(m_importFolderName);
        // check if this is a folder or a ZIP file
        if (m_importResource.isFile()) {
            try {
                m_zipStreamIn = new ZipInputStream(new FileInputStream(m_importResource));
            } catch (IOException e) {
                // if file but no ZIP file throw an exception
                throw new CmsVfsException(
                    Messages.get().container(Messages.ERR_NO_ZIPFILE_1, m_importResource.getName()),
                    e);
            }
        }
    }",Get the import resource.
"public static ImmoXmlDocument newDocument(Immoxml immoxml) throws ParserConfigurationException, JAXBException {
        if (immoxml.getUebertragung() == null)
            immoxml.setUebertragung(ImmoXmlUtils.getFactory().createUebertragung());
        if (StringUtils.isBlank(immoxml.getUebertragung().getVersion()))
            immoxml.getUebertragung().setVersion(ImmoXmlUtils.VERSION.toReadableVersion());

        Document document = XmlUtils.newDocument();
        ImmoXmlUtils.createMarshaller(""UTF-8"", true).marshal(immoxml, document);
        return new ImmoXmlDocument(document);
    }",Create a new document from an immoxml object.
"public static ResourceMeta withStream(final HasInputStream stream, final Map<String, String> meta) {
        return new BaseStreamResource(meta,stream);
    }",Create a new stream resource.
"public InputStream getInputStream() {
        if (m_requestEntity.length == 0) {
            return null;
        }
        ByteArrayInputStream bis = new ByteArrayInputStream(m_requestEntity);
        InputStream inStream = bis;
        if (m_bEntityCompressed) {
            try {
                inStream = new GZIPInputStream(bis);
            } catch (IOException e) {
                throw new IllegalArgumentException(""Error decompressing input: "" + e.toString());
            }
        }
        return inStream;
    }",Returns an input stream for the HTTP request entity.
"public boolean canFilter(Example example)
    {
        Example result = example;

        if (result == null) return false;

        if (isBeginTag(result) || isEndTag(result)) return true;
        else if (!lazyMode) return false;

        if (isEndTag(getNextTag(result)))
            return false;
        
        return !isWithinBeginAndEndTags(result);
    }",Checks if the example can be filtered by the CIDCTYPE filter.
"public static void cublasCherk(char uplo, char trans, int n, int k, float alpha, Pointer A, int lda, float beta, Pointer C, int ldc)
    {
        cublasCherkNative(uplo, trans, n, k, alpha, A, lda, beta, C, ldc);
        checkResultBLAS();
    }",Cublas Cherk for a symmetric matrix.
"private static boolean isCollectionMatching(Joinable mainSideJoinable, OgmCollectionPersister inverseSidePersister) {
		boolean isSameTable = mainSideJoinable.getTableName().equals( inverseSidePersister.getTableName() );

		if ( !isSameTable ) {
			return false;
		}

		return Arrays.equals( mainSideJoinable.getKeyColumnNames(), inverseSidePersister.getElementColumnNames() );
	}",Checks if the given joinable and inverse persister are matching.
"void genCode() throws IOException {
        if (!outputDirectory.exists()) {
            if (!outputDirectory.mkdirs()) {
                throw new IOException(""unable to create output directory ""
                        + outputDirectory);
            }
        }
        FileWriter cc = new FileWriter(new File(outputDirectory, mName + "".cc""));
        FileWriter hh = new FileWriter(new File(outputDirectory, mName + "".hh""));

        hh.write(""/**\n"");
        hh.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
        hh.write(""* or more contributor license agreements.  See the NOTICE file\n"");
        hh.write(""* distributed with this work for additional information\n"");
        hh.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
        hh.write(""* to you under the Apache License, Version 2.0 (the\n"");
        hh.write(""* \""License\""); you may not use this file except in compliance\n"");
        hh.write(""* with the License.  You may obtain a copy of the License at\n"");
        hh.write(""*\n"");
        hh.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
        hh.write(""*\n"");
        hh.write(""* Unless required by applicable law or agreed to in writing, software\n"");
        hh.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
        hh.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
        hh.write(""* See the License for the specific language governing permissions and\n"");
        hh.write(""* limitations under the License.\n"");
        hh.write(""*/\n"");
        hh.write(""\n"");

        cc.write(""/**\n"");
        cc.write(""* Licensed to the Apache Software Foundation (ASF) under one\n"");
        cc.write(""* or more contributor license agreements.  See the NOTICE file\n"");
        cc.write(""* distributed with this work for additional information\n"");
        cc.write(""* regarding copyright ownership.  The ASF licenses this file\n"");
        cc.write(""* to you under the Apache License, Version 2.0 (the\n"");
        cc.write(""* \""License\""); you may not use this file except in compliance\n"");
        cc.write(""* with the License.  You may obtain a copy of the License at\n"");
        cc.write(""*\n"");
        cc.write(""*     http://www.apache.org/licenses/LICENSE-2.0\n"");
        cc.write(""*\n"");
        cc.write(""* Unless required by applicable law or agreed to in writing, software\n"");
        cc.write(""* distributed under the License is distributed on an \""AS IS\"" BASIS,\n"");
        cc.write(""* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n"");
        cc.write(""* See the License for the specific language governing permissions and\n"");
        cc.write(""* limitations under the License.\n"");
        cc.write(""*/\n"");
        cc.write(""\n"");

        hh.write(""#ifndef __"" + mName.toUpperCase().replace('.', '_') + ""__\n"");
        hh.write(""#define __"" + mName.toUpperCase().replace('.', '_') + ""__\n"");

        hh.write(""#include \""recordio.hh\""\n"");
        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext();) {
            JFile f = i.next();
            hh.write(""#include \"""" + f.getName() + "".hh\""\n"");
        }
        cc.write(""#include \"""" + mName + "".hh\""\n"");

        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext();) {
            JRecord jr = i.next();
            jr.genCppCode(hh, cc);
        }

        hh.write(""#endif //"" + mName.toUpperCase().replace('.', '_') + ""__\n"");

        hh.close();
        cc.close();
    }",Generate the code for the class.
"public UNode toDoc() {
        // Root object is a MAP called ""batch"".
        UNode batchNode = UNode.createMapNode(""batch"");
        
        // Add a ""docs"" node as an array.
        UNode docsNode = batchNode.addArrayNode(""docs"");
        for (DBObject dbObj : m_dbObjList) {
            docsNode.addChildNode(dbObj.toDoc());
        }
        return batchNode;
    }",Returns a UNode tree representing the object in this DBObjectList as a MAP.
"public Link expand(Map<String, ? extends Object> arguments) {
		return new Link(template.expand(arguments).toString(), getRel());
	}",Expand the template with the given arguments.
"public List<Runnable> shutdownNow() {
        List<Runnable> tasks;
        final ReentrantLock mainLock = this.mainLock;
        mainLock.lock();
        try {
            /* J2ObjC removed.
            checkShutdownAccess();
            */
            advanceRunState(STOP);
            interruptWorkers();
            tasks = drainQueue();
        } finally {
            mainLock.unlock();
        }
        tryTerminate();
        return tasks;
    }",Shutdown the thread.
"private String findContainerId(String imageNameOrAlias, boolean checkAllContainers) throws DockerAccessException {
        String id = lookupContainer(imageNameOrAlias);

        // check for external container. The image name is interpreted as a *container name* for that case ...
        if (id == null) {
            Container container = queryService.getContainer(imageNameOrAlias);
            if (container != null && (checkAllContainers || container.isRunning())) {
                id = container.getId();
            }
        }
        return id;
    }",Find the container id for the image name or alias.
"public String getOauthPageUrl(String redirectUrl, OauthScope scope, String state) {
        BeanUtil.requireNonNull(redirectUrl, ""redirectUrl is null"");
        BeanUtil.requireNonNull(scope, ""scope is null"");
        String userState = StrUtil.isBlank(state) ? ""STATE"" : state;
        String url = null;
        try {
            url = URLEncoder.encode(redirectUrl, ""UTF-8"");
        } catch (UnsupportedEncodingException e) {
            LOG.error(""异常"", e);
        }
        StringBuilder stringBuilder = new StringBuilder(""https://open.weixin.qq.com/connect/oauth2/authorize?"");
        stringBuilder.append(""appid="").append(this.config.getAppid())
                .append(""&redirect_uri="").append(url)
                .append(""&response_type=code&scope="").append(scope.toString())
                .append(""&state="")
                .append(userState)
                .append(""#wechat_redirect"");
        return stringBuilder.toString();
    }",Gets the authorization page url.
"public static Scopes from(String... scopes)
    {
        if (scopes == null || scopes.length == 0) return NONE;
        return new Scopes(scopes, true);
    }",Creates a new Scopes object from the given list of scopes.
"void compressNew(PointList points, int removed) {
        int freeIndex = -1;
        for (int currentIndex = 0; currentIndex < points.getSize(); currentIndex++) {
            if (Double.isNaN(points.getLatitude(currentIndex))) {
                if (freeIndex < 0)
                    freeIndex = currentIndex;

                continue;
            } else if (freeIndex < 0) {
                continue;
            }

            points.set(freeIndex, points.getLatitude(currentIndex), points.getLongitude(currentIndex), points.getElevation(currentIndex));
            points.set(currentIndex, Double.NaN, Double.NaN, Double.NaN);
            // find next free index
            int max = currentIndex;
            int searchIndex = freeIndex + 1;
            freeIndex = currentIndex;
            for (; searchIndex < max; searchIndex++) {
                if (Double.isNaN(points.getLatitude(searchIndex))) {
                    freeIndex = searchIndex;
                    break;
                }
            }
        }
        points.trimToSize(points.getSize() - removed);
    }",Compress new points.
"@Override
	public CPDefinition create(long CPDefinitionId) {
		CPDefinition cpDefinition = new CPDefinitionImpl();

		cpDefinition.setNew(true);
		cpDefinition.setPrimaryKey(CPDefinitionId);

		String uuid = PortalUUIDUtil.generate();

		cpDefinition.setUuid(uuid);

		cpDefinition.setCompanyId(companyProvider.getCompanyId());

		return cpDefinition;
	}",Creates a new cp definition in the database. Also sets the new flag to true.
"public AttributeDataset parse(InputStream stream) throws IOException, ParseException {
        try (Reader r = new BufferedReader(new InputStreamReader(stream))) {
            StreamTokenizer tokenizer = new StreamTokenizer(r);
            initTokenizer(tokenizer);

            List<Attribute> attributes = new ArrayList<>();
            String relationName = readHeader(tokenizer, attributes);

            if (attributes.isEmpty()) {
                throw new IOException(""no header information available"");
            }
        
            Attribute response = null;
            Attribute[] attr = new Attribute[attributes.size()];
            attributes.toArray(attr);
        
            for (int i = 0; i < attributes.size(); i++) {
                if (responseIndex == i) {
                    response = attributes.remove(i);
                    break;
                }
            }
        
            AttributeDataset data = new AttributeDataset(relationName, attributes.toArray(new Attribute[attributes.size()]), response);
        
            while (true) {
                // Check if end of file reached.
                getFirstToken(tokenizer);
                if (tokenizer.ttype == StreamTokenizer.TT_EOF) {
                    break;
                }

                // Parse instance
                if (tokenizer.ttype == '{') {
                    readSparseInstance(tokenizer, data, attr);
                } else {
                    readInstance(tokenizer, data, attr);
                }
            }
        
            for (Attribute attribute : attributes) {
                if (attribute instanceof NominalAttribute) {
                    NominalAttribute a = (NominalAttribute) attribute;
                    a.setOpen(false);
                }
            
                if (attribute instanceof StringAttribute) {
                    StringAttribute a = (StringAttribute) attribute;
                    a.setOpen(false);
                }
            }
        
            return data;
        }
    }",Parses the specified input stream.
"public static void copyParagraphAnnotations(JCas source, JCas target)
            throws IllegalArgumentException
    {
        if (!source.getDocumentText().equals(target.getDocumentText())) {
            throw new IllegalArgumentException(
                    ""source.documentText and target.documentText are not equal"");
        }

        Collection<Paragraph> targetParagraphs = JCasUtil.select(target, Paragraph.class);
        if (!targetParagraphs.isEmpty()) {
            throw new IllegalArgumentException(""target already contains paragraph annotations"");
        }

        for (Paragraph paragraph : JCasUtil.select(source, Paragraph.class)) {
            Paragraph paragraphCopy = new Paragraph(target);
            paragraphCopy.setBegin(paragraph.getBegin());
            paragraphCopy.setEnd(paragraph.getEnd());
            paragraphCopy.addToIndexes();
        }
    }",Copy Paragraph annotations from source to target.
"protected Object getValue(Object value, ComparisonType type) {
        return type == ComparisonType.NODE_TYPE ? nodeType((Short) value) : value;
    }",Get the value of the attribute.
"public final void mVOID() throws RecognitionException {
        try {
            int _type = VOID;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // com/dyuproject/protostuff/parser/ProtoLexer.g:223:5: ( 'void' )
            // com/dyuproject/protostuff/parser/ProtoLexer.g:223:9: 'void'
            {
            match(""void""); 


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }",start void
"@SuppressWarnings(""unchecked"")
	@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case AfplibPackage.PPORG__RG_LENGTH:
				setRGLength((Integer)newValue);
				return;
			case AfplibPackage.PPORG__OBJ_TYPE:
				setObjType((Integer)newValue);
				return;
			case AfplibPackage.PPORG__PROC_FLGS:
				setProcFlgs((Integer)newValue);
				return;
			case AfplibPackage.PPORG__XOCA_OSET:
				setXocaOset((Integer)newValue);
				return;
			case AfplibPackage.PPORG__YOCA_OSET:
				setYocaOset((Integer)newValue);
				return;
			case AfplibPackage.PPORG__TRIPLETS:
				getTriplets().clear();
				getTriplets().addAll((Collection<? extends Triplet>)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}",Override the eSet method for the featureID
"private String getElementID(final String relativePath) {
        final String fragment = getFragment(relativePath);
        if (fragment != null) {
            if (fragment.lastIndexOf(SLASH) != -1) {
                return fragment.substring(fragment.lastIndexOf(SLASH) + 1);
            } else {
                return fragment;
            }
        }
        return null;
    }",Gets the element ID from the relative path.
"public static SelectColumn includes(String[] cols, String... columns) {
        return new SelectColumn(Utility.append(cols, columns), false);
    }",Creates a SelectColumn that includes the specified columns.
"@NullableDecl
  static <T> T pollNext(Iterator<T> iterator) {
    if (iterator.hasNext()) {
      T result = iterator.next();
      iterator.remove();
      return result;
    } else {
      return null;
    }
  }",Polls the next element from the iterator.
"private void increment(final Calendar cal) {
        // initialise interval..
        final int calInterval = (getInterval() >= 1) ? getInterval() : 1;
        cal.add(calIncField, calInterval);
    }",Increments the calendar by the value of the interval field.
"@Override
	public CommerceOrderNote fetchByC_R_Last(long commerceOrderId,
		boolean restricted,
		OrderByComparator<CommerceOrderNote> orderByComparator) {
		int count = countByC_R(commerceOrderId, restricted);

		if (count == 0) {
			return null;
		}

		List<CommerceOrderNote> list = findByC_R(commerceOrderId, restricted,
				count - 1, count, orderByComparator);

		if (!list.isEmpty()) {
			return list.get(0);
		}

		return null;
	}",Returns the last commerce order note in the ordered set where C_R = 1
"public static Point2i convert(Tuple2D<?> tuple) {
		if (tuple instanceof Point2i) {
			return (Point2i) tuple;
		}
		return new Point2i(tuple.getX(), tuple.getY());
	}",Convert the given tuple to a real Point2i.
"protected Response getWithAccepts(MultivaluedMap<String, String> queryParams, URL url, String accepts) {
        return (invocation(url, queryParams, accepts).get());
    }",Get a response with the given query parameters and URL
"protected void stopJobAcquisitionThread() {
    if (asyncJobAcquisitionThread != null) {
      try {
        asyncJobAcquisitionThread.join();
      } catch (InterruptedException e) {
        log.warn(""Interrupted while waiting for the async job acquisition thread to terminate"", e);
      }
      asyncJobAcquisitionThread = null;
    }
  }",Stop the async job acquisition thread
"public static Element getChild(Element element, String name) {
        return (Element) element.getElementsByTagName(name).item(0);
    }",Get the first child element with the given name.
"protected void initMojoMultiValueParameters() {

		// Set default values for 'checkFileSets' to ""src/main/resources/*.btdesign""
		if (checkFileSets == null) {
			FileSet defaultFileSet = new FileSet();
			defaultFileSet.setDirectory(project.getBasedir() + ""/src/main/resources"");
			defaultFileSet.addInclude(""*.btdesign"");
			checkFileSets = new FileSet[] { defaultFileSet };
		}
	}",Initialize the multi - value parameters.
"public Set<Class<? extends Exception>> getRecoverableExceptions() {
    return recoverableExceptions != null ? recoverableExceptions : parent != null ? parent.getRecoverableExceptions()
      : Collections.<Class<? extends Exception>>emptySet();
  }",Returns the set of recoverable exceptions.
"public Coordinate getCoordinateN(int n) {
		if (isEmpty()) {
			return null;
		}
		if (n >= 0 && n < coordinates.length) {
			return coordinates[n];
		}
		return null;
	}",Get the n - th coordinate in this list.
"@Override
	public Integer next() {
		if (!hasNext()) {
			throw new NoSuchElementException(toString() + "" ended"");
		}

		current = next;
		next = next + increment;

		return current();
	}",Returns the next value in the iterator.
"protected void writeIndent() throws IOException {
		final int start = writeLineSepartor ? 0 : offsetNewLine;
		final int level = (depth > maxIndentLevel) ? maxIndentLevel : depth;
		out.write(indentationBuf, start, ((level - 1) * indentationJump) + offsetNewLine);
	}",Write indentation.
"public final static String process(final File file, final Configuration configuration) throws IOException
    {
        final FileInputStream input = new FileInputStream(file);
        final String ret = process(input, configuration);
        input.close();
        return ret;
    }",Process a file containing a CIDCTYPE file.
"@GetMapping(value = ""/{entityTypeId}/exist"", produces = APPLICATION_JSON_VALUE)
  public boolean entityExists(@PathVariable(""entityTypeId"") String entityTypeId) {
    return dataService.hasRepository(entityTypeId);
  }",Checks if entity exists.
"public ResultsWrapper<Issue> getIssues(Params parameters) throws RedmineException {
        return transport.getObjectsListNoPaging(Issue.class, parameters.getList());
    }",Gets the issues.
"public void openGalleryDialog(CmsResource resource) {

        try {
            CmsObject cms = A_CmsUI.getCmsObject();
            JSONObject conf = new JSONObject();
            conf.put(I_CmsGalleryProviderConstants.CONFIG_GALLERY_MODE, GalleryMode.view.name());
            conf.put(I_CmsGalleryProviderConstants.CONFIG_GALLERY_PATH, cms.getSitePath(resource));
            conf.put(I_CmsGalleryProviderConstants.CONFIG_GALLERY_STORAGE_PREFIX, """");
            conf.put(I_CmsGalleryProviderConstants.CONFIG_TAB_CONFIG, CmsGalleryTabConfiguration.TC_SELECT_ALL);
            getRpcProxy(I_CmsGwtDialogClientRpc.class).openGalleryDialog(conf.toString());
        } catch (JSONException e) {
            CmsErrorDialog.showErrorDialog(e);
        }
    }",Open the gallery dialog for the given resource.
"public final V set(int index, K key, V value) {
    if (index < 0) {
      throw new IndexOutOfBoundsException();
    }
    int minSize = index + 1;
    ensureCapacity(minSize);
    int dataIndex = index << 1;
    V result = valueAtDataIndex(dataIndex + 1);
    setData(dataIndex, key, value);
    if (minSize > this.size) {
      this.size = minSize;
    }
    return result;
  }",Sets the value at the given index.
"public static VectorNd normalizeSafe(VectorNd v) {
        try {
            return v.normalize();
        } catch (ArithmeticException ex) {
            return new VectorNd(v.size());
        }
    }",Normalize a vector.
"public void setSecond(Integer newSecond) {
		Integer oldSecond = second;
		second = newSecond;
		if (eNotificationRequired())
			eNotify(new ENotificationImpl(this, Notification.SET, AfplibPackage.UNIVERSAL_DATE_AND_TIME_STAMP__SECOND, oldSecond, second));
	}",Sets the second value.
"<E> Observable<E> addLogging(@NonNull Observable<E> obs, @NonNull Logger log, final String msg) {
        return obs.doOnNext(r -> log(log, (ComapiResult) r, msg))
                .doOnError(t -> log(log, t, msg));
    }",Add logging to an observable.
"private static List<MutableDoubleTuple> validate(
        Collection<? extends DoubleTuple> inputs,
        List<MutableDoubleTuple> results)
    {
        if (results == null)
        {
            results = new ArrayList<MutableDoubleTuple>(inputs.size());
            for (DoubleTuple input : inputs)
            {
                results.add(DoubleTuples.create(input.getSize()));
            }
        }
        else
        {
            if (inputs.size() != results.size())
            {
                throw new IllegalArgumentException(
                    ""The number of inputs ("" + inputs.size() + "") must "" +
                    ""be the same as the number of results "" +
                    ""("" + results.size() + "")"");
            }
        }
        return results;
    }",Validates the input list and results.
"public EvalError toEvalError(
        String msg, SimpleNode node, CallStack callstack  )
    {
        if ( null == msg )
            msg = this.getMessage();
        else
            msg += "": "" + this.getMessage();

        return new TargetError( msg, this.getCause(), node, callstack, false );
    }",To EvalError.
"public boolean isSet(_Fields field) {
    if (field == null) {
      throw new IllegalArgumentException();
    }

    switch (field) {
    case NUM_CPUS:
      return isSetNumCpus();
    case NETWORK_MBPS:
      return isSetNetworkMBps();
    case MEMORY_MB:
      return isSetMemoryMB();
    case DISK_GB:
      return isSetDiskGB();
    }
    throw new IllegalStateException();
  }",Checks if the specified field is set to a value of a CRA_Compute_Product_Group object.
"public Object invokeMethod(String name, Object args) {
        boolean notExpectedArgs = false;
        if (args != null && Object[].class.isAssignableFrom(args.getClass())) {
            Object[] arr = (Object[]) args;
            try {
                switch(arr.length) {
                    case 0:
                        call(name);
                    break;
                    case 1:
                        if (arr[0] instanceof Closure) {
                            final Closure callable = (Closure) arr[0];
                            call(name, callable);
                        } else if (arr[0] instanceof Map) {
                            final Map<String, Map> map = Collections.singletonMap(name, (Map) arr[0]);
                            call(map);
                        } else {
                            notExpectedArgs = true;
                        }
                    break;
                    case 2:
                        final Object first = arr[0];
                        final Object second = arr[1];
                        final boolean isClosure = second instanceof Closure;

                        if(isClosure && first instanceof Map ) {
                            final Closure callable = (Closure) second;
                            call(name, (Map)first, callable);
                        }
                        else if(isClosure && first instanceof Iterable) {
                            final Iterable coll = (Iterable) first;
                            final Closure callable = (Closure) second;
                            call(name, coll, callable);
                        }
                        else if(isClosure && first.getClass().isArray()) {
                            final Iterable coll = Arrays.asList((Object[])first);
                            final Closure callable = (Closure) second;
                            call(name, coll, callable);
                        }
                        else {
                            notExpectedArgs = true;
                        }
                    break;
                    default:
                        notExpectedArgs = true;
                }
            } catch (IOException ioe) {
                throw new JsonException(ioe);
            }
        } else {
            notExpectedArgs = true;
        }

        if (!notExpectedArgs) {
            return this;
        } else {
            throw new JsonException(""Expected no arguments, a single map, a single closure, or a map and closure as arguments."");
        }
    }",This method is called by the reflection to call a method on the class that is passed as parameter.
"public ListApplicationVersionsResult withVersions(VersionSummary... versions) {
        if (this.versions == null) {
            setVersions(new java.util.ArrayList<VersionSummary>(versions.length));
        }
        for (VersionSummary ele : versions) {
            this.versions.add(ele);
        }
        return this;
    }",A list of the versions of the application.
"public Observable<Void> createOrUpdateAsync(String vaultName, String resourceGroupName, String fabricName, String containerName, String protectedItemName, ProtectedItemResourceInner parameters) {
        return createOrUpdateWithServiceResponseAsync(vaultName, resourceGroupName, fabricName, containerName, protectedItemName, parameters).map(new Func1<ServiceResponse<Void>, Void>() {
            @Override
            public Void call(ServiceResponse<Void> response) {
                return response.body();
            }
        });
    }",Creates or updates a CDNA resource.
"@Override
    public void close() {
        namedParamSqlCache.clear();
        namedParamIndexPropCache.clear();
        clearStatementCache();
        if (useConnection != null) {
            try {
                useConnection.close();
            } catch (SQLException e) {
                LOG.finest(""Caught exception closing connection: "" + e.getMessage());
            }
        }
    }",Close the database connection.
"public static ThreeDSecure retrieve(String threeDSecure) throws StripeException {
    return retrieve(threeDSecure, (Map<String, Object>) null, (RequestOptions) null);
  }",Retrieves a ThreeDSecure resource.
"@Override
    public UpdatePullRequestStatusResult updatePullRequestStatus(UpdatePullRequestStatusRequest request) {
        request = beforeClientExecution(request);
        return executeUpdatePullRequestStatus(request);
    }",Updates the status of a PRON process.
"void register(URL url, InMemoryMappingFile immf) {
        _data.put(url.getFile(), immf);
    }",Registers an InMemoryMappingFile for the given URL.
"protected void add(IIsotope isotope) {
        Integer atomicNum = isotope.getAtomicNumber();
        assert atomicNum != null;
        List<IIsotope> isotopesForElement = isotopes[atomicNum];
        if (isotopesForElement == null) {
            isotopesForElement = new ArrayList<>();
            isotopes[atomicNum] = isotopesForElement;
        }
        isotopesForElement.add(isotope);
    }",Add an IIsotope to the set of isotopes.
"protected X509Credential loadProxyCredential(String proxyPath) {

    PEMCredential cred = null;

    listener.notifyCredentialLookup(proxyPath);

    try {

      FilePermissionHelper.checkProxyPermissions(proxyPath);
      cred = new PEMCredential(new FileInputStream(proxyPath), (char[]) null);
      listener.notifyLoadCredentialSuccess(proxyPath);

    } catch (Throwable t) {

      listener.notifyLoadCredentialFailure(t, proxyPath);
    }

    return cred;
  }",Load the proxy credential.
"protected void checkAttribute(String attribute) {
        if (!hasAttribute(attribute)) {
            String sb = ""Attribute: '"" + attribute + ""' is not defined in model: '"" + getModelClass() + "". ""
                    + ""Available attributes: "" +getAttributeNames();
            throw new IllegalArgumentException(sb);
        }
    }",Check if the attribute is defined in the model.
"private void readConfig(){
		AccumulatorsConfig config = MoskitoConfigurationHolder.getConfiguration().getAccumulatorsConfig();
		AccumulatorConfig[] acs = config.getAccumulators();
		if (acs!=null && acs.length>0){
			for (AccumulatorConfig ac  : acs){
				AccumulatorDefinition ad = new AccumulatorDefinition();
				ad.setName(ac.getName());
				ad.setIntervalName(ac.getIntervalName());
				ad.setProducerName(ac.getProducerName());
				ad.setStatName(ac.getStatName());
				ad.setTimeUnit(TimeUnit.valueOf(ac.getTimeUnit()));
				ad.setValueName(ac.getValueName());
				Accumulator acc = createAccumulator(ad);
				if (log.isDebugEnabled()){
					log.debug(""Created accumulator ""+acc);
				}
			}
		}

		AutoAccumulatorConfig[] autoAccumulatorConfigs = config.getAutoAccumulators();
		if (autoAccumulatorConfigs != null && autoAccumulatorConfigs.length>0){
			for (AutoAccumulatorConfig aac : autoAccumulatorConfigs){
				AutoAccumulatorDefinition aad = new AutoAccumulatorDefinition();
				aad.setNamePattern(aac.getNamePattern());
				aad.setProducerNamePattern(aac.getProducerNamePattern());
				aad.setIntervalName(aac.getIntervalName());
				aad.setValueName(aac.getValueName());
				aad.setStatName(aac.getStatName());
				aad.setTimeUnit(TimeUnit.fromString(aac.getTimeUnit()));
				aad.setAccumulationAmount(aac.getAccumulationAmount());
				autoAccumulatorDefinitions.add(aad);
			}
		}

	}",Read configuration.
"@Override
    public void contextRootAdded(String contextRoot, VirtualHost virtualHost) {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEventEnabled()) {
            Tr.event(tc, ""Added contextRoot {0} to virtual host {1}"", contextRoot, virtualHost.getName());
        }

        // Check that our app got installed
        if (contextRoot != null
            && contextRoot.contains(APIConstants.JMX_CONNECTOR_API_ROOT_PATH)
            && ""default_host"".equals(virtualHost.getName())) {
            registeredContextRoot = contextRoot;

            if (secureVirtualHost == virtualHost) {
                createJMXWorkAreaResourceIfChanged(virtualHost);
            }
        }
    }",Override contextRootAdded to add a contextRoot to a VirtualHost.
"public static void bufferedToPlanar_U8(DataBufferInt buffer, WritableRaster src, Planar<GrayU8> dst) {
		int[] srcData = buffer.getData();

		int srcStride = stride(src);
		int srcOffset = getOffset(src);

		int numBands = src.getNumBands();
		byte[] data1 = dst.getBand(0).data;
		byte[] data2 = dst.getBand(1).data;
		byte[] data3 = dst.getBand(2).data;

		if( numBands == 3 ) {
			//CONCURRENT_BELOW BoofConcurrency.loopFor(0, dst.height, y -> {
			for (int y = 0; y < dst.height; y++) {
				int indexSrc = srcOffset + y*srcStride;
				int indexDst = dst.startIndex + y * dst.stride;
				for (int x = 0; x < dst.width; x++, indexDst++) {

					int rgb = srcData[indexSrc++];

					data1[indexDst] = (byte) (rgb >>> 16);
					data2[indexDst] = (byte) (rgb >>> 8);
					data3[indexDst] = (byte) rgb;
				}
			}
			//CONCURRENT_ABOVE });
		} else if( numBands == 4 ) {
			byte[] data4 = dst.getBand(3).data;

			//CONCURRENT_BELOW BoofConcurrency.loopFor(0, dst.height, y -> {
			for (int y = 0; y < dst.height; y++) {
				int indexSrc = srcOffset + y*srcStride;
				int indexDst = dst.startIndex + y * dst.stride;
				for (int x = 0; x < dst.width; x++, indexDst++) {

					int rgb = srcData[indexSrc++];

					data1[indexDst] = (byte) (rgb >>> 24);
					data2[indexDst] = (byte) (rgb >>> 16);
					data3[indexDst] = (byte) (rgb >>> 8);
					data4[indexDst] = (byte) rgb;
				}
			}
			//CONCURRENT_ABOVE });
		}
	}",Converts a buffered raster into a planar image.
"static Pair<String, Integer> getId(Annotation annot) {

		if (annot instanceof DictTerm) {
			DictTerm dt = (DictTerm) annot;
			String[] split = dt.getEntityId().split("":"");
			return Pair.of(split[0], parseInt(split[1]));

			// } else if (annot instanceof Measure) {
			// Measure m = (Measure) annot;
			// return Pair.of(""""+m.getNormalizedUnit(), parseInt(split[1]));

		} else
			throw new RuntimeException(""NOT IMPLEMENTED xxx"");// FIXME
	}",Get the ID of an annotation.
"public void removeAndTryClose(Connection connection) {
        if (null == connection) {
            return;
        }
        boolean res = this.conns.remove(connection);
        if (res) {
            connection.decreaseRef();
        }
        if (connection.noRef()) {
            connection.close();
        }
    }",Remove and try close a connection.
"private static boolean isCompatibleWithProvidedType(Class<?> providedClass,
                                                      Class<?> replacementClass) {
    if (Integer.class.isAssignableFrom(providedClass)) {
      return (replacementClass == String.class ||
          replacementClass == Integer.class ||
          replacementClass == Long.class);
    } else if (Long.class.isAssignableFrom(providedClass)) {
      return (replacementClass == String.class ||
          replacementClass == Long.class);
    } else if (String.class.isAssignableFrom(providedClass)) {
      return replacementClass == String.class;
    }
    return false;
  }",Checks if the provided type is compatible with the replacement type.
"public void addItem (int index, T item)
    {
        if (_items == null) {
            return;
        }
        _items.add(index, item);
    }",Add an item to the list of items.
"public static Observable<AsyncViewResult> mapToViewResult(final AsyncBucket bucket, final ViewQuery query,
        final ViewQueryResponse response) {

        return response
            .info()
            .singleOrDefault(null)
            .map(new ByteBufToJsonObject())
            .map(new BuildViewResult(bucket, query, response));
    }",Map to view result observable.
"public static int setPrivate(int modifier, boolean b) {
        if (b) {
            return (modifier | PRIVATE) & (~PUBLIC & ~PROTECTED);
        }
        else {
            return modifier & ~PRIVATE;
        }
    }",Sets the private modifier.
"@Override
    public <T> T getJsonProperty(String propertyName) {
        return (T) getProperty(propertyName, String.class);
    }",Get a property from the cache.
"protected Element createTextElement(float width)
    {
        Element el = doc.createElement(""div"");
        el.setAttribute(""id"", ""p"" + (textcnt++));
        el.setAttribute(""class"", ""p"");
        String style = curstyle.toString();
        style += ""width:"" + width + UNIT + "";"";
        el.setAttribute(""style"", style);
        return el;
    }",Create a text element.
"public void onCommandException(CommandResponse response) {
		String message = I18nProvider.getGlobal().commandError() + "":"";
		for (String error : response.getErrorMessages()) {
			message += ""\n"" + error;
		}
		Log.logWarn(message);
		if (response.getExceptions() == null || response.getExceptions().size() == 0) {
			SC.warn(message);
		} else {
			// The error messaging window only supports 1 exception to display:
			ExceptionWindow window = new ExceptionWindow(response.getExceptions().get(0));
			window.show();
		}
	}",Called when a command exception occurs.
"public void invalidate(Key... keys) {
        for (Key key : keys) {
            logger.debug(""Invalidating the response cache key : {} {} {} {}, {}"",
                    key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());

            readWriteCacheMap.invalidate(key);
            Collection<Key> keysWithRegions = regionSpecificKeys.get(key);
            if (null != keysWithRegions && !keysWithRegions.isEmpty()) {
                for (Key keysWithRegion : keysWithRegions) {
                    logger.debug(""Invalidating the response cache key : {} {} {} {} {}"",
                            key.getEntityType(), key.getName(), key.getVersion(), key.getType(), key.getEurekaAccept());
                    readWriteCacheMap.invalidate(keysWithRegion);
                }
            }
        }
    }",Invalidates the response cache for the given keys.
"@Override
    public Money divide(Number divisor) {
        if (NumberVerifier.isInfinityAndNotNaN(divisor)) {
            return Money.of(0, getCurrency());
        }
        BigDecimal divisorBD = MoneyUtils.getBigDecimal(divisor);
        if (divisorBD.equals(BigDecimal.ONE)) {
            return this;
        }
        BigDecimal dec =
                this.number.divide(divisorBD, MoneyUtils.getMathContext(getContext(), RoundingMode.HALF_EVEN));
        return new Money(dec, getCurrency());
    }",This method is used to divide this Money by another.
"public JSONObject linkToJSON(Link s) {
        JSONObject o = new JSONObject();
        o.put(""id"", s.id());
        o.put(CAPACITY_LABEL, s.getCapacity());
        o.put(SWITCH_LABEL, s.getSwitch().id());
        o.put(""physicalElement"", physicalElementToJSON(s.getElement()));
        return o;
    }",Convert a Link to a JSONObject
"public AVQuery<T> whereContainsAll(String key, Collection<?> values) {
    conditions.whereContainsAll(key, values);
    return this;
  }",Add a constraint to the query that requires a particular key s value to contain all of the provided values.
"private final JSRemoteConsumerPoint findOrCreateJSRemoteConsumerPoint(String[] discriminators, int[] selectorDomains,
                                                        String[] selectors)
    throws ClosedException
  {
    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.entry(tc, ""findOrCreateJSRemoteConsumerPoint"",
          new Object[]{Arrays.toString(discriminators),
                       Arrays.toString(selectorDomains),
                       Arrays.toString(selectors)});

    String selectionCriteriasAsString = parent.convertSelectionCriteriasToString(
                                                  discriminators, selectorDomains, selectors);

    JSRemoteConsumerPoint aock = (JSRemoteConsumerPoint) consumerKeyTable.get(selectionCriteriasAsString);
    if (aock == null)
    {
      try
      {
        // create an JSRemoteConsumerPoint
        aock = new JSRemoteConsumerPoint();
        SelectionCriteria[] criterias = new SelectionCriteria[discriminators.length];
        ConsumableKey[] consumerKeys = new ConsumableKey[discriminators.length];
        OrderingContextImpl ocontext = null;
        SIBUuid12 connectionUuid = new SIBUuid12();

        if (discriminators.length > 1)
          ocontext = new OrderingContextImpl(); // create a new ordering context
        for (int i=0; i < discriminators.length; i++)
        {
          SelectorDomain domain = SelectorDomain.getSelectorDomain(selectorDomains[i]);
          criterias[i] = parent.createSelectionCriteria(discriminators[i], selectors[i], domain);

          // attach as many times as necessary
          consumerKeys[i] =
            (ConsumableKey) consumerDispatcher.attachConsumerPoint(
              aock,
              criterias[i],
              connectionUuid,
              false,
              false,
              null);

          if (ocontext != null)
            consumerDispatcher.joinKeyGroup(consumerKeys[i], ocontext);

          consumerKeys[i].start(); // in case we use a ConsumerKeyGroup, this is essential

        }

        if (parent.getCardinalityOne() || consumerDispatcher.isPubSub())
        {
          // effectively infinite timeout, since don't want to close the ConsumerKey if RME is inactive for
          // a while. Only close this ConsumerKey when start flushing this stream.
          // NOTE shared durable subs might not be cardinality one but we still do not want the streams
          // to flush on timeout
          //
          // Defect 516583, set the idleTimeout parameter to 0, not to Long.MAX_VALUE in order to have an
          // ""infinite timeout"".
          aock.init(this, selectionCriteriasAsString, consumerKeys, 0, am, criterias);
        }
        else
        {
          aock.init(
            this,
            selectionCriteriasAsString,
            consumerKeys,
            mp.getCustomProperties().get_ck_idle_timeout(),
            am,
            criterias);
        }
        consumerKeyTable.put(selectionCriteriasAsString, aock);
      }
      catch (Exception e)
      {
        // should not occur!
        FFDCFilter.processException(
          e,
          ""com.ibm.ws.sib.processor.impl.AOStream.findOrCreateJSRemoteConsumerPoint"",
          ""1:2942:1.80.3.24"",
          this);
        SibTr.exception(tc, e);

        aock = null;
        ClosedException e2 = new ClosedException(e.getMessage());
        // just using the ClosedException as a convenience
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
          SibTr.exit(tc, ""findOrCreateJSRemoteConsumerPoint"", e2);

        throw e2;
      }
    }

    if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
      SibTr.exit(tc, ""findOrCreateJSRemoteConsumerPoint"", aock);

    return aock;
  }",This method is called by the JSRemoteConsumerPoint class when a JSRemoteConsumerPoint object is created.
"String getPath() {
    StringBuilder result = new StringBuilder();

    boolean first = true;
    for (String part : getSegments()) {
      if (first) {
        result.append(part);
        first = false;
      } else {
        result.append(""/"").append(part);
      }
    }

    return result.toString();
  }",Get the path of the resource.
"public static void writeIntegerLittleEndian(IO.WritableByteStream io, int value) throws IOException {
		io.write((byte)(value & 0xFF));
		io.write((byte)((value >> 8) & 0xFF));
		io.write((byte)((value >> 16) & 0xFF));
		io.write((byte)((value >> 24) & 0xFF));
	}",Writes the given big - endian value to the given IO.
"private void setUpdateTimer(final String subscriptionId, final String serviceContextId, long ms) {
    Date timeToRun = new Date(System.currentTimeMillis() + ms);
    sendUpdatetimer.schedule(new TimerTask() {
      public void run() {
        try {
          updateCharging(subscriptionId, serviceContextId, partialCallDurationCounter);
        }
        catch (Exception e) {
          logger.error(""(( $ )) Failure trying to create/send CCR (UPDATE) message. (( $ ))"", e);
        }
      }
    }, timeToRun);
  }",Set the update timer to run when the update is complete.
"@Override
    public ListJobsByStatusResult listJobsByStatus(ListJobsByStatusRequest request) {
        request = beforeClientExecution(request);
        return executeListJobsByStatus(request);
    }",Returns a list of jobs that have the specified status.
"public DescribeSessionsResult withSessions(Session... sessions) {
        if (this.sessions == null) {
            setSessions(new com.amazonaws.internal.SdkInternalList<Session>(sessions.length));
        }
        for (Session ele : sessions) {
            this.sessions.add(ele);
        }
        return this;
    }",Adds the sessions value to the list of sessions.
"@Override
    public synchronized ServerBootstrap newServerBootstrap() throws Exception {
        if (serverChannelFactory == null) {
            Executor workerExecutor = executorServiceFactory.newExecutorService(""worker.server"");
            NioDatagramWorkerPool workerPool = new NioDatagramWorkerPool(workerExecutor, 1);
            serverChannelFactory = new UdpServerChannelFactory(workerPool, timer);

            // unshared
            channelFactories.add(serverChannelFactory);
        }

        return new ServerBootstrap(serverChannelFactory);
    }",Creates a new server bootstrap.
"public static void copy(String in, Writer out) throws IOException {
		Assert.notNull(in, ""No input String specified"");
		Assert.notNull(out, ""No Writer specified"");
		try {
			out.write(in);
		}
		finally {
			try {
				out.close();
			}
			catch (IOException ex) {
			}
		}
	}",Copy the contents of the given String to the given Writer.
"public void startAuthActivity(Context context, Bundle extras) {
        if (!startDelegateActivity(context, delegate.getAuthStartIntent(), extras)) {
            startActivity(context, extras, AuthActivity.class);
        }
    }",Start the AuthActivity.
"@Override
	public Statement apply(final Statement base, final Description description) {
		return new Statement() {

			@Override
			public void evaluate() throws Throwable {
				PactVerifications pactVerifications = description.getAnnotation(PactVerifications.class);
				if (pactVerifications != null) {
					evaluatePactVerifications(pactVerifications, base, description);
					return;
				}

				PactVerification pactDef = description.getAnnotation(PactVerification.class);
				// no pactVerification? execute the test normally
				if (pactDef == null) {
					base.evaluate();
					return;
				}

				Message providedMessage = null;
				Map<String, Message> pacts;
				if (StringUtils.isNoneEmpty(pactDef.fragment())) {
          Optional<Method> possiblePactMethod = findPactMethod(pactDef);
          if (!possiblePactMethod.isPresent()) {
            base.evaluate();
            return;
          }

          pacts = new HashMap<>();
          Method method = possiblePactMethod.get();
          Pact pact = method.getAnnotation(Pact.class);
          MessagePactBuilder builder = MessagePactBuilder.consumer(pact.consumer()).hasPactWith(provider);
          messagePact = (MessagePact) method.invoke(testClassInstance, builder);
          for (Message message : messagePact.getMessages()) {
            pacts.put(message.getProviderStates().stream().map(ProviderState::getName).collect(Collectors.joining()),
							message);
          }
        } else {
          pacts = parsePacts();
        }

        if (pactDef.value().length == 2 && !pactDef.value()[1].trim().isEmpty()) {
          providedMessage = pacts.get(pactDef.value()[1].trim());
        } else if (!pacts.isEmpty()) {
          providedMessage = pacts.values().iterator().next();
        }

				if (providedMessage == null) {
					base.evaluate();
					return;
				}

				setMessage(providedMessage, description);
				try {
					base.evaluate();
					PactFolder pactFolder = testClassInstance.getClass().getAnnotation(PactFolder.class);
					if (pactFolder != null) {
						messagePact.write(pactFolder.value(), PactSpecVersion.V3);
					} else {
						messagePact.write(PactConsumerConfig.INSTANCE.getPactDirectory(), PactSpecVersion.V3);
					}
				} catch (Throwable t) {
					throw t;
				}
			}
		};
	}",Override the default implementation of the Statement.
"public static base_responses unset(nitro_service client, String groupname[], String args[]) throws Exception {
		base_responses result = null;
		if (groupname != null && groupname.length > 0) {
			systemgroup unsetresources[] = new systemgroup[groupname.length];
			for (int i=0;i<groupname.length;i++){
				unsetresources[i] = new systemgroup();
				unsetresources[i].groupname = groupname[i];
			}
			result = unset_bulk_request(client, unsetresources,args);
		}
		return result;
	}",Use this API to unset the properties of systemgroup resources. Properties that need to be unset are specified in args array.
"private static void setupCSSClasses(Object owner, CSSClassManager manager, StyleLibrary style) throws CSSNamingConflict {
    if(!manager.contains(CSS_AXIS)) {
      CSSClass axis = new CSSClass(owner, CSS_AXIS);
      axis.setStatement(SVGConstants.CSS_STROKE_PROPERTY, style.getColor(StyleLibrary.AXIS));
      axis.setStatement(SVGConstants.CSS_STROKE_WIDTH_PROPERTY, style.getLineWidth(StyleLibrary.AXIS));
      manager.addClass(axis);
    }
    if(!manager.contains(CSS_AXIS_TICK)) {
      CSSClass tick = new CSSClass(owner, CSS_AXIS_TICK);
      tick.setStatement(SVGConstants.CSS_STROKE_PROPERTY, style.getColor(StyleLibrary.AXIS_TICK));
      tick.setStatement(SVGConstants.CSS_STROKE_WIDTH_PROPERTY, style.getLineWidth(StyleLibrary.AXIS_TICK));
      manager.addClass(tick);
    }
    if(!manager.contains(CSS_AXIS_LABEL)) {
      CSSClass label = new CSSClass(owner, CSS_AXIS_LABEL);
      label.setStatement(SVGConstants.CSS_FILL_PROPERTY, style.getTextColor(StyleLibrary.AXIS_LABEL));
      label.setStatement(SVGConstants.CSS_FONT_FAMILY_PROPERTY, style.getFontFamily(StyleLibrary.AXIS_LABEL));
      label.setStatement(SVGConstants.CSS_FONT_SIZE_PROPERTY, style.getTextSize(StyleLibrary.AXIS_LABEL));
      manager.addClass(label);
    }
  }",Setup the CSS classes.
"@SuppressFBWarnings(""RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE"")
    private C4Document save(Document document, C4Document base, boolean deletion)
        throws LiteCoreException {
        FLSliceResult body = null;
        try {
            int revFlags = 0;
            if (deletion) { revFlags = C4Constants.RevisionFlags.DELETED; }
            if (!deletion && !document.isEmpty()) {
                // Encode properties to Fleece data:
                body = document.encode();
                if (C4Document.dictContainsBlobs(body, sharedKeys.getFLSharedKeys())) {
                    revFlags |= C4Constants.RevisionFlags.HAS_ATTACHMENTS;
                }
            }

            // Save to database:
            final C4Document c4Doc = base != null ? base : document.getC4doc();
            if (c4Doc != null) { return c4Doc.update(body, revFlags); }

            return getC4Database().create(document.getId(), body, revFlags);
        }
        finally {
            if (body != null) { body.free(); }
        }
    }",Save a document to the database.
"public LDIFChangeRecord nextRecord() {
        if (entryIterator.hasNext()) {
            try {
                final Node entryNode = entryIterator.next();
                final String dn = entryNode.valueOf(""@dn"");
                final List<Attribute> attributes = new ArrayList<Attribute>();

                final List<Node> objectClassList = (List<Node>) objectClassXPath.selectNodes(entryNode);
                final String[] objectClasses = new String[objectClassList.size()];
                for (int j = 0; j < objectClasses.length; ++j) {
                    objectClasses[j] = objectClassList.get(j).getStringValue();
                }
                attributes.add(new Attribute(""objectclass"", objectClasses));
                for (final Node attributeNode : (List<Node>) attrXPath.selectNodes(entryNode)) {
                    final String attributeName = attributeNode.valueOf(""@name"");
                    final List<Node> attributeValueNodes = (List<Node>) attrValueXPath.selectNodes(attributeNode);
                    switch (attributeValueNodes.size()) {
                        case 0:
                            break;
                        case 1: {
                            final String attributeValue = attributeValueNodes.get(0).getStringValue();
                            attributes.add(new Attribute(attributeName, attributeValue));
                            break;
                        }
                        default: {
                            final String[] attributeValues = new String[attributeValueNodes.size()];
                            for (int j = 0; j < attributeValueNodes.size(); ++j) {
                                attributeValues[j] = attributeValueNodes.get(j).getStringValue();
                            }
                            attributes.add(new Attribute(attributeName, attributeValues));
                            break;
                        }
                    }
                }
                return new LDIFAddChangeRecord(dn, attributes);
            } catch (final JaxenException e) {
                return null;
            }
        } else {
            return null;
        }
    }",Gets the next LDIFChangeRecord.
"synchronized void checkLeases() {
    int numPathsChecked = 0;
    for(; sortedLeases.size() > 0; ) {
      final Lease oldest = sortedLeases.first();
      if (!oldest.expiredHardLimit()) {
        return;
      }
      
      // internalReleaseLease() removes paths corresponding to empty files,
      // i.e. it needs to modify the collection being iterated over
      // causing ConcurrentModificationException
      String[] leasePaths = new String[oldest.getPaths().size()];
      oldest.getPaths().toArray(leasePaths);
      LOG.info(""Lease "" + oldest
          + "" has expired hard limit. Recovering lease for paths: ""
          + Arrays.toString(leasePaths));
      for(String p : leasePaths) {
        if (++numPathsChecked > this.maxPathsPerCheck) {
          return;
        }
        try {
          fsnamesystem.getFSNamesystemMetrics().numLeaseRecoveries.inc();
          fsnamesystem.internalReleaseLeaseOne(
              oldest, p, this.discardLastBlockIfNoSync);
        } catch (IOException e) {
          LOG.error(""Cannot release the path ""+p+"" in the lease ""+oldest, e);
          removeLease(oldest, p);
          fsnamesystem.getFSNamesystemMetrics().numLeaseManagerMonitorExceptions.inc();
        }
      }
    }
  }",Check leases.
"public void undelete(CmsUUID entryId, String sitePath) {

        CmsSitemapChange change = new CmsSitemapChange(entryId, sitePath, ChangeType.undelete);
        CmsSitemapClipboardData data = CmsSitemapView.getInstance().getController().getData().getClipboardData().copy();
        data.getDeletions().remove(entryId);
        change.setClipBoardData(data);
        commitChange(change, null);
    }",Undelete an entry from the sitemap.
"public Analyzer<Partition<T>> getOrCreateAnalyzer()
   {
      Node node = childNode.getOrCreate(""analyzer"");
      Analyzer<Partition<T>> analyzer = new AnalyzerImpl<Partition<T>>(this, ""analyzer"", childNode, node);
      return analyzer;
   }",Get or create an analyzer object.
"public static Window showCWF(BaseComponent root, String... excludedProperties) {
        Window window = showXML(CWF2XML.toDocument(root, excludedProperties));
        window.setTitle(""CWF Markup"");
        return window;
    }",Show a CWF Markup window.
"protected String getValue(String arg) {
        String[] split = arg.split(""="");
        if (split.length <= 1) {
            return null;
        }
        return split[1];
    }",Get the value of a CIDCTYPE attribute.
"public final void success () {
		Status previousStatus = status;
		status = Status.SUCCEEDED;
		if (tree.listeners != null && tree.listeners.size > 0) tree.notifyStatusUpdated(this, previousStatus);
		end();
		if (control != null) control.childSuccess(this);
	}",Notify all listeners that the node has been successfully updated.
"public Future<IEvaluation[]> execute(IEvaluation[] evals, int evalWorkers, int evalBatchSize, Iterator<DataSet> ds, Iterator<MultiDataSet> mds,
                                         boolean isCG, Broadcast<String> json, Broadcast<byte[]> params){
        Preconditions.checkArgument(evalWorkers > 0, ""Invalid number of evaluation workers: must be > 0. Got: %s"", evalWorkers);
        Preconditions.checkState(ds != null || mds != null, ""No data provided - both DataSet and MultiDataSet iterators were null"");

        //For multi-GPU we'll use a round robbin approach for worker thread/GPU affinity
        int numDevices = Nd4j.getAffinityManager().getNumberOfDevices();
        if(numDevices <= 0)
            numDevices = 1;

        //Create the device local params if required
        DeviceLocalNDArray deviceLocalParams;
        synchronized (this){
            if(!paramsMap.containsKey(params.getValue())){
                //Due to singleton pattern, this block should execute only once (first thread)
                //Initially put on device 0. For CPU, this means we only have a single copy of the params INDArray shared by
                // all threads, which is both safe and uses the least amount of memory
                //For CUDA, we can't share threads otherwise arrays will be continually relocated, causing a crash
                //Nd4j.getMemoryManager().releaseCurrentContext();
                //NativeOpsHolder.getInstance().getDeviceNativeOps().setDevice(0);
                //Nd4j.getAffinityManager().attachThreadToDevice(Thread.currentThread(), 0);
                byte[] pBytes = params.getValue();
                INDArray p;
                try{
                    p = Nd4j.read(new ByteArrayInputStream(pBytes));
                } catch (IOException e){
                    throw new RuntimeException(e);  //Should never happen
                }
                DeviceLocalNDArray dlp = new DeviceLocalNDArray(p);
                paramsMap.put(params.getValue(), dlp);
                //log.info(""paramsMap: size {}"", paramsMap.size());
            }
            deviceLocalParams = paramsMap.get(params.getValue());
        }

        int currentWorkerCount;
        while((currentWorkerCount = workerCount.get()) < evalWorkers){
            //For load balancing: we're relying on the fact that threads are mapped to devices in a round-robbin approach
            // the first time they touch an INDArray. If we assume this method is called by new threads,
            // then the first N workers will be distributed evenly across available devices.

                if (workerCount.compareAndSet(currentWorkerCount, currentWorkerCount + 1)) {
                    log.debug(""Starting evaluation in thread {}"", Thread.currentThread().getId());
                    //This thread is now a worker
                    EvaluationFuture f = new EvaluationFuture();
                    f.setResult(evals);
                    try {
                        Model m;
                        if (isCG) {
                            ComputationGraphConfiguration conf = ComputationGraphConfiguration.fromJson(json.getValue());
                            ComputationGraph cg = new ComputationGraph(conf);
                            cg.init(deviceLocalParams.get(), false);
                            m = cg;
                        } else {
                            MultiLayerConfiguration conf = MultiLayerConfiguration.fromJson(json.getValue());
                            MultiLayerNetwork net = new MultiLayerNetwork(conf);
                            net.init(deviceLocalParams.get(), false);
                            m = net;
                        }

                        //Perform eval on this thread's data
                        try {
                            doEval(m, evals, ds, mds, evalBatchSize);
                        } catch (Throwable t) {
                            f.setException(t);
                        } finally {
                            f.getSemaphore().release(1);
                        }

                        //Perform eval on other thread's data
                        while (!queue.isEmpty()) {
                            Eval e = queue.poll();  //Use poll not remove to avoid race condition on last element
                            if (e == null)
                                continue;
                            try {
                                doEval(m, evals, e.getDs(), e.getMds(), evalBatchSize);
                            } catch (Throwable t) {
                                e.getFuture().setException(t);
                            } finally {
                                e.getFuture().getSemaphore().release(1);
                            }
                        }
                    } finally {
                        workerCount.decrementAndGet();
                        log.debug(""Finished evaluation in thread {}"", Thread.currentThread().getId());
                    }

                    Nd4j.getExecutioner().commit();
                    return f;
                }
        }

        //At this point: not a worker thread (otherwise, would have returned already)
        log.debug(""Submitting evaluation from thread {} for processing in evaluation thread"", Thread.currentThread().getId());
        EvaluationFuture f = new EvaluationFuture();
        queue.add(new Eval(ds, mds, evals, f));
        return f;
    }",Execute the block
"public void marshall(CatalogImportStatus catalogImportStatus, ProtocolMarshaller protocolMarshaller) {

        if (catalogImportStatus == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(catalogImportStatus.getImportCompleted(), IMPORTCOMPLETED_BINDING);
            protocolMarshaller.marshall(catalogImportStatus.getImportTime(), IMPORTTIME_BINDING);
            protocolMarshaller.marshall(catalogImportStatus.getImportedBy(), IMPORTEDBY_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given CatalogImportStatus object to the JSON object.
"public final void setValidField(final int field, final boolean valid)
	{
		if (field < 0 || field >= FIELD_MASKS.length)
			throw new KNXIllegalArgumentException(""illegal field"");
		setBit(0, FIELD_MASKS[field], !valid);
	}",Sets the value of a field to a valid state.
"public static void append(StringBuilder buf, String s, int offset, int length) {
        synchronized (buf) {
            int end = offset + length;
            for (int i = offset; i < end; i++) {
                if (i >= s.length())
                    break;
                buf.append(s.charAt(i));
            }
        }
    }",Append a sequence of characters to a StringBuilder.
"public void setFeature (String name, boolean value)
    throws SAXNotRecognizedException, SAXNotSupportedException
    {
    if (name.equals(NAMESPACES)) {
        checkNotParsing(""feature"", name);
        namespaces = value;
        if (!namespaces && !prefixes) {
        prefixes = true;
        }
    } else if (name.equals(NAMESPACE_PREFIXES)) {
        checkNotParsing(""feature"", name);
        prefixes = value;
        if (!prefixes && !namespaces) {
        namespaces = true;
        }
    } else if (name.equals(XMLNS_URIs)) {
        checkNotParsing(""feature"", name);
        uris = value;
    } else {
        throw new SAXNotRecognizedException(""Feature: "" + name);
    }
    }",Sets the value of a feature.
"private void processMultipart(final Multipart mp) throws MessagingException, IOException {
		final int count = mp.getCount();
		for (int i = 0; i < count; i++) {
			final Part innerPart = mp.getBodyPart(i);
			processPart(innerPart);
		}
	}",Process a Multipart.
"public void instrumentClassFile(File classfile) throws IOException {
        FileInputStream fis = new FileInputStream(classfile);
        byte[] bytes = transform(fis);
        fis.close();
        fis = null;

        // If the class was successfully transformed, rewrite it
        if (bytes != null) {
            FileOutputStream fos = new FileOutputStream(classfile);
            fos.write(bytes);
            fos.close();
        }
    }",Instrument a class file.
"@Override
    protected XWikiSyntaxResourceRenderer createXWikiSyntaxLinkRenderer(ListenerChain listenerChain,
        ResourceReferenceSerializer linkReferenceSerializer)
    {
        return new XWikiSyntaxResourceRenderer((XWikiSyntaxListenerChain) listenerChain, linkReferenceSerializer);
    }",Create an instance of the XWikiSyntaxLinkRenderer interface.
"public static ThreadPoolExecutor getBoundedThreadPoolExecutor(int maxPoolSize, long keepAliveTime, TimeUnit unit, ThreadFactory tFactory) {
        return new ThreadPoolExecutor(0, maxPoolSize, keepAliveTime, unit,
                                      new SynchronousQueue<Runnable>(), tFactory);
    }",Get a bounded thread pool executor.
"public final void recycle(final T instance) {
        if (instance != null) {
            usedInstances.remove(instance);
            if (instance instanceof Resettable) {
                ((Resettable) instance).reset();
            }
            unusedInstances.add(instance);
        }
    }",Recycle an instance.
"public Integer updateInfoByIdService(String id,Map requestParamMap,String tableName,String cusCondition,String cusSetStr) throws Exception{
		return updateInfoServiceInner(id,requestParamMap,tableName,cusCondition,cusSetStr,null);
	}",Update the info of a service identified by the id.
"public static void onCreate(Context context) {
        sContext = context;
        context.registerReceiver(ALARM_BROADCAST_RECEIVER, new IntentFilter(PING_ALARM_ACTION));
        sAlarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
        sPendingIntent = PendingIntent.getBroadcast(context, 0, new Intent(PING_ALARM_ACTION), 0);
        sAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,
                SystemClock.elapsedRealtime() + AlarmManager.INTERVAL_HALF_HOUR,
                AlarmManager.INTERVAL_HALF_HOUR, sPendingIntent);
    }",Called when the application is created.
"@Override
	public void stopped() {

		// Stop heartbeat timer
		if (heartBeatTimer != null) {
			heartBeatTimer.cancel(false);
			heartBeatTimer = null;
		}

		// Stop timeout checker's timer
		if (checkTimeoutTimer != null) {
			checkTimeoutTimer.cancel(false);
			checkTimeoutTimer = null;
		}

		// Send ""disconnected"" packet
		sendDisconnectPacket();

		// Clear all stored data
		nodes.clear();
	}",Called by the server to inform us that the connection has been stopped.
"public synchronized <T extends Object> T register(Class<T> type) throws InvalidTypeException, TypeFilterException, DoubleIDException, InvalidMethodException, InvocationException, ControllerPersistenceException {
	return register(type, null);
    }",Registers a new type with the controller.
"@Override
  public void setPermission(Path path, FsPermission permission) throws IOException {
    LOG.debug(""setMode({},{})"", path, permission.toString());
    AlluxioURI uri = new AlluxioURI(HadoopUtils.getPathWithoutScheme(path));
    SetAttributePOptions options = SetAttributePOptions.newBuilder()
        .setMode(new Mode(permission.toShort()).toProto()).setRecursive(false).build();
    try {
      mFileSystem.setAttribute(uri, options);
    } catch (AlluxioException e) {
      throw new IOException(e);
    }
  }",Sets the permission for a node.
"public final void evalError() {
    final List<EvaluationMonitor<POSSample>> listeners = new LinkedList<EvaluationMonitor<POSSample>>();
    listeners.add(new POSEvaluationErrorListener());
    final POSEvaluator evaluator = new POSEvaluator(this.posTagger,
        listeners.toArray(new POSTaggerEvaluationMonitor[listeners.size()]));
    try {
      evaluator.evaluate(this.testSamples);
    } catch (IOException e) {
      e.printStackTrace();
    }
    System.out.println(evaluator.getWordAccuracy());
  }",Evaluate the error.
"private void configureEvent(CacheEntryListenerInvocation listenerInvocation,
                               EventImpl<K, V> e, K key, V value, Metadata metadata) {
      e.setKey(convertKey(listenerInvocation, key));
      e.setValue(convertValue(listenerInvocation, value));
      e.setMetadata(metadata);
      e.setOriginLocal(true);
      e.setPre(false);
   }",Configure the event.
"public void getDistributedObjects(Collection<DistributedObject> result) {
        Collection<DistributedObjectFuture> futures = proxies.values();
        for (DistributedObjectFuture future : futures) {
            if (!future.isSetAndInitialized()) {
                continue;
            }
            try {
                DistributedObject object = future.get();
                result.add(object);
            } catch (Throwable ignored) {
                // ignore if proxy creation failed
                ignore(ignored);
            }
        }
    }",Get all DistributedObjects in the cache.
"public static ProcessBuilder getProcessBuilder(String mainClass, List<URL> classPath, List<String> args) throws LauncherException
	{
		List<String> cmdList = new ArrayList<String>();
		String[] cmdArray;
		
		cmdList.add(getJavaPath());
		if(classPath != null && classPath.size() > 0)
		{
			cmdList.add(""-cp"");
			cmdList.add(mkPath(classPath));
		}
		cmdList.add(mainClass);
		if(args!=null && args.size()>0)
			cmdList.addAll(args);
		cmdArray = cmdList.toArray(new String[cmdList.size()]);
		if(logger.isDebugEnabled())
			logger.debug(""cmdArray="" + Arrays.toString(cmdArray));
		return new ProcessBuilder(cmdArray);
	}",Get a ProcessBuilder for the specified main class and class path.
"@Override
	public CPOptionValue fetchByUUID_G(String uuid, long groupId) {
		return fetchByUUID_G(uuid, groupId, true);
	}",Returns the cp option value with the matching UUID and group.
"@Override
    public CancelReservedInstancesListingResult cancelReservedInstancesListing(CancelReservedInstancesListingRequest request) {
        request = beforeClientExecution(request);
        return executeCancelReservedInstancesListing(request);
    }",Cancels a list of reserved instances.
"private List<TransformerChangeListener> getAllListeners() {
        @SuppressWarnings(""deprecation"") final List<TransformerChangeListener> globalChangeListeners =
                getAnalysisJobBuilder().getTransformerChangeListeners();

        final List<TransformerChangeListener> list =
                new ArrayList<>(globalChangeListeners.size() + _localChangeListeners.size());
        list.addAll(globalChangeListeners);
        list.addAll(_localChangeListeners);
        return list;
    }",Gets all transformer change listeners.
"public Future<AuthenticationResult> acquireTokenByAuthorizationCode(
            final String authorizationCode, final URI redirectUri,
            final AsymmetricKeyCredential credential,
            final AuthenticationCallback callback)
            throws AuthenticationException {
        return this.acquireTokenByAuthorizationCode(authorizationCode,
                redirectUri, credential, null, callback);
    }",Acquire token by authorization code.
"@Override
    public Request<DescribeBundleTasksRequest> getDryRunRequest() {
        Request<DescribeBundleTasksRequest> request = new DescribeBundleTasksRequestMarshaller().marshall(this);
        request.addParameter(""DryRun"", Boolean.toString(true));
        return request;
    }",Returns a request configured with additional parameters to indicate whether to delete the bundle tasks.
"public void setTau0(double tau0)
    {
        if(tau0 <= 0 || Double.isInfinite(tau0) || Double.isNaN(tau0))
            throw new IllegalArgumentException(""Eta must be a positive constant, not "" + tau0);
        this.tau0 = tau0;
    }",Sets the tau0 value.
"public static void runExample(AdManagerServices adManagerServices, AdManagerSession session)
      throws RemoteException {
    // Get the NetworkService.
    NetworkServiceInterface networkService =
        adManagerServices.get(session, NetworkServiceInterface.class);

    // Get all networks that you have access to with the current authentication
    // credentials.
    Network[] networks = networkService.getAllNetworks();

    if (networks == null || networks.length == 0) {
      System.out.printf(""No accessible networks found.%n"");
      return;
    }

    int i = 0;
    for (Network network : networks) {
      System.out.printf(
          ""%d) Network with network code '%s' and display name '%s' was found.%n"",
          i++, network.getNetworkCode(), network.getDisplayName());
    }

    System.out.printf(""Number of networks found: %d%n"", networks.length);
  }",Example of how to run the example.
"@Nonnull
  public static ICommonsList <IAuthToken> getAllTokensOfSubject (@Nonnull final IAuthSubject aSubject)
  {
    ValueEnforcer.notNull (aSubject, ""Subject"");

    return s_aRWLock.readLocked ( () -> CommonsArrayList.createFiltered (s_aMap.values (),
                                                                         aToken -> aToken.getIdentification ()
                                                                                         .hasAuthSubject (aSubject)));
  }",Get all tokens of the given subject.
"@Execute
    public HtmlResponse index() {
        esApiManager.saveToken();
        return asHtml(path_AdminDashboard_AdminDashboardJsp).renderWith(data -> {
            RenderDataUtil.register(data, ""serverPath"", esApiManager.getServerPath());
        });
    }",Display a single page of the page.
"protected void sendExit2(final OtpErlangPid from, final OtpErlangPid dest,
            final OtpErlangObject reason) throws IOException {
        sendExit(exit2Tag, from, dest, reason);
    }",Send an exit message to a node.
"public String getGlobusID(String userID) {
        if (userID == null) {
            throw new IllegalArgumentException(i18n.getMessage(""userIdNull""));
        }

        if (this.map == null) {
            return null;
        }

        Iterator iter = this.map.entrySet().iterator();
        Map.Entry mapEntry;
        GridMapEntry entry;
        while(iter.hasNext()) {
            mapEntry = (Map.Entry)iter.next();
            entry = (GridMapEntry)mapEntry.getValue();
            if (entry.containsUserID(userID)) {
                return entry.getGlobusID();
            }
        }
        return null;
    }",Gets the globus ID for the specified user ID.
"public Formula getFormula() {
		Reagent[] reagents = new Reagent[] {SOURCE, PARAMETER_NAME};
		return new SimpleFormula(ServletContextInitParameterPhrase.class, reagents);
	}",Gets the formula for the ServletContextInitParameterPhrase.
"public List<J4pRemoteException> getRemoteExceptions() {
        List<J4pRemoteException> ret = new ArrayList<J4pRemoteException>();
        for (Object entry : results) {
            if (entry instanceof J4pRemoteException) {
                ret.add((J4pRemoteException) entry);
            }
        }
        return ret;
    }",Get the list of remote exceptions.
"@Override
  public void run() {
    // Workaround for Issue #4 (http://code.google.com/p/jdiameter/issues/detail?id=4)
    // BEGIN WORKAROUND // Give some time to initialization...
    int sleepTime = 250;
    logger.debug(""Sleeping for {}ms before starting transport so that listeners can all be added and ready for messages"", sleepTime);
    try {
      Thread.sleep(sleepTime);
    }
    catch (InterruptedException e) {
      // ignore
    }
    logger.debug(""Finished sleeping for {}ms. By now, MutablePeerTableImpl should have added its listener"", sleepTime);

    logger.debug(""Transport is started. Socket is [{}]"", socketDescription);
    Selector selector = null;
    try {
      selector = Selector.open();
      socketChannel.register(selector, SelectionKey.OP_READ);
      while (!stop) {
        selector.select(SELECT_TIMEOUT);
        Iterator<SelectionKey> it = selector.selectedKeys().iterator();
        while (it.hasNext()) {
          // Get the selection key
          SelectionKey selKey = it.next();
          // Remove it from the list to indicate that it is being processed
          it.remove();
          if (selKey.isValid() && selKey.isReadable()) {
            // Get channel with bytes to read
            SocketChannel sChannel = (SocketChannel) selKey.channel();
            int dataLength = sChannel.read(buffer);
            logger.debug(""Just read [{}] bytes on [{}]"", dataLength, socketDescription);
            if (dataLength == -1) {
              stop = true;
              break;
            }
            buffer.flip();
            byte[] data = new byte[buffer.limit()];
            buffer.get(data);
            append(data);
            buffer.clear();
          }
        }
      }
    }
    catch (ClosedByInterruptException e) {
      logger.error(""Transport exception "", e);
    }
    catch (AsynchronousCloseException e) {
      logger.error(""Transport is closed"");
    }
    catch (Throwable e) {
      logger.error(""Transport exception "", e);
    }
    finally {
      try {
        clearBuffer();
        if (selector != null) {
          selector.close();
        }
        if (socketChannel != null && socketChannel.isOpen()) {
          socketChannel.close();
        }
        getParent().onDisconnect();
      }
      catch (Exception e) {
        logger.error(""Error"", e);
      }
      stop = false;
      logger.info(""Read thread is stopped for socket [{}]"", socketDescription);
    }
  }","Run method for the
 banner transport."
"private void checkPopup(MouseEvent e) {
        if (e.isPopupTrigger()) {
            popup.show(this, e.getX(), e.getY());
        }
    }",Check popup.
"public static Set<String> lowercaseLines(final Class<?> origin, final String resource) throws IOException {
        return ImmutableSet.copyOf(new HashSet<String>() {{
            readResource(origin, resource, new NullReturnLineProcessor() {
                @Override
                public boolean processLine(@Nonnull final String line) {
                    final String l = simplify(line);
                    // add to the containing HashSet we are currently in the init block of
                    if (!l.startsWith(""#"") && !l.isEmpty()) add(toEngLowerCase(l));
                    return true;
                }
            });
        }});
    }",Returns a set of lines from a file that are lowercase.
"private void syncVfsToRfs(String folder) throws CmsException {

        int action = 0;
        //get all resources in the given folder
        List<CmsResource> resources = m_cms.getResourcesInFolder(folder, CmsResourceFilter.IGNORE_EXPIRATION);
        // now look through all resources in the folder
        for (int i = 0; i < resources.size(); i++) {
            CmsResource res = resources.get(i);
            // test if the resource is marked as deleted. if so,
            // do nothing, the corresponding file in the FS will be removed later
            if (!res.getState().isDeleted()) {
                // do a recursion if the current resource is a folder
                if (res.isFolder()) {
                    // first check if this folder must be synchronized
                    action = testSyncVfs(res);
                    // do the correct action according to the test result
                    if (action == EXPORT_VFS) {
                        exportToRfs(res);
                    } else if (action != DELETE_VFS) {
                        skipResource(res);
                    }
                    // recurse into the sub folders. This must be done before
                    // the folder might be deleted!
                    syncVfsToRfs(m_cms.getSitePath(res));
                    if (action == DELETE_VFS) {
                        deleteFromVfs(res);
                    }
                } else {
                    // if the current resource is a file, check if it has to
                    // be synchronized
                    action = testSyncVfs(res);
                    // do the correct action according to the test result
                    switch (action) {
                        case EXPORT_VFS:
                            exportToRfs(res);
                            break;

                        case UPDATE_VFS:
                            updateFromRfs(res);
                            break;

                        case DELETE_VFS:
                            deleteFromVfs(res);
                            break;

                        default:
                            skipResource(res);

                    }
                }
                // free memory
                res = null;
            }
        }
        //  free memory
        resources = null;
    }",Synchronize VFS to RFS.
"public void addInheritedSummaryAnchor(ClassDoc cd, Content inheritedTree) {
        inheritedTree.addContent(writer.getMarkerAnchor(
                SectionName.NESTED_CLASSES_INHERITANCE,
                cd.qualifiedName()));
    }",Add the inherited summary anchor.
"public static void setPreferredRoadInternColor(Integer color) {
		final Preferences prefs = Preferences.userNodeForPackage(RoadNetworkLayerConstants.class);
		if (prefs != null) {
			if (color == null) {
				prefs.remove(""ROAD_INTERN_COLOR""); //$NON-NLS-1$
			} else {
				prefs.put(""ROAD_INTERN_COLOR"", Integer.toString(color.intValue())); //$NON-NLS-1$
			}
			try {
				prefs.flush();
			} catch (BackingStoreException exception) {
				//
			}
		}
	}",Set the preferred color for the road network.
"private void initDefaultLoginFilter(H http) {
		DefaultLoginPageGeneratingFilter loginPageGeneratingFilter = http
				.getSharedObject(DefaultLoginPageGeneratingFilter.class);
		if (loginPageGeneratingFilter != null) {
			loginPageGeneratingFilter.setRememberMeParameter(getRememberMeParameter());
		}
	}",Initialize the default login filter.
"public <T> void register(final Class<T> type, final TypeConverter<T> typeConverter) {
		converters.put(type, typeConverter);
	}",Register a type converter.
"@Override
    public R visitUnknown(TypeMirror t, P p) {
        throw new UnknownTypeException(t, p);
    }",Visit an unknown type mirror.
"public void removeAttributeNS(String namespaceURI, String localName)
        throws DOMException {
        throw new DOMException(DOMException.NO_MODIFICATION_ALLOWED_ERR, null);
    }",Remove an attribute from the attribute set.
"@Override
    public boolean isJobInstancePurgeable(long jobInstanceId) {
        InstanceState instanceState = getJobInstance(jobInstanceId).getInstanceState();

        if (instanceState.equals(InstanceState.SUBMITTED)
            || instanceState.equals(InstanceState.JMS_QUEUED)
            || instanceState.equals(InstanceState.JMS_CONSUMED)
            || instanceState.equals(InstanceState.DISPATCHED)) {
            return false;
        } else {
            return true;
        }
    }",This method is used to check if a job instance is purgeable.
"public synchronized void putAll(SerialArrayList<U> data, int startIndex) {
    ensureCapacity((startIndex * unitSize) + data.maxByte);
    System.arraycopy(data.buffer, 0, this.buffer, startIndex * unitSize, data.maxByte);
  }",Copies all the elements from the given array into this array.
"@Override
  public void doAction(char cha) {

    if (cha == '\""') {

      /* annotation for first section:simple polymer section */
      if (sectionCounter == 1) {
        LOG.info(""Add annotation to simple polymer:"");
        PolymerNotation current = _parser.notationContainer.getCurrentPolymer();
        _parser.notationContainer.changeLastPolymerNotation(new PolymerNotation(current.getPolymerID(),
            current.getPolymerElements(), comment));
        _parser.setState(new BetweenParser(_parser));
      } /* annotation for second section:connection section */ else if (sectionCounter == 2) {
        LOG.info(""Add annotation to connection section:"");
        ConnectionNotation current = _parser.notationContainer.getCurrentConnection();
        _parser.notationContainer.changeConnectionNotation(new ConnectionNotation(current.getSourceId(),
            current.getTargetId(), current.getSourceUnit(), current.getTargetUnit(), current.getrGroupSource(),
            current.getrGroupTarget(), comment));
        _parser.setState(new BetweenInlineConnectionParser(_parser));
      } /* annotation for a single monomer in the first section */ else if (sectionCounter == 11) {
        LOG.info(""Add annotation to a single monomer:"");
        _parser.notationContainer.getCurrentPolymer().getPolymerElements().getCurrentMonomerNotation().setAnnotation(comment);
        _parser.setState(new BetweenInlineMonomerParser(_parser));
      }

    } else {
      comment += (cha);
    }
  }","Method to handle the
    action"
"@Programmatic
    public List<CommunicationChannelOwnerLink> findByOwner(final CommunicationChannelOwner owner) {
        if(owner == null) {
            return null;
        }
        final Bookmark bookmark = bookmarkService.bookmarkFor(owner);
        if(bookmark == null) {
            return null;
        }
        return container.allMatches(
                new QueryDefault<>(CommunicationChannelOwnerLink.class,
                        ""findByOwner"",
                        ""ownerObjectType"", bookmark.getObjectType(),
                        ""ownerIdentifier"", bookmark.getIdentifier()));
    }",Find by owner.
"public static NumberingSystem getInstance(ULocale locale) {
        // Check for @numbers
        boolean nsResolved = true;
        String numbersKeyword = locale.getKeywordValue(""numbers"");
        if (numbersKeyword != null ) {
            for ( String keyword : OTHER_NS_KEYWORDS ) {
                if ( numbersKeyword.equals(keyword)) {
                    nsResolved = false;
                    break;
                }
            }
        } else {
            numbersKeyword = ""default"";
            nsResolved = false;
        }

        if (nsResolved) {
            NumberingSystem ns = getInstanceByName(numbersKeyword);
            if (ns != null) {
                return ns;
            }
            // If the @numbers keyword points to a bogus numbering system name,
            // we return the default for the locale.
            numbersKeyword = ""default"";
        }

        // Attempt to get the numbering system from the cache
        String baseName = locale.getBaseName();
        // TODO: Caching by locale+numbersKeyword could yield a large cache.
        // Try to load for each locale the mappings from OTHER_NS_KEYWORDS and default
        // to real numbering system names; can we get those from supplemental data?
        // Then look up those mappings for the locale and resolve the keyword.
        String key = baseName+""@numbers=""+numbersKeyword;
        LocaleLookupData localeLookupData = new LocaleLookupData(locale, numbersKeyword);
        return cachedLocaleData.getInstance(key, localeLookupData);
    }",Get the NumberingSystem object for the given locale.
"@NonNull
  public Caffeine<K, V> weakKeys() {
    requireState(keyStrength == null, ""Key strength was already set to %s"", keyStrength);
    requireState(writer == null, ""Weak keys may not be used with CacheWriter"");

    keyStrength = Strength.WEAK;
    return this;
  }",Sets the key strength to weak.
"protected void validate(String operationType) throws Exception
	{
		super.validate(operationType);

		MPSString id_validator = new MPSString();
		id_validator.validate(operationType, id, ""\""id\"""");
		
		MPSInt adapter_id_validator = new MPSInt();
		adapter_id_validator.validate(operationType, adapter_id, ""\""adapter_id\"""");
		
		MPSInt virtualdrive_validator = new MPSInt();
		virtualdrive_validator.validate(operationType, virtualdrive, ""\""virtualdrive\"""");
		
		MPSInt targetid_validator = new MPSInt();
		targetid_validator.validate(operationType, targetid, ""\""targetid\"""");
		
		MPSString name_validator = new MPSString();
		name_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);
		name_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);
		name_validator.validate(operationType, name, ""\""name\"""");
		
		MPSString size_validator = new MPSString();
		size_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);
		size_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);
		size_validator.validate(operationType, size, ""\""size\"""");
		
		MPSString state_validator = new MPSString();
		state_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);
		state_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);
		state_validator.validate(operationType, state, ""\""state\"""");
		
		MPSString drives_validator = new MPSString();
		drives_validator.setConstraintMaxStrLen(MPSConstants.GENERIC_CONSTRAINT, 128);
		drives_validator.setConstraintMinStrLen(MPSConstants.GENERIC_CONSTRAINT, 1);
		drives_validator.validate(operationType, drives, ""\""drives\"""");
		
		MPSIPAddress host_ip_address_validator = new MPSIPAddress();
		host_ip_address_validator.validate(operationType, host_ip_address, ""\""host_ip_address\"""");
		
		MPSString physical_disk_slot_1_validator = new MPSString();
		physical_disk_slot_1_validator.validate(operationType, physical_disk_slot_1, ""\""physical_disk_slot_1\"""");
		
		MPSString physical_disk_slot_2_validator = new MPSString();
		physical_disk_slot_2_validator.validate(operationType, physical_disk_slot_2, ""\""physical_disk_slot_2\"""");
		
	}","Validates the
 operationType."
"public T put(YamlNode key, Long value) {
        return put(key, getNodeFactory().longNode(value));
    }",Put a Long value into the context.
"private static int scanDatePart(char prefix, int defaultValue, String str, AtomicInteger pos,
                                    int minDigits, int maxDigits, int minValue, int maxValue) 
            throws IllegalArgumentException {
        // If all characters are consumed, just return the default value.
        if (pos.get() >= str.length()) {
            return defaultValue;
        }
        
        // If there's a prefix character, require it.
        if (prefix != '\0') {
            require(str.charAt(pos.getAndIncrement()) == prefix, ""'"" + prefix + ""' expected"");
        }
        
        // Scan up to maxDigits into a numeric value.
        int value = 0;
        int digitsScanned = 0;
        while (pos.get() < str.length() && digitsScanned < maxDigits) {
            char ch = str.charAt(pos.get());
            if (ch >= '0' && ch <= '9') {
                value = value * 10 + (ch - '0');
                digitsScanned++;
                pos.incrementAndGet();
            } else {
                break;
            }
        }
        
        // Ensure we got the required minimum digits and the value is within range.
        Utils.require(digitsScanned >= minDigits && value >= minValue && value <= maxValue,
                      ""Invalid value for date/time part"");
        return value;
    }",Scans a date part of a string.
"public <T> T getValue(Class<T> type, String parameter, Message message, T uriParameterValue){
        if(message==null && uriParameterValue!=null){
            return uriParameterValue;
        }
        T value = message.getHeader(parameter, type);
        if(value==null){
            value = uriParameterValue;
        }
        return value;
    }",Gets the value of the attribute.
"private PatchingResult applyPatch(final String patchId, final Patch patch, final IdentityPatchContext context) throws PatchingException, IOException, XMLStreamException {

        final Identity identity = patch.getIdentity();
        final Patch.PatchType patchType = identity.getPatchType();
        final InstallationManager.InstallationModification modification = context.getModification();
        if (patchType == Patch.PatchType.CUMULATIVE) {
            // Invalidate all installed patches (one-off, cumulative) - we never need to invalidate the release base
            final List<String> invalidation = new ArrayList<String>(modification.getPatchIDs());
            if (!invalidation.isEmpty()) {
                try {
                    // Before rolling back the one-off patches, validate that the state until that point is consistent
                    validateRollbackState(invalidation.get(invalidation.size() - 1),
                            modification.getUnmodifiedInstallationState());
                } catch (PatchingException e) {
                    throw e;
                } catch (Exception e) {
                    throw new PatchingException(e);
                }
                // Invalidate the installed patches first
                for (final String rollback : invalidation) {
                    rollback(rollback, context);
                }
            }
        }

        // Add to installed patches list
        modification.addInstalledPatch(patchId);

        // Then apply the current patch
        for (final PatchElement element : patch.getElements()) {
            // Apply the content modifications
            final IdentityPatchContext.PatchEntry target = context.resolveForElement(element);
            final PatchElementProvider provider = element.getProvider();
            final Patch.PatchType elementPatchType = provider.getPatchType();
            final String elementPatchId = element.getId();
            // See if we can skip this element
            if (target.isApplied(elementPatchId)) {
                // TODO if it is already applied, we can just skip the entry (maybe based ont the type of the patch)
                // This needs some further testing, maybe we need to compare our history with the patch if they are consistent
                throw PatchLogger.ROOT_LOGGER.alreadyApplied(elementPatchId);
            }
            // Check upgrade conditions
            checkUpgradeConditions(provider, target);
            apply(elementPatchId, element.getModifications(), target);
            target.apply(elementPatchId, elementPatchType);
        }
        // Apply the patch to the identity
        final IdentityPatchContext.PatchEntry identityEntry = context.getIdentityEntry();
        apply(patchId, patch.getModifications(), identityEntry);
        identityEntry.apply(patchId, patchType);

        // Port forward missing module changes
        if (patchType == Patch.PatchType.CUMULATIVE) {
            portForward(patch, context);
        }

        // We need the resulting version for rollback
        if (patchType == Patch.PatchType.CUMULATIVE) {
            final Identity.IdentityUpgrade upgrade = identity.forType(Patch.PatchType.CUMULATIVE, Identity.IdentityUpgrade.class);
            identityEntry.setResultingVersion(upgrade.getResultingVersion());
        }

        // Execute the tasks
        final IdentityApplyCallback callback = new IdentityApplyCallback(patch, identityEntry.getDirectoryStructure());
        try {
            return executeTasks(context, callback);
        } catch (Exception e) {
            context.cancel(callback);
            throw rethrowException(e);
        }
    }",Apply a patch.
"private Map<NodeId, NodeId> resolveAliases(Iterable<Alias> aliases) {
        Map<NodeId, NodeId> resolved = Maps.newHashMap();
        Map<NodeId, Set<NodeId>> inverse = Maps.newHashMap();

        for (Alias alias : aliases) {
            NodeId from = alias.getFromId();
            NodeId to = alias.getToId();
            if (resolved.containsKey(to)) {
                to = resolved.get(to);
            }
            resolved.put(from, to);
            if (inverse.get(to) == null) {
                inverse.put(to, Sets.<NodeId> newHashSet());
            }
            inverse.get(to).add(from);

            Set<NodeId> prev = inverse.get(from);
            if (prev != null) {
                for (NodeId id : prev) {
                    resolved.remove(id);
                    inverse.get(from).remove(id);
                    resolved.put(id, to);
                    inverse.get(to).add(id);
                }
            }
        }

        return resolved;
    }",Resolve the aliases.
"public List<InputColumn<?>> getAvailableInputColumns(final ComponentBuilder componentBuilder,
            final Class<?> dataType) {
        List<InputColumn<?>> result = getAvailableInputColumns(dataType);

        final SourceColumnFinder finder = new SourceColumnFinder();
        finder.addSources(this);

        result = CollectionUtils.filter(result, new Predicate<InputColumn<?>>() {
            @Override
            public Boolean eval(InputColumn<?> inputColumn) {
                if (inputColumn.isPhysicalColumn()) {
                    return true;
                }

                final InputColumnSourceJob origin = finder.findInputColumnSource(inputColumn);
                if (origin == null) {
                    return true;
                }

                if (origin == componentBuilder) {
                    // exclude columns from the component itself
                    return false;
                }

                final Set<Object> sourceComponents = finder.findAllSourceJobs(origin);
                if (sourceComponents.contains(componentBuilder)) {
                    // exclude columns that depend
                    return false;
                }

                return true;
            }
        });

        return result;
    }",Get the list of input columns for a given data type.
"public static Member member(MemberId memberId, Address address) {
    return builder(memberId)
        .withAddress(address)
        .build();
  }",Create a member with the given member id and address.
"@Override
	public void close() throws IOException {
		for(int i=0;i<oss.length;++i) {
			if(close[i]) {
				oss[i].close();
			}
    	}
	}",Close the underlying file.
"public Object executeOutboundOperation(final Message<?> message) {

		try {
			String serializedMessage = messageMarshaller.serialize(message);

			if (snsTestProxy == null) {
				PublishRequest request = new PublishRequest();
				PublishResult result = client.publish(request.withTopicArn(
						topicArn).withMessage(serializedMessage));
				log.debug(""Published message to topic: ""
						+ result.getMessageId());
			} else {
				snsTestProxy.dispatchMessage(serializedMessage);
			}

		} catch (MessageMarshallerException e) {
			log.error(e.getMessage(), e);
			throw new MessagingException(e.getMessage(), e.getCause());
		}

		return message.getPayload();
	}",Execute an outbound operation on the SNS topic.
"public static String formatDate(Date d, String fmt) {
        return FastDateFormat.getInstance(fmt).format(d);
    }",Format a date to a string.
"private boolean isInlineAppend(FQMethod fqm) {
        if (!SignatureUtils.isPlainStringConvertableClass(fqm.getClassName())) {
            return false;
        }

        if (stack.getStackDepth() <= 1) {
            return true;
        }

        OpcodeStack.Item itm = stack.getStackItem(1);
        return itm.getUserValue() == UCPMUserValue.INLINE;
    }",returns true if the method is an inline append method
"@Override
    public void clear() {
        for (int i = 0; i < buckets.length; i++) {
            buckets[i] = null;
        }
        size = 0;
        lastDeletedKey = minKey;
        currentMin = null;
    }",Clear the cache.
"@NotNull
    public OptionalLong or(@NotNull Supplier<OptionalLong> supplier) {
        if (isPresent()) return this;
        Objects.requireNonNull(supplier);
        return Objects.requireNonNull(supplier.get());
    }",Gets the value of the CID    either from the given Supplier.
"public static FSAHeader read(InputStream in) throws IOException {
    if (in.read() != ((FSA_MAGIC >>> 24)       ) ||
        in.read() != ((FSA_MAGIC >>> 16) & 0xff) ||
        in.read() != ((FSA_MAGIC >>>  8) & 0xff) ||
        in.read() != ((FSA_MAGIC       ) & 0xff)) {
      throw new IOException(""Invalid file header, probably not an FSA."");
    }

    int version = in.read();
    if (version == -1) {
      throw new IOException(""Truncated file, no version number."");
    }

    return new FSAHeader((byte) version);
  }",Read the FSA header from the specified input stream.
"@Override
	protected Variable[] createVariablesSub(int num) {
		int[] tp = tpCreate(num);
		Variable[] ret = new Variable[num];
		for (int i = 0; i < tp.length; i++) {
			ret[i] = tPoints[tp[i]];			
		}
		return ret;
	}",Create the variable array sub - array.
"public JSON with(Feature feature, boolean state)
    {
        int f = _features;
        if (state) {
            f |= feature.mask();
        } else {
            f &= ~feature.mask();
        }
        return _with(f);
    }",Sets the feature mask and state of the result.
"@BetaApi
  public final Policy setIamPolicyImage(
      ProjectGlobalImageResourceName resource,
      GlobalSetPolicyRequest globalSetPolicyRequestResource) {

    SetIamPolicyImageHttpRequest request =
        SetIamPolicyImageHttpRequest.newBuilder()
            .setResource(resource == null ? null : resource.toString())
            .setGlobalSetPolicyRequestResource(globalSetPolicyRequestResource)
            .build();
    return setIamPolicyImage(request);
  }",Sets the Iam Policy image for the specified resource.
"protected static String toLowerCase(String input) {
        if(Character.isUpperCase(input.charAt(0)))
            return input.substring(0, 1).toLowerCase() + input.substring(1);
        return input;
    }",Returns the first letter of the input string.
"public void marshall(ShareDetails shareDetails, ProtocolMarshaller protocolMarshaller) {

        if (shareDetails == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(shareDetails.getSuccessfulShares(), SUCCESSFULSHARES_BINDING);
            protocolMarshaller.marshall(shareDetails.getShareErrors(), SHAREERRORS_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given ShareDetails object to the JSON object.
"public String toQueryString(Criteria criteria, CriteriaQueryBuilder queryBuilder) {

    // query builder
    StringBuilder builder = new StringBuilder();

    // build the basic query
    builder.append( queryBuilder.getAbsolutePath(criteria, relativePath) );
    builder.append( "" IN ("");
    
    // We must add each value as a parameter, because not all JPA
    // implementations allow lists or arrays as parameters.
    if( values != null ) {
      for( int i = 0; i < values.length; i++) {
        builder.append( queryBuilder.createPositionalParameter() );
        if( i < values.length - 1 ) {
          builder.append(',');
        }
      }
    }
    builder.append("")"");
    
    // return result
    return builder.toString();
  }",Build the query string for the IN clause.
"public static ClassFinder instance(Context context) {
        ClassFinder instance = context.get(classFinderKey);
        if (instance == null)
            instance = new ClassFinder(context);
        return instance;
    }",Get the ClassFinder instance.
"@Override
	public void close() throws IOException {
		if (upload != null) {
			flush();
			// close the connection
			try {
				upload.close();
			} catch (SQLException e) {
				LOG.info(""JDBC statement could not be closed: "" + e.getMessage());
			} finally {
				upload = null;
			}
		}

		if (dbConn != null) {
			try {
				dbConn.close();
			} catch (SQLException se) {
				LOG.info(""JDBC connection could not be closed: "" + se.getMessage());
			} finally {
				dbConn = null;
			}
		}
	}",Close the connection.
"protected void checkDiskError(Exception e ) throws IOException {
    if (e instanceof ClosedByInterruptException
        || e instanceof java.io.InterruptedIOException) {
      return;
    }
    LOG.warn(""checkDiskError: exception: "", e);
    
    if (e.getMessage() != null &&
        e.getMessage().startsWith(""No space left on device"")) {
      throw new DiskOutOfSpaceException(""No space left on device"");
    } else {
      checkDiskError();
    }
  }",Check disk error.
"public static int ptb2Text(Reader ptbText, Writer w) throws IOException {
    int numTokens = 0;
    PTB2TextLexer lexer = new PTB2TextLexer(ptbText);
    for (String token; (token = lexer.next()) != null; ) {
      numTokens++;
      w.write(token);
    }
    return numTokens;
  }",Read and write a sequence of tokens from a PTB file.
"public static String getDisplayName(String localeID, String displayLocaleID) {
        return getDisplayNameInternal(new ULocale(localeID), new ULocale(displayLocaleID));
    }",Get the display name for a locale ID.
"public List<MethodSymbol> interfaceCandidates(Type site, MethodSymbol ms) {
        CandidatesCache.Entry e = candidatesCache.new Entry(site, ms);
        List<MethodSymbol> candidates = candidatesCache.get(e);
        if (candidates == null) {
            Filter<Symbol> filter = new MethodFilter(ms, site);
            List<MethodSymbol> candidates2 = List.nil();
            for (Symbol s : membersClosure(site, false).getSymbols(filter)) {
                if (!site.tsym.isInterface() && !s.owner.isInterface()) {
                    return List.of((MethodSymbol)s);
                } else if (!candidates2.contains(s)) {
                    candidates2 = candidates2.prepend((MethodSymbol)s);
                }
            }
            candidates = prune(candidates2);
            candidatesCache.put(e, candidates);
        }
        return candidates;
    }",Get the candidates of a method in an interface.
"public ImmutableSet<ClassInfo> getTopLevelClassesRecursive(String packageName) {
    checkNotNull(packageName);
    String packagePrefix = packageName + '.';
    ImmutableSet.Builder<ClassInfo> builder = ImmutableSet.builder();
    ImmutableSet<ClassInfo> topLevelClasses = getTopLevelClasses();
    List<String> debugData = Lists.newLinkedList();
    for (ClassInfo classInfo : topLevelClasses) {
      if (classInfo.getName().startsWith(packagePrefix)) {
        builder.add(classInfo);
        debugData.add(classInfo.getResourceName() + ""\n"");
      }
    }
    return builder.build();
  }",Get the top level classes recursively.
"public GetDocumentTextDetectionResult withWarnings(Warning... warnings) {
        if (this.warnings == null) {
            setWarnings(new java.util.ArrayList<Warning>(warnings.length));
        }
        for (Warning ele : warnings) {
            this.warnings.add(ele);
        }
        return this;
    }",A list of warnings that were detected during the detection process.
"public File getFilteredVersion(File input) {
        File out = getOutputFile(input);
        if (!out.isFile()) {
            return null;
        }
        return out;
    }",Get the filtered version of a file.
"public JobDetails getJobByJobID(String cluster, String jobId)
      throws IOException {
    return getJobByJobID(cluster, jobId, false);
  }",Get the JobDetails for a given job ID.
"public boolean markMigrated(VectorClock vectorClock) {
        stateWriteLock.lock();
        try {
            if (stateVectorClock.equals(vectorClock)) {
                migrated = true;
            }
            return migrated;
        } finally {
            stateWriteLock.unlock();
        }
    }",Mark the migration of a class to a new vector clock.
"public static WxaUserInfo validateUserInfo(String session_key, String rawData, String signature) {
		try {
			if (DigestUtils.shaHex(rawData + session_key).equals(signature)) {
				return JsonUtil.parseObject(rawData, WxaUserInfo.class);
			}
		} catch (Exception e) {
			logger.error("""", e);
		}
		return null;
	}",Validate a raw data and signature.
"public static String getFilename(final URL url) throws UnsupportedEncodingException
	{
		if (isJar(url) || isEar(url))
		{
			String fileName = URLDecoder.decode(url.getFile(), ""UTF-8"");
			fileName = fileName.substring(5, fileName.indexOf(""!""));
			return fileName;
		}
		return URLDecoder.decode(url.getFile(), ""UTF-8"");
	}",Gets the filename from the URL.
"public static DZcsn cs_chol(DZcs A, DZcss S) {
		double[] d, lki ;
		DZcsa Lx = new DZcsa (), x, Cx = new DZcsa () ;
		int top, i, p, k, n, Li[], Lp[], cp[], pinv[], s[], c[], parent[], Cp[], Ci[] ;
		DZcs L, C, E ;
		DZcsn N ;
		if (!CS_CSC(A) || S == null || S.cp == null || S.parent == null) return (null) ;
		n = A.n ;
		N = new DZcsn () ;		/* allocate result */
		c = new int [2*n] ;		/* get int workspace */
		x = new DZcsa (n) ;		/* get complex workspace */
		cp = S.cp ; pinv = S.pinv ; parent = S.parent ;
		C = pinv != null ? cs_symperm (A, pinv, true) : A ;
		E = pinv != null ? C : null ;	/* E is alias for A, or a copy E=A(p,p) */
		if (N == null || c == null || x == null || C == null) return (cs_ndone (N, E, c, x, false)) ;
		s = c ;
		int s_offset = n ;
		Cp = C.p ; Ci = C.i ; Cx.x = C.x ;
		N.L = L = cs_spalloc (n, n, cp[n], true, false); /* allocate result */
		if (L == null) return (cs_ndone (N, E, c, x, false)) ;
		Lp = L.p ; Li = L.i ; Lx.x = L.x ;
		for (k = 0 ; k < n ; k++) Lp [k] = c [k] = cp [k] ;
		for (k = 0 ; k < n ; k++)	/* compute L(k,:) for L*L' = C */
		{
			/* --- Nonzero pattern of L(k,:) ------------------------------------ */
			top = cs_ereach (C, k, parent, s, s_offset, c) ;		/* find pattern of L(k,:) */
			x.set(k, cs_czero ()) ;					/* x (0:k) is now zero */
			for (p = Cp [k] ; p < Cp [k + 1] ; p++)			/* x = full(triu(C(:,k))) */
			{
				if (Ci [p] <= k) x.set(Ci [p], Cx.get(p)) ;
			}
			d = x.get(k) ;				/* d = C(k,k) */
			x.set(k, cs_czero ()) ;			/* clear x for k+1st iteration */
			/* --- Triangular solve --------------------------------------------- */
			for ( ; top < n ; top++)		/* solve L(0:k-1,0:k-1) * x = C(:,k) */
			{
				i = s [s_offset + top] ;	/* s [top..n-1] is pattern of L(k,:) */
				lki = cs_cdiv (x.get(i), Lx.get(Lp [i])) ; /* L(k,i) = x (i) / L(i,i) */
				x.set(i, cs_czero ()) ;		/* clear x for k+1st iteration */
				for (p = Lp [i] + 1 ; p < c [i] ; p++)
				{
					x.set(Li [p], cs_cminus (x.get(Li [p]), cs_cmult (Lx.get(p), lki))) ;
				}
				d = cs_cminus (d, cs_cmult (lki, cs_conj (lki))) ;	/* d = d - L(k,i)*L(k,i) */
				p = c [i]++ ;
				Li [p] = k ;			/* store L(k,i) in column i */
				Lx.set(p, cs_conj (lki)) ;
			}
			/* --- Compute L(k,k) ----------------------------------------------- */
			if (d[0] <= 0 || d[1] != 0)
				return (cs_ndone (N, E, c, x, false)) ;	/* not pos def */
			p = c [k]++ ;
			Li [p] = k ;				/* store L(k,k) = sqrt (d) in column k */
			Lx.set(p, cs_csqrt (d)) ;
		}
		Lp [n] = cp [n] ;				/* finalize L */
		return (cs_ndone (N, E, c, x, true)) ;		/* success: free E,s,x; return N */
	}",Returns the Cholesky decomposition of A and S.
"public static Map<Object, int[]> countAnnotationsPerCategory(
			final ICodingAnnotationStudy study) {
		Map<Object, int[]> result = new HashMap<Object, int[]>();
		for (ICodingAnnotationItem item : study.getItems()) {
            for (IAnnotationUnit unit : item.getUnits()) {
				Object category = unit.getCategory();
				if (category == null) {
                    continue;
                }

				int[] counts = result.get(category);
				if (counts == null) {
                    counts = new int[study.getRaterCount()];
                }
				counts[unit.getRaterIdx()]++;
				result.put(category, counts);
			}
        }
		return result;
	}",Count the number of annotations per category for a given annotation study.
"@SuppressWarnings(""unchecked"")
  void registerConsumer(Inspector<? super OutT> subInspector) {
    consumers.add((Inspector<OutT>) subInspector);
  }",Registers a consumer to the container.
"void logOrphans(final List<Map<String, Object>> toLog) {
        try {
            String result = pretty
                    ? prettyWriter().writeValueAsString(toLog)
                    : writer().writeValueAsString(toLog);
            LOGGER.warn(""Orphan responses observed: {}"", result);
        } catch (Exception ex) {
            LOGGER.warn(""Could not write orphan log."", ex);
        }
    }",Log orphans.
"public void setRefreshType(com.google.api.ads.admanager.axis.v201902.RefreshType refreshType) {
        this.refreshType = refreshType;
    }",Sets the refreshType value for this BaseResource.
"protected void resolvePropertyReplacements(Api api) {
        if (api == null) {
            return;
        }
        String endpoint = api.getEndpoint();
        endpoint = resolveProperties(endpoint);
        api.setEndpoint(endpoint);

        Map<String, String> properties = api.getEndpointProperties();
        for (Entry<String, String> entry : properties.entrySet()) {
            String value = entry.getValue();
            value = resolveProperties(value);
            entry.setValue(value);
        }

        resolvePropertyReplacements(api.getApiPolicies());
    }",Resolve property replacements for the API.
"private static Method accessible(Method method) {
        if (method != null) {
            method.setAccessible(true);
        }
        return method;
    }",Set the method accessible.
"public static boolean isISODate(final String val) throws BadDateException {
    try {
      if (val.length() != 8) {
        return false;
      }
      fromISODate(val);
      return true;
    } catch (Throwable t) {
      return false;
    }
  }",Check if the string is a valid date.
"public void setFragment(boolean newFragment)
  {
    boolean oldFragment = fragment;
    fragment = newFragment;
    if (eNotificationRequired())
      eNotify(new ENotificationImpl(this, Notification.SET, SimpleAntlrPackage.RULE__FRAGMENT, oldFragment, fragment));
  }",Sets the fragment flag.
"@NonNull
    private static ObservableTransformer<byte[], PresenterEvent> transformToPresenterEvent(Type type) {
        return observable -> observable.map(writtenBytes -> ((PresenterEvent) new ResultEvent(writtenBytes, type)))
                .onErrorReturn(throwable -> new ErrorEvent(throwable, type));
    }",Transform a result event to a presenter event.
"private List<String> searchTokens(SNode n, long cnr)
  {
    List<String> result = new LinkedList<String>();
    if (n instanceof SToken)
    {
      result.add(n.getId());
      if (componentOfToken.get(n.getId()) == null)
      {
        List<Long> newlist = new LinkedList<Long>();
        newlist.add(cnr);
        componentOfToken.put(n.getId(), newlist);
      }
      else
      {
        List<Long> newlist = componentOfToken.get(n.getId());
        if (!newlist.contains(cnr))
        {
          newlist.add(cnr);
        }
      }
    }
    else
    {
      List<SRelation<SNode, SNode>> outgoing = n.getGraph().getOutRelations(n.getId());
      if(outgoing != null)
      {
        for (SRelation<? extends SNode,? extends SNode> e : outgoing)
        {
          if(!(e instanceof SPointingRelation) && e.getSource() instanceof SNode && e.getTarget() instanceof SNode)
          {
            List<String> Med = searchTokens((SNode) e.getTarget(), cnr);
            for (String s : Med)
            {
              if (!result.contains(s))
              {
                result.add(s);
              }
            }
          }
        }
      }
    }
    return result;
  }",Search tokens.
"protected ResultSet getResultSet() {
		if (table == null) {
			throw new IllegalArgumentException(""missing parameter: table"");
		}

		String whereClause = """";
		if (where != null) {
            whereClause = "" WHERE "" + where;
        }

        try {
			statement = connection.createStatement();
			return statement.executeQuery(""SELECT * FROM "" + table + whereClause);
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
	}",Returns a ResultSet object for the table where the where clause is not null.
"public Observable<ServiceResponse<OperationStatus>> updatePrebuiltEntityRoleWithServiceResponseAsync(UUID appId, String versionId, UUID entityId, UUID roleId, UpdatePrebuiltEntityRoleOptionalParameter updatePrebuiltEntityRoleOptionalParameter) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException(""Parameter this.client.endpoint() is required and cannot be null."");
        }
        if (appId == null) {
            throw new IllegalArgumentException(""Parameter appId is required and cannot be null."");
        }
        if (versionId == null) {
            throw new IllegalArgumentException(""Parameter versionId is required and cannot be null."");
        }
        if (entityId == null) {
            throw new IllegalArgumentException(""Parameter entityId is required and cannot be null."");
        }
        if (roleId == null) {
            throw new IllegalArgumentException(""Parameter roleId is required and cannot be null."");
        }
        final String name = updatePrebuiltEntityRoleOptionalParameter != null ? updatePrebuiltEntityRoleOptionalParameter.name() : null;

        return updatePrebuiltEntityRoleWithServiceResponseAsync(appId, versionId, entityId, roleId, name);
    }",Updates an entity role.
"@Override
    public <T, A> AsyncFuture<T> executeRequest(final Integer operationId, final ManagementRequest<T, A> request) throws IOException {
        final ActiveOperation<T, A> operation = super.getActiveOperation(operationId);
        if(operation == null) {
            throw ProtocolLogger.ROOT_LOGGER.responseHandlerNotFound(operationId);
        }
        return executeRequest(operation, request);
    }",Execute a request.
"private static void assignKeyFromAddressNode(ModelNode payload, ModelNode address) {
        List<Property> props = address.asPropertyList();
        Property lastToken = props.get(props.size()-1);
        payload.get(""entity.key"").set(lastToken.getValue().asString());
    }",Assigns the key from the address node to the last token in the address node.
"public void setNeedleBorderColor(final Color COLOR) {
        if (null == needleBorderColor) {
            _needleBorderColor = null == COLOR ? Color.TRANSPARENT : COLOR;
            fireUpdateEvent(REDRAW_EVENT);
        } else {
            needleBorderColor.set(COLOR);
        }
    }",Defines the color that will be used to colorize the border of the contour of the contour.
"public String getReservedNickname() throws SmackException, InterruptedException {
        try {
            DiscoverInfo result =
                ServiceDiscoveryManager.getInstanceFor(connection).discoverInfo(
                    room,
                    ""x-roomuser-item"");
            // Look for an Identity that holds the reserved nickname and return its name
            for (DiscoverInfo.Identity identity : result.getIdentities()) {
                return identity.getName();
            }
        }
        catch (XMPPException e) {
            LOGGER.log(Level.SEVERE, ""Error retrieving room nickname"", e);
        }
        // If no Identity was found then the user does not have a reserved room nickname
        return null;
    }",Get the reserved nickname of the user.
"private boolean isInjectorOrAssistedProvider(Dependency<?> dependency) {
    Class<?> annotationType = dependency.getKey().getAnnotationType();
    if (annotationType != null && annotationType.equals(Assisted.class)) { // If it's assisted..
      if (dependency
          .getKey()
          .getTypeLiteral()
          .getRawType()
          .equals(Provider.class)) { // And a Provider...
        return true;
      }
    } else if (dependency
        .getKey()
        .getTypeLiteral()
        .getRawType()
        .equals(Injector.class)) { // If it's the Injector...
      return true;
    }
    return false;
  }",Checks if the dependency is an Injector or an AssistedProvider.
"private static void doInsert(CallInfo callInfo, Table table, DataSet data) {
    StringBuilder sql = new StringBuilder(""INSERT INTO "");
    List<String> tableColumns = table.getColumns();
    int columnCount = tableColumns.size();
    int[] paramIdx = new int[columnCount];
    int param = 0;
    Iterator<String> itr = tableColumns.iterator();
    String col = itr.next();
    
    paramIdx[param] = ++param;
    sql.append(table.getName())
       .append('(')
       .append(col);
    
    while (itr.hasNext()) {
      paramIdx[param] = ++param;
      col = itr.next();
      sql.append(',')
         .append(col);
    }
    sql.append("") VALUES (?"");
    for (int i=1; i < columnCount; i++) {
      sql.append("",?"");
    }
    sql.append(')');

    dataSetOperation(callInfo, table, data, sql.toString(), paramIdx);
  }",Insert data set into a table.
"private Map<Key, Object> cacheGetAll(final Collection<Key> keys) {
		try {
			return this.memcache.getAll(keys);
		} catch (Exception ex) {
			// Some sort of serialization error, just wipe out the values
			log.warn(""Error fetching values from memcache, deleting keys"", ex);

			this.memcache.deleteAll(keys);

			return new HashMap<>();
		}
	}",Gets all the values from the memcached cache.
"@Override
	public HashMap<String, Object> getApplicationMap() {
		return (HashMap<String, Object>) JKThreadLocal.getValue(JKContextConstants.APPLICATION_MAP);
	}",Get the application map.
"@SuppressWarnings(""unchecked"")
    private void readObject(java.io.ObjectInputStream s)
        throws java.io.IOException, ClassNotFoundException
    {
        // Read in the key type and any hidden stuff
        s.defaultReadObject();

        keyUniverse = getKeyUniverse(keyType);
        vals = new Object[keyUniverse.length];

        // Read in size (number of Mappings)
        int size = s.readInt();

        // Read the keys and values, and put the mappings in the HashMap
        for (int i = 0; i < size; i++) {
            K key = (K) s.readObject();
            V value = (V) s.readObject();
            put(key, value);
        }
    }",Read the object from an input stream.
"public Set getSIBDestinationLocalitySet(String busName, String uuid,
                                            boolean newSet) throws SIBExceptionDestinationNotFound,
                    SIBExceptionBase {

        /*
         * if (TraceComponent.isAnyTracingEnabled() &&
         * tc.isEntryEnabled()) SibTr.entry(tc, ""getSIBDestinationLocalitySet"",
         * new Object[] { busName, uuid, new Boolean(newSet) });
         * 
         * Set results = _engine.getSIBDestinationLocalitySet(busName, uuid,
         * newSet);
         * 
         * if (TraceComponent.isAnyTracingEnabled() &&
         * tc.isEntryEnabled()) SibTr.exit(tc, ""getSIBDestinationLocalitySet"",
         * results);
         */

        //Venu Liberty change:
        //_localistySet is filled up with this ME Uuid in startInternal();
        // This function would get called only after _localistySet is filled up at lease once

        return _localistySet;
    }",This method is called by the SIBEngineImpl to get a set of Locality objects from a destination.
"@Override
    public List<Character> subList(int fromIndex, int toIndex) {
        return new CharArrayList(a, fromIndex, toIndex - fromIndex);
    }",Returns a sub - list of this sequence.
"public static Response get(URI uri, Credentials credentials, Header[] requestHeaders)
        throws URISyntaxException, HttpException {
        return send(new HttpGet(uri), credentials, requestHeaders);
    }",Perform an HTTP GET on the given URI using the given credentials and request headers.
"private static String[][] resizeArray(String[][] array, int size)
    {
        if (array.length == size) return array;
        String[][] nArray = new String[size][];
        System.arraycopy(array, 0, nArray, 0, size);
        return nArray;
    }",Resize the array to the given size.
"static <T> Optional<T> findFirst(final Class<T> service) {
        final ServiceLoader<T> loader = load(service);
        if (loader == null) return empty();
        final Iterator<T> services = loader.iterator();
        return services.hasNext() ? of(services.next()) : empty();
    }",Find first Service in ServiceLoader.
"public static double getDouble(String pStr) {
        if (isEmpty(pStr)) {
            return 0.0;
        }
        double value = 0.0;
        pStr = pStr.substring(0, pStr.length() - 2) + ""."" + pStr.substring(pStr.length() - 2);
        try {
            value = Double.parseDouble(pStr);
        } catch (NumberFormatException ex) {
        }
        return value;
    }",Get the double value from a string.
"public void marshall(ListUsersRequest listUsersRequest, ProtocolMarshaller protocolMarshaller) {

        if (listUsersRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(listUsersRequest.getBrokerId(), BROKERID_BINDING);
            protocolMarshaller.marshall(listUsersRequest.getMaxResults(), MAXRESULTS_BINDING);
            protocolMarshaller.marshall(listUsersRequest.getNextToken(), NEXTTOKEN_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",Creates the marshalling method for the ANSCTYPE service.
"private Mapper<K, V> addConstraint(MapConstraint<K, V> constraint) {
		this.delegate = Optional.of(MapConstraints.constrainedMap(delegate.get(), constraint));
		return this;
	}",Add a constraint to the delegate map.
"private static void inplace_merge(int first, int middle, int last, IntComparator comp, Swapper swapper) {
	if (first >= middle || middle >= last)
		return;
	if (last - first == 2) {
		if (comp.compare(middle, first)<0) {
			swapper.swap(first,middle);
		}
		return;
	}
	int firstCut;
	int secondCut;
	if (middle - first > last - middle) {
		firstCut = first + (middle - first) / 2;
		secondCut = lower_bound(middle, last, firstCut, comp);
	} 
	else {
		secondCut = middle + (last - middle) / 2;
		firstCut = upper_bound(first, middle, secondCut, comp);
	}

	// rotate(firstCut, middle, secondCut, swapper);
	// is manually inlined for speed (jitter inlining seems to work only for small call depths, even if methods are ""static private"")
	// speedup = 1.7
	// begin inline
	int first2 = firstCut; int middle2 = middle; int last2 = secondCut;
	if (middle2 != first2 && middle2 != last2) {
		int first1 = first2; int last1 = middle2;
		while (first1 < --last1) swapper.swap(first1++,last1);
		first1 = middle2; last1 = last2;
		while (first1 < --last1) swapper.swap(first1++,last1);
		first1 = first2; last1 = last2;
		while (first1 < --last1) swapper.swap(first1++,last1);
	}
	// end inline

	middle = firstCut + (secondCut - middle);
	inplace_merge(first, firstCut, middle, comp, swapper);
	inplace_merge(middle, secondCut, last, comp, swapper);
}",Inplace merge of two 16 - bit integers.
"public Observable<ServiceResponse<RegexEntityExtractor>> getRegexEntityEntityInfoWithServiceResponseAsync(UUID appId, String versionId, UUID regexEntityId) {
        if (this.client.endpoint() == null) {
            throw new IllegalArgumentException(""Parameter this.client.endpoint() is required and cannot be null."");
        }
        if (appId == null) {
            throw new IllegalArgumentException(""Parameter appId is required and cannot be null."");
        }
        if (versionId == null) {
            throw new IllegalArgumentException(""Parameter versionId is required and cannot be null."");
        }
        if (regexEntityId == null) {
            throw new IllegalArgumentException(""Parameter regexEntityId is required and cannot be null."");
        }
        String parameterizedHost = Joiner.on("", "").join(""{Endpoint}"", this.client.endpoint());
        return service.getRegexEntityEntityInfo(appId, versionId, regexEntityId, this.client.acceptLanguage(), parameterizedHost, this.client.userAgent())
            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<RegexEntityExtractor>>>() {
                @Override
                public Observable<ServiceResponse<RegexEntityExtractor>> call(Response<ResponseBody> response) {
                    try {
                        ServiceResponse<RegexEntityExtractor> clientResponse = getRegexEntityEntityInfoDelegate(response);
                        return Observable.just(clientResponse);
                    } catch (Throwable t) {
                        return Observable.error(t);
                    }
                }
            });
    }",Gets information about an entity in an App Service Environment.
"public void setContent(IContent content)
	{
		this.content = content;
		content.setParent(this);
		content.setPosition(Position.middleCenter(content).plus(offsetPosition));
	}",Sets the content of the page.
"@Override
    protected AstNode parseCreateViewStatement( DdlTokenStream tokens,
                                                AstNode parentNode ) throws ParsingException {
        assert tokens != null;
        assert parentNode != null;

        markStartOfStatement(tokens);
        // CREATE [OR REPLACE]
        // [[NO] FORCE] VIEW [schema.] view
        // [ ( { alias [ inline_constraint... ]
        // | out_of_line_constraint
        // }
        // [, { alias [ inline_constraint...]
        // | out_of_line_constraint
        // }
        // ]
        // )
        // | object_view_clause
        // | XMLType_view_clause
        // ]
        // AS subquery [ subquery_restriction_clause ] ;

        // NOTE: the query expression along with the CHECK OPTION clause require no SQL statement terminator.
        // So the CHECK OPTION clause will NOT

        String stmtType = ""CREATE"";
        tokens.consume(""CREATE"");
        if (tokens.canConsume(""OR"", ""REPLACE"")) {
            stmtType = stmtType + SPACE + ""OR REPLACE"";
        } else if (tokens.canConsume(""NO"", ""FORCE"")) {
            stmtType = stmtType + SPACE + ""NO FORCE"";
        } else if (tokens.canConsume(""FORCE"")) {
            stmtType = stmtType + SPACE + ""FORCE"";
        }

        tokens.consume(""VIEW"");
        stmtType = stmtType + SPACE + ""VIEW"";

        String name = parseName(tokens);

        AstNode createViewNode = nodeFactory().node(name, parentNode, TYPE_CREATE_VIEW_STATEMENT);

        // CONSUME COLUMNS
        parseColumnNameList(tokens, createViewNode, TYPE_COLUMN_REFERENCE);

        // (object_view_clause)
        //
        // OF [ schema. ] type_name
        // { WITH OBJECT IDENTIFIER
        // { DEFAULT | ( attribute [, attribute ]... ) }
        // | UNDER [ schema. ] superview
        // }
        // ( { out_of_line_constraint
        // | attribute { inline_constraint }...
        // } [, { out_of_line_constraint
        // | attribute { inline_constraint }...
        // }
        // ]...
        // )

        // (XMLType_view_clause)
        //
        // OF XMLTYPE [ XMLSchema_spec ]
        // WITH OBJECT IDENTIFIER
        // { DEFAULT | ( expr [, expr ]...) }

        // Basically, if next token matches ""OF"", then parse until token matches ""AS""

        if (tokens.matches(""OF"")) {
            do {
                tokens.consume();
            } while (!tokens.matches(""AS""));
        }

        tokens.consume(""AS"");

        String queryExpression = parseUntilTerminator(tokens);

        createViewNode.setProperty(CREATE_VIEW_QUERY_EXPRESSION, queryExpression);

        markEndOfStatement(tokens, createViewNode);

        return createViewNode;
    }",Parse a CREATE VIEW statement.
"public byte[] getBytes(int size){ 
        _checkForRead(size);
        byte[] dst = new byte[size];
       _buf.get(dst, 0, size);
       return dst;
    }",Get a byte array of the specified size from the buffer.
"public static vpnglobal_authenticationlocalpolicy_binding[] get(nitro_service service) throws Exception{
		vpnglobal_authenticationlocalpolicy_binding obj = new vpnglobal_authenticationlocalpolicy_binding();
		vpnglobal_authenticationlocalpolicy_binding response[] = (vpnglobal_authenticationlocalpolicy_binding[]) obj.get_resources(service);
		return response;
	}",Use this API to fetch a vpnglobal_authenticationlocalpolicy_binding resources.
"public void setTerms(java.util.Collection<Term> terms) {
        if (terms == null) {
            this.terms = null;
            return;
        }

        this.terms = new java.util.ArrayList<Term>(terms);
    }",Sets the value terms property.
"public SslPolicy withSslProtocols(String... sslProtocols) {
        if (this.sslProtocols == null) {
            setSslProtocols(new java.util.ArrayList<String>(sslProtocols.length));
        }
        for (String ele : sslProtocols) {
            this.sslProtocols.add(ele);
        }
        return this;
    }",A list of ssl protocols to use for this certificate.
"public int scanScalar(int req_width, Pointer _cursor, int len) {
        byte[] cursorb = _cursor.buffer;
        int cursor = _cursor.start;

        int start = 0;
        int flags = SCAN_NONE;
        if(len < 1) {
            return flags;
        }

        switch(cursorb[cursor]) {
        case '[': case ']':
        case '{': case '}':
        case '!': case '*':
        case '&': case '|':
        case '>': case '\'':
        case '""': case '#':
        case '%': case '@':
        case '`':
            flags |= SCAN_INDIC_S;
            break;
        case '-': case ':':
        case '?': case ',':
            if(len == 1 || cursorb[cursor+1] == ' ' || cursorb[cursor+1] == '\n') {
                flags |= SCAN_INDIC_S;
            }
            break;
        }

        if(cursorb[cursor + len - 1] != '\n') {
            flags |= SCAN_NONL_E;
        } else if(len > 1 && cursorb[cursor + len - 2] == '\n') {
            flags |= SCAN_MANYNL_E;
        }

        if(
           (len>0 && (cursorb[cursor] == ' ' || cursorb[cursor] == '\t')) ||
           (len>1 && (cursorb[cursor + len - 1] == ' ' || cursorb[cursor + len - 1] == '\t'))
           ) {
            flags |= SCAN_WHITEEDGE;
        }

        if(len >= 3 && cursorb[cursor] == '-' && cursorb[cursor+1] == '-' && cursorb[cursor+2] == '-') {
            flags |= SCAN_DOCSEP;
        }

        for(int i=0; i<len; i++) {
            int ci = (int)(cursorb[cursor+i]&0xFF);
            if(! ( ci == 0x9 ||
                   ci == 0xA ||
                   ci == 0xD ||
                   (ci >= 0x20 && ci <= 0x7E))) {
                flags |= SCAN_NONPRINT;
            } else if(ci == '\n') {
                flags |= SCAN_NEWLINE;
                if(len - i >= 3 && cursorb[cursor+i+1] == '-' && cursorb[cursor+i+2] == '-' && cursorb[cursor+i+3] == '-' ) {
                    flags |= SCAN_DOCSEP;
                }
                if(i+1 < len && (cursorb[cursor+i+1] == ' ' || cursorb[cursor+i+1] == '\t')) {
                    flags |= SCAN_INDENTED;
                }
                if(req_width > 0 && (i - start) > req_width) {
                    flags |= SCAN_WIDE;
                }
                start = i;
            } else if(ci == '\'') {
                flags |= SCAN_SINGLEQ;
            } else if(ci == '""') {
                flags |= SCAN_DOUBLEQ;
            } else if(ci == ']') {
                flags |= SCAN_FLOWSEQ;
            } else if(ci == '}') {
                flags |= SCAN_FLOWMAP;
            } else if(((ci == ' ' && (i+1<len && cursorb[cursor+i+1] == '#') ) ||
                       (ci == ':' && ((i+1<len && cursorb[cursor+i+1] == ' ') || 
                                      (i+1<len && cursorb[cursor+i+1] == '\n') || 
                                      i == len - 1 )))) {
                flags |= SCAN_INDIC_C;
            } else if(ci == ',' && ((i == len - 1 ||
                                     cursorb[cursor+i+1] == ' ' || 
                                     cursorb[cursor+i+1] == '\n'))) {
                flags |= SCAN_FLOWMAP;
                flags |= SCAN_FLOWSEQ;
            }
        }

        return flags;
    }",Scan scalar.
"private boolean fastAllPathsReturnCheck(ControlFlowGraph<Node> cfg) {
    for (DiGraphEdge<Node, Branch> s : cfg.getImplicitReturn().getInEdges()) {
      Node n = s.getSource().getValue();
      // NOTE(dimvar): it is possible to change ControlFlowAnalysis.java, so
      // that the calls that always throw are treated in the same way as THROW
      // in the CFG. Then, we would not need to use the coding convention here.
      if (!n.isReturn() && !convention.isFunctionCallThatAlwaysThrows(n)) {
        return false;
      }
    }
    return true;
  }",Fast check for all paths that always throw a return value.
"public static Date dateStrToDate(final String dateStr) {
		
		String paddedDateStr = padStartDateStr(dateStr);
		try {
			return ArchiveUtils.parse14DigitDate(paddedDateStr);
		} catch (ParseException e) {
			e.printStackTrace();
			// TODO: This is certainly not the right thing, but padStartDateStr
			// should ensure we *never* get here..
			return new Date((long)SSE_YEAR_LOWER_LIMIT * 1000);
		}
	}",Converts a date string to a Date object.
"public QueryResult execute(Query query) throws QueryEngineException {
        if (!(query instanceof QueryImpl)) {
            throw new QueryEngineException(""Couldn't cast Query to QueryImpl."");
        }
        QueryImpl q = (QueryImpl) query;


        // search for unbound results vars
        resvarsLoop:
        for (QueryArgument arg : q.getResultVars()) {
            for (QueryAtomGroup g : q.getAtomGroups()) {
                for (QueryAtom a : g.getAtoms()) {
                    if (a.getArguments().contains(arg)) {
                        continue resvarsLoop;
                    }
                }
            }
//			throw new QueryEngineException(""Query contains an unbound result argument "" + arg + ""."");
        }

        Queue<QueryResultImpl> results = new LinkedList<>();
        for (QueryAtomGroup g : q.getAtomGroups()) {

            QueryAtomGroupImpl group = (QueryAtomGroupImpl) g;

            List<QueryAtomGroupImpl> components = findComponents(group);
            Queue<QueryResultImpl> componentResults = new LinkedList<>();
            boolean groupAsk = true;
            for (QueryAtomGroupImpl component : components) {

                QueryAtomGroupImpl preorderedGroup = preorder(component);

                QueryResultImpl result = new QueryResultImpl(query);
                if (eval(q, preorderedGroup, result, new QueryBindingImpl(), BoundChecking.CHECK_BOUND)) {
                    if (query.isSelectDistinct()) {
                        result = eliminateDuplicates(result);
                    }

                    componentResults.add(result);
                }
                else {
                    groupAsk = false;
                    break;
                }
            }

            if (groupAsk) {
                results.add(combineResults(componentResults,
                                           query.getType() == SELECT_DISTINCT));
            }
            else {
                // return only empty result with no solution for this group
                QueryResultImpl ret = new QueryResultImpl(query);
                ret.setAsk(false);
                results.add(ret);
            }
        }

        return unionResults(q, results, query.getType() == SELECT_DISTINCT);
    }",Execute the given query.
"protected void addTagsAsChildren( Git git,
                                      CallSpecification spec,
                                      DocumentWriter writer ) throws GitAPIException {
        // Generate the child references to the branches, which will be sorted by name (by the command).
        ListTagCommand command = git.tagList();
        List<Ref> tags = command.call();
        // Reverse the sort of the branch names, since they might be version numbers ...
        Collections.sort(tags, REVERSE_REF_COMPARATOR);
        for (Ref ref : tags) {
            String fullName = ref.getName();
            String name = fullName.replaceFirst(TAG_PREFIX, """");
            writer.addChild(spec.childId(name), name);
        }
    }",Add the tags as children of the branch.
"public void resume(UOWHandle handle) throws CSIException {
        final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();
        if (isTraceOn && tc.isEntryEnabled())
            Tr.entry(tc, ""resume : "" + handle);

        //A null handle indicates that during the execution of the corresponding suspend,
        //there wasn't a Tx to suspend, so do nothing.
        if (handle != null) {
            //Cast the handle to a UOWHandleImpl in order to get the instance
            //variables from it.
            UOWHandleImpl handleImpl = (UOWHandleImpl) handle;

            try {
                //From the handle we can determine if it is a local tx.  If so resume the local
                // tx, otherwise we have a global tx.
                if (handleImpl.suspendedLocalTx != null) {
                    //Get the LocalTransactionCoordinator from the handle, and resume the local
                    //Tx associated with it.
                    resumeLocalTx(handleImpl.suspendedLocalTx);
                }
                else {
                    //Get the suspended global tx from the handle, and resume the global
                    //tx associated with it.
                    resumeGlobalTx(handleImpl.suspendedGlobalTx, TIMEOUT_CLOCK_START);
                }
            } catch (Throwable t) {
                FFDCFilter.processException(t, CLASS_NAME + "".resume"", ""1491"", this);
                if (isTraceOn && tc.isEntryEnabled())
                    Tr.exit(tc, ""resume"", ""Error resuming tx in TransactionControlImpl: "" + t);
                throw new CSIException(""Error resuming tx in TransactionControlImpl."", t);
            }
        }

        if (isTraceOn && tc.isEntryEnabled())
            Tr.exit(tc, ""resume"");
    }",Resume the transaction associated with the specified UOWHandle.
"public static Collection<AbstractAttribute> findAttributesByAttributeFilter(
            final boolean parallel,
            final Predicate<? super AbstractAttribute> filter,
            final AbstractHtml... fromTags) throws NullValueException {

        if (filter == null) {
            throw new NullValueException(""The tagName should not be null"");
        }

        if (fromTags == null) {
            throw new NullValueException(""The fromTags should not be null"");
        }

        final Collection<Lock> locks = getReadLocks(fromTags);
        for (final Lock lock : locks) {
            lock.lock();
        }

        try {
            return getAllNestedChildrenIncludingParent(parallel, fromTags)
                    .filter(child -> {
                        return child.getAttributes() != null;
                    }).map(child -> {
                        return child.getAttributes();
                    }).flatMap(attributes -> attributes.stream()).filter(filter)
                    .collect(Collectors.toSet());
        } finally {
            for (final Lock lock : locks) {
                lock.unlock();
            }
        }
    }",Find attributes by attribute filter.
"private void sendFile(final YokeRequest request, final String file, final FileProps props) {
        // write content type
        String contentType = MimeType.getMime(file);
        String charset = MimeType.getCharset(contentType);
        request.response().setContentType(contentType, charset);
        request.response().putHeader(""Content-Length"", Long.toString(props.size()));

        // head support
        if (HttpMethod.HEAD.equals(request.method())) {
            request.response().end();
        } else {
            request.response().sendFile(file);
        }
    }",Send file.
"public final String getValue() {
        final StringBuilder b = new StringBuilder();
        if (getMinVersion() != null) {
            b.append(getMinVersion());
            if (getMaxVersion() != null) {
                b.append(';');
            }
        }
        if (getMaxVersion() != null) {
            b.append(getMaxVersion());
        }
        return b.toString();
    }",Gets the value of the attribute.
"private static boolean keyIsValid(final BinaryRequest request) {
        if (request.keyBytes() == null || request.keyBytes().length < MIN_KEY_BYTES) {
            request.observable().onError(new IllegalArgumentException(""The Document ID must not be null or empty.""));
            return false;
        }

        if (request.keyBytes().length > MAX_KEY_BYTES) {
            request.observable().onError(new IllegalArgumentException(
                ""The Document ID must not be longer than 250 bytes.""));
            return false;
        }

        return true;
    }",Check if the key is valid.
"public void setRfpType(com.google.api.ads.admanager.axis.v201811.RfpType rfpType) {
        this.rfpType = rfpType;
    }",Sets the rfpType value for this BaseRfp.
"private static void allocateNodeLengthsWithRelocation(final int[] array,
                                                           final int nodesToMove, final int insertDepth) {
        int firstNode = array.length - 2;
        int nextNode = array.length - 1;
        int currentDepth = insertDepth == 1 ? 2 : 1;
        int nodesLeftToMove = insertDepth == 1 ? nodesToMove - 2 : nodesToMove;

        for (int availableNodes = currentDepth << 1; availableNodes > 0; currentDepth++) {
            final int lastNode = firstNode;
            firstNode = firstNode <= nodesToMove ? firstNode : first(array, lastNode - 1, nodesToMove);

            int offset = 0;
            if (currentDepth >= insertDepth) {
                offset = Math.min(nodesLeftToMove, 1 << (currentDepth - insertDepth));
            } else if (currentDepth == insertDepth - 1) {
                offset = 1;
                if (array[firstNode] == lastNode) {
                    firstNode++;
                }
            }

            for (int i = availableNodes - (lastNode - firstNode + offset); i > 0; i--) {
                array[nextNode--] = currentDepth;
            }

            nodesLeftToMove -= offset;
            availableNodes = (lastNode - firstNode + offset) << 1;
        }
    }",Allocate node lengths with relocation.
"public Map<String, List<String>> listCommands() {
        Map<String, List<String>> result = new HashMap<String, List<String>>();
        for (String cat : restMetadataJson.keySet())  {
            JsonObject commands = restMetadataJson.getJsonObject(cat);
            List<String> names = new ArrayList<String>();
            for (String commandName: commands.keySet()) {
                names.add(commandName);
            }       
            result.put(cat, names);
        }
        return result;
    }",List all the commands in the resource.
"@Override
	public void open(Configuration config) throws IOException {
		streamer.open();
		streamer.sendBroadCastVariables(config);
	}",Open the connection to the server.
"public List<JAXBElement<Object>> get_GenericApplicationPropertyOfSquare() {
        if (_GenericApplicationPropertyOfSquare == null) {
            _GenericApplicationPropertyOfSquare = new ArrayList<JAXBElement<Object>>();
        }
        return this._GenericApplicationPropertyOfSquare;
    }",Gets the value of the genericApplicationPropertyOfSquare property.
"public static Object columnlist(PageContext pc, Object obj) throws PageException {
	if (obj instanceof Query) {
	    Key[] columnNames = ((Query) obj).getColumnNames();

	    boolean upperCase = pc.getCurrentTemplateDialect() == CFMLEngine.DIALECT_CFML;

	    StringBuilder sb = new StringBuilder();
	    for (int i = 0; i < columnNames.length; i++) {
		if (i > 0) sb.append(',');
		sb.append(upperCase ? columnNames[i].getUpperString() : columnNames[i].getString());
	    }
	    return sb.toString();

	}
	return pc.getCollection(obj, KeyConstants._COLUMNLIST);
    }",returns a column list of the specified object
"public static void exportevaluationCalibrationToHtmlFile(EvaluationCalibration ec, File file) throws IOException {
        String asHtml = evaluationCalibrationToHtml(ec);
        FileUtils.writeStringToFile(file, asHtml);
    }",Export evaluation calibration to HTML file.
"public static DrawBlock getDrawBlockFromBlockState(IBlockState state, List<IProperty> extraProperties)
    {
        if (state == null)
            return null;

        DrawBlock block = new DrawBlock();
        Object blockName = Block.REGISTRY.getNameForObject(state.getBlock());
        if (blockName instanceof ResourceLocation)
        {
            String name = ((ResourceLocation)blockName).getResourcePath();
            BlockType type = BlockType.fromValue(name);
            block.setType(type);
        }

        Colour col = null;
        Variation var = null;
        Facing face = null;

        // Add properties:
        for (IProperty prop : state.getProperties().keySet())
        {
            String propVal = state.getValue(prop).toString();
            boolean matched = false;
            // Try colour first:
            if (col == null)
            {
                col = attemptToGetAsColour(propVal);
                if (col != null)
                    matched = true;
            }
            // Then variant:
            if (!matched && var == null)
            {
                var = attemptToGetAsVariant(propVal);
                if (var != null)
                    matched = true;
            }
            // Then facing:
            if (!matched && face == null)
            {
                face = attemptToGetAsFacing(propVal);
                if (face != null)
                    matched = true;
            }
            if (!matched)
            {
                if (extraProperties != null)
                    extraProperties.add(prop);
            }
        }
        if (col != null)
            block.setColour(col);
        if (var != null)
            block.setVariant(var);
        if (face != null)
            block.setFace(face);
        return block;
    }",Get a DrawBlock object from a block state.
"protected SemanticSpace getSpace() {
        Transform transform = null;
        if (argOptions.hasOption('T'))
            transform = ReflectionUtil.getObjectInstance(
                    argOptions.getStringOption('T'));
        else
            transform = new NoTransform();
        int bound = argOptions.getIntOption('b', 10000);
        int windowSize = argOptions.getIntOption('w', 5);
        return new OccurrenceCounter(transform, bound, windowSize);
    }",Get the SemanticSpace object.
"public void setLastPoint(Point3d point) {
		if (this.numCoordsProperty.get()>=3) {
			this.coordsProperty[this.numCoordsProperty.get()-3] = point.xProperty;
			this.coordsProperty[this.numCoordsProperty.get()-2] = point.yProperty;
			this.coordsProperty[this.numCoordsProperty.get()-1] = point.zProperty;
			this.graphicalBounds = null;
			this.logicalBounds = null;
		}
	}",Sets the last point of this shape.
"private void addListToTerm(List<NewWord> newWords) {
		if (newWords.size() == 0) {
			return;
		}
		for (NewWord newWord : newWords) {

			TermNatures termNatures = new NatureRecognition(forests).getTermNatures(newWord.getName());

			if (termNatures == TermNatures.NULL) {
				addTerm(newWord);
			}
		}
	}",Adds the list of words to the term.
"private JsonToken scanUnquotedString(final char firstChar) {
        StringBuilder sb = new StringBuilder();
        sb.append(firstChar);
        int c = buffer.read();
        while (c == '$' || c == '_' || Character.isLetterOrDigit(c)) {
            sb.append((char) c);
            c = buffer.read();
        }
        buffer.unread(c);
        String lexeme = sb.toString();
        return new JsonToken(JsonTokenType.UNQUOTED_STRING, lexeme);
    }",Scan an unquoted string.
"public Object getInfoFromHandle(Object bookmark, boolean bGetTable, int iHandleType) throws DBException
    {
        if (iHandleType == DBConstants.OBJECT_ID_HANDLE)
        {
            if (!(bookmark instanceof String))
                return null;
            int iLastColon = ((String)bookmark).lastIndexOf(BaseTable.HANDLE_SEPARATOR);
            if (iLastColon == -1)
                return null;
            if (bGetTable)
                return ((String)bookmark).substring(0, iLastColon);
            else
                return ((String)bookmark).substring(iLastColon+1);
        }
        return bookmark;
    }",Get the bookmark from the bookmark.
"public static void writePng(Image image, OutputStream out) throws IORuntimeException {
		write(image, IMAGE_TYPE_PNG, out);
	}",Write a PNG image to an OutputStream.
"public static int select(long w, int j) {
    int part1 = (int) (w & 0xFFFFFFFF);
    int wfirsthalf = Integer.bitCount(part1);
    if (wfirsthalf > j) {
      return select(part1, j);
    } else {
      return select((int) (w >>> 32), j - wfirsthalf) + 32;
    }
  }",Select the first j bits of a long.
"public static boolean hasRoles(List<String> roleNames) throws Throwable
    {
        DEADBOLT_HANDLER.beforeRoleCheck();

        RoleHolder roleHolder = getRoleHolder();

        return roleHolder != null &&
               roleHolder.getRoles() != null &&
               hasAllRoles(roleHolder,
                           roleNames.toArray(new String[roleNames.size()]));
    }",Check if a set of roles exists in the current application.
"public void drawCornerShadow(
            Canvas canvas,
            Matrix matrix,
            RectF bounds,
            int elevation,
            float startAngle,
            float sweepAngle) {

        Path arcBounds = scratch;

        // Calculate the arc bounds to prevent drawing shadow in the same part of the arc.
        arcBounds.rewind();
        arcBounds.moveTo(bounds.centerX(), bounds.centerY());
        arcBounds.arcTo(bounds, startAngle, sweepAngle);
        arcBounds.close();

        bounds.inset(-elevation, -elevation);
        cornerColors[0] = 0;
        cornerColors[1] = shadowStartColor;
        cornerColors[2] = shadowMiddleColor;
        cornerColors[3] = shadowEndColor;

        float startRatio = 1f - (elevation / (bounds.width() / 2f));
        float midRatio = startRatio + ((1f - startRatio) / 2f);
        cornerPositions[1] = startRatio;
        cornerPositions[2] = midRatio;

        cornerShadowPaint.setShader(
                new RadialGradient(
                        bounds.centerX(),
                        bounds.centerY(),
                        bounds.width() / 2,
                        cornerColors,
                        cornerPositions,
                        Shader.TileMode.CLAMP));

        // TODO: handle oval bounds by scaling the canvas.

        canvas.save();
        canvas.concat(matrix);
        cornerShadowPaint.setStyle(Paint.Style.STROKE);
        cornerShadowPaint.setStrokeWidth(elevation * 2);
        canvas.drawArc(bounds, startAngle, sweepAngle, false, cornerShadowPaint);
        canvas.restore();
    }",Draw a corner shadow.
"@Override
	public StatementInfo[] getInfos(String CorpNum, int ItemCode,
			String[] MgtKeyList) throws PopbillException {
		if (MgtKeyList == null)
			throw new PopbillException(-99999999, ""관리번호 배열이 입력되지 않았습니다."");
		
		String PostData = toJsonString(MgtKeyList);
		
		return httppost(""/Statement/"" + ItemCode, CorpNum, 
					PostData, null, StatementInfo[].class);
	}",Get the Statement infos for the given item code
"synchronized void close()
   {
      releaseWriterAndReaders();
      if (directory != null)
      {
         try
         {
            directory.close();
         }
         catch (IOException e)
         {
            directory = null;
         }
      }
   }",Close the file system.
"public static boolean isColumnNullable (Connection conn, String table,
                                            String column)
        throws SQLException
    {
        ResultSet rs = getColumnMetaData(conn, table, column);
        try {
            return rs.getString(""IS_NULLABLE"").equals(""YES"");
        } finally {
            rs.close();
        }
    }",Get the column nullable.
"@Override
	public void cacheResult(
		CommerceUserSegmentCriterion commerceUserSegmentCriterion) {
		entityCache.putResult(CommerceUserSegmentCriterionModelImpl.ENTITY_CACHE_ENABLED,
			CommerceUserSegmentCriterionImpl.class,
			commerceUserSegmentCriterion.getPrimaryKey(),
			commerceUserSegmentCriterion);

		commerceUserSegmentCriterion.resetOriginalValues();
	}",Caches the commerce user segment criterion in the entity cache if it is enabled.
"protected void prepareDataForNextChannel() {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {
            Tr.entry(tc, ""prepareDataForNextChannel"");
        }

        // Ensure the output buffers are already set in place for the calling channel.
        if (getJITAllocateAction()) {
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""Allocation was done here, adjust and hand off buffers, JIT=""
                             + getJITAllocateSize());
            }

            // Multiple cases to handle here. Remember, we allocated these buffers.
            // 1 - decNetBuffers has only 1 buffer and it is <= the JIT size
            // We can just send it up to the caller.
            // 2 - decNetBuffers has only 1 buffer, but it is > the JIT size
            // We need to copy it to a JIT sized buffer and save the rest of a future read.
            // 3 - decNetBuffers has multiple buffers, the first of which has the matching JIT size.
            // We should pass the first buffer back to the caller and save the rest of a future read.
            // 4 - decNetBuffers has multiple buffers, the first of which does not match the JIT size.
            // We have to check ensure the JIT size is honored. May have to do a buffer copy.
            int decryptedDataSize = SSLUtils.lengthOf(decryptedNetBuffers, 0);
            if (decryptedNetBuffers.length == 1) {
                if (decryptedDataSize <= getJITAllocateSize()) {

                    // Case 1:
                    // There is only one decryptedNetBuffer and the size is less than the JIT.
                    // Therefore, we can return this buffer to the caller.
                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                        Tr.debug(tc, ""single decNetBuffer is okay to pass to caller"");
                    }
                    // Data is currently between pos and lim. Adjust for calling channel.
                    SSLUtils.positionToLimit(decryptedNetBuffers);
                    // Reset the limits saved for the decryptedNetBuffers.
                    SSLUtils.setBufferLimits(decryptedNetBuffers, decryptedNetLimitInfo);
                    // Store the decrypted buffer to this context for reference by the caller.
                    setBuffer(decryptedNetBuffers[0]);

                } else {
                    // Case 2:
                    // There is only one decryptedNetBuffer, but the size is greater than the JIT.
                    // Therefore, we have to copy the buffer into a JIT sized buffer
                    // and save the left overs.
                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                        Tr.debug(tc, ""only one decNetBuffer, but too big (""
                                     + decryptedDataSize + "") for JIT.  Need to copy."");
                    }
                    // Create a new buffer to hand to the caller.
                    // We want to reuse copyDataToCallerBuffers.
                    // It copies from decryptedNetBuffers to getBuffers() which
                    // are currently the same, so change it.
                    setBuffer(SSLUtils.allocateByteBuffer(getJITAllocateSize(), false));
                    getBuffer().limit(getJITAllocateSize());
                    // Copy from the decNetBuffers into the buffers to be sent to the caller.
                    copyDataToCallerBuffers();
                }

            } else {
                // There are > 1 decryptedNetBuffers.
                // Check if the first one matches the JIT size.
                // TODO this is wrong. should be using capacity() instead of
                // remaining I think since after decrypt, remaining is less than
                // buffer cap (decrypt 4 bytes and remaining is 8188 but buffer is
                // the 8192 that JIT size is by default), meaning it's fine
                // not sure about all cases though...
                if (decryptedNetBuffers[0].remaining() == getJITAllocateSize()) {
                    // Case 3:
                    // Found a match. Return the first buffer to the caller and
                    // save the rest for a future read.
                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                        Tr.debug(tc, ""multiple buffers, first of which matches the JIT size"");
                    }
                    // Data is currently between pos and lim. Adjust for calling channel.
                    decryptedNetBuffers[0].position(decryptedNetBuffers[0].limit());
                    // Store the decrypted buffer to this context for reference by the caller.
                    setBuffer(decryptedNetBuffers[0]);
                    // Now save the other buffers in the unconsumedDecData (which is null at this point)
                    if (null != unconsumedDecData) {
                        if (TraceComponent.isAnyTracingEnabled() && tc.isEventEnabled()) {
                            Tr.event(tc, ""Expected null unconsumed array, but isn't: ""
                                         + SSLUtils.getBufferTraceInfo(unconsumedDecData));
                        }
                        // shouldn't release buffers we might not own (especially since
                        // they shouldn't even be here in the first place)
                        // WsByteBufferUtils.releaseBufferArray(unconsumedDecData);
                    }
                    // figure out if any more buffers exist with actual data to save
                    int size = 0;
                    for (int i = 1; i < decryptedNetBuffers.length; i++) {
                        // if there is nothing in this buffer, just release it
                        if (0 == decryptedNetBuffers[i].remaining()) {
                            decryptedNetBuffers[i].release();
                        } else {
                            size++;
                        }
                    }
                    if (0 < size) {
                        unconsumedDecData = new WsByteBuffer[size];
                        for (int i = 1, x = 0; x < size; i++, x++) {
                            unconsumedDecData[x] = decryptedNetBuffers[i];
                        }
                        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                            Tr.debug(tc, ""unconsumedDecData: ""
                                         + SSLUtils.getBufferTraceInfo(unconsumedDecData));
                        }
                    }

                } else {
                    // Case 4:
                    // Multiple buffers, first of which doesn't match the JIT. Need to copy.
                    if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                        Tr.debug(tc, ""multiple buffers, first does not match the JIT size."");
                    }
                    // Create a new buffer to hand to the caller.
                    // We want to reuse copyDataToCallerBuffers.
                    // It copies from decryptedNetBuffers to getBuffers() which
                    // are currently the same, so change it.
                    setBuffer(SSLUtils.allocateByteBuffer(getJITAllocateSize(), false));
                    getBuffer().limit(getJITAllocateSize());
                    // Adjust the decryptedNetBuffers. Results from the JSSE keep
                    // untouched buffers with their pos = lim. Buffers with data
                    // have nonzero pos and lim. Unused buffers have zero
                    // pos and lim. We need the data to be between pos and lim
                    // for the copy. Zeroing out the pos enables this.
                    for (int i = 0; i < decryptedNetBuffers.length; i++) {
                        decryptedNetBuffers[i].position(0);
                    }
                    // Copy from the decNetBuffers into the buffers to be sent to the caller.
                    copyDataToCallerBuffers();
                }
            }

        } else {
            if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                Tr.debug(tc, ""Using channel provided buffers"");
            }
            // Calling channel provided buffers to read into.
            if (decryptedNetBufferReleaseRequired) {
                // User provided buffers were not originally adequate. Temporary
                // buffers were allocated to hold the result.
                for (int i = 0; i < this.decryptedNetBuffers.length; i++) {
                    if (null != this.decryptedNetBuffers[i]) {
                        this.decryptedNetBuffers[i].position(0);
                    }
                }
                copyDataToCallerBuffers();
            } else {
                // User provided buffers were adequate
                SSLUtils.positionToLimit(decryptedNetBuffers);
                SSLUtils.setBufferLimits(decryptedNetBuffers, decryptedNetLimitInfo);
            }
        }
        // The decryptedNetBuffers are being given to the next channel.
        // Eliminate tracking of ownership.
        decryptedNetBuffers = null;
        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
            Tr.debug(tc, ""Buffers being sent to next channel: ""
                         + SSLUtils.getBufferTraceInfo(getBuffers()));
        }

        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled()) {
            Tr.exit(tc, ""prepareDataForNextChannel"");
        }
    }",This method is called by the SSL channel to prepare the output buffers for the next channel.
"@Indexable(type = IndexableType.DELETE)
	@Override
	public CommerceNotificationTemplate deleteCommerceNotificationTemplate(
		long commerceNotificationTemplateId) throws PortalException {
		return commerceNotificationTemplatePersistence.remove(commerceNotificationTemplateId);
	}",Deletes the commerce notification template with the primary key from the database. Also notifies the appropriate model listeners.
"public ReportRequest asReportRequest(ReportingRule rules, Clock clock) {
    Preconditions.checkState(!Strings.isNullOrEmpty(getServiceName()),
        ""a service name must be set"");

    // Populate metrics and labels if they can be associated with a method/operation
    Operation.Builder o = asOperation(clock).toBuilder();
    if (!Strings.isNullOrEmpty(o.getOperationId())
        && !Strings.isNullOrEmpty(o.getOperationName())) {
      Map<String, String> addedLabels = Maps.newHashMap();
      for (KnownLabels l : rules.getLabels()) {
        l.performUpdate(this, addedLabels);
      }
      // Forcibly add platform reporting here, as the base service config does not specify it as a
      // label.
      if (!o.getLabelsMap().containsKey(KnownLabels.SCC_PLATFORM.getName())) {
        KnownLabels.SCC_PLATFORM.performUpdate(this, addedLabels);
      }
      o.putAllLabels(getSystemLabels());
      o.putAllLabels(addedLabels);
      KnownMetrics[] metrics = rules.getMetrics();
      for (KnownMetrics m : metrics) {
        m.performUpdate(this, o);
      }
    }

    String[] logs = rules.getLogs();
    long timestampMillis = clock.currentTimeMillis();
    for (String l : logs) {
      o.addLogEntries(asLogEntry(l, timestampMillis));
    }

    return ReportRequest.newBuilder().addOperations(o).setServiceName(getServiceName()).build();
  }",Creates a ReportRequest object from this report rule.
"public PrintWriter getLogWriter() throws SQLException
    {
        if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled())
            Tr.debug(tc, ""getLogWriter : "" + ivPuId + "", "" + ivLogWriter);

        return ivLogWriter;
    }",Get the PrintWriter object that will be used to write the log file to the underlying stream.
"public PhotoList<Photo> getPhotos(String photosetId, int perPage, int page) throws FlickrException {
        return getPhotos(photosetId, Extras.MIN_EXTRAS, Flickr.PRIVACY_LEVEL_NO_FILTER, perPage, page);
    }",Get a list of photos from a photoset.
"public static <T, X extends Throwable> Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(
            final Stream<T> stream, final long x, final Consumer<? super T> consumerElement, final Consumer<? super Throwable> consumerError) {
        return forEachXEvents(stream, x, consumerElement, consumerError, () -> {
        });
    }",For each X event of a Stream with a Consumer element and a Consumer error.
"public static SSTableIndexIndex readIndex(final FileSystem fileSystem, final Path sstablePath) throws IOException {
        final Closer closer = Closer.create();
        final Path indexPath = sstablePath.suffix(SSTABLE_INDEX_SUFFIX);

        // Detonate if we don't have an index.
        final FSDataInputStream inputStream = closer.register(fileSystem.open(indexPath));

        final SSTableIndexIndex indexIndex = new SSTableIndexIndex();
        try {
            while (inputStream.available() != 0) {
                indexIndex.add(inputStream.readLong(), inputStream.readLong());
            }
        } finally {
            closer.close();
        }

        return indexIndex;
    }",Read the index.
"public <T> T unwrap(final Class<T> iface) throws SQLException {
        if (!isWrapperFor(iface)) {
            throw new SQLException();
        } // end of if

        @SuppressWarnings(""unchecked"")
        final T proxy = (T) this;

        return proxy;
    }",Unwraps the underlying object.
"private V binarySearch(final K iKey) {
    int low = 0;
    int high = getSize() - 1;
    int mid = 0;

    while (low <= high) {
      mid = (low + high) >>> 1;
      Object midVal = getKeyAt(mid);

      if (tree.comparator != null)
        tree.pageItemComparator = tree.comparator.compare((K) midVal, iKey);
      else
        tree.pageItemComparator = ((Comparable<? super K>) midVal).compareTo(iKey);

      if (tree.pageItemComparator == 0) {
        // FOUND: SET THE INDEX AND RETURN THE NODE
        tree.pageItemFound = true;
        tree.pageIndex = mid;
        return getValueAt(tree.pageIndex);
      }

      if (low == high)
        break;

      if (tree.pageItemComparator < 0)
        low = mid + 1;
      else
        high = mid;
    }

    tree.pageIndex = mid;
    return null;
  }",Searches for the key in the array and returns the value at the index.
"private static String initCreateEntityQuery(EntityKeyMetadata entityKeyMetadata) {
		StringBuilder queryBuilder = new StringBuilder( ""CREATE "" );
		appendEntityNode( ENTITY_ALIAS, entityKeyMetadata, queryBuilder );
		queryBuilder.append( "" RETURN "" );
		queryBuilder.append( ENTITY_ALIAS );
		return queryBuilder.toString();
	}",Create the create entity query.
"public void loadFolder(String folderPath) {
		// Get the file path.
		File path = null;
		if(folderPath != null && folderPath.length() > 0) {
			path = new File(folderPath);
		}
		
		this.loadFolder(path);
	}",Loads a folder from the file system.
"@Override
	public void addDecorator(String clazzName, IDecorator decorator) {
		registry.put(clazzName, decorator);
	}",Add a decorator to the registry.
"protected boolean setConnector() {
    if (this.host == null) {
      log.error(""No host value set, cannot set up socket connector."");
      return false;
    }
    if (this.port < 0 || this.port > 65535) {
      log.error(""Port value is invalid {}."", Integer.valueOf(this.port));
      return false;
    }
    if (this.executors == null) {
      this.executors = new ExecutorFilter(1);
    }

    this.connector = new NioSocketConnector();
    this.connector.getSessionConfig().setIdleTime(IdleStatus.WRITER_IDLE,
        ClientWorldModelInterface.TIMEOUT_PERIOD / 2);
//    this.connector.getSessionConfig().setIdleTime(IdleStatus.READER_IDLE,
//        (int) (ClientWorldModelInterface.TIMEOUT_PERIOD * 1.1f));
    if (!this.connector.getFilterChain().contains(
        WorldModelClientProtocolCodecFactory.CODEC_NAME)) {
      this.connector.getFilterChain().addLast(
          WorldModelClientProtocolCodecFactory.CODEC_NAME,
          new ProtocolCodecFilter(
              new WorldModelClientProtocolCodecFactory(true)));
    }
    this.connector.getFilterChain().addLast(""ExecutorPool"", this.executors);
    this.connector.setHandler(this.ioHandler);
    log.debug(""Connector set up successful."");
    return true;
  }",Set the connector.
"public Observable<ServiceResponse<JobExecutionInner>> createWithServiceResponseAsync(String resourceGroupName, String serverName, String jobAgentName, String jobName) {
        if (resourceGroupName == null) {
            throw new IllegalArgumentException(""Parameter resourceGroupName is required and cannot be null."");
        }
        if (serverName == null) {
            throw new IllegalArgumentException(""Parameter serverName is required and cannot be null."");
        }
        if (jobAgentName == null) {
            throw new IllegalArgumentException(""Parameter jobAgentName is required and cannot be null."");
        }
        if (jobName == null) {
            throw new IllegalArgumentException(""Parameter jobName is required and cannot be null."");
        }
        if (this.client.subscriptionId() == null) {
            throw new IllegalArgumentException(""Parameter this.client.subscriptionId() is required and cannot be null."");
        }
        if (this.client.apiVersion() == null) {
            throw new IllegalArgumentException(""Parameter this.client.apiVersion() is required and cannot be null."");
        }
        Observable<Response<ResponseBody>> observable = service.create(resourceGroupName, serverName, jobAgentName, jobName, this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent());
        return client.getAzureClient().getPostOrDeleteResultAsync(observable, new TypeToken<JobExecutionInner>() { }.getType());
    }",Creates a new job in an App Service Environment.
"public void updateSecurityMetadataWithRunAs(SecurityMetadata securityMetadataFromDD, IServletConfig servletConfig) {
        String runAs = servletConfig.getRunAsRole();
        if (runAs != null) {
            String servletName = servletConfig.getServletName();
            //only add if there is no run-as entry in web.xml
            Map<String, String> servletNameToRunAsRole = securityMetadataFromDD.getRunAsMap();
            if (servletNameToRunAsRole.get(servletName) == null) {
                servletNameToRunAsRole.put(servletName, runAs);
                List<String> allRoles = securityMetadataFromDD.getRoles();
                if (!allRoles.contains(runAs)) {
                    allRoles.add(runAs);
                }
                if (TraceComponent.isAnyTracingEnabled() && tc.isDebugEnabled()) {
                    Tr.debug(tc, ""Added runAs role: "" + runAs);
                }
            }
        }
    }",Update the security metadata with the run - as entry in web. xml.
"static <K, V> WellBehavedMap<K, V> wrap(Map<K, V> delegate) {
    return new WellBehavedMap<K, V>(delegate);
  }",Wrap a map in a WellBehavedMap.
"public void writeToFile(File file, String fileContent) {
        if (!file.exists()) {
            try {
                FileWriter writer = new FileWriter(file);
                writer.write(fileContent);
                writer.close();
            } catch (FileNotFoundException e) {
                e.printStackTrace();
            } catch (IOException e) {
                e.printStackTrace();
            } finally {

            }
        }
    }",Write to file.
"@Override
    public void visit(NodeVisitor v) {
        if (v.visit(this)) {
            for (AstNode var : variables) {
                var.visit(v);
            }
        }
    }",Visit this node then all the variables.
"public static void extractZip(final String path, final File dest, final String prefix, final String stripPrefix,
                                  final streamCopier copier) throws IOException {
        extractZip(path, dest, prefix, new PrefixStripper(stripPrefix), copier);
    }",Extract a zip file to a destination file using the CID license.
"public Object allocateConnection(ManagedConnectionFactory mcf, ConnectionRequestInfo cri) throws ResourceException
   {
      if (shutdown.get())
         throw new ResourceException();
      Credential credential;
      if (subjectFactory == null || cmConfiguration.getSecurityDomain() == null)
      {
         credential = new Credential(null, cri);
      }
      else
      {
         credential = new Credential(SecurityActions.createSubject(subjectFactory,
                                                                   cmConfiguration.getSecurityDomain(),
                                                                   mcf),
                                     cri);
      }
      org.ironjacamar.core.connectionmanager.listener.ConnectionListener cl = getConnectionListener(credential);
      Object connection = cl.getConnection();

      if (ccm != null)
         ccm.registerConnection(this, cl, connection);

      return connection;
   }",Allocate a connection.
"public I_CmsExtractionResult extractContent(CmsObject cms, CmsResource resource, I_CmsSearchIndex index)
    throws CmsIndexException, CmsException {

        logContentExtraction(resource, index);
        CmsFile file = readFile(cms, resource);
        try {
            return CmsExtractorPdf.getExtractor().extractText(file.getContents());
        } catch (Exception e) {
            if (e.getClass().getSimpleName().equals(""EncryptedDocumentException"")) {
                throw new CmsIndexException(
                    Messages.get().container(Messages.ERR_DECRYPTING_RESOURCE_1, resource.getRootPath()),
                    e);
            }
            if (e instanceof InvalidPasswordException) {
                // default password """" was wrong.
                throw new CmsIndexException(
                    Messages.get().container(Messages.ERR_PWD_PROTECTED_1, resource.getRootPath()),
                    e);
            }
            throw new CmsIndexException(
                Messages.get().container(Messages.ERR_TEXT_EXTRACTION_1, resource.getRootPath()),
                e);
        }
    }",Extract content from a resource.
"public static boolean delete(File file) {
        if (!file.exists())
            return false;
        if (file.isDirectory()) {
            File[] files = file.listFiles();
            for (int i = 0; files != null && i < files.length; i++)
                delete(files[i]);
        }
        return file.delete();
    }

    /**
     * Closes an arbitrary closable, and logs exceptions at ignore level
     *
     * @param closeable the closeable to close
     */
    public static void close(Closeable closeable) {
        try {
            if (closeable != null)
                closeable.close();
        } catch (IOException ignore) {
        }
    }

    /**
     * closes an input stream, and logs exceptions
     *
     * @param is the input stream to close
     */
    public static void close(InputStream is) {
        close((Closeable) is);
    }

    /**
     * closes an output stream, and logs exceptions
     *
     * @param os the output stream to close
     */
    public static void close(OutputStream os) {
        close((Closeable) os);
    }

    /**
     * closes a reader, and logs exceptions
     *
     * @param reader the reader to close
     */
    public static void close(Reader reader) {
        close((Closeable) reader);
    }

    /**
     * closes a writer, and logs exceptions
     *
     * @param writer the writer to close
     */
    public static void close(Writer writer) {
        close((Closeable) writer);
    }

    public static byte[] readBytes(InputStream in) throws IOException {
        ByteArrayOutputStream bout = new ByteArrayOutputStream();
        copy(in, bout);
        return bout.toByteArray();
    }

    /**
     * A gathering write utility wrapper.
     * <p>
     * This method wraps a gather write with a loop that handles the limitations
     * of some operating systems that have a limit on the number of buffers
     * written. The method loops on the write until either all the content is
     * written or no progress is made.
     *
     * @param out     The GatheringByteChannel to write to
     * @param buffers The buffers to write
     * @param offset  The offset into the buffers array
     * @param length  The length in buffers to write
     * @return The total bytes written
     * @throws IOException if unable write to the GatheringByteChannel
     */
    public static long write(GatheringByteChannel out, ByteBuffer[] buffers, int offset, int length)
            throws IOException {
        long total = 0;
        write:
        while (length > 0) {
            // Write as much as we can
            long wrote = out.write(buffers, offset, length);

            // If we can't write any more, give up
            if (wrote == 0)
                break;

            // count the total
            total += wrote;

            // Look for unwritten content
            for (int i = offset; i < buffers.length; i++) {
                if (buffers[i].hasRemaining()) {
                    // loop with new offset and length;
                    length = length - (i - offset);
                    offset = i;
                    continue write;
                }
            }
            length = 0;
        }

        return total;
    }

    /**
     * @return An outputstream to nowhere
     */
    public static OutputStream getNullStream() {
        return __nullStream;
    }

    /**
     * @return An outputstream to nowhere
     */
    public static InputStream getClosedStream() {
        return __closedStream;
    }

    private static class NullOS extends OutputStream {
        @Override
        public void close() {
        }

        @Override
        public void flush() {
        }

        @Override
        public void write(byte[] b) {
        }

        @Override
        public void write(byte[] b, int i, int l) {
        }

        @Override
        public void write(int b) {
        }
    }

    private static NullOS __nullStream = new NullOS();

    private static class ClosedIS extends InputStream {
        @Override
        public int read() throws IOException {
            return -1;
        }
    }

    private static ClosedIS __closedStream = new ClosedIS();

    /**
     * @return An writer to nowhere
     */
    public static Writer getNullWriter() {
        return __nullWriter;
    }

    /**
     * @return An writer to nowhere
     */
    public static PrintWriter getNullPrintWriter() {
        return __nullPrintWriter;
    }

    private static class NullWrite extends Writer {
        @Override
        public void close() {
        }

        @Override
        public void flush() {
        }

        @Override
        public void write(char[] b) {
        }

        @Override
        public void write(char[] b, int o, int l) {
        }

        @Override
        public void write(int b) {
        }

        @Override
        public void write(String s) {
        }

        @Override
        public void write(String s, int o, int l) {
        }
    }

    private static NullWrite __nullWriter = new NullWrite();
    private static PrintWriter __nullPrintWriter = new PrintWriter(__nullWriter);

}",Delete a single file from the cache.
"public static <T1, T2> BiFunction<T1, T2, Void> function(BiConsumer<T1, T2> adaptee) {
        dbc.precondition(adaptee != null, ""cannot adapt a null consumer"");
        return (first, second) -> {
            adaptee.accept(first, second);
            return null;
        };
    }",Adapts a binary consumer to a binary function.
"URI generateOutputFile(final URI ref) {
        final FileInfo srcFi = job.getFileInfo(ref);
        final URI newSrc = srcFi.src.resolve(generateFilename());
        final URI tmp = tempFileNameScheme.generateTempFileName(newSrc);

        if (job.getFileInfo(tmp) == null) {
            job.add(new FileInfo.Builder()
                    .result(newSrc)
                    .uri(tmp)
                    .build());
        }

        return job.tempDirURI.resolve(tmp);
    }",Generate output file.
"@Override
	public void stopped() {

		// Stop timer
		ScheduledFuture<?> task = callTimeoutTimer.get();
		if (task != null) {
			task.cancel(false);
		}

		// Stop pending invocations
		Iterator<PendingPromise> pendingPromises = promises.values().iterator();
		while (pendingPromises.hasNext()) {
			PendingPromise pending = pendingPromises.next();
			pendingPromises.remove();
			try {
				pending.promise.complete(new RequestRejectedError(nodeID, pending.action));
			} catch (Throwable cause) {
				logger.warn(""Unable to reject action \"""" + pending.action + ""\""!"", cause);
			}
		}

		// Stop middlewares
		for (Middleware middleware : middlewares) {
			try {
				middleware.stopped();
			} catch (Throwable cause) {
				logger.warn(""Unable to stop middleware \"""" + middleware.name + ""\""!"", cause);
			}
		}

		// Stop registered services
		stopAllLocalServices();

		// Clear registries
		final long stamp = lock.writeLock();
		try {

			// Delete strategies (and registered actions)
			strategies.clear();

			// Delete all service names
			names.clear();

			// Delete middlewares
			middlewares.clear();

			// Delete cached node descriptor
			clearDescriptorCache();

		} finally {
			lock.unlockWrite(stamp);
		}
	}",Stop all the services and invocations.
"public BufferedImage copyImage(BufferedImage image) {
        BufferedImage newImage = new BufferedImage(image.getWidth(), image.getHeight(), image.getType());
        Graphics2D g2d = newImage.createGraphics();
        g2d.drawImage(image, 0, 0, null);
        g2d.dispose();
        return newImage;
    }",Copy the image to a new BufferedImage.
"public DepictionGenerator withMappedRxnAlign(boolean val) {
        DepictionGenerator copy = new DepictionGenerator(this);
        copy.alignMappedReactions = val;
        return copy;
    }",This method is used to set the mapped RxnAlign flag.
"public static Consul consul(final String host, final int port) {
        try {
            return new Consul(new URL(""http"", host, port, """").toString());
        } catch (MalformedURLException e) {
            throw new ConsulException(""Bad Consul URL"", e);
        }
    }",Create a Consul instance with the given host and port.
"public void setLocaterInfo(SourceLocator locator)
  {

    if (null != locator)
    {
      m_publicId = locator.getPublicId();
      m_systemId = locator.getSystemId();

      if (null != m_systemId)
      {
        try
        {
          m_href = SystemIDResolver.getAbsoluteURI(m_systemId, null);
        }
        catch (TransformerException se)
        {

          // Ignore this for right now
        }
      }

      super.setLocaterInfo(locator);
    }
  }",Set the LocaterInfo field of the SourceLocator object.
"public void setParameter(final String key, final String value) {
		parameters.put(key, new String[]{value});
	}",Sets a parameter to the connection.
"public T find(Object val, CacheLoader<T> loader) {
        if( order.size() != 1 ) {
            throw new CacheManagementException(""You may only call this method when the cache is managing one unique identifier."");
        }
        return find(order.get(0), val, loader);
    }",Find the object in the cache.
"public SoyMsgBundle createFromResource(URL inputResource) throws IOException {

    try {
      String inputFileContent = Resources.asCharSource(inputResource, UTF_8).read();
      return msgPlugin.parseTranslatedMsgsFile(inputFileContent);

    } catch (SoyMsgException sme) {
      sme.setFileOrResourceName(inputResource.toString());
      throw sme;
    }
  }",Creates a SoyMsgBundle from a file or resource name.
"public static void buildFieldProperties(final Class<?> aClass, final DescriptionBuilder builder) {
        for (final Field field : collectClassFields(aClass)) {
            final PluginProperty annotation = field.getAnnotation(PluginProperty.class);
            if (null == annotation) {
                continue;
            }
            final Property pbuild = propertyFromField(field, annotation);
            if (null == pbuild) {
                continue;
            }
            builder.property(pbuild);
        }
    }",Build field properties from the class.
"public void debug(Object message, Throwable t) {
        differentiatedLog(null, CATEGORY_FQCN, LocationAwareLogger.DEBUG_INT, message, t);
    }",Issue a log message and throwable with a level of DEBUG.
"public org.grails.datastore.mapping.query.api.ProjectionList sum(String propertyName, String alias) {
        final AggregateProjection proj = Projections.sum(calculatePropertyName(propertyName));
        addProjectionToList(proj, alias);
        return this;
    }",Adds a projection to the result set.
"static SmileGenerator newSmileGenerator(OutputStream out, byte[] buf, int offset,
            boolean bufferRecyclable, IOContext context)
    {
        return new SmileGenerator(context,
                DEFAULT_SMILE_FACTORY.getGeneratorFeatures(),
                DEFAULT_SMILE_FACTORY.getSmileGeneratorFeatures(),
                DEFAULT_SMILE_FACTORY.getCodec(),
                out,
                buf,
                offset,
                bufferRecyclable);
    }",Creates a new instance of the smile generator class.
"@SuppressWarnings(""WeakerAccess"")
  public ApiFuture<List<Cluster>> listClustersAsync(String instanceId) {
    String name = NameUtil.formatInstanceName(projectId, instanceId);
    com.google.bigtable.admin.v2.ListClustersRequest request =
        com.google.bigtable.admin.v2.ListClustersRequest.newBuilder().setParent(name).build();

    return ApiFutures.transform(
        stub.listClustersCallable().futureCall(request),
        new ApiFunction<com.google.bigtable.admin.v2.ListClustersResponse, List<Cluster>>() {
          @Override
          public List<Cluster> apply(com.google.bigtable.admin.v2.ListClustersResponse proto) {
            // NOTE: serverside pagination is not and will not be implemented, so remaining pages
            // are not fetched. However, if that assumption turns out to be wrong, fail fast to
            // avoid returning partial data.
            Verify.verify(
                proto.getNextPageToken().isEmpty(),
                ""Server returned an unexpected paginated response"");

            ImmutableList.Builder<Cluster> clusters = ImmutableList.builder();
            for (com.google.bigtable.admin.v2.Cluster cluster : proto.getClustersList()) {
              clusters.add(Cluster.fromProto(cluster));
            }

            ImmutableList.Builder<String> failedZones = ImmutableList.builder();
            for (String locationStr : proto.getFailedLocationsList()) {
              failedZones.add(NameUtil.extractZoneIdFromLocationName(locationStr));
            }

            if (!failedZones.build().isEmpty()) {
              throw new PartialListClustersException(failedZones.build(), clusters.build());
            }

            return clusters.build();
          }
        },
        MoreExecutors.directExecutor());
  }",Asynchronously lists all clusters in the specified instance.
"private void checkForEmptyIdentifier() {
    Character la = chars.lookahead(1);
    if (CharType.DOT.isMatchedBy(la) || CharType.PLUS.isMatchedBy(la)
        || CharType.EOL.isMatchedBy(la)) {
      throw new ParseException(""Identifiers MUST NOT be empty"", new UnexpectedCharacterException(la,
          chars.currentOffset(), CharType.DIGIT, CharType.LETTER, CharType.HYPHEN));
    }
  }",Check for empty identifier.
"static synchronized CatLog getDefaultCatLog() {
        if (!PACKAGE_CAT_LOG_KEYS.isEmpty()) {
            String callingPackage = CatUtil.getCallingPackage();
            for (int i = PACKAGE_CAT_LOG_KEYS.size() - 1; i >= 0; i--) {
                String catLogPackage = PACKAGE_CAT_LOG_KEYS.get(i);
                if (callingPackage.startsWith(catLogPackage)) {
                    return PACKAGE_CAT_LOGS.get(catLogPackage);
                }
            }
        }

        return defaultCatLog;
    }",Get the default CatLog
"private void cacheStream() {
        try {
            File fi = getTemproralCacheFile();
            if (fi.exists()) {
                if (!fi.delete()) {
                    throw new IllegalStateException(""Cannot delete file "" + fi.getAbsolutePath() + ""!"");
                }
            }
            FileOutputStream fout = new FileOutputStream(fi);
            InputStream in = grabStream();
            byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];
            int n;
            while (-1 != (n = in.read(buffer))) {
                fout.write(buffer, 0, n);
            }
            fout.flush();
            fout.close();
            in.close();
            
            File cacheFile = getCacheFile();
            if (!fi.renameTo(cacheFile)) {
                throw new IllegalStateException(""Cannot rename file \"""" + fi.getAbsolutePath() + ""\"" to \"""" + cacheFile.getAbsolutePath() + ""\""!"");
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }",Cache the result of a single record in a stream.
"public void initializePackageContents()
  {
    if (isInitialized) return;
    isInitialized = true;

    // Initialize package
    setName(eNAME);
    setNsPrefix(eNS_PREFIX);
    setNsURI(eNS_URI);

    // Obtain other dependent packages
    XtypePackage theXtypePackage = (XtypePackage)EPackage.Registry.INSTANCE.getEPackage(XtypePackage.eNS_URI);
    XbasePackage theXbasePackage = (XbasePackage)EPackage.Registry.INSTANCE.getEPackage(XbasePackage.eNS_URI);

    // Create type parameters

    // Set bounds for type parameters

    // Add supertypes to classes

    // Initialize classes and features; add operations and parameters
    initEClass(modelEClass, Model.class, ""Model"", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);
    initEReference(getModel_ImportSection(), theXtypePackage.getXImportSection(), null, ""importSection"", null, 0, 1, Model.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);
    initEReference(getModel_Block(), theXbasePackage.getXBlockExpression(), null, ""block"", null, 0, 1, Model.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);

    // Create resource
    createResource(eNS_URI);
  }",Initialize the package contents.
"public synchronized static boolean areConnectedUpstream(PfafstetterNumber p1,
                                                            PfafstetterNumber p2) {

        List<Integer> p1OrdersList = p1.getOrdersList();
        List<Integer> p2OrdersList = p2.getOrdersList();

        int levelDiff = p1OrdersList.size() - p2OrdersList.size();
        if (levelDiff == 0) {
            if (p1.toStringUpToLastLevel().equals(p2.toStringUpToLastLevel())) {
                int p1Last = p1OrdersList.get(p1OrdersList.size() - 1);
                int p2Last = p2OrdersList.get(p2OrdersList.size() - 1);
                if (p2Last == p1Last + 1 || p2Last == p1Last + 2) {
                    return p1Last % 2 != 0;
                }
            }
        } else if (levelDiff == -1) {
            if (p2.toString().startsWith(p1.toStringUpToLastLevel())) {
                int p2Last = p2OrdersList.get(p2OrdersList.size() - 1);
                if (p2Last != 1) {
                    return false;
                }
                int p1Last = p1OrdersList.get(p1OrdersList.size() - 1);
                int p2LastMinus1 = p2OrdersList.get(p2OrdersList.size() - 2);
                if (p2LastMinus1 == p1Last + 1 || p2Last == p1Last + 2) {
                    return p1Last % 2 != 0;
                }
            }
        }
        return false;
    }",Is the two PfafstetterNumber objects connected upstream?
"@Nullable
  @ReturnsMutableCopy
  public static ICommonsList <String> readStreamLines (@Nullable final IHasInputStream aISP,
                                                       @Nonnull final Charset aCharset,
                                                       @Nonnegative final int nLinesToSkip,
                                                       @CheckForSigned final int nLinesToRead)
  {
    if (aISP == null)
      return null;

    return readStreamLines (aISP.getInputStream (), aCharset, nLinesToSkip, nLinesToRead);
  }",Read the lines from the passed input stream.
"private Collection<org.ironjacamar.core.api.deploymentrepository.ConfigProperty>
      injectConfigProperties(Object o,
                             Collection<org.ironjacamar.common.api.metadata.spec.ConfigProperty> configProperties,
                             Map<String, String> overrides,
                             ClassLoader classLoader)
      throws Throwable
   {
      Collection<org.ironjacamar.core.api.deploymentrepository.ConfigProperty> dcps = null;
      if (configProperties != null && !configProperties.isEmpty())
      {
         Injection injector = new Injection();

         dcps = new ArrayList<org.ironjacamar.core.api.deploymentrepository.ConfigProperty>(configProperties.size());
         for (org.ironjacamar.common.api.metadata.spec.ConfigProperty cp : configProperties)
         {
            String name = cp.getConfigPropertyName().getValue();
            Class<?> type = Class.forName(cp.getConfigPropertyType().getValue(), true, classLoader);
            boolean readOnly = cp.getConfigPropertySupportsDynamicUpdates() != null ?
               cp.getConfigPropertySupportsDynamicUpdates().booleanValue() : true;
            boolean confidential = cp.getConfigPropertyConfidential() != null ?
               cp.getConfigPropertyConfidential().booleanValue() : false;
            boolean declared = true;

            Object value = cp.isValueSet() ? cp.getConfigPropertyValue().getValue() : null;
            if (overrides != null)
            {
               if (overrides.containsKey(cp.getConfigPropertyName().getValue()))
               {
                  value = overrides.get(cp.getConfigPropertyName().getValue());
               }
               else
               {
                  String alternative = cp.getConfigPropertyName().getValue().substring(0, 1).toUpperCase();
                  if (cp.getConfigPropertyName().getValue().length() > 1)
                     alternative += cp.getConfigPropertyName().getValue().substring(1);

                  if (overrides.containsKey(alternative))
                  {
                     value = overrides.get(alternative);
                  }
                  else
                  {
                     log.tracef(""%s: Override for %s not found"", o.getClass().getName(),
                                cp.getConfigPropertyName().getValue());
                  }
               }
            }

            if (value != null)
            {
               try
               {
                  injector.inject(o,
                                  cp.getConfigPropertyName().getValue(),
                                  value,
                                  cp.getConfigPropertyType().getValue());
               }
               catch (Throwable t)
               {
                  type = convertType(type);
                     
                  if (type != null)
                  {
                     injector.inject(o,
                                     cp.getConfigPropertyName().getValue(),
                                     value,
                                     type.getName());
                  }
                  else
                  {
                     throw new DeployException(bundle.unableToInject(o.getClass().getName(),
                           cp.getConfigPropertyName().getValue(),
                           value.toString()), t);
                  }
               }
            }

            dcps.add(new ConfigPropertyImpl(o, name, type,
                                            value, readOnly, confidential,
                                            declared));
         }
      }
      return dcps;
   }",Inject config properties into a single object.
"protected void writeVersion(WritableByteChannel channel) throws IOException {
        ByteBuffer version = ByteBuffer.allocate(STORAGE_VERSION_LENGTH);
        version.putInt(STORAGE_VERSION);
        version.flip();
        channel.write(version);
    }",Write the version of the class to the given channel.
"public static int nvgraphAllocateEdgeData(
        nvgraphHandle handle, 
        nvgraphGraphDescr descrG, 
        long numsets, 
        Pointer settypes)
    {
        return checkResult(nvgraphAllocateEdgeDataNative(handle, descrG, numsets, settypes));
    }",Allocate edge data for a graph.
"private static boolean criteriaListForcesUserLimitation(Set<String> userAndGroupIds, List<QueryCriteria> criteriaList) {
        boolean userLimitiationIntersection = false;

        if( criteriaList.isEmpty() ) {
            return false;
        }
        for( QueryCriteria criteria : criteriaList ) {
          if( criteria.isUnion() && criteriaList.size() > 1) {
              return false;
          }
          if( criteria.isGroupCriteria() ) {
              if( criteriaListForcesUserLimitation(userAndGroupIds, criteria.getCriteria()) ) {
                  return true;
              }
              continue;
          }
          // intersection criteria
          if( taskUserRoleLimitingListIds.contains(criteria.getListId()) ) {
              for( Object param : criteria.getParameters() ) {
                  if( userAndGroupIds.contains(param) )  {
                      return true;
                  }
              }
          }
        }
        return userLimitiationIntersection;
    }",Checks if the criteria list forces user limiting.
"String toTag(Archive source, String name, Archive target) {
        if (source == target || !target.getModule().isNamed()) {
            return target.getName();
        }

        Module module = target.getModule();
        String pn = name;
        if ((type == CLASS || type == VERBOSE)) {
            int i = name.lastIndexOf('.');
            pn = i > 0 ? name.substring(0, i) : """";
        }

        // exported API
        if (module.isExported(pn) && !module.isJDKUnsupported()) {
            return showProfileOrModule(module);
        }

        // JDK internal API
        if (!source.getModule().isJDK() && module.isJDK()){
            return ""JDK internal API ("" + module.name() + "")"";
        }

        // qualified exports or inaccessible
        boolean isExported = module.isExported(pn, source.getModule().name());
        return module.name() + (isExported ?  "" (qualified)"" : "" (internal)"");
    }",Returns a tag for the specified archive.
"public String newIndex(final String name,
                         final String mappingPath) throws IndexException {
    try {
      final String newName = name + newIndexSuffix();

      final IndicesAdminClient idx = getAdminIdx();

      final CreateIndexRequestBuilder cirb = idx.prepareCreate(newName);

      final File f = new File(mappingPath);

      final byte[] sbBytes = Streams.copyToByteArray(f);

      cirb.setSource(sbBytes);

      final CreateIndexRequest cir = cirb.request();

      final ActionFuture<CreateIndexResponse> af = idx.create(cir);

      /*resp = */af.actionGet();

      //index(new UpdateInfo());

      info(""Index created"");

      return newName;
    } catch (final ElasticsearchException ese) {
      // Failed somehow
      error(ese);
      return null;
    } catch (final IndexException ie) {
      throw ie;
    } catch (final Throwable t) {
      error(t);
      throw new IndexException(t);
    }
  }",Creates a new index with the given name and mapping path.
"public Menu get() {
        String url = WxEndpoint.get(""url.menu.get"");
        String content = wxClient.get(url);
        logger.debug(""get default menu: {}"", content);
        MenuWrapper menuWrapper = JsonMapper.nonEmptyMapper().fromJson(content, MenuWrapper.class);
        return menuWrapper.getMenu();
    }",Get the default menu
"public float getScalarFloat(int recnum, StructureMembers.Member m) {
    if (m.getDataType() != DataType.FLOAT)
      throw new IllegalArgumentException(""Type is "" + m.getDataType() + "", must be float"");
    Array data = m.getDataArray();
    return data.getFloat(recnum * m.getSize()); // gets first one in the array
  }",Returns the float value of a single record in the block.
"@Override
    public DescribeBuildResult describeBuild(DescribeBuildRequest request) {
        request = beforeClientExecution(request);
        return executeDescribeBuild(request);
    }",Returns information about a build.
"public static <T extends AccessibleObject> T makeAccessible(T accessibleObject) {
        AccessController.doPrivileged((PrivilegedAction<Object>) () -> {
            accessibleObject.setAccessible(true);
            return null;
        });
        return accessibleObject;
    }",Make the given object accessible.
"protected final JSerializerType getKeySerializerFromType( JType type ) throws UnsupportedTypeException, UnableToCompleteException {
        return getKeySerializerFromType( type, false, false );
    }",Get the serializer type from the given type.
"public ByteBuffer get4x4(int index, ByteBuffer buffer) {
        MemUtil.INSTANCE.put4x4(this, index, buffer);
        return buffer;
    }",Get a 4 - byte version of the specified attribute in the specified buffer.
"public Observable<OperationStatus> deleteHierarchicalEntityChildAsync(UUID appId, String versionId, UUID hEntityId, UUID hChildId) {
        return deleteHierarchicalEntityChildWithServiceResponseAsync(appId, versionId, hEntityId, hChildId).map(new Func1<ServiceResponse<OperationStatus>, OperationStatus>() {
            @Override
            public OperationStatus call(ServiceResponse<OperationStatus> response) {
                return response.body();
            }
        });
    }",Delete a hierarchical entity child.
"private KeyScope cascadeChildKeys(final KeyScope rootScope) {
        final Map<String, KeyDef> res = new HashMap<>(rootScope.keyDefinition);
        cascadeChildKeys(rootScope, res, """");
        return new KeyScope(rootScope.id, rootScope.name, res, new ArrayList<>(rootScope.childScopes));
    }",Cascade child keys.
"public String getGroupName(final HttpServletRequest request) {
    Validate.notNull(request);
    String uri = request.getRequestURI();
    // check if include or uri path are present and use one of these as request uri.
    final String includeUriPath = (String) request.getAttribute(ATTR_INCLUDE_PATH);
    uri = includeUriPath != null ? includeUriPath : uri;
    final String groupName = FilenameUtils.getBaseName(stripSessionID(uri));
    return StringUtils.isEmpty(groupName) ? null : groupName;
  }",Get the group name from the request.
"private void callOnMessageError(WebSocketException cause, List<WebSocketFrame> frames)
    {
        mWebSocket.getListenerManager().callOnMessageError(cause, frames);
    }",Call onMessageError method.
"public static Optional<Method> extractGetter(final Class<?> targetClass, final String propertyName, final Class<?> propertyType) {
        
        final String methodName = ""get"" + Utils.capitalize(propertyName);
        
        Method method;
        try {
            method = targetClass.getMethod(methodName);
            
        } catch (NoSuchMethodException | SecurityException e) {
            return Optional.empty();
        }
        
        method.setAccessible(true);
        
        if(method.getParameterCount() > 0) {
            return Optional.empty();
        }
        
        if(!method.getReturnType().equals(propertyType)) {
            return Optional.empty();
        }
        
        return Optional.of(method);
    }",Extract a getter method from the target class.
"public static <F, T extends Iterable<S>, S> PropertyPattern<F, T> empty(Property<F, T> property)
    {
        return PropertyPattern.upcast(property.matching(Iterables::isEmpty));
    }",Returns a property pattern that matches any of the given property.
"@Override
    public StreamT<W,T> iterate(UnaryOperator<T> fn, T alt) {

        return super.iterate(fn,alt);
    }",Override iterate to allow for customization of the iterator
"public ListStackSetOperationsResult withSummaries(StackSetOperationSummary... summaries) {
        if (this.summaries == null) {
            setSummaries(new com.amazonaws.internal.SdkInternalList<StackSetOperationSummary>(summaries.length));
        }
        for (StackSetOperationSummary ele : summaries) {
            this.summaries.add(ele);
        }
        return this;
    }",Adds the specified summaries to the list of operation summaries.
"public void checkInactiveSession(Session session) {
        if (session == null) {
            return;
        }
        if (log.isDebugEnabled()) {
            log.debug(""Checking for idle "" +  session.getId());
        }
        try (Lock ignored = session.lock()) {
            if (getEvictionPolicy() > 0 && session.isIdleLongerThan(getEvictionPolicy()) &&
                    session.isValid() && session.isResident() && session.getRequests() <= 0) {
                // Be careful with saveOnInactiveEviction - you may be able to re-animate a session that was
                // being managed on another node and has expired.
                try {
                    if (log.isDebugEnabled()) {
                        log.debug(""Evicting idle session "" + session.getId());
                    }

                    // save before evicting
                    if (isSaveOnInactiveEviction() && sessionDataStore != null) {
                        if (sessionDataStore.isPassivating()) {
                            sessionHandler.willPassivate(session);
                        }
                        sessionDataStore.store(session.getId(), session.getSessionData());
                    }

                    doDelete(session.getId()); // detach from this cache
                    session.setResident(false);
                } catch (Exception e) {
                    log.warn(""Passivation of idle session"" + session.getId() + "" failed"", e);
                    session.updateInactivityTimer();
                }
            }
        }
    }",Check if the session is inactive.
"public static void throwIfRequestingUnknownFeatures(HColumnDescriptor columnDescriptor) {
    List<String> unknownFeatures = getUnknownFeatures(columnDescriptor);
    if (!unknownFeatures.isEmpty()) {
      String featureString = String.format(
          ""Unknown configuration options: [%s]"",
          Joiner.on("", "").join(unknownFeatures));
      throw new UnsupportedOperationException(featureString);
    }
  }",Throw UnsupportedOperationException if requested unknown features are not present in the column descriptor
"@Override
    public void doExceptionCaughtListeners(final Throwable cause) {
        runManagementTask(new Runnable() {
            @Override
            public void run() {
                try {
                    List<SessionManagementListener> sessionListeners = getManagementListeners();
                    for (final SessionManagementListener listener : sessionListeners) {
                        listener.doExceptionCaught(SessionManagementBeanImpl.this, cause);
                    }

                    markChanged();
                } catch (Exception ex) {
                    logger.warn(""Error during doExceptionCaught session listener notifications:"", ex);
                }
            }
        });
    }",Override this method to notify all session listeners that an exception has occurred.
"private static int toSeleniumCoordinate(Object openCVCoordinate) {
        if (openCVCoordinate instanceof Long) {
            return ((Long) openCVCoordinate).intValue();
        }
        if (openCVCoordinate instanceof Double) {
            return ((Double) openCVCoordinate).intValue();
        }
        return (int) openCVCoordinate;
    }",Convert a CV coordinate to a Selenium coordinate.
"public Event withEventCategories(String... eventCategories) {
        if (this.eventCategories == null) {
            setEventCategories(new com.amazonaws.internal.SdkInternalList<String>(eventCategories.length));
        }
        for (String ele : eventCategories) {
            this.eventCategories.add(ele);
        }
        return this;
    }",Sets the eventCategories value for this Event.
"private static MavenCoordinates findCompileDependency(String zipEntryPath, String groupId) {
		int apiNameIndex = zipEntryPath.indexOf(groupId);
		int extensionIndex = zipEntryPath.lastIndexOf("".jar"");
		if (apiNameIndex >= 0 && extensionIndex >= 0) {
			String fileNameWithoutExtension = zipEntryPath.substring(apiNameIndex, extensionIndex);

			String artifactId = fileNameWithoutExtension.substring(0, fileNameWithoutExtension.lastIndexOf(""_""));
			String versionId = fileNameWithoutExtension.substring(fileNameWithoutExtension.lastIndexOf(""_"")+1, fileNameWithoutExtension.length());
			MavenCoordinates coordinates = new MavenCoordinates(groupId, artifactId, versionId);
			System.out.println(""Found compile dependency: "" + coordinates);
			return coordinates;
		}
		return null;
	}",Find the compile dependency of the given zip entry path.
"@Nonnull
  public FineUploader5DeleteFile addParam (@Nonnull @Nonempty final String sKey, @Nonnull final String sValue)
  {
    ValueEnforcer.notEmpty (sKey, ""Key"");
    ValueEnforcer.notNull (sValue, ""Value"");

    m_aDeleteFileParams.put (sKey, sValue);
    return this;
  }",Add a new delete file parameter.
"public GroovyRowResult firstRow(GString gstring) throws SQLException {
        List<Object> params = getParameters(gstring);
        String sql = asSql(gstring, params);
        return firstRow(sql, params);
    }",Returns the first row of the resultset that matches the given gstring.
"public void configure(JobConf job) {
    this.longCounters = new TreeMap<Object, Long>();
    this.doubleCounters = new TreeMap<Object, Double>();
  }",Configure the cluster.
"public static MozuUrl getFileUrl(String applicationKey, String fileName)
	{
		UrlFormatter formatter = new UrlFormatter(""/api/platform/appdev/filebasedpackage/packages/{applicationKey}?fileName={fileName}"");
		formatter.formatUrl(""applicationKey"", applicationKey);
		formatter.formatUrl(""fileName"", fileName);
		return new MozuUrl(formatter.getResourceUrl(), MozuUrl.UrlLocation.HOME_POD) ;
	}",Get Resource Url for GetFile
"@Override
    public final <D, E> Choice3<A, D, E> biMap(Function<? super B, ? extends D> lFn,
                                               Function<? super C, ? extends E> rFn) {
        return match(Choice3::a, b -> b(lFn.apply(b)), c -> c(rFn.apply(c)));
    }",Choice 2 of two function mapping.
"private void post(final String endpoint, final HttpContent body, final Class responseClass, final KickflipCallback cb) {
        acquireAccessToken(new OAuthCallback() {
            @Override
            public void onSuccess(HttpRequestFactory requestFactory) {
                request(requestFactory, METHOD.POST, makeApiUrl(endpoint), body, responseClass, cb);
            }

            @Override
            public void onFailure(Exception e) {
                postExceptionToCallback(cb, UNKNOWN_ERROR_CODE);
            }
        });
    }",Post an HTTP POST request.
"public void dispatch_event(final EventData eventData) {
        final TangoInterfaceChange interfaceChange = this;
        if (EventUtil.graphicAvailable()) {
            //   Causes doRun.run() to be executed asynchronously
            //      on the AWT event dispatching thread.
            Runnable do_work_later = new Runnable() {
                public void run() {
                    fireTangoInterfaceChangeEvent(interfaceChange, eventData);
                }
            };
            SwingUtilities.invokeLater(do_work_later);
        }
        else {
            fireTangoInterfaceChangeEvent(interfaceChange, eventData);
        }
    }",Dispatch an event to the TangoInterfaceChange interface.
"public Collection<Set<Integer>> valueSets() {
        // An IntSet _is_ a Set<Integer>, but the JVM doesn't recognize
        // covaraince in the return type generics, so we must cast
        Collection<?> c = map.valueCollection();
        @SuppressWarnings(""unchecked"")
        Collection<Set<Integer>> c2 = (Collection<Set<Integer>>)c;            
        return c2;
    }",Returns a Collection of Set<Integer > of the value sets of the IdentitySet.
"public short getBlockReplication(BlockInfo block) {
    if (storage.isSourceBlock(block)) {
      return getReplication();
    } else {
      if (storage.getStorageType() == StorageType.RAID_STORAGE) {
        return ((INodeRaidStorage)storage).getCodec().parityReplication;
      } else {
        throw new IllegalStateException(""parity block "" + block +
            "" belongs to a non-raid file"");
      }
    }
  }",Get the replication value for a given block.
"@SuppressWarnings(""unchecked"")
    public void restoreState(FacesContext context, Object state) {

        if (context == null) {
            throw new NullPointerException();
        }

        if (state != null) {

            // Unchecked cast from Object to List<BehaviorListener>
            listeners = (List<BehaviorListener>)UIComponentBase.restoreAttachedState(context, state);

            // If we saved state last time, save state again next time.
            clearInitialState();
        }
    }",Restore the state of the component.
"private ByteBuffer getPartitionKey(List<Pair<String, Serializable>> equalsList, Serializable inValue) {

        assert (equalsList.size() + 1) == ((CompositeType) keyValidator).componentsCount();

        ByteBuffer[] serialized = new ByteBuffer[equalsList.size() + 1];
        for (int i = 0; i < equalsList.size(); i++) {
            ByteBuffer buffer = ((AbstractType) keyValidator.getComponents().get(i)).decompose(equalsList.get(i).right);
            serialized[i] = buffer;
        }
        serialized[serialized.length - 1] = ((AbstractType) keyValidator.getComponents().get(serialized.length - 1))
                .decompose(inValue);

        return CompositeType.build(serialized);
    }",getPartitionKey This is a helper method to get the partition key from the composite type.
"public String getInfo() {
        ReportCreator reporter = new ReportCreator(this);
        return reporter.msdosHeaderReport() + reporter.coffHeaderReport() +
                reporter.optHeaderReport() + reporter.secTableReport();
    }",Get the information about the resource.
"public java.util.List<String> getMemberNames() {
    List<String> memberNames = new ArrayList<>();
    for (Member m : members) {
      memberNames.add(m.getName());
    }
    return memberNames;
  }",Returns a list of member names.
"@Nullable
  public static <ENUMTYPE extends Enum <ENUMTYPE> & IHasName> ENUMTYPE getFromNameOrNull (@Nonnull final Class <ENUMTYPE> aClass,
                                                                                          @Nullable final String sName)
  {
    return getFromNameOrDefault (aClass, sName, null);
  }",Get the enumeration from the passed class and name.
"private void validateFinishDate(Task task)
   {
      if (task.getFinish() == null)
      {
         Date startDate = task.getStart();
         if (startDate != null)
         {
            if (task.getMilestone())
            {
               task.setFinish(startDate);
            }
            else
            {
               Duration duration = task.getDuration();
               if (duration != null)
               {
                  ProjectCalendar calendar = task.getEffectiveCalendar();
                  task.setFinish(calendar.getDate(startDate, duration, false));
               }
            }
         }
      }
   }",Validate the finish date for a Task.
"public static long toLocalDate(TimeZone browserTZ, TimeZone targetTZ, Date utcDate) {
        long utc = utcDate.getTime();
        int targetOffsetFromUTC = targetTZ.getOffset(utc);
        int browserOffsetFromUTC = browserTZ.getOffset(utc);

        return utc + targetOffsetFromUTC - browserOffsetFromUTC;
    }",Get the local date from the given date using the given time zone.
"public static base_response add(nitro_service client, nsip resource) throws Exception {
		nsip addresource = new nsip();
		addresource.ipaddress = resource.ipaddress;
		addresource.netmask = resource.netmask;
		addresource.type = resource.type;
		addresource.arp = resource.arp;
		addresource.icmp = resource.icmp;
		addresource.vserver = resource.vserver;
		addresource.telnet = resource.telnet;
		addresource.ftp = resource.ftp;
		addresource.gui = resource.gui;
		addresource.ssh = resource.ssh;
		addresource.snmp = resource.snmp;
		addresource.mgmtaccess = resource.mgmtaccess;
		addresource.restrictaccess = resource.restrictaccess;
		addresource.dynamicrouting = resource.dynamicrouting;
		addresource.ospf = resource.ospf;
		addresource.bgp = resource.bgp;
		addresource.rip = resource.rip;
		addresource.hostroute = resource.hostroute;
		addresource.hostrtgw = resource.hostrtgw;
		addresource.metric = resource.metric;
		addresource.vserverrhilevel = resource.vserverrhilevel;
		addresource.ospflsatype = resource.ospflsatype;
		addresource.ospfarea = resource.ospfarea;
		addresource.state = resource.state;
		addresource.vrid = resource.vrid;
		addresource.icmpresponse = resource.icmpresponse;
		addresource.ownernode = resource.ownernode;
		addresource.arpresponse = resource.arpresponse;
		addresource.td = resource.td;
		return addresource.add_resource(client);
	}",Use this API to add nsip.
"static List<Point> find(
        String text, String query, boolean ignoreCase)
    {
        List<Point> appearances = new ArrayList<Point>();
        int offset = StringUtils.indexOf(text, query, 0, ignoreCase);
        int length = query.length();
        while (offset != -1)
        {
            appearances.add(new Point(offset, offset + length));
            offset = StringUtils.indexOf(text, query, offset + 1, ignoreCase);
        }
        return appearances;
    }",Find a list of points in a sequence of strings that are contained in a Sequence of characters.
"@Override
  public void cancelOperation(OperationHandle opHandle) throws HiveSQLException {
    try {
      TCancelOperationReq req = new TCancelOperationReq(opHandle.toTOperationHandle());
      TCancelOperationResp resp = cliService.CancelOperation(req);
      checkStatus(resp.getStatus());
    } catch (HiveSQLException e) {
      throw e;
    } catch (Exception e) {
      throw new HiveSQLException(e);
    }
  }",Cancel an operation.
"public <E extends Exception> void depthFirstSearch(Vertex<T> v, VisitorEX<T, E> visitor)
      throws E
   {
      if( visitor != null )
         visitor.visit(this, v);      
      v.visit();
      for (int i = 0; i < v.getOutgoingEdgeCount(); i++)
      {
         Edge<T> e = v.getOutgoingEdge(i);
         if (!e.getTo().visited())
         {
            depthFirstSearch(e.getTo(), visitor);
         }
      }
   }",Depth - first search.
"public Boolean deleteEntityPost(DeleteEntityRequest request) throws ApiException {
        ApiResponse<Boolean> resp = deleteEntityPostWithHttpInfo(request);
        return resp.getData();
    }",Delete entity Delete entity
"public static CommerceSubscriptionEntry findByPrimaryKey(
		long commerceSubscriptionEntryId)
		throws com.liferay.commerce.exception.NoSuchSubscriptionEntryException {
		return getPersistence().findByPrimaryKey(commerceSubscriptionEntryId);
	}",Returns the commerce subscription entry with the primary key.
"public synchronized boolean statusUpdate(TaskAttemptID taskid,
                                              TaskStatus taskStatus)
  throws IOException {
    TaskInProgress tip = tasks.get(taskid);
    if (tip != null) {
      tip.reportProgress(taskStatus);
      myInstrumentation.statusUpdate(tip.getTask(), taskStatus);
      return true;
    } else {
      if (LOG.isDebugEnabled()) {
        LOG.debug(""Progress from unknown child task: ""+taskid);
      }
      return false;
    }
  }",Report the progress of a child task.
"public static synchronized AccountManager getInstance(XMPPConnection connection) {
        AccountManager accountManager = INSTANCES.get(connection);
        if (accountManager == null) {
            accountManager = new AccountManager(connection);
            INSTANCES.put(connection, accountManager);
        }
        return accountManager;
    }",Get an instance of the AccountManager class.
"@Override
    public ListRecordsResult listRecords(ListRecordsRequest request) {
        request = beforeClientExecution(request);
        return executeListRecords(request);
    }",Returns a list of the records in an authority.
"public static void get(String path, TemplateViewRoute route, TemplateEngine engine) {
        getInstance().get(path, route, engine);
    }",Get a resource from the resource table.
"@InterfaceAudience.Private
    private void addPending(RevisionInternal revisionInternal) {
        synchronized (pendingSequencesLock) {
            long seq = revisionInternal.getSequence();
            pendingSequences.add(seq);
            if (seq > maxPendingSequence) {
                maxPendingSequence = seq;
            }
        }
    }",Add a pending sequence to the list of pending sequence numbers.
"private void makeCellsFlowReady( int iteration, GridNode pitfillExitNode, List<GridNode> cellsToMakeFlowReady,
            BitMatrix allPitsPositions, WritableRandomIter pitIter, float delta ) {
        iteration++;

        double exitElevation = pitfillExitNode.elevation;
        List<GridNode> connected = new ArrayList<>();
        for( GridNode checkNode : cellsToMakeFlowReady ) {
            List<GridNode> validSurroundingNodes = checkNode.getValidSurroundingNodes();
            for( GridNode gridNode : validSurroundingNodes ) {
                if (!pitfillExitNode.equals(gridNode) && allPitsPositions.isMarked(gridNode.col, gridNode.row)
                        && gridNode.elevation == exitElevation) {
                    if (!connected.contains(gridNode))
                        connected.add(gridNode);
                }
            }
        }
        if (connected.size() == 0) {
            return;
        }

        for( GridNode gridNode : connected ) {
            double newElev = (double) (gridNode.elevation + delta * (double) iteration);
            gridNode.setValueInMap(pitIter, newElev);
        }
        List<GridNode> updatedConnected = new ArrayList<>();
        for( GridNode gridNode : connected ) {
            GridNode updatedNode = new GridNode(pitIter, gridNode.cols, gridNode.rows, gridNode.xRes, gridNode.yRes, gridNode.col,
                    gridNode.row);
            updatedConnected.add(updatedNode);
        }
        makeCellsFlowReady(iteration, pitfillExitNode, updatedConnected, allPitsPositions, pitIter, delta);
    }",makeCellsFlowReady This method is called to make cells flow ready.
"public void marshall(Notifications notifications, ProtocolMarshaller protocolMarshaller) {

        if (notifications == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(notifications.getProgressing(), PROGRESSING_BINDING);
            protocolMarshaller.marshall(notifications.getCompleted(), COMPLETED_BINDING);
            protocolMarshaller.marshall(notifications.getWarning(), WARNING_BINDING);
            protocolMarshaller.marshall(notifications.getError(), ERROR_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given Notifications object to the given protocolMarshaller.
"public Set<Location> getDerefLocationSet(ValueNumber vn) {
        Set<Location> derefLocationSet = derefLocationSetMap.get(vn);
        if (derefLocationSet == null) {
            derefLocationSet = new HashSet<>();
            derefLocationSetMap.put(vn, derefLocationSet);
        }
        return derefLocationSet;
    }",Gets the set of dereferences for a value number.
"@Override
   protected void addColumnComponents(HtmlDataTable dataTable, Map<String, String> attributes, NodeList elements,
            StaticXmlMetawidget metawidget)
   {
      super.addColumnComponents(dataTable, attributes, elements, metawidget);

      if (dataTable.getChildren().isEmpty())
      {
         return;
      }

      if (!attributes.containsKey(N_TO_MANY) || metawidget.isReadOnly())
      {
         return;
      }

      HtmlCommandLink removeLink = new HtmlCommandLink();
      removeLink.putAttribute(""styleClass"", ""remove-button"");
      String removeExpression = COLLECTION_VAR + "".remove("" + dataTable.getAttribute(""var"") + "")"";
      removeLink.putAttribute(""action"", StaticFacesUtils.wrapExpression(removeExpression));

      HtmlColumn column = new HtmlColumn();
      column.putAttribute(""headerClass"", ""remove-column"");
      column.putAttribute(""footerClass"", ""remove-column"");
      column.getChildren().add(removeLink);
      dataTable.getChildren().add(column);

      // If bidirectional, an 'Add' button too

      String inverseRelationship = attributes.get(INVERSE_RELATIONSHIP);

      if (inverseRelationship != null)
      {
         String componentType = WidgetBuilderUtils.getComponentType(attributes);

         if (componentType != null)
         {
            String controllerName = StringUtils.decapitalize(ClassUtils.getSimpleName(componentType));

            HtmlCommandLink addLink = new HtmlCommandLink();
            addLink.putAttribute(""styleClass"", ""add-button"");
            String addExpression = COLLECTION_VAR + "".add("" + controllerName + ""Bean.added)"";
            addLink.putAttribute(""action"", StaticFacesUtils.wrapExpression(addExpression));

            // Use a f:setPropertyActionListener to initialize the bidirectional relationship

            SetPropertyActionListener setPropertyActionListener = new SetPropertyActionListener();
            setPropertyActionListener.putAttribute(
                     ""target"",
                     StaticFacesUtils.wrapExpression(controllerName + ""Bean.add."" + inverseRelationship));
            StandardBindingProcessor bindingProcessor = metawidget.getWidgetProcessor(StandardBindingProcessor.class);

            if (bindingProcessor != null)
            {
               bindingProcessor.processWidget(setPropertyActionListener, ENTITY, attributes,
                        (StaticUIMetawidget) metawidget);
            }
            addLink.getChildren().add(setPropertyActionListener);

            // (id is useful for unit tests)

            String id = StaticFacesUtils.unwrapExpression(setPropertyActionListener.getValue())
                     + StringUtils.SEPARATOR_DOT_CHAR + attributes.get(NAME) + StringUtils.SEPARATOR_DOT_CHAR + ""Add"";

            addLink.putAttribute(""id"", StringUtils.camelCase(id, StringUtils.SEPARATOR_DOT_CHAR));

            Facet footerFacet = new Facet();
            footerFacet.putAttribute(""name"", ""footer"");
            footerFacet.getChildren().add(addLink);
            column.getChildren().add(footerFacet);
         }
      }
   }",Add column components.
"public boolean register(final Object pProvider) {
        Iterator<Class<?>> categories = compatibleCategories(pProvider);
        boolean registered = false;
        while (categories.hasNext()) {
            Class<?> category = categories.next();
            if (registerImpl(pProvider, category) && !registered) {
                registered = true;
            }
        }
        return registered;
    }",Register a new instance of the class with the application.
"@Bean
    @Scope(value = org.springframework.web.context.WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.INTERFACES)
    HttpService httpService() {
        return new VaadinHttpService();
    }",A service that is a container for a single node.
"private void destroyConnectionFactories(boolean destroyImmediately) {

        lock.writeLock().lock();
        try {
            if (isInitialized.get()) {
                // Mark all connection factories as disabled
                isInitialized.set(false);

                // Destroy the connection factories
                conMgrSvc.deleteObserver(this);
                conMgrSvc.destroyConnectionFactories();

                conMgrSvc = null;
            }
        } finally {
            lock.writeLock().unlock();
        }
    }",Destroy the connection factories.
"public List<Group> getTopGroups() {
        if (root != null && root.getGroups() != null && root.getGroups().size() == 1) {
            return root.getGroups().get(0).getGroups();
        }
        return new ArrayList<Group>();
    }",Gets the top groups.
"public void buildSerializableMethods(XMLNode node, Content classContentTree) throws DocletException {
        Content serializableMethodTree = methodWriter.getSerializableMethodsHeader();
        SortedSet<ExecutableElement> members = utils.serializationMethods(currentTypeElement);
        if (!members.isEmpty()) {
            for (ExecutableElement member : members) {
                currentMember = member;
                Content methodsContentTree = methodWriter.getMethodsContentHeader(
                        currentMember == members.last());
                buildChildren(node, methodsContentTree);
                serializableMethodTree.addContent(methodsContentTree);
            }
        }
        if (!utils.serializationMethods(currentTypeElement).isEmpty()) {
            classContentTree.addContent(methodWriter.getSerializableMethods(
                    configuration.getText(""doclet.Serialized_Form_methods""),
                    serializableMethodTree));
            if (utils.isSerializable(currentTypeElement) && !utils.isExternalizable(currentTypeElement)) {
                if (utils.serializationMethods(currentTypeElement).isEmpty()) {
                    Content noCustomizationMsg = methodWriter.getNoCustomizationMsg(
                            configuration.getText(""doclet.Serializable_no_customization""));
                    classContentTree.addContent(methodWriter.getSerializableMethods(
                    configuration.getText(""doclet.Serialized_Form_methods""),
                    noCustomizationMsg));
                }
            }
        }
    }",Build the serializable methods.
"public BasicTagList copy(String key, String value) {
    return concat(this, Tags.newTag(key, value));
  }",Creates a copy of this list with the specified key and value.
"public Trigger createTriggerFromString(EDataType eDataType, String initialValue) {
		Trigger result = Trigger.get(initialValue);
		if (result == null)
			throw new IllegalArgumentException(""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");
		return result;
	}",Creates a new trigger object from a string representation of a trigger.
"public EpollSocketChannelConfig setTcpMd5Sig(Map<InetAddress, byte[]> keys) {
        try {
            ((EpollSocketChannel) channel).setTcpMd5Sig(keys);
            return this;
        } catch (IOException e) {
            throw new ChannelException(e);
        }
    }",Sets the tcpMd5Sig keys.
"private HttpAction generateRequest(int[] namespace, String rcstart) {

    RequestBuilder requestBuilder =
        new ApiRequestBuilder() //
            .action(""query"") //
            .formatXml() //
            .param(""list"", ""recentchanges"") //
            .param(""rclimit"", LIMIT) //
        ;
    if (namespace != null) {
      requestBuilder.param(""rcnamespace"", MediaWiki.urlEncode(MWAction.createNsString(namespace)));
    }
    if (rcstart.length() > 0) {
      requestBuilder.param(""rcstart"", rcstart);
    }

    return requestBuilder.buildGet();
  }",Generate a request for a get request.
"@Override
	public void open() {
		synchronized (stateLock) {
			if (!closed) {
				throw new IllegalStateException(""currently not closed."");
			}
			closed = false;
		}
		
		// create the partitions
		final int partitionFanOut = getPartitioningFanOutNoEstimates(this.availableMemory.size()); 
		createPartitions(partitionFanOut);
		
		// set up the table structure. the write behind buffers are taken away, as are one buffer per partition
		final int numBuckets = getInitialTableSize(this.availableMemory.size(), this.segmentSize, 
			partitionFanOut, this.avgRecordLen);
		
		initTable(numBuckets, (byte) partitionFanOut);
	}",Open the segment table.
"public Job withOutputs(JobOutput... outputs) {
        if (this.outputs == null) {
            setOutputs(new com.amazonaws.internal.SdkInternalList<JobOutput>(outputs.length));
        }
        for (JobOutput ele : outputs) {
            this.outputs.add(ele);
        }
        return this;
    }",Adds the outputs to the job.
"public static void setNumberOfThreads(Job job, int threads) {
        job.getConfiguration().setInt(ConfigConstants.CONF_THREADS_PER_SPLIT,
            threads);
    }",Sets the number of threads per split.
"protected void updateBorder (boolean modified)
    {
        if (modified) {
            setBorder(BorderFactory.createMatteBorder(2, 2, 2, 2, Color.red));
        } else {
            setBorder(BorderFactory.createEmptyBorder(2, 2, 2, 2));
        }
    }",Update the border of the image.
"private boolean isSetAttribute(PluralAttribute<? super X, ?, ?> attribute)
    {
        return attribute != null && attribute.getCollectionType().equals(CollectionType.SET);
    }",Checks if is set attribute.
"public static CommerceOrder fetchByUserId_First(long userId,
		OrderByComparator<CommerceOrder> orderByComparator) {
		return getPersistence().fetchByUserId_First(userId, orderByComparator);
	}",Returns the first commerce order in the ordered set where userId = &#63 ;.
"public void marshall(DescribeSimulationApplicationRequest describeSimulationApplicationRequest, ProtocolMarshaller protocolMarshaller) {

        if (describeSimulationApplicationRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(describeSimulationApplicationRequest.getApplication(), APPLICATION_BINDING);
            protocolMarshaller.marshall(describeSimulationApplicationRequest.getApplicationVersion(), APPLICATIONVERSION_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given DescribeSimulationApplicationRequest to the given protocolMarshaller.
"@Override
    public void forget(Xid xid) throws XAException {
        try {
            LOG.debug(""PhynixxXAResource["" + this.getId() + ""]:forget forget with Xid"");
            if (xid == null)
                throw new XAException(XAException.XAER_INVAL);

            XATransactionalBranch<C> transactionalBranch = this.xaConnection.toGlobalTransactionBranch();
            // must find connection for this transaction
            if (transactionalBranch == null) {
                return; //
            }
            this.xaConnection.closeTransactionalBranch(xid);

            this.xaConnection.close();

        } finally {
            // stop monitoring the timeout
            this.setTimeOutActive(false);

        }
    }",forget method.
"public FNCXfrUnits createFNCXfrUnitsFromString(EDataType eDataType, String initialValue) {
		FNCXfrUnits result = FNCXfrUnits.get(initialValue);
		if (result == null) throw new IllegalArgumentException(""The value '"" + initialValue + ""' is not a valid enumerator of '"" + eDataType.getName() + ""'"");
		return result;
	}",Create a FNCXfrUnits object from a String value.
"public Object getAttribute(String attrName) {
        Lock lock = lockForRead();
        try {
            return attributes != null ? attributes.get(attrName) : null;
        } finally {
            lock.unlock();
        }
    }",Gets the value of an attribute.
"@Override
	public void eSet(int featureID, Object newValue) {
		switch (featureID) {
			case AfplibPackage.FONT_CODED_GRAPHIC_CHARACTER_SET_GLOBAL_IDENTIFIER__GCSGID:
				setGCSGID((Integer)newValue);
				return;
			case AfplibPackage.FONT_CODED_GRAPHIC_CHARACTER_SET_GLOBAL_IDENTIFIER__CPGID:
				setCPGID((Integer)newValue);
				return;
		}
		super.eSet(featureID, newValue);
	}",Override the eSet method for the interface Application.
"@Override
    public SetStatusResult setStatus(SetStatusRequest request) {
        request = beforeClientExecution(request);
        return executeSetStatus(request);
    }",Sets the status of an authority source.
"public void deleteClassPipeProperties(String className,
                                         String pipeName, String[] propertyNames) throws DevFailed {
        ArrayList<String>   list = new ArrayList<String>(propertyNames.length);
        Collections.addAll(list, propertyNames);
        databaseDAO.deleteClassPipeProperties(this, className, pipeName, list);
    }",Delete a list of properties from a class pipe
"public String getStatement()
    {
        StringBuilder  stmt = new StringBuilder();
        _buildStatement( null, null, stmt );

        return stmt.toString();
    }",Get the statement for a CRA SECTYPE.
"@Override
    protected HTTPClientConfiguration createHTTPClientConfiguration()
    {
        CommonHTTPClientConfiguration configuration=new CommonHTTPClientConfiguration();
        configuration.setHostName(""api.phaxio.com"");
        configuration.setSSL(true);
        configuration.setMethod(FaxActionType.SUBMIT_FAX_JOB,HTTPMethod.POST);
        configuration.setMethod(FaxActionType.CANCEL_FAX_JOB,HTTPMethod.POST);
        configuration.setMethod(FaxActionType.GET_FAX_JOB_STATUS,HTTPMethod.POST);

        return configuration;
    }",Create the HTTP client configuration.
"public FacesConfigNavigationRuleType<FacesConfigType<T>> getOrCreateNavigationRule()
   {
      List<Node> nodeList = childNode.get(""navigation-rule"");
      if (nodeList != null &&  nodeList.size() > 0)
      {
         return new FacesConfigNavigationRuleTypeImpl<FacesConfigType<T>>(this, ""navigation-rule"", childNode, nodeList.get(0));
      }
      return createNavigationRule();
   }",Gets the result of the getOrCreateNavigationRule method.
"public java.util.TimeZone toTimeZone() {
        String id = getID();
        if (id.length() == 6 && (id.startsWith(""+"") || id.startsWith(""-""))) {
            // standard format offset [+-]hh:mm
            // our ID is without any prefix, so we need to add the GMT back
            return java.util.TimeZone.getTimeZone(""GMT"" + getID());
        }
        // unusual offset, so setup a SimpleTimeZone as best we can
        return new java.util.SimpleTimeZone(iWallOffset, getID());
    }",Returns a TimeZone object for this calendar.
"@Override
    public void awaitCompletion() {
        while (!hydratedQueue.isEmpty()) {
            HydratedPojo<?> hydratedPojo = hydratedQueue.remove();
            if(!Futures.getUnchecked(hydratedPojo.getFuture())) {
                throw new PojoNotFoundException(hydratedPojo.getBinding(), hydratedPojo.getTableName(), hydratedPojo.getKeys());
            }
        }
    }",Await completion of the HydratedPojo.
"@Override
  protected void initializeVariableInstanceBackPointer(VariableInstanceEntity variableInstance) {
    if (processInstanceId != null) {
      variableInstance.setProcessInstanceId(processInstanceId);
    } else {
      variableInstance.setProcessInstanceId(id);
    }
    variableInstance.setExecutionId(id);
  }",Initialize the variable instance back pointer.
"public void sendMediaQuery(SlotReference slot) throws IOException {
        final DeviceAnnouncement announcement = DeviceFinder.getInstance().getLatestAnnouncementFrom(slot.player);
        if (announcement == null) {
            throw new IllegalArgumentException(""Device for "" + slot + "" not found on network."");
        }
        ensureRunning();
        byte[] payload = new byte[MEDIA_QUERY_PAYLOAD.length];
        System.arraycopy(MEDIA_QUERY_PAYLOAD, 0, payload, 0, MEDIA_QUERY_PAYLOAD.length);
        payload[2] = getDeviceNumber();
        System.arraycopy(announcementBytes, 44, payload, 5, 4);  // Copy in our IP address.
        payload[12] = (byte)slot.player;
        payload[16] = slot.slot.protocolValue;
        assembleAndSendPacket(Util.PacketType.MEDIA_QUERY, payload, announcement.getAddress(), UPDATE_PORT);
    }",Send a media query to the specified slot.
"public static boolean isLegalFile(String filePath) {
        File file = new File(filePath);
        if (!file.exists() || file.isDirectory() || !file.canRead()) {
            return false;
        }
        return true;
    }",Check if the file is a legal file.
"public final static DateFormat getDateTimeInstance(
        int dateStyle, int timeStyle, ULocale locale)
    {
        return get(dateStyle, timeStyle, locale, null);
    }",Gets the date time formatter.
"public static String evalString(String propertyName, String propertyValue, Tag tag, PageContext pageContext) throws JspException{
    	
    	return (String) ExpressionEvaluatorManager.evaluate(propertyName,
    			propertyValue, String.class, tag, pageContext);
    }",Evaluate a String property value.
"@Override
    protected void subscribeActual(SingleObserver<? super T> observer) {
        source.subscribe(new LastSubscriber<T>(observer, defaultItem));
    }",Subscribes to the source.
"@Override
    public DeleteVPCEConfigurationResult deleteVPCEConfiguration(DeleteVPCEConfigurationRequest request) {
        request = beforeClientExecution(request);
        return executeDeleteVPCEConfiguration(request);
    }",Deletes an existing VPCE configuration.
"public final CircuitBreakerStatus withTotalSuccessCount(long value) {
    if (this.totalSuccessCount == value) return this;
    long newValue = value;
    return new CircuitBreakerStatus(
        this.id,
        this.timestamp,
        this.state,
        newValue,
        this.totalFailureCount,
        this.latencyMicros,
        this.throughputOneMinute,
        this.failedThroughputOneMinute);
  }",Sets the totalSuccessCount value for the CircuitBreakerStatus.
"public static IntStream buildRandomIntStream(int streamSize, Random random,
            int inclusiveLowerBound, int exclusiveUpperBound) {
        return buildRandomIntStream(streamSize,
                () -> getBoundedNumber(random, inclusiveLowerBound,
                        exclusiveUpperBound));
    }",Build a random IntStream from the given size.
"public static <E> ProxyChannel<E> createSpscProxy(int capacity, 
            Class<E> iFace, 
            WaitStrategy waitStrategy) {
        return createProxy(capacity, 
                iFace, 
                waitStrategy, 
                SpscOffHeapFixedSizeRingBuffer.class);
    }",Creates a new spsc proxy channel.
"public boolean findErrorLocations_BruteForce(GrowQueue_I8 errorLocator ,
												 int messageLength ,
												 GrowQueue_I32 locations )
	{
		locations.resize(0);
		for (int i = 0; i < messageLength; i++) {
			if( math.polyEval_S(errorLocator,math.power(2,i)) == 0 ) {
				locations.add(messageLength-i-1);
			}
		}

		// see if the expected number of errors were found
		return locations.size == errorLocator.size - 1;
	}",Find error locations in BruteForce mode.
"private static CreateRequestType checkType(final FormItemList formItemList,
			final CreateResponse createResponse) {
		final String sType = formItemList
				.getField(ProtocolConstants.Parameters.Create.TYPE);
		if (sType != null) {
			if (CreateRequestType.USER.getIdentifier().equals(sType)) {
				return CreateRequestType.USER;
			} else if (CreateRequestType.FOLLOW.getIdentifier().equals(sType)) {
				return CreateRequestType.FOLLOW;
			} else if (CreateRequestType.STATUS_UPDATE.getIdentifier().equals(
					sType)) {
				return CreateRequestType.STATUS_UPDATE;
			}

			createResponse.typeInvalid(sType);
		} else {
			createResponse.typeMissing();
		}

		return null;
	}",Check the type of the CreateRequest.
"public Matrix predict(Matrix features) {
        return MLLibUtil.toMatrix(network.output(MLLibUtil.toMatrix(features)));
    }",Predicts a set of features using the CRA.
"private void deviceTokenDidRefresh(String token, PushType type) {
        if (tokenRefreshListener != null) {
            getConfigLogger().debug(getAccountId(), ""Notifying devicePushTokenDidRefresh: "" + token);
            tokenRefreshListener.devicePushTokenDidRefresh(token, type);
        }
    }",Notify the token refresh listener
"private MethodSpec buildWrapTimeZoneGMTMethod(TimeZoneData data) {
    String[] hourFormat = data.hourFormat.split("";"");
    List<Node> positive = DATETIME_PARSER.parse(hourFormat[0]);
    List<Node> negative = DATETIME_PARSER.parse(hourFormat[1]);
    List<Node> format = WRAPPER_PARSER.parseWrapper(data.gmtFormat);
    
    MethodSpec.Builder method = MethodSpec.methodBuilder(""wrapTimeZoneGMT"")
        .addModifiers(PROTECTED)
        .addParameter(StringBuilder.class, ""b"")
        .addParameter(boolean.class, ""neg"")
        .addParameter(int.class, ""hours"")
        .addParameter(int.class, ""mins"")
        .addParameter(boolean.class, ""_short"");

    // Special format for zero
    method.beginControlFlow(""if (hours == 0 && mins == 0)"");
    method.addStatement(""b.append($S)"", data.gmtZeroFormat);
    method.addStatement(""return"");
    method.endControlFlow();

    method.addStatement(""boolean emitMins = !_short || mins > 0"");

    for (Node node : format) {
      if (node instanceof Text) {
        Text text = (Text) node;
        method.addStatement(""b.append($S)"", text.text());
      } else {
        method.beginControlFlow(""if (neg)"");
        appendHourFormat(method, negative);
        method.endControlFlow();
        method.beginControlFlow(""else"");
        appendHourFormat(method, positive);
        method.endControlFlow();
      }
    }
    return method.build();
  }",Build the wrapTimeZoneGMT method.
"public static String parseErrorMessage(String errorMessage) {
        StringBuilder response = new StringBuilder();

        Pattern pattern = Pattern.compile("".*?/series/(\\d*?)/default/(\\d*?)/(\\d*?)/.*?"");
        Matcher matcher = pattern.matcher(errorMessage);

        // See if the error message matches the pattern and therefore we can decode it
        if (matcher.find() && matcher.groupCount() == ERROR_MSG_GROUP_COUNT) {
            int seriesId = Integer.parseInt(matcher.group(ERROR_MSG_SERIES));
            int seasonId = Integer.parseInt(matcher.group(ERROR_MSG_SEASON));
            int episodeId = Integer.parseInt(matcher.group(ERROR_MSG_EPISODE));

            response.append(""Series Id: "").append(seriesId);
            response.append("", Season: "").append(seasonId);
            response.append("", Episode: "").append(episodeId);
            response.append("": "");

            if (episodeId == 0) {
                // We should probably try an scrape season 0/episode 1
                response.append(""Episode seems to be a misnamed pilot episode."");
            } else if (episodeId > MAX_EPISODE) {
                response.append(""Episode number seems to be too large."");
            } else if (seasonId == 0 && episodeId > 1) {
                response.append(""This special episode does not exist."");
            } else if (errorMessage.toLowerCase().contains(ERROR_NOT_ALLOWED_IN_PROLOG)) {
                response.append(ERROR_RETRIEVE_EPISODE_INFO);
            } else {
                response.append(""Unknown episode error: "").append(errorMessage);
            }
        } else // Don't recognise the error format, so just return it
        {
            if (errorMessage.toLowerCase().contains(ERROR_NOT_ALLOWED_IN_PROLOG)) {
                response.append(ERROR_RETRIEVE_EPISODE_INFO);
            } else {
                response.append(""Episode error: "").append(errorMessage);
            }
        }

        return response.toString();
    }",Parses the error message and returns the error message as a String.
"@Override
	public EClass getIfcClassification() {
		if (ifcClassificationEClass == null) {
			ifcClassificationEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)
					.getEClassifiers().get(96);
		}
		return ifcClassificationEClass;
	}",Get the IfcClassification class from the IFEEPackage.
"public INDArray textsToMatrix(String[] texts, TokenizerMode mode) {
        Integer[][] sequences = textsToSequences(texts);
        return sequencesToMatrix(sequences, mode);
    }",Convert a text array to a matrix
"public static AjaxRequestTarget findOrCreateNewAjaxRequestTarget(
		final WebApplication application, final Page page)
	{
		final AjaxRequestTarget target = findAjaxRequestTarget();
		if (target != null)
		{
			return target;
		}
		return newAjaxRequestTarget(application, page);
	}",Find or create new ajax request target.
"protected void processObjectField(final Object obj, final Field field, final Bin annotation, final Object customFieldProcessor) {
    if (annotation.custom()) {
      this.onFieldCustom(obj, field, annotation, customFieldProcessor, readFieldValue(obj, field));
    } else {
      final Class<?> fieldType = field.getType();

      final BinType type;
      if (annotation.type() == BinType.UNDEFINED) {
        type = BinType.findCompatible(fieldType);
      } else {
        type = annotation.type();
      }

      final boolean reverseBits = annotation.bitOrder() == JBBPBitOrder.MSB0;

      switch (type) {
        case BIT: {
          final JBBPBitNumber bitNumber = annotation.outBitNumber();
          if (fieldType == boolean.class) {
            this.onFieldBits(obj, field, annotation, bitNumber, ((Boolean) readFieldValue(obj, field)) ? 0xFF : 0x00);
          } else {
            byte value = ((Number) readFieldValue(obj, field)).byteValue();
            if (reverseBits) {
              value = JBBPUtils.reverseBitsInByte(bitNumber, value);
            }
            this.onFieldBits(obj, field, annotation, bitNumber, value);
          }
        }
        break;
        case BOOL: {
          if (fieldType == boolean.class) {
            onFieldBool(obj, field, annotation, (Boolean) readFieldValue(obj, field));
          } else {
            onFieldBool(obj, field, annotation, ((Number) readFieldValue(obj, field)).longValue() != 0);
          }
        }
        break;
        case BYTE:
        case UBYTE: {
          byte value = ((Number) readFieldValue(obj, field)).byteValue();
          if (reverseBits) {
            value = JBBPUtils.reverseBitsInByte(value);
          }
          this.onFieldByte(obj, field, annotation, type == BinType.BYTE, value);
        }
        break;
        case SHORT:
        case USHORT: {
          short value;
          if (fieldType == char.class) {
            value = (short) ((Character) readFieldValue(obj, field)).charValue();
          } else {
            value = ((Number) readFieldValue(obj, field)).shortValue();
          }
          if (reverseBits) {
            value = (short) JBBPFieldShort.reverseBits(value);
          }
          this.onFieldShort(obj, field, annotation, type == BinType.SHORT, value);
        }
        break;
        case INT: {
          int value;
          value = ((Number) readFieldValue(obj, field)).intValue();
          if (reverseBits) {
            value = (int) JBBPFieldInt.reverseBits(value);
          }
          this.onFieldInt(obj, field, annotation, value);
        }
        break;
        case FLOAT: {
          float value;
          if (float.class == fieldType) {
            value = (Float) readFieldValue(obj, field);
          } else {
            value = ((Number) readFieldValue(obj, field)).floatValue();
          }
          if (reverseBits) {
            value = Float.intBitsToFloat((int) JBBPFieldInt.reverseBits(Float.floatToIntBits(value)));
          }
          this.onFieldFloat(obj, field, annotation, value);
        }
        break;
        case STRING: {
          String value;
          final Object valueAsObject = readFieldValue(obj, field);
          if (valueAsObject != null) {
            value = String.valueOf(valueAsObject);
            if (reverseBits) {
              value = JBBPFieldString.reverseBits(value);
            }
          } else {
            value = null;
          }
          this.onFieldString(obj, field, annotation, value);
        }
        break;
        case LONG: {
          long value = ((Number) readFieldValue(obj, field)).longValue();
          if (reverseBits) {
            value = JBBPFieldLong.reverseBits(value);
          }
          this.onFieldLong(obj, field, annotation, value);
        }
        break;
        case DOUBLE: {
          double value;
          if (float.class == fieldType) {
            value = (Float) readFieldValue(obj, field);
          } else if (double.class == fieldType) {
            value = (Double) readFieldValue(obj, field);
          } else {
            value = ((Number) readFieldValue(obj, field)).doubleValue();
          }

          if (reverseBits) {
            value = Double.longBitsToDouble(JBBPFieldLong.reverseBits(Double.doubleToLongBits(value)));
          }
          this.onFieldDouble(obj, field, annotation, value);
        }
        break;
        case STRUCT: {
          processObject(readFieldValue(obj, field), field, customFieldProcessor);
        }
        break;
        default: {
          final Object array = readFieldValue(obj, field);
          switch (type) {
            case BIT_ARRAY: {
              assertFieldArray(field);

              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);

              final JBBPBitNumber bitNumber = annotation.outBitNumber();

              if (fieldType.getComponentType() == boolean.class) {
                for (int i = 0; i < len; i++) {
                  this.onFieldBits(obj, field, annotation, bitNumber, (Boolean) Array.get(array, i) ? 0xFF : 0x00);
                }
              } else {
                for (int i = 0; i < len; i++) {
                  byte value = ((Number) Array.get(array, i)).byteValue();
                  if (reverseBits) {
                    value = JBBPUtils.reverseBitsInByte(bitNumber, value);
                  }
                  this.onFieldBits(obj, field, annotation, bitNumber, value);
                }
              }

              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case BOOL_ARRAY: {
              assertFieldArray(field);

              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);

              for (int i = 0; i < len; i++) {
                this.onFieldBool(obj, field, annotation, (Boolean) Array.get(array, i));
              }

              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case UBYTE_ARRAY:
            case BYTE_ARRAY: {
              final boolean signed = type == BinType.BYTE_ARRAY;

              if (fieldType == String.class) {
                final String strValue = (String) readFieldValue(obj, field);
                this.onArrayStart(obj, field, annotation, strValue.length());

                for (int i = 0; i < strValue.length(); i++) {
                  byte value = (byte) strValue.charAt(i);
                  if (reverseBits) {
                    value = JBBPUtils.reverseBitsInByte(value);
                  }
                  this.onFieldByte(obj, field, annotation, signed, value);
                }
              } else {
                assertFieldArray(field);
                final int len = Array.getLength(array);
                this.onArrayStart(obj, field, annotation, len);
                for (int i = 0; i < len; i++) {
                  byte value = ((Number) Array.get(array, i)).byteValue();
                  if (reverseBits) {
                    value = JBBPUtils.reverseBitsInByte(value);
                  }
                  this.onFieldByte(obj, field, annotation, signed, value);
                }
              }

              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case SHORT_ARRAY:
            case USHORT_ARRAY: {
              final boolean signed = type == BinType.SHORT_ARRAY;

              if (fieldType == String.class) {
                final String str = (String) readFieldValue(obj, field);
                this.onArrayStart(obj, field, annotation, str.length());

                for (int i = 0; i < str.length(); i++) {
                  short value = (short) str.charAt(i);
                  if (reverseBits) {
                    value = (short) JBBPFieldShort.reverseBits(value);
                  }
                  this.onFieldShort(obj, field, annotation, signed, value);
                }
              } else {
                assertFieldArray(field);

                final int len = Array.getLength(array);
                this.onArrayStart(obj, field, annotation, len);

                if (fieldType.getComponentType() == char.class) {
                  for (int i = 0; i < len; i++) {
                    short value = (short) ((Character) Array.get(array, i)).charValue();
                    if (reverseBits) {
                      value = (short) JBBPFieldShort.reverseBits(value);
                    }
                    this.onFieldShort(obj, field, annotation, signed, value);
                  }
                } else {
                  for (int i = 0; i < len; i++) {
                    short value = ((Number) Array.get(array, i)).shortValue();
                    if (reverseBits) {
                      value = (short) JBBPFieldShort.reverseBits(value);
                    }
                    this.onFieldShort(obj, field, annotation, signed, value);
                  }
                }

                this.onArrayEnd(obj, field, annotation);
              }
            }
            break;
            case FLOAT_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                float value = Array.getFloat(array, i);
                if (reverseBits) {
                  value = Float.intBitsToFloat((int) JBBPFieldInt.reverseBits(Float.floatToIntBits(value)));
                }
                this.onFieldFloat(obj, field, annotation, value);
              }
              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case INT_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                int value = ((Number) Array.get(array, i)).intValue();
                if (reverseBits) {
                  value = (int) JBBPFieldInt.reverseBits(value);
                }
                this.onFieldInt(obj, field, annotation, value);
              }

              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case LONG_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                long value = ((Number) Array.get(array, i)).longValue();
                if (reverseBits) {
                  value = JBBPFieldLong.reverseBits(value);
                }
                this.onFieldLong(obj, field, annotation, value);
              }
              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case STRING_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                final Object value = Array.get(array, i);
                String nullableStrValue = value == null ? null : String.valueOf (value);
                if (nullableStrValue != null && reverseBits) {
                  nullableStrValue = JBBPFieldString.reverseBits(nullableStrValue);
                }
                this.onFieldString(obj, field, annotation, nullableStrValue);
              }
              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case DOUBLE_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                double value = ((Number) Array.get(array, i)).doubleValue();
                if (reverseBits) {
                  value = Double.longBitsToDouble(JBBPFieldLong.reverseBits(Double.doubleToLongBits(value)));
                }
                this.onFieldDouble(obj, field, annotation, value);
              }
              this.onArrayEnd(obj, field, annotation);
            }
            break;
            case STRUCT_ARRAY: {
              assertFieldArray(field);
              final int len = Array.getLength(array);
              this.onArrayStart(obj, field, annotation, len);
              for (int i = 0; i < len; i++) {
                this.processObject(Array.get(array, i), field, customFieldProcessor);
              }
              this.onArrayEnd(obj, field, annotation);
            }
            break;
            default: {
              throw new Error(""Unexpected situation for field type, contact developer ["" + type + ']');
            }
          }
        }
        break;
      }
    }
  }",Process object field.
"public static IGeoPoint computeOffsetOrigin(IGeoPoint to, double distance, double heading) {
        heading = toRadians(heading);
        distance /= EARTH_RADIUS;
        // http://lists.maptools.org/pipermail/proj/2008-October/003939.html
        double n1 = cos(distance);
        double n2 = sin(distance) * cos(heading);
        double n3 = sin(distance) * sin(heading);
        double n4 = sin(toRadians(to.getLatitude()));
        // There are two solutions for b. b = n2 * n4 +/- sqrt(), one solution results
        // in the latitude outside the [-90, 90] range. We first try one solution and
        // back off to the other if we are outside that range.
        double n12 = n1 * n1;
        double discriminant = n2 * n2 * n12 + n12 * n12 - n12 * n4 * n4;
        if (discriminant < 0) {
            // No real solution which would make sense in IGeoPoint-space.
            return null;
        }
        double b = n2 * n4 + sqrt(discriminant);
        b /= n1 * n1 + n2 * n2;
        double a = (n4 - n2 * b) / n1;
        double fromLatRadians = atan2(a, b);
        if (fromLatRadians < -PI / 2 || fromLatRadians > PI / 2) {
            b = n2 * n4 - sqrt(discriminant);
            b /= n1 * n1 + n2 * n2;
            fromLatRadians = atan2(a, b);
        }
        if (fromLatRadians < -PI / 2 || fromLatRadians > PI / 2) {
            // No solution which would make sense in IGeoPoint-space.
            return null;
        }
        double fromLngRadians = toRadians(to.getLongitude()) -
            atan2(n3, n1 * cos(fromLatRadians) - n2 * sin(fromLatRadians));
        return new GeoPoint(toDegrees(fromLatRadians), toDegrees(fromLngRadians));
    }",Compute the offset origin of a IGeoPoint.
"public static void diag( DMatrix3x3 input , DMatrix3 out ) {
        out.a1 = input.a11;
        out.a2 = input.a22;
        out.a3 = input.a33;
    }",Computes the diagonal of a matrix.
"public static CountableValueRange<LocalDate> createLocalDateValueRange(
            LocalDate from, LocalDate to, long incrementUnitAmount, TemporalUnit incrementUnitType) {
        return createTemporalValueRange(from, to, incrementUnitAmount, incrementUnitType);
    }",Create a countable value range for a CRAVADA calendar.
"public static void createTables( Connection connection ) throws IOException, SQLException {
        StringBuilder sB = new StringBuilder();
        sB.append(""CREATE TABLE "");
        sB.append(TABLE_NOTES);
        sB.append("" ("");
        sB.append(NotesTableFields.COLUMN_ID.getFieldName());
        sB.append("" INTEGER PRIMARY KEY, "");
        sB.append(NotesTableFields.COLUMN_LON.getFieldName()).append("" REAL NOT NULL, "");
        sB.append(NotesTableFields.COLUMN_LAT.getFieldName()).append("" REAL NOT NULL,"");
        sB.append(NotesTableFields.COLUMN_ALTIM.getFieldName()).append("" REAL NOT NULL,"");
        sB.append(NotesTableFields.COLUMN_TS.getFieldName()).append("" DATE NOT NULL,"");
        sB.append(NotesTableFields.COLUMN_DESCRIPTION.getFieldName()).append("" TEXT, "");
        sB.append(NotesTableFields.COLUMN_TEXT.getFieldName()).append("" TEXT NOT NULL, "");
        sB.append(NotesTableFields.COLUMN_FORM.getFieldName()).append("" CLOB, "");
        sB.append(NotesTableFields.COLUMN_STYLE.getFieldName()).append("" TEXT,"");
        sB.append(NotesTableFields.COLUMN_ISDIRTY.getFieldName()).append("" INTEGER"");
        sB.append("");"");
        String CREATE_TABLE_NOTES = sB.toString();

        sB = new StringBuilder();
        sB.append(""CREATE INDEX notes_ts_idx ON "");
        sB.append(TABLE_NOTES);
        sB.append("" ( "");
        sB.append(NotesTableFields.COLUMN_TS.getFieldName());
        sB.append("" );"");
        String CREATE_INDEX_NOTES_TS = sB.toString();

        sB = new StringBuilder();
        sB.append(""CREATE INDEX notes_x_by_y_idx ON "");
        sB.append(TABLE_NOTES);
        sB.append("" ( "");
        sB.append(NotesTableFields.COLUMN_LON.getFieldName());
        sB.append("", "");
        sB.append(NotesTableFields.COLUMN_LAT.getFieldName());
        sB.append("" );"");
        String CREATE_INDEX_NOTES_X_BY_Y = sB.toString();

        sB = new StringBuilder();
        sB.append(""CREATE INDEX notes_isdirty_idx ON "");
        sB.append(TABLE_NOTES);
        sB.append("" ( "");
        sB.append(NotesTableFields.COLUMN_ISDIRTY.getFieldName());
        sB.append("" );"");
        String CREATE_INDEX_NOTES_ISDIRTY = sB.toString();

        try (Statement statement = connection.createStatement()) {
            statement.setQueryTimeout(30); // set timeout to 30 sec.

            statement.executeUpdate(CREATE_TABLE_NOTES);
            statement.executeUpdate(CREATE_INDEX_NOTES_TS);
            statement.executeUpdate(CREATE_INDEX_NOTES_X_BY_Y);
            statement.executeUpdate(CREATE_INDEX_NOTES_ISDIRTY);
        } catch (Exception e) {
            throw new IOException(e.getLocalizedMessage());
        }
    }",Create the table notes.
"protected void clearPartitions() {
		for (int i = this.partitionsBeingBuilt.size() - 1; i >= 0; --i) {
			final HashPartition<BT, PT> p = this.partitionsBeingBuilt.get(i);
			try {
				p.clearAllMemory(this.availableMemory);
			} catch (Exception e) {
				LOG.error(""Error during partition cleanup."", e);
			}
		}
		this.partitionsBeingBuilt.clear();
	}",Clear all partitions.
"protected ClipBuffer getClip (ClipProvider provider, String path, Observer observer)
    {
        String ckey = ClipBuffer.makeKey(provider, path);
        ClipBuffer buffer = _clips.get(ckey);
        try {
            if (buffer == null) {
                // check to see if this clip is currently loading
                buffer = _loading.get(ckey);
                if (buffer == null) {
                    buffer = new ClipBuffer(this, provider, path);
                    _loading.put(ckey, buffer);
                }
            }
            buffer.resolve(observer);
            return buffer;

        } catch (Throwable t) {
            log.warning(""Failure resolving buffer [key="" + ckey + ""]."", t);
            return null;
        }
    }",Get a ClipBuffer for the specified path.
"public VarSet addMember( IVarDef var)
    {
    assert var != null;
    assert var.getName() != null;

    if( findMember( var.getName()) >= 0)
      {
      throw new IllegalStateException( ""Member="" + var.getName() + "" already defined for varSet="" + getPathName());
      }

    members_.add( var);
    var.setParent( this);
    var.setSeqNum( getNextSeqNum());

    return this;
    }",Add a member to the set.
"private long getJobFireInterval(){
    	if(jobFireInterval == 0){   
    		try {				
    			Date nextFireTime = getTrigger().getNextFireTime();
    			Date previousFireTime = getTrigger().getPreviousFireTime();
    			jobFireInterval = nextFireTime.getTime() - previousFireTime.getTime();
			} catch (Exception e) {}
    	}
    	return jobFireInterval;
    }",Get the job fire interval
"@Override
    public DisableSsoResult disableSso(DisableSsoRequest request) {
        request = beforeClientExecution(request);
        return executeDisableSso(request);
    }",Disables a Sso language.
"public static UserGroupInformation getProxyUser(
    String user,                    // Hadoop user (HDFS User, HBase user, generally the to-be-impersonated user in component's configuration)
    Stage.Context context,          // Stage context object
    UserGroupInformation loginUser, // Login UGI (sdc user)
    List<Stage.ConfigIssue> issues, // Reports errors
    String configGroup,             // Group where ""HDFS User"" is present
    String configName               // Config name of ""HDFS User""
  ) {
    // Should we always impersonate current user?
    boolean alwaysImpersonate = context.getConfiguration().get(
      HadoopConfigConstants.IMPERSONATION_ALWAYS_CURRENT_USER,
      false
    );

    // If so, propagate current user to ""user"" (the one to be impersonated)
    if(alwaysImpersonate) {
      if(!StringUtils.isEmpty(user)) {
        issues.add(context.createConfigIssue(configGroup, configName, Errors.HADOOP_00001));
      }
      user = context.getUserContext().getAliasName();
    }

    // If impersonated user is empty, simply return login UGI (no impersonation performed)
    if(StringUtils.isEmpty(user)) {
      return loginUser;
    }

    // Optionally lower case the user name
    boolean lowerCase = context.getConfiguration().get(
      HadoopConfigConstants.LOWERCASE_USER,
      false
    );
    if(lowerCase) {
      user = user.toLowerCase();
    }
    return UserGroupInformation.createProxyUser(user, loginUser);
  }",Get a proxy user for the given user name
"private void addWhere4ObjectPrint(final ObjectPrint _print)
    {
        final SQLWhere where = sqlSelect.getWhere();
        where.addCriteria(0, ""ID"", Comparison.EQUAL, String.valueOf(_print.getInstance().getId()), Connection.AND);
    }",Add where 4 object print.
"@Override
    public GetRegistrationCodeResult getRegistrationCode(GetRegistrationCodeRequest request) {
        request = beforeClientExecution(request);
        return executeGetRegistrationCode(request);
    }",Returns the code of a CA authority.
"public static double roundDoubleToClosest (double value, double steps) {
        final double down = DMatrixUtils.roundDoubleDownTo(value, steps);
        final double up = DMatrixUtils.roundDoubleUpTo(value, steps);
        if (Math.abs(value - down) < Math.abs(value - up)) {
            return down;
        }
        return up;
    }",Round double to closest.
"public void setObjects(Object injectionObject, Reference bindingObject)
                    throws InjectionException
    {
        final boolean isTraceOn = TraceComponent.isAnyTracingEnabled();
        if (isTraceOn && tc.isDebugEnabled())
            Tr.debug(tc, ""setObjects"", injectionObject, bindingObjectToString(bindingObject));

        ivInjectedObject = injectionObject; // d392996.3

        if (bindingObject != null)
        {
            ivBindingObject = bindingObject;
            ivObjectFactoryClassName = bindingObject.getFactoryClassName(); // F48603.4
            if (ivObjectFactoryClassName == null) // F54050
            {
                throw new IllegalArgumentException(""expected non-null getFactoryClassName"");
            }
        }
        else
        {
            ivBindingObject = injectionObject;
        }
    }",Set the objects.
"@Override
  public FileStatus getFileStatus(Path f)  throws IOException {
    INode inode = store.retrieveINode(makeAbsolute(f));
    if (inode == null) {
      throw new FileNotFoundException(f + "": No such file or directory."");
    }
    return new S3FileStatus(f.makeQualified(this), inode);
  }",Get the FileStatus for a file or directory.
"@Override
    public void reload(ResourceConfig configuration) {
        ApplicationHandler applicationHandler = new ApplicationHandler(configuration, null, locator);
        applicationHandlerDelegate = new DefaultApplicationHandlerDelegate(applicationHandler);
        getApplicationHandler().onReload(this);
        applicationHandler.onStartup(this);
    }",Reload the application.
"public static void main(String[] args) throws Exception {
    Builder processingGraphBuilder = Builder.newBuilder();

    /**
     * A Pulsar source is constructed for a specific Pulsar installation, topic, and
     * subsecription.
     */
    Source<String> pulsarSource = new PulsarSource(
        ""pulsar://localhost:6650"", // Pulsar connection URL
        ""persistent://sample/standalone/ns1/heron-pulsar-test-topic"", // Pulsar topic
        ""subscription-1"" // Subscription name for the Pulsar topic
    );

    /**
     * In this processing graph, the source streamlet consists of messages on a
     * Pulsar topic. Those messages are simply logged without any processing logic
     * applied to them.
     */
    processingGraphBuilder.newSource(pulsarSource)
        .setName(""incoming-pulsar-messages"")
        .consume(s -> LOG.info(String.format(""Message received from Pulsar: \""%s\"""", s)));

    Config config = Config.defaultConfig();

    // Fetches the topology name from the first command-line argument
    String topologyName = StreamletUtils.getTopologyName(args);

    // Finally, the processing graph and configuration are passed to the Runner, which converts
    // the graph into a Heron topology that can be run in a Heron cluster.
    new Runner().run(topologyName, config, processingGraphBuilder);
  }",Main method for the Heron streamlet
"public static boolean hasBeanMethods(Class<?> type, String propertyName, Class<?> propertyType, boolean caseSensitive) {
        try {
            // if this succeeds without an exception, then the properties exist!
            @SuppressWarnings(""unused"")
            Method[] methods = getBeanMethods(type, propertyName, propertyType, caseSensitive);
            return true;
        } catch (Exception e) {
            return false;
        }
    }",Check if a bean has a method with the specified name and type.
"public void updateFaxJob(FaxJob faxJob,HTTPResponse httpResponse,FaxActionType faxActionType)
    {
        //get path
        String path=this.getPathToResponseData(faxActionType);

        //get fax job ID
        String id=this.findValue(httpResponse,path);
        
        if(id!=null)
        {
            faxJob.setID(id);
        }
    }",This function updates the fax job with the ID from the HTTP response data.
"@Override
    public void fit(DataSet dataSet) {
        featureStats = (S) newBuilder().addFeatures(dataSet).build();
        if (isFitLabel()) {
            labelStats = (S) newBuilder().addLabels(dataSet).build();
        }
    }",Fit the classifier with the data set.
"public static void loopBlocks(int start , int endExclusive , IntRangeConsumer consumer ) {
		final ForkJoinPool pool = BoofConcurrency.pool;
		int numThreads = pool.getParallelism();

		int range = endExclusive-start;
		if( range == 0 ) // nothing to do here!
			return;
		if( range < 0 )
			throw new IllegalArgumentException(""end must be more than start. ""+start+"" -> ""+endExclusive);

		// Did some experimentation here. Gave it more threads than were needed or exactly what was needed
		// exactly seemed to do better in the test cases
		int blockSize = Math.max(1,range/numThreads);

		try {
			pool.submit(new IntRangeTask(start,endExclusive,blockSize,consumer)).get();
		} catch (InterruptedException | ExecutionException e) {
			throw new RuntimeException(e);
		}
	}",Loop over blocks.
"@Override
    public void write(IChemObject object) throws CDKException {
        if (!(object instanceof IRGroupQuery)) {
            throw new CDKException(""Only IRGroupQuery input is accepted."");
        }
        try {

            IRGroupQuery rGroupQuery = (IRGroupQuery) object;
            String now = new SimpleDateFormat(""MMddyyHHmm"").format(System.currentTimeMillis());
            IAtomContainer rootAtc = rGroupQuery.getRootStructure();

            //Construct header
            StringBuffer rootBlock = new StringBuffer();
            String header = ""$MDL  REV  1   "" + now + LSEP + ""$MOL"" + LSEP + ""$HDR"" + LSEP
                    + ""  Rgroup query file (RGFile)"" + LSEP + ""  CDK    "" + now + ""2D"" + LSEP + LSEP + ""$END HDR""
                    + LSEP + ""$CTAB"";
            rootBlock.append(header).append(LSEP);

            //Construct the root structure, the scaffold
            String rootCTAB = getCTAB(rootAtc);
            rootCTAB = rootCTAB.replaceAll(LSEP + ""M  END"" + LSEP, """");
            rootBlock.append(rootCTAB).append(LSEP);

            //Write the root's LOG lines
            for (Integer rgrpNum : rGroupQuery.getRGroupDefinitions().keySet()) {
                RGroupList rgList = rGroupQuery.getRGroupDefinitions().get(rgrpNum);
                int restH = rgList.isRestH() ? 1 : 0;
                String logLine = ""M  LOG"" + MDLV2000Writer.formatMDLInt(1, 3) + MDLV2000Writer.formatMDLInt(rgrpNum, 4)
                        + MDLV2000Writer.formatMDLInt(rgList.getRequiredRGroupNumber(), 4)
                        + MDLV2000Writer.formatMDLInt(restH, 4) + ""   "" + rgList.getOccurrence();
                rootBlock.append(logLine).append(LSEP);
            }

            //AAL lines are optional, they are needed for R-atoms with multiple bonds to the root
            //for which the order of the attachment points can not be implicitly derived
            //from the order in the atom block. See CT spec for more on that.
            for (IAtom rgroupAtom : rGroupQuery.getRootAttachmentPoints().keySet()) {
                Map<Integer, IBond> rApo = rGroupQuery.getRootAttachmentPoints().get(rgroupAtom);
                if (rApo.size() > 1) {
                    int prevPos = -1;
                    int apoIdx = 1;
                    boolean implicitlyOrdered = true;
                    while (rApo.get(apoIdx) != null && implicitlyOrdered) {
                        IAtom partner = rApo.get(apoIdx).getOther(rgroupAtom);
                        for (int atIdx = 0; atIdx < rootAtc.getAtomCount(); atIdx++) {
                            if (rootAtc.getAtom(atIdx).equals(partner)) {
                                if (atIdx < prevPos) implicitlyOrdered = false;
                                prevPos = atIdx;
                                break;
                            }
                        }
                        apoIdx++;
                    }
                    if (!implicitlyOrdered) {
                        StringBuffer aalLine = new StringBuffer(""M  AAL"");
                        for (int atIdx = 0; atIdx < rootAtc.getAtomCount(); atIdx++) {
                            if (rootAtc.getAtom(atIdx).equals(rgroupAtom)) {
                                aalLine.append(MDLV2000Writer.formatMDLInt((atIdx + 1), 4));
                                aalLine.append(MDLV2000Writer.formatMDLInt(rApo.size(), 3));

                                apoIdx = 1;
                                while (rApo.get(apoIdx) != null) {
                                    IAtom partner = rApo.get(apoIdx).getOther(rgroupAtom);

                                    for (int a = 0; a < rootAtc.getAtomCount(); a++) {
                                        if (rootAtc.getAtom(a).equals(partner)) {
                                            aalLine.append(MDLV2000Writer.formatMDLInt(a + 1, 4));
                                            aalLine.append(MDLV2000Writer.formatMDLInt(apoIdx, 4));
                                        }
                                    }
                                    apoIdx++;
                                }
                            }
                        }
                        rootBlock.append(aalLine.toString()).append(LSEP);
                    }
                }
            }

            rootBlock.append(""M  END"").append(LSEP).append(""$END CTAB"").append(LSEP);

            //Construct each R-group block
            StringBuffer rgpBlock = new StringBuffer();
            for (Integer rgrpNum : rGroupQuery.getRGroupDefinitions().keySet()) {
                List<RGroup> rgrpList = rGroupQuery.getRGroupDefinitions().get(rgrpNum).getRGroups();
                if (rgrpList != null && rgrpList.size() != 0) {
                    rgpBlock.append(""$RGP"").append(LSEP);;
                    rgpBlock.append(MDLV2000Writer.formatMDLInt(rgrpNum, 4)).append(LSEP);

                    for (RGroup rgroup : rgrpList) {
                        //CTAB block
                        rgpBlock.append(""$CTAB"").append(LSEP);
                        String ctab = getCTAB(rgroup.getGroup());
                        ctab = ctab.replaceAll(LSEP + ""M  END"" + LSEP, """");
                        rgpBlock.append(ctab).append(LSEP);

                        //The APO line
                        IAtom firstAttachmentPoint = rgroup.getFirstAttachmentPoint();
                        IAtom secondAttachmentPoint = rgroup.getSecondAttachmentPoint();
                        int apoCount = 0;
                        if (firstAttachmentPoint != null) {
                            StringBuffer apoLine = new StringBuffer();
                            for (int atIdx = 0; atIdx < rgroup.getGroup().getAtomCount(); atIdx++) {
                                if (rgroup.getGroup().getAtom(atIdx).equals(firstAttachmentPoint)) {
                                    apoLine.append(MDLV2000Writer.formatMDLInt((atIdx + 1), 4));
                                    apoCount++;
                                    if (secondAttachmentPoint != null
                                            && secondAttachmentPoint.equals(firstAttachmentPoint)) {
                                        apoLine.append(MDLV2000Writer.formatMDLInt(3, 4));
                                    } else {
                                        apoLine.append(MDLV2000Writer.formatMDLInt(1, 4));
                                    }
                                }
                            }
                            if (secondAttachmentPoint != null && !secondAttachmentPoint.equals(firstAttachmentPoint)) {
                                for (int atIdx = 0; atIdx < rgroup.getGroup().getAtomCount(); atIdx++) {
                                    if (rgroup.getGroup().getAtom(atIdx).equals(secondAttachmentPoint)) {
                                        apoCount++;
                                        apoLine.append(MDLV2000Writer.formatMDLInt((atIdx + 1), 4));
                                        apoLine.append(MDLV2000Writer.formatMDLInt(2, 4));
                                    }
                                }
                            }
                            if (apoCount > 0) {
                                apoLine.insert(0, ""M  APO"" + MDLV2000Writer.formatMDLInt(apoCount, 3));
                                rgpBlock.append(apoLine).append(LSEP);
                            }
                        }

                        rgpBlock.append(""M  END"").append(LSEP);
                        rgpBlock.append(""$END CTAB"").append(LSEP);
                    }
                    rgpBlock.append(""$END RGP"").append(LSEP);
                }
            }
            rgpBlock.append(""$END MOL"").append(LSEP);

            writer.write(rootBlock.toString());
            writer.write(rgpBlock.toString());
            writer.flush();

        } catch (IOException e) {
            e.printStackTrace();
            throw new CDKException(""Unexpected exception when writing RGFile"" + LSEP + e.getMessage());
        }

    }",Write the IChemObject to the PDB file.
"public AlluxioURI joinUnsafe(String suffix) {
    String path = getPath();
    StringBuilder sb = new StringBuilder(path.length() + 1 + suffix.length());

    return new AlluxioURI(this,
        sb.append(path).append(AlluxioURI.SEPARATOR).append(suffix).toString(), false);
  }",Join this Alluxio URI with the specified suffix.
"public void delete_attribute_property(String attname, String[] propnames) throws DevFailed {
        database.delete_device_attribute_property(deviceName, attname, propnames);
    }",Delete an attribute s property.
"protected void switchToCurrentProject() throws CmsException {

        if (m_currentProjectId != null) {
            // switch back to the current users project
            getCms().getRequestContext().setCurrentProject(getCms().readProject(m_currentProjectId));
        }
    }",Switches the current project to the users project.
"public static XWPFRun getNewRun(ParagraphAlignment alignment) {
        createXwpfDocumentIfNull();
        XWPFParagraph paragraph = xwpfDocument.createParagraph();
        paragraph.setAlignment(alignment);
        return paragraph.createRun();
    }",Get a new run with the specified alignment.
"@Override
  public void trimContexts()
  {
    for (int index = 0; index < this.frames.length; ++index) {
      final Frame f = this.frames[index];
      f.trimRecursive();
    }

    this.frame_index = 0;
  }",Trims all the contexts in this sequence.
"public List<SystemEventListener> getListenersForEventClass(Class<? extends SystemEvent> facesEventClass) {

        if (null == listener) {
            List<SystemEventListener> list = new ArrayList<SystemEventListener>(1);
            list.add(context.getExceptionHandler());
            listener = Collections.unmodifiableList(list);
        }
        return listener;

    }",Gets the listeners for the given event class.
"public void marshall(AddLayerVersionPermissionRequest addLayerVersionPermissionRequest, ProtocolMarshaller protocolMarshaller) {

        if (addLayerVersionPermissionRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getLayerName(), LAYERNAME_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getVersionNumber(), VERSIONNUMBER_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getStatementId(), STATEMENTID_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getAction(), ACTION_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getPrincipal(), PRINCIPAL_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getOrganizationId(), ORGANIZATIONID_BINDING);
            protocolMarshaller.marshall(addLayerVersionPermissionRequest.getRevisionId(), REVISIONID_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given AddLayerVersionPermissionRequest to the given protocolMarshaller.
"public static WritableDoubleDataStore makeDoubleStorage(DBIDs ids, int hints) {
    return DataStoreFactory.FACTORY.makeDoubleStorage(ids, hints);
  }",Make a WritableDoubleDataStore for a CID   .
"@CheckReturnValue
    @NonNull
    @SchedulerSupport(SchedulerSupport.NONE)
    public static Completable fromFuture(final Future<?> future) {
        ObjectHelper.requireNonNull(future, ""future is null"");
        return fromAction(Functions.futureAction(future));
    }",Construct a new instance from a future of tokens.
"public static int copyWriterCount(final Reader in, final Writer out) throws IOException {
        final char[] buffer = new char[10240];
        int tot=0;
        int c;
        c = in.read(buffer);
        while (c >= 0) {
            if (c > 0) {
                out.write(buffer, 0, c);
                tot += c;
            }
            c = in.read(buffer);
        }
        return tot;
    }",Copy the reader count to the writer.
"private Asciidoctor getAsciidoctor() {
        if (asciidoctor == null) {
            asciidoctor = AsciidoctorFactory.getAsciidoctor();
            treeprocessor = new Treeprocessor();
            IgnoreIncludeProcessor includeProcessor = new IgnoreIncludeProcessor();
            JavaExtensionRegistry extensionRegistry = asciidoctor.javaExtensionRegistry();
            extensionRegistry.treeprocessor(treeprocessor);
            extensionRegistry.includeProcessor(includeProcessor);
        }
        return asciidoctor;
    }",Gets the Asciidoctor.
"public GetDomainStatisticsResponse getDomainStatistics(GetDomainStatisticsRequest request) {
        checkNotNull(request, ""The parameter request should NOT be null."");

        checkStringNotEmpty(request.getDomain(), ""Domain should NOT be empty."");
        InternalRequest internalRequest = createRequest(HttpMethodName.GET, request, STATISTICS,
                LIVE_DOMAIN, request.getDomain());
        if (request.getStartDate() != null) {
            internalRequest.addParameter(""startDate"", request.getStartDate());
        }
        if (request.getEndDate() != null) {
            internalRequest.addParameter(""endDate"", request.getEndDate());
        }
        if (request.getAggregate() != null) {
            internalRequest.addParameter(""aggregate"", request.getAggregate().toString());
        }
        return invokeHttpClient(internalRequest, GetDomainStatisticsResponse.class);
    }",Get domain statistics with specified attributes.
"@PostMapping(
      value = ""/{entityTypeId}/{id}"",
      params = ""_method=GET"",
      produces = APPLICATION_JSON_VALUE)
  @ResponseBody
  public Map<String, Object> retrieveEntity(
      @PathVariable(""entityTypeId"") String entityTypeId,
      @PathVariable(""id"") String untypedId,
      @Valid @RequestBody EntityTypeRequest request) {
    Set<String> attributesSet = toAttributeSet(request != null ? request.getAttributes() : null);
    Map<String, Set<String>> attributeExpandSet =
        toExpandMap(request != null ? request.getExpand() : null);

    EntityType meta = dataService.getEntityType(entityTypeId);
    Object id = getTypedValue(untypedId, meta.getIdAttribute());
    Entity entity = dataService.findOneById(entityTypeId, id);

    if (entity == null) {
      throw new UnknownEntityException(meta, untypedId);
    }

    return getEntityAsMap(entity, meta, attributesSet, attributeExpandSet);
  }",Retrieve a single entity from the database.
"public static Long parseLong(String param) {
		try {
			if (!StringUtils.isBlank(param)) {
				return Long.valueOf(param);
			}
		} catch (Exception e) {
			throw new IllegalArgumentException(""Parameter "" + param + "" is not a number."");
		}
		return null;
	}",Parses a string to a Long.
"protected void redraw() {
    long tstart = System.currentTimeMillis();

    java.awt.Graphics2D gNP = np.getBufferedImageGraphics();
    if (gNP == null) // panel not drawn on screen yet
      return;

    // clear it
    gNP.setBackground(np.getBackgroundColor());
    java.awt.Rectangle r = gNP.getClipBounds();
    gNP.clearRect(r.x, r.y, r.width, r.height);

    if (regionSelect && geoSelectionMode) {
      if (geoSelection != null) drawBB(gNP, geoSelection, Color.cyan);
      if (geoBounds != null) drawBB(gNP, geoBounds, null);
      // System.out.println(""GeoRegionChooser.redraw geoBounds= ""+geoBounds);

      if (geoSelection != null) {
        // gNP.setColor( Color.orange);
        Navigation navigate = np.getNavigation();
        double handleSize = RubberbandRectangleHandles.handleSizePixels / navigate.getPixPerWorld();
        Rectangle2D rect = new Rectangle2D.Double(geoSelection.getX(), geoSelection.getY(), geoSelection.getWidth(), geoSelection.getHeight());
        RubberbandRectangleHandles.drawHandledRect(gNP, rect, handleSize);
        if (debug) System.out.println(""GeoRegionChooser.drawHandledRect="" + handleSize + "" = "" + geoSelection);
      }
    }

    for (int i = 0; i < renderers.size(); i++) {
      ucar.nc2.ui.util.Renderer rend = (Renderer) renderers.get(i);
      rend.draw(gNP, atI);
    }
    gNP.dispose();

    if (debug) {
      long tend = System.currentTimeMillis();
      System.out.println(""StationRegionDateChooser draw time = "" + (tend - tstart) / 1000.0 + "" secs"");
    }

    // copy buffer to the screen
    np.repaint();
  }",redraw the station region panel
"@javax.annotation.Nonnull
  public com.simiacryptus.util.data.DoubleStatistics combine(@javax.annotation.Nonnull final com.simiacryptus.util.data.DoubleStatistics other) {
    super.combine(other);
    simpleSumOfSquare += other.simpleSumOfSquare;
    sumOfSquareWithCompensation(other.sumOfSquare);
    sumOfSquareWithCompensation(other.sumOfSquareCompensation);
    return this;
  }",Combine two double statistics.
"@NonNull
    public Intent build() {
        Uri mailtoUri = constructMailtoUri();
        return new Intent(Intent.ACTION_SENDTO, mailtoUri);
    }",Build an Intent to send the SMS to the user.
"@Override
	public RandomVariable getValue(double evaluationTime, AssetModelMonteCarloSimulationModel model) throws CalculationException {
		if(exerciseMethod == ExerciseMethod.UPPER_BOUND_METHOD) {
			// Find optimal lambda
			GoldenSectionSearch optimizer = new GoldenSectionSearch(-1.0, 1.0);
			while(!optimizer.isDone()) {
				double lambda = optimizer.getNextPoint();
				double value = this.getValues(evaluationTime, model, lambda).getAverage();
				optimizer.setValue(value);
			}
			return getValues(evaluationTime, model, optimizer.getBestPoint());
		}
		else {
			return getValues(evaluationTime, model, 0.0);
		}
	}",This method returns the value of the Cashflows model optimizer.
"private <T> Creator<T> register(ConstructorKey key, Constructor<T> constructor, CreationModifier<T> modifier) {

        Creator<T> creator = new ReflectionCreator<T>(constructor);

        if (modifier != null) creator = new ModifiedCreator<T>(creator, modifier);

        return register(key, creator);
    }",Register a new class with the constructor.
"public void set( List<Point2D_F64> list ) {
		vertexes.resize(list.size());
		for (int i = 0; i < list.size(); i++) {
			vertexes.data[i].set( list.get(i));
		}
	}",Sets the list of vertexes to be the same as the input.
"public void setExportIds(java.util.Collection<String> exportIds) {
        if (exportIds == null) {
            this.exportIds = null;
            return;
        }

        this.exportIds = new java.util.ArrayList<String>(exportIds);
    }",Sets the value of the exportIds property.
"public UrlChain moreUrl(Object... urlParts) {
        final String argTitle = ""urlParts"";
        assertArgumentNotNull(argTitle, urlParts);
        checkWrongUrlChainUse(argTitle, urlParts);
        this.urlParts = urlParts;
        return this;
    }",Add more urls to the url chain.
"@Override
    protected void compareData(ITable expectedTable, ITable actualTable, ComparisonColumn[] comparisonCols, FailureHandler failureHandler) throws DataSetException {
        logger.debug(""compareData(expectedTable={}, actualTable={}, ""
                        + ""comparisonCols={}, failureHandler={}) - start"",
                new Object[]{expectedTable, actualTable, comparisonCols,
                        failureHandler});

        if (expectedTable == null) {
            throw new NullPointerException(
                    ""The parameter 'expectedTable' must not be null"");
        }
        if (actualTable == null) {
            throw new NullPointerException(
                    ""The parameter 'actualTable' must not be null"");
        }
        if (comparisonCols == null) {
            throw new NullPointerException(
                    ""The parameter 'comparisonCols' must not be null"");
        }
        if (failureHandler == null) {
            throw new NullPointerException(
                    ""The parameter 'failureHandler' must not be null"");
        }

        // iterate over all rows
        for (int i = 0; i < expectedTable.getRowCount(); i++) {
            // iterate over all columns of the current row
            for (int j = 0; j < comparisonCols.length; j++) {
                ComparisonColumn compareColumn = comparisonCols[j];

                String columnName = compareColumn.getColumnName();
                DataType dataType = compareColumn.getDataType();

                Object expectedValue = expectedTable.getValue(i, columnName);
                Object actualValue = actualTable.getValue(i, columnName);

                // Compare the values
                if (skipCompare(columnName, expectedValue, actualValue)) {
                    if (logger.isTraceEnabled()) {
                        logger.trace(""ignoring comparison "" + expectedValue + ""="" +
                                actualValue + "" on column "" + columnName);
                    }
                    continue;
                }

                if(expectedValue != null && expectedValue.toString().startsWith(""regex:"")){
                    if(!regexMatches(expectedValue.toString(),actualValue.toString())){
                        Difference diff = new Difference(
                                expectedTable, actualTable,
                                i, columnName,
                                expectedValue, actualValue);

                        // Handle the difference (throw error immediately or something else)
                        failureHandler.handle(diff);
                    }
                }
                else if (dataType.compare(expectedValue, actualValue) != 0) {

                    Difference diff = new Difference(
                            expectedTable, actualTable,
                            i, columnName,
                            expectedValue, actualValue);

                    // Handle the difference (throw error immediately or something else)
                    failureHandler.handle(diff);
                }
            }
        }
    }",Compare data.
"public Response addItem( HttpServletRequest request,
                             String repositoryName,
                             String workspaceName,
                             String path,
                             String requestBody ) throws JSONException, RepositoryException {
        JSONObject requestBodyJSON = stringToJSONObject(requestBody);

        String parentAbsPath = parentPath(path);
        String newNodeName = newNodeName(path);

        Session session = getSession(request, repositoryName, workspaceName);
        Node parentNode = (Node)session.getItem(parentAbsPath);
        Node newNode = addNode(parentNode, newNodeName, requestBodyJSON);

        session.save();
        RestItem restNewNode = createRestItem(request, 0, session, newNode);
        return Response.status(Response.Status.CREATED).entity(restNewNode).build();
    }",Add a new item to the cache.
"@Override
    public void warning(String message, String sourceName, int offset, int length)
    {
        errors.add(new ParseProblem(ParseProblem.Type.Warning,
                                    message, sourceName,
                                    offset, length));
    }",Report a warning.
"private void parameterize(Parameterized parameterized) {
		try {
			parameterized.configure(parameters);
		} catch (RuntimeException ex) {
			throw new ProgramParametrizationException(ex.getMessage());
		}
	}",Parameterizes the given parameterized object.
"public void moveResource(CmsDbContext dbc, CmsResource source, String destination, boolean internal)
    throws CmsException {

        CmsFolder destinationFolder = readFolder(dbc, CmsResource.getParentFolder(destination), CmsResourceFilter.ALL);
        m_securityManager.checkPermissions(
            dbc,
            destinationFolder,
            CmsPermissionSet.ACCESS_WRITE,
            false,
            CmsResourceFilter.ALL);

        if (source.isFolder()) {
            m_monitor.flushCache(CmsMemoryMonitor.CacheType.HAS_ROLE, CmsMemoryMonitor.CacheType.ROLE_LIST);
        }
        getVfsDriver(dbc).moveResource(dbc, dbc.getRequestContext().getCurrentProject().getUuid(), source, destination);

        if (!internal) {
            CmsResourceState newState = CmsResource.STATE_CHANGED;
            if (source.getState().isNew()) {
                newState = CmsResource.STATE_NEW;
            } else if (source.getState().isDeleted()) {
                newState = CmsResource.STATE_DELETED;
            }
            source.setState(newState);
            // safe since this operation always uses the ids instead of the resource path
            getVfsDriver(dbc).writeResourceState(
                dbc,
                dbc.currentProject(),
                source,
                CmsDriverManager.UPDATE_STRUCTURE_STATE,
                false);
            // log it
            log(
                dbc,
                new CmsLogEntry(
                    dbc,
                    source.getStructureId(),
                    CmsLogEntryType.RESOURCE_MOVED,
                    new String[] {source.getRootPath(), destination}),
                false);
        }

        CmsResource destRes = readResource(dbc, destination, CmsResourceFilter.ALL);
        // move lock
        m_lockManager.moveResource(source.getRootPath(), destRes.getRootPath());

        // flush all relevant caches
        m_monitor.clearAccessControlListCache();
        m_monitor.flushCache(
            CmsMemoryMonitor.CacheType.PROPERTY,
            CmsMemoryMonitor.CacheType.PROPERTY_LIST,
            CmsMemoryMonitor.CacheType.PROJECT_RESOURCES);

        List<CmsResource> resources = new ArrayList<CmsResource>(4);
        // source
        resources.add(source);
        try {
            resources.add(readFolder(dbc, CmsResource.getParentFolder(source.getRootPath()), CmsResourceFilter.ALL));
        } catch (Exception e) {
            if (LOG.isDebugEnabled()) {
                LOG.debug(e);
            }
        }
        // destination
        resources.add(destRes);
        resources.add(destinationFolder);

        Map<String, Object> eventData = new HashMap<String, Object>();
        eventData.put(I_CmsEventListener.KEY_RESOURCES, resources);
        eventData.put(I_CmsEventListener.KEY_DBCONTEXT, dbc);

        // fire the events
        OpenCms.fireCmsEvent(new CmsEvent(I_CmsEventListener.EVENT_RESOURCE_MOVED, eventData));
    }",Moves a resource from one location to another.
"public List<Object> getClauseValue(String paramString) {
        if (typedParameter != null && typedParameter.getParameters() != null) {
            List<FilterClause> clauses = typedParameter.getParameters().get(paramString);
            if (clauses != null) {
                return clauses.get(0).getValue();
            } else {
                throw new IllegalArgumentException(""parameter is not a parameter of the query"");
            }
        }

        logger.error(""Parameter {} is not a parameter of the query."", paramString);
        throw new IllegalArgumentException(""Parameter is not a parameter of the query."");
    }",Gets the clause value for the parameter.
"public ClientStatsContext fetch() {
        m_current = m_distributor.getStatsSnapshot();
        m_currentIO = m_distributor.getIOStatsSnapshot();
        m_currentTS = System.currentTimeMillis();
        m_currentAffinity = m_distributor.getAffinityStatsSnapshot();
        return this;
    }",Fetch the client stats from the cache.
"public DeleteVpcEndpointServiceConfigurationsRequest withServiceIds(String... serviceIds) {
        if (this.serviceIds == null) {
            setServiceIds(new com.amazonaws.internal.SdkInternalList<String>(serviceIds.length));
        }
        for (String ele : serviceIds) {
            this.serviceIds.add(ele);
        }
        return this;
    }",Sets the value of the serviceIds property.
"protected void initializeClient(JestClient client, String indexName, String defaultIndexName) {
        try {
            client.execute(new Health.Builder().build());
            Action<JestResult> action = new IndicesExists.Builder(indexName).build();
            // There was occasions where a race occurred here when multiple threads try to
            // create the index simultaneously. This caused a non-fatal, but annoying, exception.
            synchronized(AbstractClientFactory.class) {
                JestResult result = client.execute(action);
                if (!result.isSucceeded()) {
                    createIndex(client, indexName, defaultIndexName + ""-settings.json""); //$NON-NLS-1$
                }
            }
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }",Initialize the client.
"public final static double roundToDecimals(double d, int c) {
		if(c < 0) return d;
		double p = Math.pow(10,c);
		d = d * p;
		double tmp = Math.round(d);
		return tmp/p;
	}",Round to decimals.
"private static boolean incrementLexicographically(
        MutableLongTuple current, LongTuple min, LongTuple max, int index)
    {
        if (index == -1)
        {
            return false;
        }
        long oldValue = current.get(index);
        long newValue = oldValue + 1;
        current.set(index, newValue);
        if (newValue >= max.get(index))
        {
            current.set(index, min.get(index));
            return incrementLexicographically(current, min, max, index-1);
        }
        return true;
    }",Increments the value of the Nth entry in the MutableLongTuple by one and increments the value of the Nth entry in the MutableLongTuple.
"public static <T> PVectorByteBufferedIntegral2s64<T> createWithBase(
    final ByteBuffer b,
    final MutableLongType base,
    final int offset)
  {
    return new PVectorByteBufferedIntegral2s64<>(b, base, offset);
  }",Creates a new PVectorByteBufferedIntegral2s64 object with the given ByteBuffer and MutableLongType base and offset.
"public T loadXml(String locationUrl) {

    DataResource resource = this.resourceFactory.createDataResource(locationUrl);
    return loadXml(resource);
  }",Load a CID    from a XML file.
"@Override
  public char[] transformIn(String inStr) throws CpoException {
    char[] retChars = null;

    if (inStr != null) {
      retChars = inStr.toCharArray();
    }

    return retChars;
  }",Transform in.
"public int executeUpdate() throws SQLException {
        return executeUpdate(new Updater() {
            
            @Override
            public int executeUpdate(final Statement statement, final String sql) throws SQLException {
                return statement.executeUpdate(sql);
            }
        });
    }",Execute an SQL update.
"public com.google.appengine.v1.UrlMap getHandlers(int index) {
    return handlers_.get(index);
  }",Gets the handlers at the given index.
"@XmlElementDecl(namespace = """", name = ""stp_duplex"")
    public JAXBElement<Stellplatz> createStpDuplex(Stellplatz value) {
        return new JAXBElement<Stellplatz>(_StpDuplex_QNAME, Stellplatz.class, null, value);
    }",Create an instance of a Stellplatz in the CTC namespace.
"public void changeFile(File file) throws FileNotFoundException {
        if (isTailing()) {
            throw new IllegalStateException(""Cannot Change FileTailer.file while current instance is tailing"");
        } else {
            if (file == null) {
                throw new NullPointerException(""changeFile(File argument) cannot be null"");
            } else if (!file.exists()) {
                throw new FileNotFoundException(""File does not exist: "" + file.getAbsolutePath());
            }
            this.file = file;
        }
    }",Changes the file of the file tailer.
"public void addFilter(final ItemFilter filter) {
        if (filters == null) {
            filters = new ArrayList<ItemFilter>();
        }

        filters.add(filter);
    }",Add a filter to the list of filters.
"public DynamicImageField<T> addDynamicImageField(int viewResId, StringExtractor<T> extractor,
                                                     DynamicImageLoader dynamicImageLoader) {

        DynamicImageField<T> field =
                new DynamicImageField<T>(viewResId, extractor, dynamicImageLoader);

        mDynamicImageFields.add(field);

        return field;
    }",Add a dynamic image field to the list of dynamic image fields.
"public void setBinding(String binding) 
        throws JspException {
        if (binding!= null && !UIComponentTag.isValueReference(binding)) {
            // PENDING i18n
            throw new JspException(""Invalid Expression:""+binding);
        }
        this.binding = binding;
    }",Sets the binding for this tag.
"protected void commitResponse(final SecurityContext securityContext, final HttpServletRequest request, final HttpServletResponse response, final RestMethodResult result, final boolean wrapSingleResultInArray) {

		final String outputDepthSrc       = request.getParameter(REQUEST_PARAMTER_OUTPUT_DEPTH);
		final int outputDepth             = Services.parseInt(outputDepthSrc, config.getOutputNestingDepth());
		final String baseUrl              = request.getRequestURI();
		final Map<String, String> headers = result.getHeaders();

		// set headers
		for (final Entry<String, String> header : headers.entrySet()) {
			response.setHeader(header.getKey(), header.getValue());
		}

		// set  response code
		response.setStatus(result.getResponseCode());

		try {

			final List<Object> content = result.getContent();
			if (content != null) {

				writeJson(securityContext, response, new PagingIterable(content), baseUrl, outputDepth, wrapSingleResultInArray);

			} else {

				final String message = result.getMessage();
				if (message != null) {

					writeStatus(response, result.getResponseCode(), message);

				} else {

					final Object nonGraphObjectResult = result.getNonGraphObjectResult();
					writeJson(securityContext, response, new PagingIterable(Arrays.asList(nonGraphObjectResult)), baseUrl, outputDepth, wrapSingleResultInArray);
				}

			}

		} catch (JsonIOException | IOException t) {

			logger.warn(""Unable to commit HttpServletResponse"", t);
		}
	}",Commit the response.
"public final void mT__141() throws RecognitionException {
        try {
            int _type = T__141;
            int _channel = DEFAULT_TOKEN_CHANNEL;
            // InternalSARL.g:127:8: ( 'finally' )
            // InternalSARL.g:127:10: 'finally'
            {
            match(""finally""); 


            }

            state.type = _type;
            state.channel = _channel;
        }
        finally {
        }
    }",start T__141
"public final Ix<T> skipWhile(IxPredicate<? super T> predicate) {
        return new IxSkipWhile<T>(this, nullCheck(predicate, ""predicate is null""));
    }",Creates an IxSkipWhile sequence that iterates over the elements of this sequence which are not skipped by the given predicate.
"public static <T, U> Function<T, U> memoize(final Function<T, U> function) {
    return new Memoizer<T, U>().doMemoize(function);
  }",Memoize a function.
"public T xpath(String expression, String value) {
        if (xpathMessageConstructionInterceptor == null) {
            xpathMessageConstructionInterceptor = new XpathMessageConstructionInterceptor();

            if (getAction().getMessageBuilder() != null) {
                (getAction().getMessageBuilder()).add(xpathMessageConstructionInterceptor);
            } else {
                PayloadTemplateMessageBuilder messageBuilder = new PayloadTemplateMessageBuilder();
                messageBuilder.getMessageInterceptors().add(xpathMessageConstructionInterceptor);

                getAction().setMessageBuilder(messageBuilder);
            }
        }

        xpathMessageConstructionInterceptor.getXPathExpressions().put(expression, value);
        return self;
    }",Adds an XPath expression to the message builder.
"public Iterable<DConnection> queryByUpdatedBy(java.lang.String updatedBy) {
    return queryByField(null, DConnectionMapper.Field.UPDATEDBY.getFieldName(), updatedBy);
  }",query - by method for field updatedBy
"Description validate(Tree tree, VisitorState state) {
    GuardedByValidationResult result = GuardedByUtils.isGuardedByValid(tree, state);
    if (result.isValid()) {
      return Description.NO_MATCH;
    }
    return buildDescription(tree)
        .setMessage(String.format(""Invalid @GuardedBy expression: %s"", result.message()))
        .build();
  }",Validate a GuardedBy expression.
"public Table getTable(String tableName) {
    // [START ]
    Table table = dataset.get(tableName);
    // [END ]
    return table;
  }",Get a table from the dataset.
"private CmsADEConfigData getConfigData(String pageRootPath) {

        if (m_configData == null) {
            m_configData = OpenCms.getADEManager().lookupConfiguration(getCmsObject(), pageRootPath);
        }
        return m_configData;
    }",Gets the configuration data.
"public static File getOwnCacheDirectory(Context context, String cacheDir) {
		File appCacheDir = null;
		if (MEDIA_MOUNTED.equals(Environment.getExternalStorageState()) && hasExternalStoragePermission(context)) {
			appCacheDir = new File(Environment.getExternalStorageDirectory(), cacheDir);
		}
		if (appCacheDir == null || (!appCacheDir.exists() && !appCacheDir.mkdirs())) {
			appCacheDir = context.getCacheDir();
		}
		return appCacheDir;
	}",Get the cache directory that is owned by the current user.
"public void marshall(SamplingRuleRecord samplingRuleRecord, ProtocolMarshaller protocolMarshaller) {

        if (samplingRuleRecord == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(samplingRuleRecord.getSamplingRule(), SAMPLINGRULE_BINDING);
            protocolMarshaller.marshall(samplingRuleRecord.getCreatedAt(), CREATEDAT_BINDING);
            protocolMarshaller.marshall(samplingRuleRecord.getModifiedAt(), MODIFIEDAT_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given samplingRuleRecord to the JSON object.
"protected static String getFirstSpecifiedKeyID(final JWKMatcher jwkMatcher) {

		Set<String> keyIDs = jwkMatcher.getKeyIDs();

		if (keyIDs == null || keyIDs.isEmpty()) {
			return null;
		}

		for (String id: keyIDs) {
			if (id != null) {
				return id;
			}
		}
		return null; // No kid in matcher
	}",Gets the first specified kid in the JWKMatcher.
"public void log(LogLevel level, String msg, Throwable t)
	{
		if (level != LogLevel.OFF && level.level <= logLevel.level)
			logger.add(writers, name, level, msg, t);
	}",Add a message to the logger.
"private String getEmailAddresses() {

        List<String> emails = new ArrayList<String>();
        Iterator<String> itIds = idsList().iterator();
        while (itIds.hasNext()) {
            String id = itIds.next();
            CmsSessionInfo session = OpenCms.getSessionManager().getSessionInfo(id);
            if (session != null) {
                try {
                    String emailAddress = getCms().readUser(session.getUserId()).getEmail();
                    if (CmsStringUtil.isNotEmptyOrWhitespaceOnly(emailAddress) && !emails.contains(emailAddress)) {
                        emails.add(emailAddress);
                    }
                } catch (Exception e) {
                    LOG.error(e.getLocalizedMessage(), e);
                }
            }
        }
        StringBuffer result = new StringBuffer(256);
        Iterator<String> itEmails = emails.iterator();
        while (itEmails.hasNext()) {
            result.append(itEmails.next());
            if (itEmails.hasNext()) {
                result.append(""; "");
            }
        }
        return result.toString();
    }",Returns the list of email addresses for all the session ids.
"public static long delayResponse() {
    Call call = CurCall.get();
    long res = 0;
    if (call != null) {
      call.delayResponse();
      res = delayedRpcId.getAndIncrement();
      delayedCalls.put(res, call);
    }
    return res;
  }",Delay the response.
"public <T> T safeGet(String fieldName){
		try {
			return get(fieldName);
		} catch (Exception e) {
			return null;
		}
	}",Get a field from the underlying resource.
"@XmlElementDecl(namespace = """", name = ""anzahl_badezimmer"")
    @XmlJavaTypeAdapter(Adapter2 .class)
    public JAXBElement<BigDecimal> createAnzahlBadezimmer(BigDecimal value) {
        return new JAXBElement<BigDecimal>(_AnzahlBadezimmer_QNAME, BigDecimal.class, null, value);
    }",Create an instance of an AnzahlBadezimmer in einen Tagen der angegebenen Badezimmer.
"protected void readHeader(ByteBuffer buffer) {
    super.readHeader(buffer);
    if (this.responseStatus == ResponseStatus.NO_ERROR) {
      this.decodeStatus = BinaryDecodeStatus.DONE;
    }
  }",readHeader This method is called to read the header of the response.
"@Override
    public UpdateXssMatchSetResult updateXssMatchSet(UpdateXssMatchSetRequest request) {
        request = beforeClientExecution(request);
        return executeUpdateXssMatchSet(request);
    }",Updates an XSSMatchSet.
"private static void verifyAncestry(Class<?> tClass) {
    if (!TBase.class.isAssignableFrom(tClass)) {
      Utils.ensureClassLoaderConsistency(TBase.class, tClass.getClassLoader());
      throw new ClassCastException(tClass.getName() + "" is not a Thrift class"");
    }
  }",Verify that the given class is a Thrift class.
"public static InstrumentedThreadFactory defaultThreadFactory(MetricRegistry registry, String name) {
        return new InstrumentedThreadFactory(Executors.defaultThreadFactory(), registry, name);
    }",Create a thread factory that uses the default thread factory.
"public AbucoinsOrderBook getAbucoinsOrderBook(String productID, AbucoinsOrderBookLevel level)
      throws IOException {
    return abucoins.getBook(productID, level.name());
  }",Get a Book object from a product ID and level
"static boolean isSignatureAssignable( Class[] from, Class[] to, int round )
    {
        if ( round != JAVA_VARARGS_ASSIGNABLE && from.length != to.length )
            return false;

        switch ( round )
        {
            case JAVA_BASE_ASSIGNABLE:
                for( int i=0; i<from.length; i++ )
                    if ( !isJavaBaseAssignable( to[i], from[i] ) )
                        return false;
                return true;
            case JAVA_BOX_TYPES_ASSIGABLE:
                for( int i=0; i<from.length; i++ )
                    if ( !isJavaBoxTypesAssignable( to[i], from[i] ) )
                        return false;
                return true;
            case JAVA_VARARGS_ASSIGNABLE:
                return isSignatureVarargsAssignable( from, to );
            case BSH_ASSIGNABLE:
                for( int i=0; i<from.length; i++ )
                    if ( !isBshAssignable( to[i], from[i] ) )
                        return false;
                return true;
            default:
                throw new InterpreterError(""bad case"");
        }
    }",Checks if the signature is assignable.
"public void start() {
        application = new CitrusRemoteApplication(configuration);
        port(configuration.getPort());
        application.init();

        if (!configuration.isSkipTests()) {
            new RunController(configuration).run();
        }

        if (configuration.getTimeToLive() == 0) {
            stop();
        }
    }",Start the application.
"private CmsInternalLinksValidator getValidator() {

        if (m_validator == null) {
            // get the content check result object
            Map objects = (Map)getSettings().getDialogObject();
            Object o = objects.get(CmsInternalLinkValidationDialog.class.getName());
            List resources = new ArrayList();
            if ((o != null) && (o instanceof List)) {
                resources = (List)o;
            }
            m_validator = new CmsInternalLinksValidator(getCms(), resources);
        }
        return m_validator;
    }",Gets the internal links validator.
"public static SqlExpressionGroup exps(String name, String op, Object value) {
        return exps(exp(name, op, value));
    }",Returns an ExpressionGroup representing a single Identity class expression.
"public static ClassFile buildClassFile(String className, Class<?>[] classes)
        throws IllegalArgumentException
    {
        return buildClassFile(className, classes, null, null, OBSERVER_DISABLED);
    }",Build a ClassFile from a class name and a list of classes.
"public static Document readXML(Reader reader) throws IOException, SAXException, ParserConfigurationException {
		assert reader != null : AssertMessages.notNullParameter();
		try {
			final DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
			final DocumentBuilder builder = factory.newDocumentBuilder();
			return builder.parse(new InputSource(reader));
		} finally {
			reader.close();
		}
	}",Read XML from a reader.
"public static clusternodegroup_nslimitidentifier_binding[] get(nitro_service service, String name) throws Exception{
		clusternodegroup_nslimitidentifier_binding obj = new clusternodegroup_nslimitidentifier_binding();
		obj.set_name(name);
		clusternodegroup_nslimitidentifier_binding response[] = (clusternodegroup_nslimitidentifier_binding[]) obj.get_resources(service);
		return response;
	}",Use this API to fetch clusternodegroup_nslimitidentifier_binding resources of given name.
"protected final List<DCSubject> parseSubjects(final List<Element> eList) {

        final List<DCSubject> subjects = new ArrayList<DCSubject>();

        for (final Element eSubject : eList) {

            final Element description = eSubject.getChild(""Description"", getRDFNamespace());

            if (description != null) {

                final String taxonomy = getTaxonomy(description);

                final List<Element> values = description.getChildren(""value"", getRDFNamespace());
                for (final Element value : values) {

                    final DCSubject subject = new DCSubjectImpl();
                    subject.setTaxonomyUri(taxonomy);
                    subject.setValue(value.getText());
                    subjects.add(subject);

                }

            } else {
                final DCSubject subject = new DCSubjectImpl();
                subject.setValue(eSubject.getText());
                subjects.add(subject);
            }
        }

        return subjects;
    }",Parses the Subjects.
"public static INDArrayIndex[] createCoveringShape(int[] shape) {
        INDArrayIndex[] ret = new INDArrayIndex[shape.length];
        for (int i = 0; i < ret.length; i++) {
            ret[i] = NDArrayIndex.interval(0, shape[i]);
        }
        return ret;
    }",Create covering shape
"public WritableGridFileChannel getWritableChannel(String pathname, boolean append, int chunkSize) throws IOException {
      GridFile file = (GridFile) getFile(pathname, chunkSize);
      checkIsNotDirectory(file);
      createIfNeeded(file);
      return new WritableGridFileChannel(file, data, append);
   }",Get a WritableGridFileChannel for a file.
"public JobExecutionStatusDetails withDetailsMap(java.util.Map<String, String> detailsMap) {
        setDetailsMap(detailsMap);
        return this;
    }",Sets the map of job status details to be used in the execution.
"@Override
    public void dereferenceConsumerManager()
    {
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.entry(tc, ""dereferenceConsumerManager"");
        setOutputHandler(null);
        if (TraceComponent.isAnyTracingEnabled() && tc.isEntryEnabled())
            SibTr.exit(tc, ""dereferenceConsumerManager"");
    }",Dereference the Consumer Manager object.
"private BufferedImage rasterizeConvoLayers(@NonNull List<INDArray> tensors3D, BufferedImage sourceImage) {
        long width = 0;
        long height = 0;

        int border = 1;
        int padding_row = 2;
        int padding_col = 80;

        /*
            We determine height of joint output image. We assume that first position holds maximum dimensionality
         */
        val shape = tensors3D.get(0).shape();
        val numImages = shape[0];
        height = (shape[2]);
        width = (shape[1]);
        //        log.info(""Output image dimensions: {height: "" + height + "", width: "" + width + ""}"");
        int maxHeight = 0; //(height + (border * 2 ) + padding_row) * numImages;
        int totalWidth = 0;
        int iOffset = 1;

        Orientation orientation = Orientation.LANDSCAPE;
        /*
            for debug purposes we'll use portait only now
         */
        if (tensors3D.size() > 3) {
            orientation = Orientation.PORTRAIT;
        }



        List<BufferedImage> images = new ArrayList<>();
        for (int layer = 0; layer < tensors3D.size(); layer++) {
            INDArray tad = tensors3D.get(layer);
            int zoomed = 0;

            BufferedImage image = null;
            if (orientation == Orientation.LANDSCAPE) {
                maxHeight = (int) ((height + (border * 2) + padding_row) * numImages);
                image = renderMultipleImagesLandscape(tad, maxHeight, (int) width, (int) height);
                totalWidth += image.getWidth() + padding_col;
            } else if (orientation == Orientation.PORTRAIT) {
                totalWidth = (int) ((width + (border * 2) + padding_row) * numImages);
                image = renderMultipleImagesPortrait(tad, totalWidth, (int) width, (int) height);
                maxHeight += image.getHeight() + padding_col;
            }

            images.add(image);
        }

        if (orientation == Orientation.LANDSCAPE) {
            // append some space for arrows
            totalWidth += padding_col * 2;
        } else if (orientation == Orientation.PORTRAIT) {
            maxHeight += padding_col * 2;
            maxHeight += sourceImage.getHeight() + (padding_col * 2);
        }

        BufferedImage output = new BufferedImage(totalWidth, maxHeight, BufferedImage.TYPE_INT_RGB);
        Graphics2D graphics2D = output.createGraphics();

        graphics2D.setPaint(bgColor);
        graphics2D.fillRect(0, 0, output.getWidth(), output.getHeight());

        BufferedImage singleArrow = null;
        BufferedImage multipleArrows = null;

        /*
            We try to add nice flow arrow here
         */
        try {

            if (orientation == Orientation.LANDSCAPE) {
                try {
                    ClassPathResource resource = new ClassPathResource(""arrow_sing.PNG"");
                    ClassPathResource resource2 = new ClassPathResource(""arrow_mul.PNG"");

                    singleArrow = ImageIO.read(resource.getInputStream());
                    multipleArrows = ImageIO.read(resource2.getInputStream());
                } catch (Exception e) {
                }

                graphics2D.drawImage(sourceImage, (padding_col / 2) - (sourceImage.getWidth() / 2),
                                (maxHeight / 2) - (sourceImage.getHeight() / 2), null);

                graphics2D.setPaint(borderColor);
                graphics2D.drawRect((padding_col / 2) - (sourceImage.getWidth() / 2),
                                (maxHeight / 2) - (sourceImage.getHeight() / 2), sourceImage.getWidth(),
                                sourceImage.getHeight());

                iOffset += sourceImage.getWidth();

                if (singleArrow != null)
                    graphics2D.drawImage(singleArrow, iOffset + (padding_col / 2) - (singleArrow.getWidth() / 2),
                                    (maxHeight / 2) - (singleArrow.getHeight() / 2), null);
            } else {
                try {
                    ClassPathResource resource = new ClassPathResource(""arrow_singi.PNG"");
                    ClassPathResource resource2 = new ClassPathResource(""arrow_muli.PNG"");

                    singleArrow = ImageIO.read(resource.getInputStream());
                    multipleArrows = ImageIO.read(resource2.getInputStream());
                } catch (Exception e) {
                }

                graphics2D.drawImage(sourceImage, (totalWidth / 2) - (sourceImage.getWidth() / 2),
                                (padding_col / 2) - (sourceImage.getHeight() / 2), null);

                graphics2D.setPaint(borderColor);
                graphics2D.drawRect((totalWidth / 2) - (sourceImage.getWidth() / 2),
                                (padding_col / 2) - (sourceImage.getHeight() / 2), sourceImage.getWidth(),
                                sourceImage.getHeight());

                iOffset += sourceImage.getHeight();
                if (singleArrow != null)
                    graphics2D.drawImage(singleArrow, (totalWidth / 2) - (singleArrow.getWidth() / 2),
                                    iOffset + (padding_col / 2) - (singleArrow.getHeight() / 2), null);

            }
            iOffset += padding_col;
        } catch (Exception e) {
            // if we can't load images - ignore them
        }



        /*
            now we merge all images into one big image with some offset
        */


        for (int i = 0; i < images.size(); i++) {
            BufferedImage curImage = images.get(i);
            if (orientation == Orientation.LANDSCAPE) {
                // image grows from left to right
                graphics2D.drawImage(curImage, iOffset, 1, null);
                iOffset += curImage.getWidth() + padding_col;

                if (singleArrow != null && multipleArrows != null) {
                    if (i < images.size() - 1) {
                        // draw multiple arrows here
                        if (multipleArrows != null)
                            graphics2D.drawImage(multipleArrows,
                                            iOffset - (padding_col / 2) - (multipleArrows.getWidth() / 2),
                                            (maxHeight / 2) - (multipleArrows.getHeight() / 2), null);
                    } else {
                        // draw single arrow
                        //    graphics2D.drawImage(singleArrow, iOffset - (padding_col / 2) - (singleArrow.getWidth() / 2), (maxHeight / 2) - (singleArrow.getHeight() / 2), null);
                    }
                }
            } else if (orientation == Orientation.PORTRAIT) {
                // image grows from top to bottom
                graphics2D.drawImage(curImage, 1, iOffset, null);
                iOffset += curImage.getHeight() + padding_col;

                if (singleArrow != null && multipleArrows != null) {
                    if (i < images.size() - 1) {
                        // draw multiple arrows here
                        if (multipleArrows != null)
                            graphics2D.drawImage(multipleArrows, (totalWidth / 2) - (multipleArrows.getWidth() / 2),
                                            iOffset - (padding_col / 2) - (multipleArrows.getHeight() / 2), null);
                    } else {
                        // draw single arrow
                        //   graphics2D.drawImage(singleArrow, (totalWidth / 2) - (singleArrow.getWidth() / 2),  iOffset - (padding_col / 2) - (singleArrow.getHeight() / 2) , null);
                    }
                }
            }
        }

        return output;
    }",rasterizeConvoLayers This method is used to rasterize the input image for the Convo layers
"public OperationStatus updateSettings(UUID appId, UpdateSettingsOptionalParameter updateSettingsOptionalParameter) {
        return updateSettingsWithServiceResponseAsync(appId, updateSettingsOptionalParameter).toBlocking().single().body();
    }",Updates the application settings.
"public synchronized StorableProperties put(String key, Object val) {
        if (!key.equals(toLowerCase(key)))
            throw new IllegalArgumentException(""Do not use upper case keys ("" + key + "") for StorableProperties since 0.7"");

        map.put(key, val.toString());
        return this;
    }",Puts a value into the cache.
"public static ReportedData getReportedDataFrom(Stanza packet) {
        // Check if the packet includes the DataForm extension
        DataForm dataForm = DataForm.from(packet);
        if (dataForm != null) {
            if (dataForm.getReportedData() != null)
                return new ReportedData(dataForm);
        }
        // Otherwise return null
        return null;
    }",Get the ReportedData from the given stanza.
"protected final void registerSession( AbstractSession sessionToAdd )
    {
    	if (sessions.put(sessionToAdd.getId(),sessionToAdd) != null)
    		throw new IllegalArgumentException(""Session ""+sessionToAdd.getId()+"" already exists"");
    }",Register a session.
"public static byte[] readRAM(final File f) throws IOException {
    final int total = (int) f.length();
    final byte[] ret = new byte[total];
    final InputStream in = new FileInputStream(f);
    try {
      int offset = 0;
      int read = 0;
      do {
        read = in.read(ret, offset, total - read);
        if (read > 0) {
          offset += read;
        }
      } while ((read != -1) && (offset != total));
      return ret;
    } finally {
      in.close();
    }
  }",Read a CRAM file.
"void writeTransactionIdFile(StorageDirectory sd, long txid) throws IOException {
    if (txid < -1) {
      // -1 is valid when formatting
      throw new IOException(""Bad txid: "" + txid);
    }
    File txIdFile = getStorageFile(sd, NameNodeFile.SEEN_TXID);
    OutputStream fos = new AtomicFileOutputStream(txIdFile);
    try {
      fos.write(String.valueOf(txid).getBytes());
      fos.write('\n');
      fos.close();
      fos = null;
    } finally {
      IOUtils.cleanup(LOG, fos);
    }
  }",Write a txid file to the storage directory.
"@Override
	public void setMedial2(double x, double y, double z) {
		this.medial2.set(x, y, z);
		ensureAIsLowerPoint();
	}",Sets the median 2 coordinate.
"private static Class<?> parameterizedReturnType(Method method) {
    Type type = method.getGenericReturnType();
    if (type instanceof ParameterizedType) {
      try {
        return Class.forName(
            (((ParameterizedType) type).getActualTypeArguments()[0]).getTypeName());
      } catch (ClassNotFoundException e) {
        return Object.class;
      }
    } else {
      return Object.class;
    }
  }",Get the parameterized return type of a method.
"public XMLResource xml(URI anUri, AbstractContent requestContent) throws IOException {
		return doPOSTOrPUT(anUri, requestContent, createXMLResource());
	}",Performs an HTTP POST or PUT request to the specified URI and returns the XML resource.
"protected Dependency createDependency(Dependency dependency, String name, String version, String scope) {
        final Dependency nodeModule = new Dependency(new File(dependency.getActualFile() + ""?"" + name), true);
        nodeModule.setEcosystem(NPM_DEPENDENCY_ECOSYSTEM);
        //this is virtual - the sha1 is purely for the hyperlink in the final html report
        nodeModule.setSha1sum(Checksum.getSHA1Checksum(String.format(""%s:%s"", name, version)));
        nodeModule.setSha256sum(Checksum.getSHA256Checksum(String.format(""%s:%s"", name, version)));
        nodeModule.setMd5sum(Checksum.getMD5Checksum(String.format(""%s:%s"", name, version)));
        nodeModule.addEvidence(EvidenceType.PRODUCT, ""package.json"", ""name"", name, Confidence.HIGHEST);
        nodeModule.addEvidence(EvidenceType.VENDOR, ""package.json"", ""name"", name, Confidence.HIGH);
        if (!StringUtils.isBlank(version)) {
            nodeModule.addEvidence(EvidenceType.VERSION, ""package.json"", ""version"", version, Confidence.HIGHEST);
            nodeModule.setVersion(version);
        }
        if (dependency.getName() != null) {
            nodeModule.addProjectReference(dependency.getName() + "": "" + scope);
        } else {
            nodeModule.addProjectReference(dependency.getDisplayFileName() + "": "" + scope);
        }
        nodeModule.setName(name);

        //TODO  - we can likely create a valid CPE as a low confidence guess using cpe:2.3:a:[name]_project:[name]:[version]
        //(and add a targetSw of npm/node)
        Identifier id;
        try {
            final PackageURL purl = PackageURLBuilder.aPackageURL().withType(StandardTypes.NPM)
                    .withName(name).withVersion(version).build();
            id = new PurlIdentifier(purl, Confidence.HIGHEST);
        } catch (MalformedPackageURLException ex) {
            LOGGER.debug(""Unable to generate Purl - using a generic identifier instead "" + ex.getMessage());
            id = new GenericIdentifier(String.format(""npm:%s@%s"", dependency.getName(), version), Confidence.HIGHEST);
        }
        nodeModule.addSoftwareIdentifier(id);
        return nodeModule;
    }",Create a dependency object.
"public String buildPreparedStatementName() {
		if (!StringUtils.hasText(preparedStatementName)) {
			preparedStatementName = getParent().buildPreparedStatementName(getName());
		}
		return preparedStatementName;
	}",Build the name of the prepared statement.
"public Observable<PublicIPAddressInner> createOrUpdateAsync(String resourceGroupName, String publicIpAddressName, PublicIPAddressInner parameters) {
        return createOrUpdateWithServiceResponseAsync(resourceGroupName, publicIpAddressName, parameters).map(new Func1<ServiceResponse<PublicIPAddressInner>, PublicIPAddressInner>() {
            @Override
            public PublicIPAddressInner call(ServiceResponse<PublicIPAddressInner> response) {
                return response.body();
            }
        });
    }",Creates or updates an IP address.
"public static String getPippoVersion() {
        // and the key inside the properties file.
        String pippoVersionPropertyKey = ""pippo.version"";

        String pippoVersion;

        try {
            Properties prop = new Properties();
            URL url = ClasspathUtils.locateOnClasspath(PippoConstants.LOCATION_OF_PIPPO_BUILTIN_PROPERTIES);
            InputStream stream = url.openStream();
            prop.load(stream);

            pippoVersion = prop.getProperty(pippoVersionPropertyKey);
        } catch (Exception e) {
            //this should not happen. Never.
            throw new PippoRuntimeException(""Something is wrong with your build. Cannot find resource {}"",
                PippoConstants.LOCATION_OF_PIPPO_BUILTIN_PROPERTIES);
        }

        return pippoVersion;
    }",Get the pippo version from the properties file.
"@Override
    public Page<Country> nextPage(final Page<Country> page, 
                                  final TwilioRestClient client) {
        Request request = new Request(
            HttpMethod.GET,
            page.getNextPageUrl(
                Domains.VOICE.toString(),
                client.getRegion()
            )
        );
        return pageForRequest(client, request);
    }",This method is used to retrieve the next page of a CDNA language.
"public Boolean getAndDecryptBoolean(String name, String providerName) throws Exception {
        return (Boolean) getAndDecrypt(name, providerName);
    }",Get a Boolean object from the cache.
"public void setAlertChannels(Collection<AlertChannel> channels)
    {
        for(AlertChannel channel : channels)
        {
            // Add the channel to any policies it is associated with
            List<Long> policyIds = channel.getLinks().getPolicyIds();
            for(long policyId : policyIds)
            {
                AlertPolicy policy = policies.get(policyId);
                if(policy != null)
                    alertChannels(policyId).add(channel);
                else
                    logger.severe(String.format(""Unable to find policy for channel '%s': %d"", channel.getName(), policyId));
            }
        }
    }",Sets the alert channels.
"@Deprecated
  public static URI getPath(String bucketName, String objectName) {
    return LEGACY_PATH_CODEC.getPath(
        bucketName, objectName, false /* do not allow empty object */);
  }",Get the path of the object in the given bucket.
"public static URI getRootUri(final Archive<?> archive) throws IllegalArgumentException {
        if (archive == null) {
            throw new IllegalArgumentException(""Archive must be specified"");
        }
        final StringBuilder sb = new StringBuilder();
        sb.append(PROTOCOL);
        sb.append(URI_PROTOCOL_SUFFIX);
        sb.append(archive.getId());
        sb.append('/');
        final URI uri = URI.create(sb.toString());
        return uri;
    }",Gets the root URI of the CRA.
"public void init()
            throws ServletException
    {
        org.slf4j.Logger logServerStartup = org.slf4j.LoggerFactory.getLogger(""serverStartup"");
        logServerStartup.info(getClass().getName() + "" initialization start"");
        try {
            System.setProperty(""file.encoding"", ""UTF-8"");
            Field charset = Charset.class.getDeclaredField(""defaultCharset"");
            charset.setAccessible(true);
            charset.set(null, null);
            initialize();
        } catch (Exception e) {
            throw new ServletException(e);
        }
    }",Initialize the application.
"@Override
    public void storeTrigger(OperableTrigger trigger, boolean replaceExisting, JedisCluster jedis) throws JobPersistenceException {
        final String triggerHashKey = redisSchema.triggerHashKey(trigger.getKey());
        final String triggerGroupSetKey = redisSchema.triggerGroupSetKey(trigger.getKey());
        final String jobTriggerSetKey = redisSchema.jobTriggersSetKey(trigger.getJobKey());

        if (!(trigger instanceof SimpleTrigger) && !(trigger instanceof CronTrigger)) {
            throw new UnsupportedOperationException(""Only SimpleTrigger and CronTrigger are supported."");
        }
        final boolean exists = jedis.exists(triggerHashKey);
        if (exists && !replaceExisting) {
            throw new ObjectAlreadyExistsException(trigger);
        }

        Map<String, String> triggerMap = mapper.convertValue(trigger, new TypeReference<HashMap<String, String>>() {
        });
        triggerMap.put(TRIGGER_CLASS, trigger.getClass().getName());

        jedis.hmset(triggerHashKey, triggerMap);
        jedis.sadd(redisSchema.triggersSet(), triggerHashKey);
        jedis.sadd(redisSchema.triggerGroupsSet(), triggerGroupSetKey);
        jedis.sadd(triggerGroupSetKey, triggerHashKey);
        jedis.sadd(jobTriggerSetKey, triggerHashKey);
        if (trigger.getCalendarName() != null && !trigger.getCalendarName().isEmpty()) {
            final String calendarTriggersSetKey = redisSchema.calendarTriggersSetKey(trigger.getCalendarName());
            jedis.sadd(calendarTriggersSetKey, triggerHashKey);
        }
        if (trigger.getJobDataMap() != null && !trigger.getJobDataMap().isEmpty()) {
            final String triggerDataMapHashKey = redisSchema.triggerDataMapHashKey(trigger.getKey());
            jedis.hmset(triggerDataMapHashKey, getStringDataMap(trigger.getJobDataMap()));
        }

        if (exists) {
            // We're overwriting a previously stored instance of this trigger, so clear any existing trigger state.
            unsetTriggerState(triggerHashKey, jedis);
        }

        Boolean triggerPausedResponse = jedis.sismember(redisSchema.pausedTriggerGroupsSet(), triggerGroupSetKey);
        Boolean jobPausedResponse = jedis.sismember(redisSchema.pausedJobGroupsSet(), redisSchema.jobGroupSetKey(trigger.getJobKey()));

        if (triggerPausedResponse || jobPausedResponse) {
            final long nextFireTime = trigger.getNextFireTime() != null ? trigger.getNextFireTime().getTime() : -1;
            final String jobHashKey = redisSchema.jobHashKey(trigger.getJobKey());
            if (isBlockedJob(jobHashKey, jedis)) {
                setTriggerState(RedisTriggerState.PAUSED_BLOCKED, (double) nextFireTime, triggerHashKey, jedis);
            } else {
                setTriggerState(RedisTriggerState.PAUSED, (double) nextFireTime, triggerHashKey, jedis);
            }
        } else if (trigger.getNextFireTime() != null) {
            setTriggerState(RedisTriggerState.WAITING, (double) trigger.getNextFireTime().getTime(), triggerHashKey, jedis);
        }
    }",Store a trigger in Redis
"protected String getQueryFor(final String key) {
        log.trace(""Trying to get query for {} "", key);
        String query = queries.get(key);
        log.trace(""Query found {} for key {}"", query, key);
        if (query == null) {
            log.error(""Query for {} key does not exist"", key);
            throw new IllegalArgumentException(""Query for key "" + key + "" does not exist"");
        } else if (StringUtils.isBlank(query)) {
            log.error(""Query for key {} can't be blank or be only whitespace"", key);
            throw new IllegalArgumentException(""Query for key "" + key + "" can't be blank or be only whitespace"");
        }
        return query.trim().replaceAll(""\\s+"", "" "");
    }",Gets the query for the given key.
"static private String findParamValueFor(String s)
	{
		int endParamIndex = s.indexOf('=');
		int endValueIndex = s.indexOf(']',endParamIndex);
		if (endValueIndex<0) throw new IllegalStateException(""illegal class description '""+s+""'"");
		return s.substring(endParamIndex+1,endValueIndex);
	}",Find the value of the parameter in the given string.
"@Nullable
  public String getListItemStartingWith (@Nullable final String sPrefix)
  {
    for (final Object aObj : m_aList)
      if (aObj instanceof List <?>)
        for (final Object aListItem : (List <?>) aObj)
          if (((String) aListItem).startsWith (sPrefix))
            return (String) aListItem;
    return null;
  }",Get the first list item starting with the passed prefix.
"public static Array convert( Array org, DataType wantType) {
    if (org == null) return null;
    Class wantClass = wantType.getPrimitiveClassType();
    if (org.getElementType().equals(wantClass))
      return org;

    Array result = Array.factory(wantType, org.getShape());
    copy(wantType, org.getIndexIterator(), result.getIndexIterator());
    return result;
  }",Converts an Array to a new Array of the given type.
"public void addTickLabelSection(final Section SECTION) {
        if (null == SECTION) return;
        tickLabelSections.add(SECTION);
        Collections.sort(tickLabelSections, new SectionComparator());
        fireUpdateEvent(REDRAW_EVENT);
    }",Adds the given Section to the list of ticklabel sections. Sections are sorted by the time of the entry.
"public void log( final Priority priority, final Object message, final Throwable t )
    {
        if ( priority == null )
        {
            return;
        }

        switch (priority.level)
        {
            case Level.FATAL_INT:
                this.fatal( message, t );
                break;
            case Level.ERROR_INT:
                this.error( message, t );
                break;
            case Level.WARN_INT:
                this.warn( message, t );
                break;
            case Level.INFO_INT:
                this.info( message, t );
                break;
            case Level.DEBUG_INT:
                this.debug( message, t );
                break;
            case Level.TRACE_INT:
            case Level.ALL_INT:
                this.trace( message, t );
                break;
            default:
                break;
        }
    }",Logs a message and exception with the specified priority.
"public static void putServiceTicketInRequestScope(final RequestContext context, final ServiceTicket ticketValue) {
        context.getRequestScope().put(PARAMETER_SERVICE_TICKET_ID, ticketValue.getId());
    }",Put service ticket in request scope.
"public ExportRequestResponse exportRequest(ExportRequestInfo exportRequestInfo) throws ApiException {
        ApiResponse<ExportRequestResponse> resp = exportRequestWithHttpInfo(exportRequestInfo);
        return resp.getData();
    }",Export Request Export Request
"public boolean getBoolean(String key, boolean def) {
        String value = getString(key);
        if (value == null) {
            return def;
        }
        else {
            return ""true"".equalsIgnoreCase(value);
        }
    }",Gets the boolean value.
"public HalCuriAugmenter register(String name, String href) {
    Link link = new Link(href).setName(name);
    return register(link);
  }",Register a new HAL CURI Augmenter with the specified name and href.
"@Override
    public boolean offer(final WaitStrategy.Offerable o) throws InterruptedException {
        while (!o.offer()) {
            LockSupport.parkNanos(1l);
        }
        return true;
    }",Offer a new object to the queue.
"public static Bitmap getFrameSloppy(SeekableDemuxerTrack vt, ContainerAdaptor decoder, int frameNumber)
            throws IOException, JCodecException {
        return ((AndroidFrameGrab) new AndroidFrameGrab(vt, decoder).seekToFrameSloppy(frameNumber)).getFrame();
    }",Get the frame from a seekable demuxer track.
"private VerticalLayout createEnableGoogleAuthButton() {
		final VerticalLayout formLayout = new VerticalLayout();
		formLayout.setSizeFull();

		final Panel formPanel = new Panel();
		formPanel.setSizeFull();

		formLayout.addComponent(formPanel);

		final FormLayout formContent = new FormLayout();
		formPanel.setContent(formContent);

		final SetGoogleAuthenticatorCredentialRequest request = new SetGoogleAuthenticatorCredentialRequest();
		request.setSessionId(RequestContextHolder.currentRequestAttributes().getSessionId());
		request.setUserpassword("""");
		final ClickListener listener = new SetGoogleAuthenticatorCredentialClickListener(request);
		getFormFactory().addRequestInputFormFields(formContent, request, SetGoogleAuthenticatorCredentialRequest.class,
				AS_LIST, ENABLE_GOOGLE_AUTHENTICATOR, listener);

		return formLayout;
	}",Create enable google auth button.
"private void processRunnableOperations(
            final Consumer<WorkflowSystem.OperationResult<DAT, RES, OP>> resultConsumer,
            final List<OP> shouldrun,
            final List<OP> shouldskip,
            final DAT inputData
    )
    {
        for (final OP operation : shouldrun) {
            if (shouldskip.contains(operation)) {
                continue;
            }
            pending.remove(operation);

            workflowEngine.event(
                    WorkflowSystemEventType.WillRunOperation,
                    String.format(""operation starting: %s"", operation),
                    operation
            );
            final ListenableFuture<RES> submit = executorService.submit(() -> operation.apply(inputData));
            inProcess.add(operation);
            futures.add(submit);
            FutureCallback<RES> callback = new FutureCallback<RES>() {
                @Override
                public void onSuccess(final RES successResult) {
                    workflowEngine.event(
                            WorkflowSystemEventType.OperationSuccess,
                            String.format(""operation succeeded: %s"", successResult),
                            successResult
                    );
                    assert successResult != null;
                    WorkflowSystem.OperationResult<DAT, RES, OP> result = result(successResult, operation);
                    resultConsumer.accept(result);
                    stateChangeQueue.add(successResult);
                    inProcess.remove(operation);
                }

                @Override
                public void onFailure(final Throwable t) {
                    workflowEngine.event(
                            WorkflowSystemEventType.OperationFailed,
                            String.format(""operation failed: %s"", t),
                            t
                    );
                    WorkflowSystem.OperationResult<DAT, RES, OP> result = result(t, operation);
                    resultConsumer.accept(result);
                    StateObj newFailureState = operation.getFailureState(t);
                    if (null != newFailureState && newFailureState.getState().size() > 0) {
                        WorkflowSystem.OperationCompleted<DAT> objectOperationCompleted = WorkflowEngine.dummyResult(
                                newFailureState);
                        stateChangeQueue.add(objectOperationCompleted);
                    }
                    inProcess.remove(operation);
                }
            };

            Futures.addCallback(submit, callback, manager);
        }
    }",Process runnable operations.
"@Override
	public EClass getIfcStructuralLoadOrResult() {
		if (ifcStructuralLoadOrResultEClass == null) {
			ifcStructuralLoadOrResultEClass = (EClass) EPackage.Registry.INSTANCE.getEPackage(Ifc4Package.eNS_URI)
					.getEClassifiers().get(645);
		}
		return ifcStructuralLoadOrResultEClass;
	}",Get the IfcStructuralLoadOrResultEClass attribute of the class.
"public static void createLoadsBasedOnDescriptor(MethodVisitor mv, String descriptor, int startindex) {
		int slot = startindex;
		int descriptorpos = 1; // start after the '('
		char ch;
		while ((ch = descriptor.charAt(descriptorpos)) != ')') {
			switch (ch) {
				case '[':
					mv.visitVarInsn(ALOAD, slot);
					slot++;
					// jump to end of array, could be [[[[I
					while (descriptor.charAt(++descriptorpos) == '[') {
					}
					if (descriptor.charAt(descriptorpos) == 'L') {
						descriptorpos = descriptor.indexOf(';', descriptorpos) + 1;
					}
					else {
						// Just a primitive array
						descriptorpos++;
					}
					break;
				case 'L':
					mv.visitVarInsn(ALOAD, slot);
					slot++;
					// jump to end of 'L' signature
					descriptorpos = descriptor.indexOf(';', descriptorpos) + 1;
					break;
				case 'J':
					mv.visitVarInsn(LLOAD, slot);
					slot += 2; // double slotter
					descriptorpos++;
					break;
				case 'D':
					mv.visitVarInsn(DLOAD, slot);
					slot += 2; // double slotter
					descriptorpos++;
					break;
				case 'F':
					mv.visitVarInsn(FLOAD, slot);
					descriptorpos++;
					slot++;
					break;
				case 'I':
				case 'Z':
				case 'B':
				case 'C':
				case 'S':
					mv.visitVarInsn(ILOAD, slot);
					descriptorpos++;
					slot++;
					break;
				default:
					throw new IllegalStateException(""Unexpected type in descriptor: "" + ch);
			}
		}
	}",Creates the load instructions based on the given descriptor.
"private void copy(ByteBuf src, ByteBuffer dst) {
		// This branch is necessary, because an Exception is thrown if the
		// destination buffer has more remaining (writable) bytes than
		// currently readable from the Netty ByteBuf source.
		if (src.isReadable()) {
			if (src.readableBytes() < dst.remaining()) {
				int oldLimit = dst.limit();

				dst.limit(dst.position() + src.readableBytes());
				src.readBytes(dst);
				dst.limit(oldLimit);
			}
			else {
				src.readBytes(dst);
			}
		}
	}",Copy the contents of src to dst.
"public static Map<String, String> mergeDefaults(
        CmsObject cms,
        Map<String, CmsXmlContentProperty> propertyConfig,
        Map<String, String> properties) {

        Map<String, String> result = new HashMap<String, String>();
        if (propertyConfig != null) {
            for (Map.Entry<String, CmsXmlContentProperty> entry : propertyConfig.entrySet()) {
                CmsXmlContentProperty prop = entry.getValue();
                String value = getPropValueIds(cms, prop.getType(), prop.getDefault());
                if (value != null) {
                    result.put(entry.getKey(), value);
                }
            }
        }
        result.putAll(properties);
        return result;
    }",Merge the default values of the content type and property configuration.
"@GwtIncompatible // NavigableSet
  public static <E> NavigableSet<E> unmodifiableNavigableSet(NavigableSet<E> set) {
    if (set instanceof ImmutableSortedSet || set instanceof UnmodifiableNavigableSet) {
      return set;
    }
    return new UnmodifiableNavigableSet<E>(set);
  }",Returns an unmodifiable view of the given NavigableSet.
"public static byte[] readBytes(File file) throws IOException {
        FileInputStream fis = null;
        ByteArrayOutputStream bos = null;
        if (file == null) {
            throw new FileNotFoundException(""No file specified"");
        }
        try {
            fis = new FileInputStream(file);
            bos = new ByteArrayOutputStream();
            byte[] buffer = new byte[BUFFER_SIZE];
            int remaining;
            while ((remaining = fis.read(buffer)) > 0) {
                bos.write(buffer, 0, remaining);
            }
            return bos.toByteArray();
        } finally {
            Closeables.closeQuietly(fis);
            Closeables.closeQuietly(bos);
        }
    }",readBytes Method.
"public GridBagLayoutBuilder appendField(Component component, int colSpan) {
        return append(component, colSpan, 1, true, false);
    }",Append a field to the end of the current line.
"public void putClass(String key, Class<?> clazz) {
		checkNotNull(key);
		checkNotNull(clazz);
		final String error = InstantiationUtil.checkForInstantiationError(clazz);
		if (error != null) {
			throw new ValidationException(""Class '"" + clazz.getName() + ""' is not supported: "" + error);
		}
		put(key, clazz.getName());
	}",Put a Class into the map.
"protected void removeSource (JComponent comp)
    {
        if (_sourceComp == comp) {
            // reset cursors
            clearComponentCursor();
            _topComp.setCursor(_topCursor);
            reset();
        }
        _draggers.remove(comp);
        comp.removeMouseListener(_sourceListener);
        comp.removeMouseMotionListener(_sourceListener);
    }",Remove a source component from the calendar.
"public static Configuration getConfFromState(State state, Optional<String> encryptedPath) {
    Config config = ConfigFactory.parseProperties(state.getProperties());
    if (encryptedPath.isPresent()) {
      config = ConfigUtils.resolveEncrypted(config, encryptedPath);
    }
    Configuration conf = newConfiguration();

    for (Entry<String, ConfigValue> entry : config.entrySet()) {
      conf.set(entry.getKey(), entry.getValue().unwrapped().toString());
    }
    return conf;
  }",Get the configuration from the state
"public void create() {
    GeneticConfiguration cfg =
      new GeneticConfiguration(config, mutation_rate, recombination_rate,
                               evolve_comparators);
    population = new ArrayList(size);
    int ix = 0;
    for (; ix < copies_of_original; ix++)
      population.add(cfg.makeCopy());
    for (; ix < size; ix++)
      population.add(cfg.makeRandomCopy());
  }

  /**
   * Returns all configurations in the current generation.
   */
  public List<GeneticConfiguration> getConfigs() {
    return population;
  }

  public void setNewGeneration(List<GeneticConfiguration> nextgen) {
    this.population = nextgen;
  }

  /**
   * Sorts the population by their achieved F-numbers.
   */
  public void sort() {
    Collections.sort(population);
    for (int ix = 0; ix < population.size(); ix++)
      population.get(ix).setRank(ix + 1);
  }

  /**
   * Returns the best configuration.
   */
  public GeneticConfiguration getBestConfiguration() {
    return population.get(0);
  }

  /**
   * Returns the worst configuration.
   */
  public GeneticConfiguration getWorstConfiguration() {
    return population.get(population.size() - 1);
  }

  /**
   * Returns a random configuration.
   */
  public GeneticConfiguration pickRandomConfig() {
    return population.get((int) Math.random() * population.size());
  }

  /**
   * Runs a tournament among k individuals to find the most fit
   * individual.
   */
  public GeneticConfiguration runTournament(int k) {
    GeneticConfiguration best = pickRandomConfig();
    for (int ix = 1; ix < k; ix++) {
      GeneticConfiguration candidate = pickRandomConfig();
      if (candidate.getFNumber() > best.getFNumber())
        best = candidate;
    }
    return best;
  }

  /**
   * Sets the size of the population.
   */
  public void setSize(int size) {
    this.size = size;
  }

  public void setMutationRate(int mutation_rate) {
    this.mutation_rate = mutation_rate;
  }

  public void setRecombinationRate(double recombination_rate) {
    this.recombination_rate = recombination_rate;
  }

  public void setEvolveComparators(boolean evolve_comparators) {
    this.evolve_comparators = evolve_comparators;
  }

  public void setCopiesOfOriginal(int copies) {
    this.copies_of_original = copies;
  }

  /**
   * Returns the size of the population.
   */
  public int size() {
    return size;
  }
}",Create the generation.
"@Override
	public CommerceVirtualOrderItem fetchByPrimaryKey(Serializable primaryKey) {
		Serializable serializable = entityCache.getResult(CommerceVirtualOrderItemModelImpl.ENTITY_CACHE_ENABLED,
				CommerceVirtualOrderItemImpl.class, primaryKey);

		if (serializable == nullModel) {
			return null;
		}

		CommerceVirtualOrderItem commerceVirtualOrderItem = (CommerceVirtualOrderItem)serializable;

		if (commerceVirtualOrderItem == null) {
			Session session = null;

			try {
				session = openSession();

				commerceVirtualOrderItem = (CommerceVirtualOrderItem)session.get(CommerceVirtualOrderItemImpl.class,
						primaryKey);

				if (commerceVirtualOrderItem != null) {
					cacheResult(commerceVirtualOrderItem);
				}
				else {
					entityCache.putResult(CommerceVirtualOrderItemModelImpl.ENTITY_CACHE_ENABLED,
						CommerceVirtualOrderItemImpl.class, primaryKey,
						nullModel);
				}
			}
			catch (Exception e) {
				entityCache.removeResult(CommerceVirtualOrderItemModelImpl.ENTITY_CACHE_ENABLED,
					CommerceVirtualOrderItemImpl.class, primaryKey);

				throw processException(e);
			}
			finally {
				closeSession(session);
			}
		}

		return commerceVirtualOrderItem;
	}",Returns the commerce virtual order item with the primary key.
"public List<U> getAll(final boolean readFromSession) {
        final LinkedHashMap<String, U> profiles = retrieveAll(readFromSession);
        return ProfileHelper.flatIntoAProfileList(profiles);
    }",Get all profiles from the cache.
"public void marshall(DescribeEventSubscriptionsRequest describeEventSubscriptionsRequest, ProtocolMarshaller protocolMarshaller) {

        if (describeEventSubscriptionsRequest == null) {
            throw new SdkClientException(""Invalid argument passed to marshall(...)"");
        }

        try {
            protocolMarshaller.marshall(describeEventSubscriptionsRequest.getSubscriptionName(), SUBSCRIPTIONNAME_BINDING);
            protocolMarshaller.marshall(describeEventSubscriptionsRequest.getFilters(), FILTERS_BINDING);
            protocolMarshaller.marshall(describeEventSubscriptionsRequest.getMaxRecords(), MAXRECORDS_BINDING);
            protocolMarshaller.marshall(describeEventSubscriptionsRequest.getMarker(), MARKER_BINDING);
        } catch (Exception e) {
            throw new SdkClientException(""Unable to marshall request to JSON: "" + e.getMessage(), e);
        }
    }",marshalls the given request to the JSON object.
"public static double skewnessSE(FlatDataCollection flatDataCollection) {
	    int n = count(flatDataCollection);
        if(n<=2) {
            throw new IllegalArgumentException(""The provided collection must have more than 2 elements."");
        }
        
        double skewnessSE=Math.sqrt((6.0*n*(n-1.0))/((n-2.0)*(n+1.0)*(n+3.0)));
        
        return skewnessSE;
    }",Get the skewness of a collection of data.
"public void registerTaskConfig(String taskName, TedProcessorFactory tedProcessorFactory, TedRetryScheduler retryScheduler) {
		tedDriverImpl.registerTaskConfig(taskName, tedProcessorFactory, null, retryScheduler, null);
	}",Register TaskConfig method.
"public Cell<C,T> width (Value<C,T> width) {
		minWidth = width;
		prefWidth = width;
		maxWidth = width;
		return this;
	}",Sets the width of the cell.
